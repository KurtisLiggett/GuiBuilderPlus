#AutoIt3Wrapper_Run_Au3Stripper=y
#Au3Stripper_Parameters=/MO
#AutoIt3Wrapper_Res_HiDpi=N
#AutoIt3Wrapper_UseX64=N
#AutoIt3Wrapper_Icon=resources\icons\icon.ico
#AutoIt3Wrapper_OutFile=GUIBuilderPlus v1.2.0.exe
#AutoIt3Wrapper_Res_Fileversion=1.2.0
#AutoIt3Wrapper_Res_Description=GUI Builder Plus
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 1.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 2.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 3.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 4.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 5.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 6.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 7.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 8.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 9.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 10.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 11.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 12.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 13.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 14.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 15.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 15.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 17.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 17.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 19.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 20.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 21.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 22.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 23.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 24.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 25.ico
#AutoIt3Wrapper_Res_Icon_Add=resources\icons\icon 26.ico
Opt("WinTitleMatchMode", 4)
Opt("MouseCoordMode", 2)
Opt("GUIOnEventMode", 1)
Opt("GuiEventOptions", 1)
Opt("TrayAutoPause", 0)
Opt("TrayOnEventMode", 1)
Opt("TrayMenuMode", 3)
TraySetClick(8)
Global $grippy_size = 5
Global $debug = True
Global $hGUI, $hToolbar, $hFormGenerateCode, $hFormObjectExplorer, $hStatusbar, $hAbout, $hEvent, $hSettings, $hFormHolder
Global $iGuiFrameH, $iGuiFrameW, $defaultGuiBkColor = 0xF0F0F0
Global $button_graphic
Global $menu_wipe, $contextmenu_lock, $menu_helpchm
Global $menu_file, $aMenuRecentList[12]
Global $menu_show_grid
Global $menu_generateCode, $menu_ObjectExplorer
Global $background, $background_contextmenu, $background_contextmenu_paste
Global $overlay = -1, $overlay_contextmenu, $overlay_contextmenutab
Global $editCodeGeneration, $radio_msgMode, $radio_eventMode, $check_guiFunc, $labelCodeGeneration
Global $lvObjects, $labelObjectCount, $childSelected
Global $editEventCode
Global $settingsChk_snapgrid, $settingsChk_pasteatmouse, $settingsChk_guifunction, $settingsChk_eventmode, $settingsInput_gridsize
Global $hListItems, $editListItems
Global $oProperties_Main, $oProperties_Ctrls, $tabSelected, $tabProperties, $tabStyles, $tabStylesHwnd
Global $properties_fontButton, $properties_borderButton
Global Const $iconset = @ScriptDir & "\resources\Icons\"
Global Enum $mode_default, $mode_draw, $mode_drawing, $mode_init_move, $mode_init_selection, $mode_paste, $resize_nw, $resize_n, $resize_ne, $resize_e, $resize_se, $resize_s, $resize_sw, $resize_w
Global Enum $props_Main, $props_Ctrls
Global Const $ARROW = 2, $CROSS = 3, $SIZE_ALL = 9, $SIZENESW = 10, $SIZENS = 11, $SIZENWSE = 12, $SIZEWS = 13
Global Enum $action_nudgeCtrl, $action_moveCtrl, $action_resizeCtrl, $action_deleteCtrl, $action_createCtrl, $action_renameCtrl, $action_changeColor, $action_changeBkColor, $action_pasteCtrl, $action_changeText, $action_changeCode, $action_drawCtrl, $action_changeBorderColor, $action_changeBorderSize
Global $bStatusNewMessage
Global $guiFontName
Global $right_click = False
Global $left_click = False, $ctrlClicked = False
Global $bResizedFlag
Global $testFileName, $TestFilePID = 0, $bReTest = 0, $aTestGuiPos, $hTestGui
Global $au3InstallPath
Global $initDraw, $initResize
Global $hSelectionGraphic = -1
Global $dblClickTime
Global $oMain, $oCtrls, $oSelected, $oClipboard, $oMouse, $oOptions
Global $aStackUndo[0], $aStackRedo[0]
Global $AgdOutFile, $lfld, $mygui
Global $sampleavi = @ScriptDir & "\resources\sampleAVI.avi"
Global $samplebmp = @ScriptDir & "\resources\SampleImage.jpg"
Global $sampleicon = @ScriptDir & "\resources\icons\icon.ico"
Global $sIniPath = @ScriptDir & "\storage\GUIBuilderPlus.ini"
#AutoIt3Wrapper_Au3Check_Parameters=-d -w 1 -w 2 -w 3 -w 4 -w 5 -w 6
Global Const $gh_AU3Obj_kernel32dll = DllOpen("kernel32.dll")
Global Const $gh_AU3Obj_oleautdll = DllOpen("oleaut32.dll")
Global Const $gh_AU3Obj_ole32dll = DllOpen("ole32.dll")
Global Const $__Au3Obj_X64 = @AutoItX64
Global Const $__Au3Obj_VT_EMPTY = 0
Global Const $__Au3Obj_VT_NULL = 1
Global Const $__Au3Obj_VT_I2 = 2
Global Const $__Au3Obj_VT_I4 = 3
Global Const $__Au3Obj_VT_R4 = 4
Global Const $__Au3Obj_VT_R8 = 5
Global Const $__Au3Obj_VT_CY = 6
Global Const $__Au3Obj_VT_DATE = 7
Global Const $__Au3Obj_VT_BSTR = 8
Global Const $__Au3Obj_VT_DISPATCH = 9
Global Const $__Au3Obj_VT_ERROR = 10
Global Const $__Au3Obj_VT_BOOL = 11
Global Const $__Au3Obj_VT_VARIANT = 12
Global Const $__Au3Obj_VT_UNKNOWN = 13
Global Const $__Au3Obj_VT_DECIMAL = 14
Global Const $__Au3Obj_VT_I1 = 16
Global Const $__Au3Obj_VT_UI1 = 17
Global Const $__Au3Obj_VT_UI2 = 18
Global Const $__Au3Obj_VT_UI4 = 19
Global Const $__Au3Obj_VT_I8 = 20
Global Const $__Au3Obj_VT_UI8 = 21
Global Const $__Au3Obj_VT_INT = 22
Global Const $__Au3Obj_VT_UINT = 23
Global Const $__Au3Obj_VT_VOID = 24
Global Const $__Au3Obj_VT_HRESULT = 25
Global Const $__Au3Obj_VT_PTR = 26
Global Const $__Au3Obj_VT_SAFEARRAY = 27
Global Const $__Au3Obj_VT_CARRAY = 28
Global Const $__Au3Obj_VT_USERDEFINED = 29
Global Const $__Au3Obj_VT_LPSTR = 30
Global Const $__Au3Obj_VT_LPWSTR = 31
Global Const $__Au3Obj_VT_RECORD = 36
Global Const $__Au3Obj_VT_INT_PTR = 37
Global Const $__Au3Obj_VT_UINT_PTR = 38
Global Const $__Au3Obj_VT_FILETIME = 64
Global Const $__Au3Obj_VT_BLOB = 65
Global Const $__Au3Obj_VT_STREAM = 66
Global Const $__Au3Obj_VT_STORAGE = 67
Global Const $__Au3Obj_VT_STREAMED_OBJECT = 68
Global Const $__Au3Obj_VT_STORED_OBJECT = 69
Global Const $__Au3Obj_VT_BLOB_OBJECT = 70
Global Const $__Au3Obj_VT_CF = 71
Global Const $__Au3Obj_VT_CLSID = 72
Global Const $__Au3Obj_VT_VERSIONED_STREAM = 73
Global Const $__Au3Obj_VT_BSTR_BLOB = 0xfff
Global Const $__Au3Obj_VT_VECTOR = 0x1000
Global Const $__Au3Obj_VT_ARRAY = 0x2000
Global Const $__Au3Obj_VT_BYREF = 0x4000
Global Const $__Au3Obj_VT_RESERVED = 0x8000
Global Const $__Au3Obj_VT_ILLEGAL = 0xffff
Global Const $__Au3Obj_VT_ILLEGALMASKED = 0xfff
Global Const $__Au3Obj_VT_TYPEMASK = 0xfff
Global Const $__Au3Obj_tagVARIANT = "word vt;word r1;word r2;word r3;ptr data; ptr"
Global Const $__Au3Obj_VARIANT_SIZE = DllStructGetSize(DllStructCreate($__Au3Obj_tagVARIANT, 1))
Global Const $__Au3Obj_PTR_SIZE = DllStructGetSize(DllStructCreate('ptr', 1))
Global Const $__Au3Obj_tagSAFEARRAYBOUND = "ulong cElements; long lLbound;"
Global $ghAutoItObjectDLL = -1, $giAutoItObjectDLLRef = 0
#interface "IUnknown"
Global Const $sIID_IUnknown = "{00000000-0000-0000-C000-000000000046}"
Global $dtagIUnknown = "QueryInterface hresult(ptr;ptr*);" &  "AddRef dword();" &  "Release dword();"
Global $ltagIUnknown = "QueryInterface;" &  "AddRef;" &  "Release;"
#interface "IDispatch"
Global Const $sIID_IDispatch = "{00020400-0000-0000-C000-000000000046}"
Global $dtagIDispatch = $dtagIUnknown &  "GetTypeInfoCount hresult(dword*);" &  "GetTypeInfo hresult(dword;dword;ptr*);" &  "GetIDsOfNames hresult(ptr;ptr;dword;dword;ptr);" &  "Invoke hresult(dword;ptr;dword;word;ptr;ptr;ptr;ptr);"
Global $ltagIDispatch = $ltagIUnknown &  "GetTypeInfoCount;" &  "GetTypeInfo;" &  "GetIDsOfNames;" &  "Invoke;"
DllCall($gh_AU3Obj_ole32dll, 'long', 'OleInitialize', 'ptr', 0)
OnAutoItExitRegister("__Au3Obj_OleUninitialize")
Func __Au3Obj_OleUninitialize()
DllCall($gh_AU3Obj_ole32dll, 'long', 'OleUninitialize')
_AutoItObject_Shutdown(True)
EndFunc
Func __Au3Obj_IUnknown_AddRef($vObj)
Local $sType = "ptr"
If IsObj($vObj) Then $sType = "idispatch"
Local $tVARIANT = DllStructCreate($__Au3Obj_tagVARIANT)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "long", "DispCallFunc",  $sType, $vObj,  "dword", $__Au3Obj_PTR_SIZE,  "dword", 4,  "dword", $__Au3Obj_VT_UINT,  "dword", 0,  "ptr", 0,  "ptr", 0,  "ptr", DllStructGetPtr($tVARIANT))
If @error Or $aCall[0] Then Return SetError(1, 0, 0)
Return DllStructGetData(DllStructCreate("dword", DllStructGetPtr($tVARIANT, "data")), 1)
EndFunc
Func __Au3Obj_IUnknown_Release($vObj)
Local $sType = "ptr"
If IsObj($vObj) Then $sType = "idispatch"
Local $tVARIANT = DllStructCreate($__Au3Obj_tagVARIANT)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "long", "DispCallFunc",  $sType, $vObj,  "dword", 2 * $__Au3Obj_PTR_SIZE,  "dword", 4,  "dword", $__Au3Obj_VT_UINT,  "dword", 0,  "ptr", 0,  "ptr", 0,  "ptr", DllStructGetPtr($tVARIANT))
If @error Or $aCall[0] Then Return SetError(1, 0, 0)
Return DllStructGetData(DllStructCreate("dword", DllStructGetPtr($tVARIANT, "data")), 1)
EndFunc
Func __Au3Obj_GetMethods($tagInterface)
Local $sMethods = StringReplace(StringRegExpReplace($tagInterface, "\h*(\w+)\h*(\w+\*?)\h*(\((.*?)\))\h*(;|;*\z)", "$1\|$2;$4" & @LF), ";" & @LF, @LF)
If $sMethods = $tagInterface Then $sMethods = StringReplace(StringRegExpReplace($tagInterface, "\h*(\w+)\h*(;|;*\z)", "$1\|" & @LF), ";" & @LF, @LF)
Return StringTrimRight($sMethods, 1)
EndFunc
Func __Au3Obj_ObjStructGetElements($sTag, ByRef $sAlign)
Local $sAlignment = StringRegExpReplace($sTag, "\h*(align\h+\d+)\h*;.*", "$1")
If $sAlignment <> $sTag Then
$sAlign = $sAlignment
$sTag = StringRegExpReplace($sTag, "\h*(align\h+\d+)\h*;", "")
EndIf
Return StringTrimRight(StringRegExpReplace($sTag, "\h*\w+\h*(\w+)\h*(\[\d+\])*\h*(;|;*\z)\h*", "$1;"), 1)
EndFunc
Func __Au3Obj_SafeArrayCreate($vType, $cDims, $rgsabound)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "ptr", "SafeArrayCreate", "dword", $vType, "uint", $cDims, 'ptr', $rgsabound)
If @error Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func __Au3Obj_SafeArrayDestroy($pSafeArray)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "int", "SafeArrayDestroy", "ptr", $pSafeArray)
If @error Then Return SetError(1, 0, 1)
Return $aCall[0]
EndFunc
Func __Au3Obj_SafeArrayAccessData($pSafeArray, ByRef $pArrayData)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "int", "SafeArrayAccessData", "ptr", $pSafeArray, 'ptr*', 0)
If @error Then Return SetError(1, 0, 1)
$pArrayData = $aCall[2]
Return $aCall[0]
EndFunc
Func __Au3Obj_SafeArrayUnaccessData($pSafeArray)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "int", "SafeArrayUnaccessData", "ptr", $pSafeArray)
If @error Then Return SetError(1, 0, 1)
Return $aCall[0]
EndFunc
Func __Au3Obj_SafeArrayGetUBound($pSafeArray, $iDim, ByRef $iBound)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "int", "SafeArrayGetUBound", "ptr", $pSafeArray, 'uint', $iDim, 'long*', 0)
If @error Then Return SetError(1, 0, 1)
$iBound = $aCall[3]
Return $aCall[0]
EndFunc
Func __Au3Obj_SafeArrayGetLBound($pSafeArray, $iDim, ByRef $iBound)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "int", "SafeArrayGetLBound", "ptr", $pSafeArray, 'uint', $iDim, 'long*', 0)
If @error Then Return SetError(1, 0, 1)
$iBound = $aCall[3]
Return $aCall[0]
EndFunc
Func __Au3Obj_SafeArrayGetDim($pSafeArray)
Local $aResult = DllCall($gh_AU3Obj_oleautdll, "uint", "SafeArrayGetDim", "ptr", $pSafeArray)
If @error Then Return SetError(1, 0, 0)
Return $aResult[0]
EndFunc
Func __Au3Obj_CreateSafeArrayVariant(ByRef Const $aArray)
Local $iDim = UBound($aArray, 0), $pData, $pSafeArray, $bound, $subBound, $tBound
Switch $iDim
Case 1
$bound = UBound($aArray) - 1
$tBound = DllStructCreate($__Au3Obj_tagSAFEARRAYBOUND)
DllStructSetData($tBound, 1, $bound + 1)
$pSafeArray = __Au3Obj_SafeArrayCreate($__Au3Obj_VT_VARIANT, 1, DllStructGetPtr($tBound))
If 0 = __Au3Obj_SafeArrayAccessData($pSafeArray, $pData) Then
For $i = 0 To $bound
_AutoItObject_VariantInit($pData + $i * $__Au3Obj_VARIANT_SIZE)
_AutoItObject_VariantSet($pData + $i * $__Au3Obj_VARIANT_SIZE, $aArray[$i])
Next
__Au3Obj_SafeArrayUnaccessData($pSafeArray)
EndIf
Return $pSafeArray
Case 2
$bound = UBound($aArray, 1) - 1
$subBound = UBound($aArray, 2) - 1
$tBound = DllStructCreate($__Au3Obj_tagSAFEARRAYBOUND & $__Au3Obj_tagSAFEARRAYBOUND)
DllStructSetData($tBound, 3, $bound + 1)
DllStructSetData($tBound, 1, $subBound + 1)
$pSafeArray = __Au3Obj_SafeArrayCreate($__Au3Obj_VT_VARIANT, 2, DllStructGetPtr($tBound))
If 0 = __Au3Obj_SafeArrayAccessData($pSafeArray, $pData) Then
For $i = 0 To $bound
For $j = 0 To $subBound
_AutoItObject_VariantInit($pData + ($j + $i * ($subBound + 1)) * $__Au3Obj_VARIANT_SIZE)
_AutoItObject_VariantSet($pData + ($j + $i * ($subBound + 1)) * $__Au3Obj_VARIANT_SIZE, $aArray[$i][$j])
Next
Next
__Au3Obj_SafeArrayUnaccessData($pSafeArray)
EndIf
Return $pSafeArray
Case Else
Return 0
EndSwitch
EndFunc
Func __Au3Obj_ReadSafeArrayVariant($pSafeArray)
Local $iDim = __Au3Obj_SafeArrayGetDim($pSafeArray), $pData, $lbound, $bound, $subBound
Switch $iDim
Case 1
__Au3Obj_SafeArrayGetLBound($pSafeArray, 1, $lbound)
__Au3Obj_SafeArrayGetUBound($pSafeArray, 1, $bound)
$bound -= $lbound
Local $array[$bound + 1]
If 0 = __Au3Obj_SafeArrayAccessData($pSafeArray, $pData) Then
For $i = 0 To $bound
$array[$i] = _AutoItObject_VariantRead($pData + $i * $__Au3Obj_VARIANT_SIZE)
Next
__Au3Obj_SafeArrayUnaccessData($pSafeArray)
EndIf
Return $array
Case 2
__Au3Obj_SafeArrayGetLBound($pSafeArray, 2, $lbound)
__Au3Obj_SafeArrayGetUBound($pSafeArray, 2, $bound)
$bound -= $lbound
__Au3Obj_SafeArrayGetLBound($pSafeArray, 1, $lbound)
__Au3Obj_SafeArrayGetUBound($pSafeArray, 1, $subBound)
$subBound -= $lbound
Local $array[$bound + 1][$subBound + 1]
If 0 = __Au3Obj_SafeArrayAccessData($pSafeArray, $pData) Then
For $i = 0 To $bound
For $j = 0 To $subBound
$array[$i][$j] = _AutoItObject_VariantRead($pData + ($j + $i * ($subBound + 1)) * $__Au3Obj_VARIANT_SIZE)
Next
Next
__Au3Obj_SafeArrayUnaccessData($pSafeArray)
EndIf
Return $array
Case Else
Return 0
EndSwitch
EndFunc
Func __Au3Obj_CoTaskMemAlloc($iSize)
Local $aCall = DllCall($gh_AU3Obj_ole32dll, "ptr", "CoTaskMemAlloc", "uint_ptr", $iSize)
If @error Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func __Au3Obj_CoTaskMemFree($pCoMem)
DllCall($gh_AU3Obj_ole32dll, "none", "CoTaskMemFree", "ptr", $pCoMem)
If @error Then Return SetError(1, 0, 0)
EndFunc
Func __Au3Obj_CoTaskMemRealloc($pCoMem, $iSize)
Local $aCall = DllCall($gh_AU3Obj_ole32dll, "ptr", "CoTaskMemRealloc", 'ptr', $pCoMem, "uint_ptr", $iSize)
If @error Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func __Au3Obj_GlobalAlloc($iSize, $iFlag)
Local $aCall = DllCall($gh_AU3Obj_kernel32dll, "ptr", "GlobalAlloc", "dword", $iFlag, "dword_ptr", $iSize)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func __Au3Obj_GlobalFree($pPointer)
Local $aCall = DllCall($gh_AU3Obj_kernel32dll, "ptr", "GlobalFree", "ptr", $pPointer)
If @error Or $aCall[0] Then Return SetError(1, 0, 0)
Return 1
EndFunc
Func __Au3Obj_SysAllocString($str)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "ptr", "SysAllocString", "wstr", $str)
If @error Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func __Au3Obj_SysCopyString($pBSTR)
If Not $pBSTR Then Return SetError(2, 0, 0)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "ptr", "SysAllocStringLen", "ptr", $pBSTR, "uint", __Au3Obj_SysStringLen($pBSTR))
If @error Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func __Au3Obj_SysReAllocString(ByRef $pBSTR, $str)
If Not $pBSTR Then Return SetError(2, 0, 0)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "int", "SysReAllocString", 'ptr*', $pBSTR, "wstr", $str)
If @error Then Return SetError(1, 0, 0)
$pBSTR = $aCall[1]
Return $aCall[0]
EndFunc
Func __Au3Obj_SysFreeString($pBSTR)
If Not $pBSTR Then Return SetError(2, 0, 0)
DllCall($gh_AU3Obj_oleautdll, "none", "SysFreeString", "ptr", $pBSTR)
If @error Then Return SetError(1, 0, 0)
EndFunc
Func __Au3Obj_SysStringLen($pBSTR)
If Not $pBSTR Then Return SetError(2, 0, 0)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "uint", "SysStringLen", "ptr", $pBSTR)
If @error Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func __Au3Obj_SysReadString($pBSTR, $iLen = -1)
If Not $pBSTR Then Return SetError(2, 0, '')
If $iLen < 1 Then $iLen = __Au3Obj_SysStringLen($pBSTR)
If $iLen < 1 Then Return SetError(1, 0, '')
Return DllStructGetData(DllStructCreate("wchar[" & $iLen & "]", $pBSTR), 1)
EndFunc
Func __Au3Obj_PtrStringLen($pStr)
Local $aResult = DllCall($gh_AU3Obj_kernel32dll, 'int', 'lstrlenW', 'ptr', $pStr)
If @error Then Return SetError(1, 0, 0)
Return $aResult[0]
EndFunc
Func __Au3Obj_PtrStringRead($pStr, $iLen = -1)
If $iLen < 1 Then $iLen = __Au3Obj_PtrStringLen($pStr)
If $iLen < 1 Then Return SetError(1, 0, '')
Return DllStructGetData(DllStructCreate("wchar[" & $iLen & "]", $pStr), 1)
EndFunc
Func __Au3Obj_FunctionProxy($FuncName, $oSelf)
Local $arg = $oSelf.__params__
If IsArray($arg) Then
Local $ret = Call($FuncName, $arg)
If @error = 0xDEAD And @extended = 0xBEEF Then Return 0
$oSelf.__error__ = @error
$oSelf.__result__ = $ret
Return 1
EndIf
EndFunc
Func __Au3Obj_EnumFunctionProxy($iAction, $FuncName, $oSelf, $pVarCurrent, $pVarResult)
Local $Current, $ret
Switch $iAction
Case 0
$Current = $oSelf.__bridge__(Number($pVarCurrent))
$ret = Execute($FuncName & "($oSelf, $Current)")
If @error Then Return False
$oSelf.__bridge__(Number($pVarCurrent)) = $Current
$oSelf.__bridge__(Number($pVarResult)) = $ret
Return 1
Case 1
Return False
Case 2
$Current = $oSelf.__bridge__(Number($pVarCurrent))
$ret = Execute($FuncName & "($oSelf, $Current)")
If @error Or Not $ret Then Return False
$oSelf.__bridge__(Number($pVarCurrent)) = $Current
Return True
EndSwitch
EndFunc
Func __Au3Obj_PointerCall($sRetType, $pAddress, $sType1 = "", $vParam1 = 0, $sType2 = "", $vParam2 = 0, $sType3 = "", $vParam3 = 0, $sType4 = "", $vParam4 = 0, $sType5 = "", $vParam5 = 0, $sType6 = "", $vParam6 = 0, $sType7 = "", $vParam7 = 0, $sType8 = "", $vParam8 = 0, $sType9 = "", $vParam9 = 0, $sType10 = "", $vParam10 = 0, $sType11 = "", $vParam11 = 0, $sType12 = "", $vParam12 = 0, $sType13 = "", $vParam13 = 0, $sType14 = "", $vParam14 = 0, $sType15 = "", $vParam15 = 0, $sType16 = "", $vParam16 = 0, $sType17 = "", $vParam17 = 0, $sType18 = "", $vParam18 = 0, $sType19 = "", $vParam19 = 0, $sType20 = "", $vParam20 = 0)
Local Static $pHook, $hPseudo, $tPtr, $sFuncName = "MemoryCallEntry"
If $pAddress Then
If Not $pHook Then
Local $sDll = "AutoItObject.dll"
If $__Au3Obj_X64 Then $sDll = "AutoItObject_X64.dll"
$hPseudo = DllOpen($sDll)
If $hPseudo = -1 Then
$sDll = "kernel32.dll"
$sFuncName = "GlobalFix"
$hPseudo = DllOpen($sDll)
EndIf
Local $aCall = DllCall($gh_AU3Obj_kernel32dll, "ptr", "GetModuleHandleW", "wstr", $sDll)
If @error Or Not $aCall[0] Then Return SetError(7, @error, 0)
Local $hModuleHandle = $aCall[0]
$aCall = DllCall($gh_AU3Obj_kernel32dll, "ptr", "GetProcAddress", "ptr", $hModuleHandle, "str", $sFuncName)
If @error Then Return SetError(8, @error, 0)
$pHook = $aCall[0]
$aCall = DllCall($gh_AU3Obj_kernel32dll, "bool", "VirtualProtect", "ptr", $pHook, "dword", 7 + 5 * $__Au3Obj_X64, "dword", 64, "dword*", 0)
If @error Or Not $aCall[0] Then Return SetError(9, @error, 0)
If $__Au3Obj_X64 Then
DllStructSetData(DllStructCreate("word", $pHook), 1, 0xB848)
DllStructSetData(DllStructCreate("word", $pHook + 10), 1, 0xE0FF)
Else
DllStructSetData(DllStructCreate("byte", $pHook), 1, 0xB8)
DllStructSetData(DllStructCreate("word", $pHook + 5), 1, 0xE0FF)
EndIf
$tPtr = DllStructCreate("ptr", $pHook + 1 + $__Au3Obj_X64)
EndIf
DllStructSetData($tPtr, 1, $pAddress)
Local $aRet
Switch @NumParams
Case 2
$aRet = DllCall($hPseudo, $sRetType, $sFuncName)
Case 4
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1)
Case 6
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2)
Case 8
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3)
Case 10
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4)
Case 12
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5)
Case 14
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6)
Case 16
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7)
Case 18
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8)
Case 20
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9)
Case 22
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10)
Case 24
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10, $sType11, $vParam11)
Case 26
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10, $sType11, $vParam11, $sType12, $vParam12)
Case 28
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10, $sType11, $vParam11, $sType12, $vParam12, $sType13, $vParam13)
Case 30
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10, $sType11, $vParam11, $sType12, $vParam12, $sType13, $vParam13, $sType14, $vParam14)
Case 32
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10, $sType11, $vParam11, $sType12, $vParam12, $sType13, $vParam13, $sType14, $vParam14, $sType15, $vParam15)
Case 34
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10, $sType11, $vParam11, $sType12, $vParam12, $sType13, $vParam13, $sType14, $vParam14, $sType15, $vParam15, $sType16, $vParam16)
Case 36
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10, $sType11, $vParam11, $sType12, $vParam12, $sType13, $vParam13, $sType14, $vParam14, $sType15, $vParam15, $sType16, $vParam16, $sType17, $vParam17)
Case 38
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10, $sType11, $vParam11, $sType12, $vParam12, $sType13, $vParam13, $sType14, $vParam14, $sType15, $vParam15, $sType16, $vParam16, $sType17, $vParam17, $sType18, $vParam18)
Case 40
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10, $sType11, $vParam11, $sType12, $vParam12, $sType13, $vParam13, $sType14, $vParam14, $sType15, $vParam15, $sType16, $vParam16, $sType17, $vParam17, $sType18, $vParam18, $sType19, $vParam19)
Case 42
$aRet = DllCall($hPseudo, $sRetType, $sFuncName, $sType1, $vParam1, $sType2, $vParam2, $sType3, $vParam3, $sType4, $vParam4, $sType5, $vParam5, $sType6, $vParam6, $sType7, $vParam7, $sType8, $vParam8, $sType9, $vParam9, $sType10, $vParam10, $sType11, $vParam11, $sType12, $vParam12, $sType13, $vParam13, $sType14, $vParam14, $sType15, $vParam15, $sType16, $vParam16, $sType17, $vParam17, $sType18, $vParam18, $sType19, $vParam19, $sType20, $vParam20)
Case Else
If Mod(@NumParams, 2) Then Return SetError(4, 0, 0)
Return SetError(5, 0, 0)
EndSwitch
Return SetError(@error, @extended, $aRet)
EndIf
Return SetError(6, 0, 0)
EndFunc
Func __Au3Obj_Mem_DllOpen($bBinaryImage = 0, $sSubrogor = "cmd.exe")
If Not $bBinaryImage Then
If $__Au3Obj_X64 Then
$bBinaryImage = __Au3Obj_Mem_BinDll_X64()
Else
$bBinaryImage = __Au3Obj_Mem_BinDll()
EndIf
EndIf
Local $tBinary = DllStructCreate("byte[" & BinaryLen($bBinaryImage) & "]")
DllStructSetData($tBinary, 1, $bBinaryImage)
Local $pPointer = DllStructGetPtr($tBinary)
Local $tIMAGE_DOS_HEADER = DllStructCreate("char Magic[2];" &  "word BytesOnLastPage;" &  "word Pages;" &  "word Relocations;" &  "word SizeofHeader;" &  "word MinimumExtra;" &  "word MaximumExtra;" &  "word SS;" &  "word SP;" &  "word Checksum;" &  "word IP;" &  "word CS;" &  "word Relocation;" &  "word Overlay;" &  "char Reserved[8];" &  "word OEMIdentifier;" &  "word OEMInformation;" &  "char Reserved2[20];" &  "dword AddressOfNewExeHeader",  $pPointer)
$pPointer += DllStructGetData($tIMAGE_DOS_HEADER, "AddressOfNewExeHeader")
$pPointer += 4
Local $tIMAGE_FILE_HEADER = DllStructCreate("word Machine;" &  "word NumberOfSections;" &  "dword TimeDateStamp;" &  "dword PointerToSymbolTable;" &  "dword NumberOfSymbols;" &  "word SizeOfOptionalHeader;" &  "word Characteristics",  $pPointer)
Local $iNumberOfSections = DllStructGetData($tIMAGE_FILE_HEADER, "NumberOfSections")
$pPointer += 20
Local $tMagic = DllStructCreate("word Magic;", $pPointer)
Local $iMagic = DllStructGetData($tMagic, 1)
Local $tIMAGE_OPTIONAL_HEADER
If $iMagic = 267 Then
If $__Au3Obj_X64 Then Return SetError(1, 0, -1)
$tIMAGE_OPTIONAL_HEADER = DllStructCreate("word Magic;" &  "byte MajorLinkerVersion;" &  "byte MinorLinkerVersion;" &  "dword SizeOfCode;" &  "dword SizeOfInitializedData;" &  "dword SizeOfUninitializedData;" &  "dword AddressOfEntryPoint;" &  "dword BaseOfCode;" &  "dword BaseOfData;" &  "dword ImageBase;" &  "dword SectionAlignment;" &  "dword FileAlignment;" &  "word MajorOperatingSystemVersion;" &  "word MinorOperatingSystemVersion;" &  "word MajorImageVersion;" &  "word MinorImageVersion;" &  "word MajorSubsystemVersion;" &  "word MinorSubsystemVersion;" &  "dword Win32VersionValue;" &  "dword SizeOfImage;" &  "dword SizeOfHeaders;" &  "dword CheckSum;" &  "word Subsystem;" &  "word DllCharacteristics;" &  "dword SizeOfStackReserve;" &  "dword SizeOfStackCommit;" &  "dword SizeOfHeapReserve;" &  "dword SizeOfHeapCommit;" &  "dword LoaderFlags;" &  "dword NumberOfRvaAndSizes",  $pPointer)
$pPointer += 96
ElseIf $iMagic = 523 Then
If Not $__Au3Obj_X64 Then Return SetError(1, 0, -1)
$tIMAGE_OPTIONAL_HEADER = DllStructCreate("word Magic;" &  "byte MajorLinkerVersion;" &  "byte MinorLinkerVersion;" &  "dword SizeOfCode;" &  "dword SizeOfInitializedData;" &  "dword SizeOfUninitializedData;" &  "dword AddressOfEntryPoint;" &  "dword BaseOfCode;" &  "uint64 ImageBase;" &  "dword SectionAlignment;" &  "dword FileAlignment;" &  "word MajorOperatingSystemVersion;" &  "word MinorOperatingSystemVersion;" &  "word MajorImageVersion;" &  "word MinorImageVersion;" &  "word MajorSubsystemVersion;" &  "word MinorSubsystemVersion;" &  "dword Win32VersionValue;" &  "dword SizeOfImage;" &  "dword SizeOfHeaders;" &  "dword CheckSum;" &  "word Subsystem;" &  "word DllCharacteristics;" &  "uint64 SizeOfStackReserve;" &  "uint64 SizeOfStackCommit;" &  "uint64 SizeOfHeapReserve;" &  "uint64 SizeOfHeapCommit;" &  "dword LoaderFlags;" &  "dword NumberOfRvaAndSizes",  $pPointer)
$pPointer += 112
Else
Return SetError(1, 0, -1)
EndIf
Local $iEntryPoint = DllStructGetData($tIMAGE_OPTIONAL_HEADER, "AddressOfEntryPoint")
Local $pOptionalHeaderImageBase = DllStructGetData($tIMAGE_OPTIONAL_HEADER, "ImageBase")
$pPointer += 8
Local $tIMAGE_DIRECTORY_ENTRY_IMPORT = DllStructCreate("dword VirtualAddress; dword Size", $pPointer)
Local $pAddressImport = DllStructGetData($tIMAGE_DIRECTORY_ENTRY_IMPORT, "VirtualAddress")
$pPointer += 8
$pPointer += 24
Local $tIMAGE_DIRECTORY_ENTRY_BASERELOC = DllStructCreate("dword VirtualAddress; dword Size", $pPointer)
Local $pAddressNewBaseReloc = DllStructGetData($tIMAGE_DIRECTORY_ENTRY_BASERELOC, "VirtualAddress")
Local $iSizeBaseReloc = DllStructGetData($tIMAGE_DIRECTORY_ENTRY_BASERELOC, "Size")
$pPointer += 8
$pPointer += 40
$pPointer += 40
Local $pBaseAddress = __Au3Obj_Mem_LoadLibraryEx($sSubrogor, 1)
If @error Then Return SetError(2, 0, -1)
Local $pHeadersNew = DllStructGetPtr($tIMAGE_DOS_HEADER)
Local $iOptionalHeaderSizeOfHeaders = DllStructGetData($tIMAGE_OPTIONAL_HEADER, "SizeOfHeaders")
If Not __Au3Obj_Mem_VirtualProtect($pBaseAddress, $iOptionalHeaderSizeOfHeaders, 4) Then Return SetError(3, 0, -1)
DllStructSetData(DllStructCreate("byte[" & $iOptionalHeaderSizeOfHeaders & "]", $pBaseAddress), 1, DllStructGetData(DllStructCreate("byte[" & $iOptionalHeaderSizeOfHeaders & "]", $pHeadersNew), 1))
Local $tIMAGE_SECTION_HEADER
Local $iSizeOfRawData, $pPointerToRawData
Local $iVirtualSize, $iVirtualAddress
Local $pRelocRaw
For $i = 1 To $iNumberOfSections
$tIMAGE_SECTION_HEADER = DllStructCreate("char Name[8];" &  "dword UnionOfVirtualSizeAndPhysicalAddress;" &  "dword VirtualAddress;" &  "dword SizeOfRawData;" &  "dword PointerToRawData;" &  "dword PointerToRelocations;" &  "dword PointerToLinenumbers;" &  "word NumberOfRelocations;" &  "word NumberOfLinenumbers;" &  "dword Characteristics",  $pPointer)
$iSizeOfRawData = DllStructGetData($tIMAGE_SECTION_HEADER, "SizeOfRawData")
$pPointerToRawData = $pHeadersNew + DllStructGetData($tIMAGE_SECTION_HEADER, "PointerToRawData")
$iVirtualAddress = DllStructGetData($tIMAGE_SECTION_HEADER, "VirtualAddress")
$iVirtualSize = DllStructGetData($tIMAGE_SECTION_HEADER, "UnionOfVirtualSizeAndPhysicalAddress")
If $iVirtualSize And $iVirtualSize < $iSizeOfRawData Then $iSizeOfRawData = $iVirtualSize
If Not __Au3Obj_Mem_VirtualProtect($pBaseAddress + $iVirtualAddress, $iVirtualSize, 64) Then
$pPointer += 40
ContinueLoop
EndIf
DllStructSetData(DllStructCreate("byte[" & $iVirtualSize & "]", $pBaseAddress + $iVirtualAddress), 1, DllStructGetData(DllStructCreate("byte[" & $iVirtualSize & "]"), 1))
If $iSizeOfRawData Then DllStructSetData(DllStructCreate("byte[" & $iSizeOfRawData & "]", $pBaseAddress + $iVirtualAddress), 1, DllStructGetData(DllStructCreate("byte[" & $iSizeOfRawData & "]", $pPointerToRawData), 1))
If $iVirtualAddress <= $pAddressNewBaseReloc And $iVirtualAddress + $iSizeOfRawData > $pAddressNewBaseReloc Then $pRelocRaw = $pPointerToRawData + ($pAddressNewBaseReloc - $iVirtualAddress)
If $iVirtualAddress <= $pAddressImport And $iVirtualAddress + $iSizeOfRawData > $pAddressImport Then __Au3Obj_Mem_FixImports($pPointerToRawData + ($pAddressImport - $iVirtualAddress), $pBaseAddress)
$pPointer += 40
Next
If $pAddressNewBaseReloc And $iSizeBaseReloc Then __Au3Obj_Mem_FixReloc($pRelocRaw, $iSizeBaseReloc, $pBaseAddress, $pOptionalHeaderImageBase, $iMagic = 523)
Local $pEntryFunc = $pBaseAddress + $iEntryPoint
__Au3Obj_PointerCall("bool", $pEntryFunc, "ptr", $pBaseAddress, "dword", 1, "ptr", 0)
Local $hPseudo = DllOpen($sSubrogor)
__Au3Obj_Mem_FreeLibrary($pBaseAddress)
Return $hPseudo
EndFunc
Func __Au3Obj_Mem_FixReloc($pData, $iSize, $pAddressNew, $pAddressOld, $fImageX64)
Local $iDelta = $pAddressNew - $pAddressOld
Local $tIMAGE_BASE_RELOCATION, $iRelativeMove
Local $iVirtualAddress, $iSizeofBlock, $iNumberOfEntries
Local $tEnries, $iData, $tAddress
Local $iFlag = 3 + 7 * $fImageX64
While $iRelativeMove < $iSize
$tIMAGE_BASE_RELOCATION = DllStructCreate("dword VirtualAddress; dword SizeOfBlock", $pData + $iRelativeMove)
$iVirtualAddress = DllStructGetData($tIMAGE_BASE_RELOCATION, "VirtualAddress")
$iSizeofBlock = DllStructGetData($tIMAGE_BASE_RELOCATION, "SizeOfBlock")
$iNumberOfEntries = ($iSizeofBlock - 8) / 2
$tEnries = DllStructCreate("word[" & $iNumberOfEntries & "]", DllStructGetPtr($tIMAGE_BASE_RELOCATION) + 8)
For $i = 1 To $iNumberOfEntries
$iData = DllStructGetData($tEnries, 1, $i)
If BitShift($iData, 12) = $iFlag Then
$tAddress = DllStructCreate("ptr", $pAddressNew + $iVirtualAddress + BitAND($iData, 0xFFF))
DllStructSetData($tAddress, 1, DllStructGetData($tAddress, 1) + $iDelta)
EndIf
Next
$iRelativeMove += $iSizeofBlock
WEnd
Return 1
EndFunc
Func __Au3Obj_Mem_FixImports($pImportDirectory, $hInstance)
Local $hModule, $tFuncName, $sFuncName, $pFuncAddress
Local $tIMAGE_IMPORT_MODULE_DIRECTORY, $tModuleName
Local $tBufferOffset2, $iBufferOffset2
Local $iInitialOffset, $iInitialOffset2, $iOffset
While 1
$tIMAGE_IMPORT_MODULE_DIRECTORY = DllStructCreate("dword RVAOriginalFirstThunk;" &  "dword TimeDateStamp;" &  "dword ForwarderChain;" &  "dword RVAModuleName;" &  "dword RVAFirstThunk",  $pImportDirectory)
If Not DllStructGetData($tIMAGE_IMPORT_MODULE_DIRECTORY, "RVAFirstThunk") Then ExitLoop
$tModuleName = DllStructCreate("char Name[64]", $hInstance + DllStructGetData($tIMAGE_IMPORT_MODULE_DIRECTORY, "RVAModuleName"))
$hModule = __Au3Obj_Mem_LoadLibraryEx(DllStructGetData($tModuleName, "Name"))
$iInitialOffset = $hInstance + DllStructGetData($tIMAGE_IMPORT_MODULE_DIRECTORY, "RVAFirstThunk")
$iInitialOffset2 = $hInstance + DllStructGetData($tIMAGE_IMPORT_MODULE_DIRECTORY, "RVAOriginalFirstThunk")
If $iInitialOffset2 = $hInstance Then $iInitialOffset2 = $iInitialOffset
$iOffset = 0
While 1
$tBufferOffset2 = DllStructCreate("ptr", $iInitialOffset2 + $iOffset)
$iBufferOffset2 = DllStructGetData($tBufferOffset2, 1)
If Not $iBufferOffset2 Then ExitLoop
If BitShift(BinaryMid($iBufferOffset2, $__Au3Obj_PTR_SIZE, 1), 7) Then
$pFuncAddress = __Au3Obj_Mem_GetAddress($hModule, BitAND($iBufferOffset2, 0xFFFFFF))
Else
$tFuncName = DllStructCreate("word Ordinal; char Name[64]", $hInstance + $iBufferOffset2)
$sFuncName = DllStructGetData($tFuncName, "Name")
$pFuncAddress = __Au3Obj_Mem_GetAddress($hModule, $sFuncName)
EndIf
DllStructSetData(DllStructCreate("ptr", $iInitialOffset + $iOffset), 1, $pFuncAddress)
$iOffset += $__Au3Obj_PTR_SIZE
WEnd
$pImportDirectory += 20
WEnd
Return 1
EndFunc
Func __Au3Obj_Mem_Base64Decode($sData)
Local $bOpcode
If $__Au3Obj_X64 Then
$bOpcode = Binary("0x4156415541544D89CC555756534C89C34883EC20410FB64104418800418B3183FE010F84AB00000073434863D24D89C54889CE488D3C114839FE0F84A50100000FB62E4883C601E8B501000083ED2B4080FD5077E2480FBEED0FB6042884C00FBED078D3C1E20241885500EB7383FE020F841C01000031C083FE03740F4883C4205B5E5F5D415C415D415EC34863D24D89C54889CE488D3C114839FE0F84CA0000000FB62E4883C601E85301000083ED2B4080FD5077E2480FBEED0FB6042884C078D683E03F410845004983C501E964FFFFFF4863D24D89C54889CE488D3C114839FE0F84E00000000FB62E4883C601E80C01000083ED2B4080FD5077E2480FBEED0FB6042884C00FBED078D389D04D8D7501C1E20483E03041885501C1F804410845004839FE747B0FB62E4883C601E8CC00000083ED2B4080FD5077E6480FBEED0FB6042884C00FBED078D789D0C1E2064D8D6E0183E03C41885601C1F8024108064839FE0F8536FFFFFF41C7042403000000410FB6450041884424044489E84883C42029D85B5E5F5D415C415D415EC34863D24889CE4D89C6488D3C114839FE758541C7042402000000410FB60641884424044489F04883C42029D85B5E5F5D415C415D415EC341C7042401000000410FB6450041884424044489E829D8E998FEFFFF41C7042400000000410FB6450041884424044489E829D8E97CFEFFFFE8500000003EFFFFFF3F3435363738393A3B3C3DFFFFFFFEFFFFFF000102030405060708090A0B0C0D0E0F10111213141516171819FFFFFFFFFFFF1A1B1C1D1E1F202122232425262728292A2B2C2D2E2F3031323358C3")
Else
$bOpcode = Binary("0x5557565383EC1C8B6C243C8B5424388B5C24308B7424340FB6450488028B550083FA010F84A1000000733F8B5424388D34338954240C39F30F848B0100000FB63B83C301E8890100008D57D580FA5077E50FBED20FB6041084C00FBED078D78B44240CC1E2028810EB6B83FA020F841201000031C083FA03740A83C41C5B5E5F5DC210008B4C24388D3433894C240C39F30F84CD0000000FB63B83C301E8300100008D57D580FA5077E50FBED20FB6041084C078DA8B54240C83E03F080283C2018954240CE96CFFFFFF8B4424388D34338944240C39F30F84D00000000FB63B83C301E8EA0000008D57D580FA5077E50FBED20FB6141084D20FBEC278D78B4C240C89C283E230C1FA04C1E004081189CF83C70188410139F374750FB60383C3018844240CE8A80000000FB654240C83EA2B80FA5077E00FBED20FB6141084D20FBEC278D289C283E23CC1FA02C1E006081739F38D57018954240C8847010F8533FFFFFFC74500030000008B4C240C0FB60188450489C82B44243883C41C5B5E5F5DC210008D34338B7C243839F3758BC74500020000000FB60788450489F82B44243883C41C5B5E5F5DC210008B54240CC74500010000000FB60288450489D02B442438E9B1FEFFFFC7450000000000EB99E8500000003EFFFFFF3F3435363738393A3B3C3DFFFFFFFEFFFFFF000102030405060708090A0B0C0D0E0F10111213141516171819FFFFFFFFFFFF1A1B1C1D1E1F202122232425262728292A2B2C2D2E2F3031323358C3")
EndIf
Local $tCodeBuffer = DllStructCreate("byte[" & BinaryLen($bOpcode) & "]")
DllStructSetData($tCodeBuffer, 1, $bOpcode)
__Au3Obj_Mem_VirtualProtect(DllStructGetPtr($tCodeBuffer), DllStructGetSize($tCodeBuffer), 64)
If @error Then Return SetError(1, 0, "")
Local $iLen = StringLen($sData)
Local $tOut = DllStructCreate("byte[" & $iLen & "]")
Local $tState = DllStructCreate("byte[16]")
Local $Call = __Au3Obj_PointerCall("int", DllStructGetPtr($tCodeBuffer), "str", $sData, "dword", $iLen, "ptr", DllStructGetPtr($tOut), "ptr", DllStructGetPtr($tState))
If @error Then Return SetError(2, 0, "")
Return BinaryMid(DllStructGetData($tOut, 1), 1, $Call[0])
EndFunc
Func __Au3Obj_Mem_LoadLibraryEx($sModule, $iFlag = 0)
Local $aCall = DllCall($gh_AU3Obj_kernel32dll, "handle", "LoadLibraryExW", "wstr", $sModule, "handle", 0, "dword", $iFlag)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func __Au3Obj_Mem_FreeLibrary($hModule)
Local $aCall = DllCall($gh_AU3Obj_kernel32dll, "bool", "FreeLibrary", "handle", $hModule)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return 1
EndFunc
Func __Au3Obj_Mem_GetAddress($hModule, $vFuncName)
Local $sType = "str"
If IsNumber($vFuncName) Then $sType = "int"
Local $aCall = DllCall($gh_AU3Obj_kernel32dll, "ptr", "GetProcAddress", "handle", $hModule, $sType, $vFuncName)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func __Au3Obj_Mem_VirtualProtect($pAddress, $iSize, $iProtection)
Local $aCall = DllCall($gh_AU3Obj_kernel32dll, "bool", "VirtualProtect", "ptr", $pAddress, "dword_ptr", $iSize, "dword", $iProtection, "dword*", 0)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return 1
EndFunc
Func __Au3Obj_Mem_BinDll()
Local $sData = "TVpAAAEAAAACAAAA//8AALgAAAAAAAAACgAAAAAAAAAOH7oOALQJzSG4AUzNIVdpbjMyIC5ETEwuDQokQAAAAFBFAABMAQMA5krtTQAAAAAAAAAA4AACIwsBCgAAOgAAABgAAAAAAABbkwAAABAAAABQAAAAAAAQABAAAAACAAAFAAEAAAAAAAUAAQAAAAAAALAAAAACAAAAAAAAAgAABQAAEAAAEAAAAAAQAAAQAAAAAAAAEAAAAACQAABUAgAAVJIAAAgBAAAAoAAAcAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALiSAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALk1QUkVTUzEAgAAAABAAAAAqAAAAAgAAAAAAAAAAAAAAAAAA4AAA4C5NUFJFU1MyFgYAAACQAAAACAAAACwAAAAAAAAAAAAAAAAAAOAAAOAucnNyYwAAAHADAAAAoAAAAAQAAAA0AAAAAAAAAAAAAAAAAABAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdjIuMTkIAMspAABVAIvs/3UIagj/ABVYUAAQUP8VSlQM0DXMQgAsBgXIUoPsIIPk8NkAwNlUJBjffCQCEN9sJBCLFrAIQEQCUQhMx+MNkF4oneeRzUECsMhAEhgPAAAAABgY/P///zcIAg3ABBSD0gDraCw65DLYLqMNsI5EARH3wipRh5sNwUWCYRDJw1aLAPGDJgCDZhgAFI1GCBUAgBUAi8ZIXi6xaEAOB1DoQBPOkDVojGD1D1JBqANew4sBwwGNQQjDi0EYZxAAi0UIiUEYXcIFBACLQRwgxgESgBhgdbWY33iHIGA26ANAdyBIaiAIWP8AZokG/xVBiByQeATx5cVF" &  "gC4wGIwQ9V/BGw8DhFUBbAT/FQQ+ADCTrCYApHUvDvAAGXyfvYAcRYDO6P//zxOJBriTAABXEIRUAjBKDQacHIEJjUYYUMcGCDxRABAdMItGCECL9QBRCINmCABAXg1CVot1DFczAckzwGaJTfQGAECuRpDV2Ac/AyCdWAR/XGQPAAAADJBYpG92DFDkD2A0f3pcBABOQCAAcFxkDgoz6jDgDmBEtwGsCHACPiM9f0oHwLDYBJEYgCtwAAQAuA5xAsAh9gJAMAP85ZUszAB8EGMTjUgYUf9wDAj/cAxRE3kQi00AFIkBM8mFwA8BlMGLwV3CELNAImoAVkahFmA19wHYG8BAXcIIRA8AAaEmQKQEALgB4B8AVLMOgPDvRLAIYkRwAOCM/hgAYAJglR4zA3wZmDZhhkIAkBiT2BdEsFg0wJBoxLBYJAKBAA4UiUYU0xGlY2Fwo2TYFSLew3AVFPALQmXVKQBcFIAxFvMLAQpSB11RdQiLBlYi/1DMAJEI0xXRBd4Vww45AwODIAAzUcDjQFNlE0YYV2mzJIs9aRP/123jVfwN//+LHV8TTJGYBqEwvWjEoacMbh/QUewGNJFoxCEmIGKqKf0C6/tiMhQAIgZfMl5bhxBZAP82ajITAJyVaJBoRFAaAPhA8p9EsBhEsAhQhbADPYewmCCwSBCYSBDZIDEF2FoQP/N/bMAiBQAAkeMHYeexCDgfwIFbuE3nsEixjH5rCVMPMEc7AX4QcuKNXgwsICBCAACw2FNO0QhghAL1f91ohMSrIDgK0BWwB7gPu2iXAVJov2egMf8zDoO8B7BtUoUxIDDIjgEwtag8GB5gdQXxUCjMA/bCAg8ghbkQwvBAOCKAAADQw9cVUNe2SFDHMeiHgAMoB4AbAEYEM9uDOP0AD5TDM8CF2w8AlcCL+IsGwecABAPHD7cIg/kAFXQZg/kUdBQAg/kadBuD+RMAdBaD+QN0EekA6wUAAGoTagBUUL0DrL0TNnxCCQwQDE4wYAz1T1fgg5Ce" &  "YGAOeuYBGASAMIiHAPBACERrAoPAOItNHAH/MVDrbT15PKDxUFjYTEBkkUSChLO+/QUzRPAFEfBQuIQHA4sGLUAeLRA3ABgadCAtEDcAA3QWALgFAAKA6UoMpDfABu8VdSCnODPAl0DSs4cbXakEuKAOSBu40FjUOGAH8x9SgeoEhcB1OU0Ak1UJaBDHAmaJsQZZGZAmkBgUd8ChloAFYZYYFF3AkQiHAT1TgyekSDBojGJFs86YDxNigFAOAJVeZfARgUcSEtlgpI8BAYPAWOvhPXcwIeCy2Icw+AcTi4wwsFgHEqa3pXFHgnwA00OQ/tAUgc9fR8VUCIJBBlhk0QcCdEVGDVhqKGaJDAfo+PjlBJkDE/8AdiCLyP92HP8EdhhW6M4hA+sCDDPAiUd5R6Ays02wM/zA+GAvCIsAfhBHO8cPjQCAHOHHsMhzmNgXgGC2s/xQeIQHtL8jPhDyO8A9S/GMDrb+PUANCTleCA8ohMgmo20CSA+EQl/HAkgPhbMoUbfEUa4wiA8IgThgBELWDJDLAAIwp8AxYJaD8FCYoQVrEisVoJsR+PsCByKwRYGUvEWgNjCgMAO8JVKYHEaQ2ARyRmZGsINBtzDVQptTFATyQtZIdIMANSYgSiucQJD+pJA1MKC01Q5QWHoBDnIB0mgMAheAAnV/D1ALAIsR+YvHkRqD4ALEIWQwAG4wCAyRFS9QCPTfHjAAvEhkjABtpAA8BAQ0998b/wKD5/6DxwJVAokARfQD/o1F8FeG4QEg6RQI2QY5KymW7QT/NsEBK2UD9SX/jCIH8Iw+nSEhCSCJRmAkngDZLbCIhTBYBsAO0DgkkFiEDtBYhA6lFqDGAPFfgWkUEE0MUVAQiUX49WpThdt+EUaLw1UCx0X0OQMAAIld/Itd9IlMRboAMTDshVBRAACLA00YjUQI8IEBYAPYyTHYhgExOAwR8N/EX/f8X5cFANi1segFtliEfxxiBJYcAJBevhB46ZUXeCOZJVCC1EqRgtOHDhXVR+kC"
$sData &= "hqV1i/i4ga0VZjkHD4US0RdWd9GXANEXBn0GWfUCCASDOP91I5F8Zol1HpIUYeAADRCUqglh0EXDVid7AEwByQSxFiUJ1J4AFaGiGaFfIBh+TbeoYbDYkw9RFHRQFHONHXkGZDapAlkHi3YYAIl19IP+/3Un4J1xShNRGjHYBy9g9Rx9UaSUXtOi0BrQekBUYUlEEEBAp4DrUBwVkNMF8kB4ry/MACZNCMkh6YdeBNHezFCdQpGDH8Ofg6+An4Mvgp+DMZwFkIPGP2gGhgzaDwAEk3KiNmCWaITigmVFAViBIgklxhIxKNAHApDoBZZXQBfX0CDidFBZkv9OCBEBgZUm/f/9fwUD4QMY6wW4GCHMAMnCJOxSHGTvAN4OAeLtAGoSwYBrWDoChW42o9YAvgTxQGjuIOCDyP9yHLN4HLNurzYhuBGPHtVSELCIPbj/7zeSACBwtciDWfjv/gDPoO4PcmXoMFONTgzofznGAyAaIToeVl4RC0ILGSBI8IUHdDNYZTaIA+BHV7J4xDC1iMMBKxTxAGBQO8EAuwWyvpAS0PjEgH5JppEI4SUhM9s2E3C1CNYTU2EnMYleBIleAwiJXgyJXiyghAEAKFCJXhiJXhwDiV4giV4k/hHlIlFBWBSgBoIuKG+NAAA7w3QLi8jon8qdLbYI8D9VHOBNA2pTAiDwDgJoWAIawAJVP70IV8IasJwj8OWaAZxmEhIVlRNPI8UA7gGQ8yUBYddXFoAeXxbDAFgWlFiEsD6Q2AWE0DXCv8iAmNi0hu8UIJUDULUhi0DgCiD/QGFLEECRuwEkGRJAEboSDxQtEo0WNTL/RfyNCQA7RxByg4tHGIDdAA7/dyCLzv8CdxxQ6HEDtULJkXE2UVH+HvdQaKkwEEQ94RkAdH0xDYNlQPyNA34QQE/HRVH4QgMAIJoBdE5T4hgBXI9UblGH0+iFMsVY+tNYhJ/UGLhllgg1wDxWebtPdbRb9XYZ1WJTtdGz8JUiUFWRAG4Scr1BtQEQ/zZocOIN" &  "Bt1q7iPBcQxgIwH/pcohgiGZAGiEhLpAKJZ2FrHODQeccB9gVxHrWb9wQAv3AVoUsS4KB2XIcB9ghBHrhXAADqdiDnBiTxHpeg/iC4Hmx8/3ARIVwUc1HHEsvhYQkDKIb5kBLUkCuAYeBAHGRwgtLWogi/noNJfvghSTqgafqmCvdhdQPVB/YYMSzpUnUTd5N1cMJMDPBFbxCtEqNiSVGgUkFAVPIBAFNNgXdcCnkAZTlBEEEwmbBjuYR8AAcBzAX8BQlwDuJBLCLOL/IU0Ii0EIf0BSGuCSIrImgQtOKSN8IpVGaEjo0DvNmTSQTiGx2kOCxfcBm3yIxqexNUqafLAuBwd8cB+QqQoXVXBACfcBmHCBowoHsHAfcAkXG3AA/AqnDXBiWZaiZAApFoEpgBEjDIP5nHUQ9gJFGAJ1ELh+DhIYRCGnAUUYAevuOioAWUVgxKC3EXQPg/lVm0IMAIEYf4hwBR5LLmkAOVjODpCc9yHRcbKOH3FQ46DJAcdGUgwBIJNexwwJAHVBZQg5UlnIYIkFO8NVBUaCVUVqaOhD7ZIBk9CZb9DSoNpBfOQvAAwVQACadWGLfRyLdwAIg/4CdAmD/ggDD4VIAREHi84AA8kz0maDfMgA8AiNTv4PlcKAPLBtNsiDjPAQUDm8MP1Q+MIJgBIa4D9Ql2CWgwSAQDegJpC1aB0QNSD9TweNzgBA+HozgUSw3jeYL5FZ5+TVEEgI7h5AGIRej5E/8HD4XZVBALEYPACcCSAMDxoiwI0mAXYEi1wIwugz/5RQJ7AIoL/oRHA19U9HIIyPzgqRL4ZZt/eSBOAwApIV4CkQi+4BkQBAlMkSTgRTUgGAxq0aX3HFfJexkgXlEV+HofIQdUq54B0AnTKJACN1Oh0CUYvWndIuBRKwjjSYb1l3VBbUbC4D1hOxzhMXgwMIOBHQsoiHcIVGXoaadGCOIusSrRLojM0M3YEozg/U5fxAagaSgYBQ3UJzEKFm01I2gqDyAwwACGpoxwapHeg76+AZ" &  "Px33A5o/sRg8iAQB8D+TnIiQiESQkohEAQzqP2JE4P6ThO4+IPFvx0Aj/3ZTCFSTRQ9BBBY3A8yThj6PoKpu6ENGBIo+aQAAyCEQWjOU45MLL7DYhQAwk2yWs/BAGAtaaTEcRbBT92A2CIAnAEA3cLReEJhhkAgR1EiwBAYAAHXhhcl0AUeSViNAOEgLjUHiPKCmJFASk+jTEuPREjE1B+WsAyUxhECgpVMCtXEk/OmEsOgkeAMIiUAIHDADPPNvliMRQGcDGk4MmQcBETt1Fr0HiRwBPADQSBQgsOiEkEhAoDAoTMADR40gBD+MgABQJ70+NmBZBBoVtBgEoUlkjkPFakEgBBYEQCA9ZGY8XEcyGHCQYwRDV6FqAwFG6SBgEBS1B1TCBLLeZM/DPHUe0FT3AF0SPbduTCgCIzAAdBAqBwGE0a1xEJAQEY/gYRCKPUih2IOJGj+VGERjaIRGQLo9nDFoBiQuBBX3A6ToFTc6i/iiApBOQQ4IZQl+DkBA6wnyGWT4M3kggSDsAPoPMQMMBYUGTRIKR9Bo+BBRav//K3ZATiXBYA0RhUxhUAMKNP8VCGEYyUlYfWEImQAhEY10R/4mShCgUqczA3ylZqAUOeiFDS1qRWBYA2oqmjMxgfv/L3QSAXRSBaBcACZDiYYgAHHcDRGNsB600ZDxQCexeJyJcKFDNxGM8BSM4tACfSYAEACNNE+NRgIYaGBTbk/Q6DKznUU1lOlRUE2B4U8Cg34l/ir9AHUpkiDgnxAPgGLk3xCmKlUUGOuGsqnhOqlh3Qo5AeIBsJggnL6CIQYxM/bRAgAMOXUIfg//NEC3PSRGWTt1CHx18XE0tQYcRMFBGBxkxMEhg8QU8RRqChIlFqVxIWIP8V+B7kgi+BGLVfzKGNVYxB9VkC0iBYREq1syUgdQxC+HAijrEVQCW3Gyg7xRAHyPfY/NXt2WSxBQ9A8VFdXNYZYDQLjkU6BY9L+OYIkG6CpZAMlCR4M6/KaoBYY6BmZqG8D6DsC1rJ9B"
$sData &= "nBCE+hHIqJSNCkAJaJDdxZBdxIDL+gTMWfAJ4Q4BFhF0KgOLwVeDfQxaFZCDIMBSB6Hmsm5NBTgALnUGaixfZokEOEKNBFGhKNpfwJZLpE0wjUgBO04IIHZGslKgRtBIBKAsKUChPDvloi2Ar5UEOQBGBHYOiw6LDACBiQyHQDtGBDBy8s5JlACQ1cgEoCCQ6JOo2hEOtkmQSEAR+G9EUM8VNcMAjFMEodQUZkpzbIDHVqZgPQCaT+D4BIlGNBWJRkCKO3Al+AGNXksBaNJCCItdDINlCICaIIDxYFtEMVgGRYECOCiAMZVoxMGT2GVNAHEvRlXAn0hQhdFIMOVWJHx1QQ6JDIkIjURTWi8AgLBONpivQFdgYFaYXKdVKNCugKCBXkZupTAKJeHt5gCJAUUQ6wSDZRAaGmLQBIEOUuGhMSiQdooiFChhZRGu4rQSwikBsFiE8V9E0UiEKg8TDBJLINQQsFPFn/FgOCdoAVYkRAHg2VT2yRK+LeI7IqJNJl8PINqkW/N5EJ5NUTIjYRGDfoIE4E9gogIOQOM5IP8VEO5ZAoQpypB+OKggSAT/FRT4elrhsECqTaDJIO4tcQexPqahigLOLwKLzpEn4PySV04mLvDn/ILGzi/i7EKwEinlAYcc4jjxX9eg34Iv6yeBBvAOKuHsYm2Czi5m47UVj1B1YxXsYhIDXO74kOFR8Qnd4qgJAkog0W/vFgDiJgXfCgBLXdxJ/x/YtvS/wp3aCP8f4PDfQP8MjLBGADhBf05EkFjF/63Shp8Bf4CfAcqXAdRNUoSfAb8wA2w3AzhdfwxdDvENUU5yMxvkoOkQ/S0GEFeJXjjdDVIgAHKgRoEuDi4IcgkdYhjBB5XGVfHXwWKWUm5h679h7Rb2Aa4ncSVOAhgxAXobF2ErTiLcdg4g9TAYiiPgKQU8EwB0IgZKEnKhDhQWHNDpTRLr3bUZtTpJC82EkpysYdJSdbrqJbJeK69FgOolwM40KB5gVSdkoF8SdCiB+akQdVkg/lM4" &  "YcsQSgIBhGEwAJgOV+AIo4wlCQQ5WDwAdQk7y3wQO0gCEH0LZjvTFiekAOnfIemNoAHFsEgBpNgPsJiEMKCQKFCFvRgdKO4/AoAAiU3QeQVKg8o4/kK4oEgkuPEPhADQGPSfuSK8CC9xFe3vnSGLxuYZUzfE7WUwY9///2JOYJwx1WwDNkpgwgD2ADFgUoUPBhBgiwEm/GAPAPLv7X4AddCJReQQjUb+OiVATJHYh0CdWAQuIxOOAwmQ/RLgJRUSeQVIgwLI/kAPhOFyULAI0ISdk1MntlhnBC5LEgcD9gIbIGcS8Yxs8E8H7/JAbklxsAhDBC+ZBCYYwL84H2xgTtDIY6BZAdUXAzZ15OEEFgiDrawA5RNFCeB0MEhNA9H4nlNBELC+gl4WaLCIfLBovFIEziV2ZCAQBWDsVggTCLBuupgwMADcSBQMD1UD4FkUCItN8IuAUMfeSEKE5HEBOCqU8FCodWGEEU36FSB0EQGWFLIIUAWflaWmkvVAcgtsLgFXV1kAZolgCupOVBzQRN8AAJRqshMEiGCgsQL4CC5WAGA22McOkNgED/FASBAywm42mA8QUXejFoBO203y/6/LBABZIQB0DchKIqBTEBQd2QsPahEaagBWfQFpEIrGS9AkwI4YkF5eItMT+ScLdaIggH4Hn04HAC8lGxleKmA3ojIEC/yH8/Ar5gVQwQ4CdSIKagLoO+HwAo/hEDgIagLrJpwgUZeDygkTnC8QxRkQahK1gXBmqnTRJZCYGDaRCaBAgE7Njf8Bzfhxg6I2kQky0DFAgM56yfkCCh4dIwOZcJUwkXBFDJEAEOhv8JBVaBOddpH6wN5llB5uwilwFEJjEJRAAhUPhLaqJEMQDjITDi9wFA5DEBoOlx0OUMSejREOJVQADwjo9tvwH+CoCj8F8NcNL93w5oFTB9Z1IG4TlRrrKmrkFnbAWrYBMLEYAqIWgGCVWMduYiDrB8cYRewo5gKgYwABAOhOf9kAWYtdCdYiAQRWmLYiUMduK1LN" &  "Uh91U6GV8CEslTACAOgZlRCcXQCL8NCgUhJhUAh1UkphEAUBAOslVcAQx1VgSTAFvjBBAHxghyYGRcyNRcxiZ6EeAjwYmOkDthrQA6DxQCi2W8oQuVFSV5FF8AmknUVXx6FGsf6yyBYmdUJsMMhGaMCRRVeRTKShEF0niVEGBOtNahXBh9JUwY6s2CIaMrAeEwKR8FDY1tcLEG9gEwNgbQIJoSD39isQh5MgIDUHBjorpeATzQEQiTyZMk2QSJCZvqSQHYBG45GgYxUAqfQfTDxBZq7ZQfYKjm2g5lGyfkYEaEDVoHPV8CJdTIFmONUQgZahEB8KAqBuHxB6QJJZcBcugClmAok1NJjhIhURUBWhRRUhuTX3FVzoUAigDScEWY0AmYEA6TpZCz4GVEQvURAAPFh0BGoI6w/gbgZgaBCyBfBwSxAMRe6pMtBgTwBZuSIrshNc8UB4rRwFZu6DQOgeFYgxEQ+Fy7Y+gpDYJMA+iL9QlyLbQA8+twfSBdAXVS7hO0BiLIAQkd6fIq8REXUotK8wqlYQiLBWUOeB+AD9Hi3dXohFgPgCfgCRjWi5lnLgqhQAmA+QpZEezlhsiowbLHGHBJoIYDX4gD9Q55dx0x4vQANhEgEIikXs6fgnORBxEppC4LAWKhvAnq6MJFATikrBHjJHUIewrQkHPiihMjCyASMVgkJHgE/xUJgfSVE0wp6ZGFTwUKh6FbICANHdhZ4Rn1DRXYQ+ExXVJ2CwAuhXtgnRFFRLtoJkkRYjQLauZFc1QbbaZEEdGUJAtmsF+QgtQgNkG0MWzENUUTVBUUeCB+hJYdbyElBEYMWwThEjLyDatkETtjFIgmkAB9AAQzP//03gg30C4P8Pj/32fhNQxICd2Adt/xhNAzk4MnRmOhvgFSEYU2UKask+KSGtAXX0wl1QR+6NFgZ1+FPosMEGJkaAu3ICKGwBjMIW4EsS7ikCzhqkbIkB/0gIi8aopENgnhHUmmoyYL8IwAWP/3BLBA/PNxW90wrQvOCX"
$sData &= "Bl43kpWF6FADHHVEWoHRWAS+yADQUFPiHMBruzESYGFstQi9gP913MUgOSHrBIc5fdB0KgDAURFoKhGDfRwedAcYQfBR5/BwKx0IRdTIbOFGFEW0th6U48cDQAez6DyzjQ5o2Aiwc1wX44UljfADL7DxEoCqACB8AYteGOhAUnYtEAwusNjHrdDYRBtVFnPlkwP/FHXgUDphgCfCEmXIoLEAxEphcKTGkNh3RWz6VhjieAFv+lZCT6C5KEAUNDCzndgFnkPQxf3gqKrXBDP2jM4u0EhkYNwZchhDv0jSBO4MAEipNhbxQCjFbAYANShyi4wKUY2sMQUF5QcA6hZmZuoHPoSBnOAYA5kKHoBh/wT4AxAPlMILympFYHAGBEwOCIoJYiCAyGRggZGO6RI/YRcAHZuaGkFkoKAEnlFQ6W8JlnEQYJZI5ICR7ok4YAKmhoEoZosA6+GPRCBB504B8QpcZCYniMg5QFdOAQwPhXDjjS3pAJBQhJHY9ID9cJtQH5UexQTxChkedWMRAGIFQuRAFQCLQAhTU2r/UAVTU4lF2MaSo2XgAJMeH3gvLYAgzIn9B8YJMYE9NaVlBnXQPoplfQRx0FURLibTFjKI/2HLB+CdoJpnAhzpjCwAACepACJoQDfRMNQRRCbEKJGrUIWRmD+wCGTdtJAswZEsRVEzB3kELuvZaFBRM1L0AEjZioo2kc1lkDtWgGbdq2jRjYYeoktQlBvQPKwJK+niWQGM8MH4Bf9LdIyg1MIoCG6NEVtrs47GBfISUKSFAyRQwlB3oTbQkVQBlh7piD8mdQS+G9BuYR8BJ4QmXVGFoZbgsgBMFvyhBGkoFpiQLVMLYbADRfzIvpPhMTpF5CyW/vVSnnSSCdD0gISvkxFcNRA0CFm5FkUwANX2CQHRltX2Gus4JhnBEQgTB/LPriIJpFQxcqFCALUM/zRsiBF97h3xL+8ATihgDDGwU8T9wLhl4hnGA0FssAOJHfdFHD0ddCahMRgVMQgBi0W8LBCW6UAZ" &  "pQpQDOk5giyB0ISQvq2JIX3UHj11WOU4nTLAkSnCnCm2xJEpqAGdKcJhNwGVEnbMlRIeGlQBYJUJIDk0dQgIWesueRAfdRqEYVoB/3W8kXJBCD7rDSoD0h5h9SdeAxJT8R9WZxcAwoBSBN/oJ2cGNXUgioAgQ0cHHUNOklGhTjvOA18gLwNb9jVAAgJAyEo0oDQCXM8iQ3OwiCySnmpRAzPAw/JmYKRPhdJeQQWqMgAGLWCEYLCI3JV+SybarYdO1qA4AO0A6ILdCFlZ/45I5D4kPQVVETJkom9FtgnjGib8pC9gMxakxoUKZsFFakgd6J3OPTEKK9ADgVwRoVftRRIyOFAFRAl3lHSxSxkUlJECwRr+thjBKt+icOOVA0qw5C0XXjnhLTd6cuOrdTQUJKByRCTgdxR5AVY06MCGN6CoWlaFBRAzRPamhPFfgdFdgb9D4l+n6ArrPz0B582AiQA5dQx1EjvGJnQkfnsQYBUL0B1CsUsEEjzg8Ag9ElaFIRY2QBoKQGG0AIvGRlw2yP7G4O8Taq/BYGoExQF5EKpU4hknUQEBJQEOsQXaR7IOAD5YRg+wiGDl0FhFLxV1IswBYMCQb10EQlXAKOoAASL33qJU4AA9UkSfeyAUNbHQMj3A6zYCgAuREsgAkQGBSU+F9kI/oPlTgX0IQK3Gd1AHE9jH8A7kCwInVmr1/xVgJCIgkSbQWIQApbYggoZApW8iIFSAAX8cWmYjH1veYGMPe5UwPEdCsv0cDBARJoAGoHsTFUwo1g6BLqAKK/EMCAgEdAVqClgStzBjL5FTA+0MCHYetRM0MbVILKCxdBFGO3QCIicuMiFeXcNmixIEdQBEsD4vEkSLAQaNTQhRaFCeY4Bj9S8hEnJ2EBaxCP+vEAWy/oFHQHg2sY4ndpQAGBTSJ4LQBVBiUgSjiRg5XQzqQeArThajtrdQCgBf6xXaFJFj0kevFkEuaVEPoFIRnQMEMSU1D4S2h4FE+M4edIwExIRhbikED44CjaFGcIKG" &  "KEYCagR9CIGTDpiRdZkAgqA6EYk2dRvJFt7WvhODheDlBO0kwkRgJwUMCwCNVfgtCPwqlMEVYRgRh51lO/N10IUoAI1V8FKNVeBSwH5nkAfAu1gHn9OVAVHnFS6hAgfrrWkLJszKVkfzOWUDBU1LlapJAfxCnFMn/AsALQGNI0X0RhmiFjCVLdHIkBkyU0jmuADmAoD+LKMhDPRZ6539HlEwD4RcRnAwJVgA4Q1pTOnWUDTCYjJoyQJWVzPbnnBQgdACEBaggzc9RdT2PRVqa2B/Ed2ErJaCEUn4yxtJQxlJbyBCGAIAEBBghX7XUQ5gjQHiptGvcwFlC0IuAIC+nPz/b7WIT4I+zAFqRHKZgJ5bSAKL8GoQdi3RygI3g8SCMyCrCeRhBypc4P0REv8VTI4AUYOkwzJDGmj/f0plEiNAhARoRqA9AVf/1rxAAWhB1DSzjtJYRN0AgOwwDHFIhBtmgZI+kkNuryUeCeLrEmjYxLNY54Ue68BeQAAAhgKAB0DweCAnBI4KI3FWWVk5XRgIdH6OIGAFCAW4uICWpKCmMCOddR+PaCkJiV0YAgywM2yHwfQ7UD+QjPFv8x9SwWPvEX0IdTZ5M8WqBhE4Vheipj4EOK4OEqjCBhg7RRxyx7CBkjCFHjRgYbPYIwTDEdf/dgRqn9AVBx8aEBNi+ERZ6SFVAgY4XRh1DW4EoVUA8JS4sJ6AIiyGBbP/cELo738MaPS5IgpvEg8gxoAColyR7mqTG9CEQB+FBpN00UQcJfIPHUsQPmNfBSG06jcgAjkgZBk1L6EIEQSgqp+ABjQFagJe61QZVMZWDQFvSgD2gwrm/oPGThZA37iBz9i4QC01ZVYQJgFQtxMxTzfWxNJYhVG+ABSl1Qt1SU5OdAUETnQc6zQOYQFHwepXARpexhDFASoi8F/xBmf6IGQvQGeMQUa70NZhVwXitW3xACCRDnxjTgLz/15VgObSBxDGkmdgrwLVEqJZIIG/LpTIQHHc3cOSWseBX97FQQb6xmST"
$sData &= "JhHOYs8g+FYKg33l+AWiVgoyLCYqGADSIqewBFAk5VTENCPjAkDGxgbANkcnhzAGl3cFImxlbgBXAEdldFBybwBjQWRkcmVzcwAAV2lkZUNoYQByVG9NdWx0aQBCeXRlAEZyZQBlTGlicmFyeUgAVEb1hloATG8gYWR8VIR3BWAEwFY3h2aUxlYmIFRnZlYm1wQgh5FGVwYUsRBTdGQISGFuZDAw9NYGABcmVzZFJ5cG4XZ2VQF5BTDEBvE2V8ZJVGVybQZpbmF0ZZ0RjRFTCGxlZXAtEEV4aQh0Q29kYDYkVxaMeWkiTW9kdWztIAhOYW1l2TJjYXSgbCIUBSCXR5UHZ8gFSGVhcJkSIBLkwMb2NhY2VQLAFAAiAJTVCm9sZSFEQ0BvvYEASUlERnIhb20pMgBDTFM8g8gPZ0lErJDkliZAlxbGlqZXLVGl45aGg6zFXm8ZEVUIbnVzZXVAaWVzIkV4NRFSdW7kcAbwJKZWNkZHFQYnlkARLJIn0fTmlgaxVibHD1Rhc2sSTWVtNSJDb4STBOA2RxfmNlYGAAJAZBQAT0xFQVVAVCFCAQUBAbcAAAGjAAG6AQG6AAABuwEBkgABAFQAAQgAAQkAAAECAAFKAAEZAAABEwABDwABABoAAREAARgAAAEXAAEMAAEHBAABfQABUrWgAAAQMAMQIBEQcCQAENADEICIDwEDATYAARUBEoMg2icBU0hMV0FQSc0goq0CVE0DdDY0vRcAgIoIsYhHsPAPRQdQswiFsAgzAA+wIr/ovYgEsQKxTDei2gUD8gP+ACvAK9IL0KzBAOIH0Ohy9gvQAAvSdAgD2ikLADv3cuToFjwAFABYBabXAAAfAUAABgFADFgDAAoIwHVvLbKkAACIA9BUV7aIxzOAD7ACbLZ4RDGAbzB4/INeRQ11WwAA6AA9AAALwHQQPuhyWGCVJkdnURfGFmBAF0sg5AYGiHQDAkVlFwV4V4sQ2P/QOAABC4YIcIB4hIIFRQUVSAX/01iL/q02XUBA" &  "1zOAb1UEsoiNwKoADKseBP919oAkQBfOA2JH4ARhtZ4QEtDqZGxgLGwCbSCrMsCMQAh1BPbr1+jmCQFfgSDH7vIDAJuuiutR6GUAq2Hpk14k4KJRGhMluEXVAyW8FADw/xsDALURABBnJgAQNa4SHkXAAGAMMMgAQKYM8AXwBUAGAFAGYAYQBlAHQMEGQMcDX5UPXwBBTlRwB1AE4MYFYG3dL2QhBiAHkKZLDGd0QDpcA8cPcooM0AYwx6VlVCBXA/DGAF1QXyxQRgnjtZANUKQBBzDWAaAcAbVs6tYG0gw3xEhBzJB2RiH1EHls4jHRK0PA6gEAIcYCBScAABBcHwAQ4RTWartQIKDWATDWDgAQQ7o1IWE0ILkAABDUJkAmAtBEA3QAaDUBZLZMBlUXVCRBVwrCNUSvNSJ0VFBXBdIqwVb1c1ZSlNDGBnYcUAfRxt4RUAIBEH5WBdRSbyATIgEAEcIAiSTNNTqlLCDEACYi/TVw9SD1ZVMAVxUDMHc0ClAPgMqzY+UgY9UAAAB4yu0D/RNKL/1zbizgPcoAY+SQBqDDTCxXAQLw0ixQ1y+SRAFYM+0CeEUgTFEGMDVOAuUXrREgACLMQhG33DHFBPUXdCTQNNE4gVgWQcTGpi8BQ2xhMHNz8hLDBExvbC4AIFlvdSBmb3UAbmQgdGhlIGUAYXN0ZXItZWcPZy4gDZrTUBDQaNub0ZbWK9CYQUcFjoVxV5x4CxBkRFBeQdZDJkgDNQNXbwUGZ0yaRgRlFUT1BkAJLbBshao8UQHdFNFaAYvWD+BWi8ISYSzSx9aUxFjNlT2WJIXWDbxF1g1QRw0dUGYlIQ0TnR1yNgByJ9ATRjN2NSJ/aRUhrME2HXIAwV8Asd8510HZGEFSjDHXw1JpcQ0QNClGAm/lKCzX1GHlxiN5bW1ulSAsA3Dt+A8AAUwzRh1aPCXYG9gAwVMKQMRTgCPVAH8HThsQri0IDAArLsdqKgHw/44IEQBFCwQgACBBABMEEjRAAAwAFAAVokBw" &  "VMADHgAfmlfAdgTRSDMTAAkEABAEylBQg1+lGAYMwM0A0AxQBcwAtAyAygCcDFAFyQCEDMDHAGwMUAXGAFAMQMQANAxQRcIAHAwAwQAEDFDFr0wG7AwAzgDQDFDFywCsDMDJAIgMUEXHAGAMAMUAPAwAx8IABiMD8P8ZHkEUDiAADgMWPIQeMkAARCAeDANQWEYAkEokJCKqOgMAamYDoAM4HFAAHhJKoB5IA5YAdEJiYCrOWhwAUjIq1jwoJCgIcBp68DTiJVMA4MJA7MQwgA4nwAFEYUakAwBABAPqdkBAJIFfACAIqUo8IGA0AEAxQKM2QEGECABiIj6ASsSCBGCFhWWFNQAKBCA1QOWmozPAB6LHhwCOcKJ4AwAWBaI8FHIqigC2gMLOShaSegBYPEhIPC5CMgAO5rpKPEgeSgA8LlhEMvIcQAAcRkZOSDoc8gAcA34cBVy+LAAcHDxiA3ayYgADVEiMjBi+VABAPPhWKhQSNgAUBybCKrCQHgAODpI6GCQkKAA+ZC4sJh4gIAAoJAMCFiqYHEAqLEDMYKLAQQJgo0AjSSQD4QVg4eFgwQEkwkJASzOChQAgA7CzHATHMTg0g8gxAJ/w7wX3/4oNAACD+BV0BYP4FHUk3UXo6EnW//+JRgiJVgzrFP8VhFAAEA+3B1BqAFZW/xWsUAAAAAAA40rtTQAAAAB4kAAAAQAAABQAAAAUAAAAKJAAAImQAAApkgAAKUEAAP9AAABBQQAAIUQAAKVFAADJQAAAs0AAAJ1AAAD0QQAAWUEAAH9BAABAQwAAUEMAAOZAAAAAQwAAV0IAABdBAABgQwAAxkIAAKtBAABBdXRvSXRPYmplY3QuZGxsANmQAADhkAAA65AAAPeQAAAQkQAAK5EAAD2RAABQkQAAaJEAAHyRAACQkQAAppEAALWRAADFkQAA0JEAAOCRAADvkQAA/JEAAAeSAAAYkgAAQWRkRW51bQBBZGRNZXRob2QAQWRkUHJvcGVydHkAQXV0b0l0T2Jq"
$sData &= "ZWN0Q3JlYXRlT2JqZWN0AEF1dG9JdE9iamVjdENyZWF0ZU9iamVjdEV4AENsb25lQXV0b0l0T2JqZWN0AENyZWF0ZUF1dG9JdE9iamVjdABDcmVhdGVBdXRvSXRPYmplY3RDbGFzcwBDcmVhdGVEbGxDYWxsT2JqZWN0AENyZWF0ZVdyYXBwZXJPYmplY3QAQ3JlYXRlV3JhcHBlck9iamVjdEV4AElVbmtub3duQWRkUmVmAElVbmtub3duUmVsZWFzZQBJbml0aWFsaXplAE1lbW9yeUNhbGxFbnRyeQBSZWdpc3Rlck9iamVjdABSZW1vdmVNZW1iZXIAUmV0dXJuVGhpcwBVblJlZ2lzdGVyT2JqZWN0AFdyYXBwZXJBZGRNZXRob2QAAAABAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATAAAAALiSAAAAAAAAAAAAAAyTAAC4kgAAxJIAAAAAAAAAAAAAGZMAAMSSAADMkgAAAAAAAAAAAAAykwAAzJIAANSSAAAAAAAAAAAAAD+TAADUkgAAAAAAAAAAAAAAAAAAAAAAAAAAAADokgAA+5IAAAAAAAAjkwAAAAAAAAUBAIAAAAAAS5MAAAAAAAAAAAAAAAAAAAAAAAAAAEdldE1vZHVsZUhhbmRsZUEAAABHZXRQcm9jQWRkcmVzcwBLRVJORUwzMi5ETEwAb2xlMzIuZGxsAAAAQ29Jbml0aWFsaXplAE9MRUFVVDMyLmRsbABTSExXQVBJLmRsbAAAAFN0clRvSW50NjRFeFcAYOgAAAAAWAWfAgAAizAD8CvAi/5mrcHgDIvIUK0ryAPxi8hXUUmKRDkGiAQxdfaL1ovP6FwAAABeWivAiQQytBAr0CvJO8pzJovZrEEk/jzodfJDg8EErQvAeAY7wnPl6wYDw3jfA8Irw4lG/OvW6AAAAABfgceM////sOmquJsCAACr6AAAAABYBRwCAADpDAIAAFWL7IPsFIoCVjP2Rjl1CIlN" &  "8IgBiXX4xkX/AA+G4wEAAFNXgH3/AIoMMnQMikQyAcDpBMDgBArIRoNl9ACITf4PtkX/i30IK/g79w+DoAEAAITJD4kXAQAAgH3/AIscMnQDwesEgeP//w8ARoF9+IEIAACL+3Mg0e/2wwF0FIHn/wcAAAPwgceBAAAAgHX/AetLg+d/60WD4wPB7wKD6wB0N0t0J0t0FUt1MoHn//8DAI10MAGBx0FEAADrz4Hn/z8AAIHHQQQAAEbrEYHn/wMAAAPwg8dB67OD5z9HgH3/AHQJD7ccMsHrBOsMM9tmixwygeP/DwAAD7ZF/4B1/wED8IvDg+APg/gPdAWNWAPrOEaB+/8PAAB0CMHrBIPDEusngH3/AHQNiwQywegEJf//AADrBA+3BDJGjZgRAQAARoH7EAEBAHRfi0X4K8eF23RCi33wA8eJXeyLXfiKCP9F+ED/TeyIDB9174pN/uskgH3/AA+2HDJ0DQ+2RDIBwesEweAEC9iLffiLRfD/RfiIHDhG/0X00OGDffQIiE3+D4ya/v//60kzwDhF/3QTikQy/MZF/wAl/AAAAMHgBUbrDGaLRDL7JcAPAADR4IPhfwPIjUQJCIXAdBaLDDKLXfiLffCDRfgEg8YESIkMH3XqD7ZF/4tNCCvIO/EPgiH+//9fW4tF+F7JwgQA6di1//8Aev//ZQEAAAAQAAAAgAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" &  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAQAAAAGAAAgAAAAAAAAAAAAAAAAAAAAQABAAAAMAAAgAAAAAAAAAAAAAAAAAAAAQAJBAAASAAAAFigAAAYAwAAAAAAAAAAAAAYAzQAAABWAFMAXwBWAEUAUgBTAEkATwBOAF8ASQBOAEYATwAAAAAAvQTv/gAAAQACAAEAAwAIAAIAAQADAAgAAAAAAAAAAAAEAAAAAgAAAAAAAAAAAAAAAAAAAHYCAAABAFMAdAByAGkAbgBnAEYAaQBsAGUASQBuAGYAbwAAAFICAAABADAANAAwADkAMAA0AEIAMAAAADAACAABAEYAaQBsAGUAVgBlAHIAcwBpAG8AbgAAAAAAMQAuADIALgA4AC4AMwAAADQACAABAFAAcgBvAGQAdQBjAHQAVgBlAHIAcwBpAG8AbgAAADEALgAyAC4AOAAuADMAAAB6ACkAAQBGAGkAbABlAEQAZQBzAGMAcgBpAHAAdABpAG8AbgAAAAAAUAByAG8AdgBpAGQAZQBzACAAbwBiAGoAZQBjAHQAIABmAHUAbgBjAHQAaQBvAG4AYQBsAGkAdAB5ACAAZgBvAHIAIABBAHUAdABvAEkAdAAAAAAAOgANAAEAUAByAG8AZAB1AGMAdABOAGEAbQBlAAAAAABBAHUAdABvAEkAdABPAGIA"
$sData &= "agBlAGMAdAAAAAAAWAAaAAEATABlAGcAYQBsAEMAbwBwAHkAcgBpAGcAaAB0AAAAKABDACkAIABUAGgAZQAgAEEAdQB0AG8ASQB0AE8AYgBqAGUAYwB0AC0AVABlAGEAbQAAAEoAEQABAE8AcgBpAGcAaQBuAGEAbABGAGkAbABlAG4AYQBtAGUAAABBAHUAdABvAEkAdABPAGIAagBlAGMAdAAuAGQAbABsAAAAAAB6ACMAAQBUAGgAZQAgAEEAdQB0AG8ASQB0AE8AYgBqAGUAYwB0AC0AVABlAGEAbQAAAAAAbQBvAG4AbwBjAGUAcgBlAHMALAAgAHQAcgBhAG4AYwBlAHgAeAAsACAASwBpAHAALAAgAFAAcgBvAGcAQQBuAGQAeQAAAAAARAAAAAEAVgBhAHIARgBpAGwAZQBJAG4AZgBvAAAAAAAkAAQAAABUAHIAYQBuAHMAbABhAHQAaQBvAG4AAAAAAAkEsAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
Return __Au3Obj_Mem_Base64Decode($sData)
EndFunc
Func __Au3Obj_Mem_BinDll_X64()
Local $sData = "TVpAAAEAAAACAAAA//8AALgAAAAAAAAACgAAAAAAAAAOH7oOALQJzSG4AUzNIVdpbjY0IC5ETEwuDQokQAAAAFBFAABkhgMACUvtTQAAAAAAAAAA8AAiIgsCCgAATAAAACAAAAAAAACLwwAAABAAAAAAAIABAAAAABAAAAACAAAFAAIAAAAAAAUAAgAAAAAAAOAAAAACAAAAAAAAAgAAAQAAEAAAAAAAACAAAAAAAAAAABAAAAAAAAAQAAAAAAAAAAAAABAAAAAAwAAAWAIAAFjCAAA4AQAAANAAAHADAAAAkAAAxAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8wgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC5NUFJFU1MxALAAAAAQAAAALAAAAAIAAAAAAAAAAAAAAAAAAOAAAOAuTVBSRVNTMpUOAAAAwAAAABAAAAAuAAAAAAAAAAAAAAAAAADgAADgLnJzcmMAAABwAwAAANAAAAAEAAAAPgAAAAAAAAAAAAAAAAAAQAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdjIuMTkLAA0qAAAAAQAgFf9LwNUagdOS+vXucGtQtg9DS6IQmf+s8pSAof/lzpNbvs5vGDaqkwL0lyayt6KDCqSJQ4o1tatkkGwANofdA4t1w8Ib1+wlEQkEKJCbSipLHHBKr6/Y6mEy+GC/8kjnyRwAZHJdcZTrUHu/EzM4ZYl2vjnQzzYkf6qnk/rxKli+ZObHVJGRugdsa7cgmEKhtKgtlm97Yptd1fTZ8W0V0aJD9dX5Xx5s05Cg1bSMBOqTveIbeU7AWdiQbctnFHaIRzOyBGSV/iWLfo1DtY2VW19ylfldAtj4wdg2rqSXt9Lc10PVzlDH1LlD/vJgj20gjm2S167q" &  "z8VH7jB2pHdgeLrs1Qif14q43BxI7if+YepWTdE82gtmuL16a0jKG99b1EclPBnmDrcZCfXwtv1heCnFFtTwkB2622gtiDn8limF5QnuWJPeZdko1n/v3b/DWDcVSyy2oJYhUEnIABAenPJ1/0b5JoERf3hlatxDJyaIB/iSh2IBxS67oswIqw8YdcSY8RCApFvXesM71R7e8zC7+9GnYgzGaG6lMrlS3J8qg+1H3qhvwMfcXxwhMhN0yYJmtJhxMsGsL4gfLOehUMQy3TC9fvdGvdc9yte8W9Otj6MBNdRgcOB6sa12271re1W8ANDKGT5Vri7z+po7EIKsxt7qQdveg0Ytuko4flx6Pd0yxtpt6obbQl8bqvAPNDuHa/+xWkEoPTEeAxbJyswWSg/Rn49G4JqPV/STyM1hhHRMJylgSziw+Bdvety5PFNlD9LxZzPEk7eNavAv7Y0ngv7RU1iK9QRsqWxuSWcvcd5KhMBwYF60WWDNxtd50mEey4FgXHrbgxIqSGKtyNoTHN2r6U9YpJnsgAPGvU3l3Dm9lmYQdwFXNUKv6KyTILGfG/ek5cisQdG33iSDQ8BE5RSyBqn2CqqhmctmrPiN45rIc7LeA9tWhGXdoGeF3iXOcexsJuI9uAymuejHL6NTsrGEN/VUNH2CN3nv8EjcQ00bXnH+TOJwPot7ai8RAn/82/YbnKFSaTJDBTNj8+cuE+BXmKjOR6H/hBxTfhhg8jJJNlxpeBjGhB1GxgM1XoOqT35/qML/FK36UzrGHXh36l+v1IUcPCLcCLR/kgRJohRP+Y/KICHU7CTA7Ob1gjGXxtqrz3p3Qw6iEjgLWJ46kCUyB0foxhvFTXz1a+pDDTTxxamTmAmU496Fkx8E5CZHSdqca/db9xb08FESdqPOQMj1OBQcFzyVNV2qKz9JfNoPBlMvBORFawrKWRJdLIYYXTIXv9qx3XxQ03xkOLUaL0zlTRjTFt/wX/+pkU6n9Ew+e3bFqveiPWX7ws4uNeI+1WPs" &  "LYq+h90W8w404kVQDTd8EUq4hePt31TkdzqJ3ExIJ3LrctGBby0qBkfyR410J62WNhY6P/BaClRjs9WRL31bf1a8VbvnteNxt9LZ/fx8tW/oZS1VayXss9Cvbje7oa0NwqsA2kVSP2qzXg3+qx9ddTIYOtpJJ4YONKuOVJ/0vx1ZgGxH40389t3cIQSd5DT5OLLm6MEU/uO07G4qF7nbwKbqJnoNO06ibk2qsbhdjAPuThhBzDUS3LutqXtbNYRYyTVdU26yh19KFlWoV9ZZzuSJk1ViBoinbnjhQL3GZN30q9KPpiU264O+K48cFpOIuM9VtEthE5GWJSCkgzZpKHLdbnymQh+N0EC37oSpBW93Su4s/eNRQng7SU9I1P38o91Q/mc4AJVGr/xujvVG6D1JvK89GdGZNxdJ0yaSmtHSW0rCX2xQxAmu1QqxAdnDLKEKF1FAktIECPJf4vtTQQ+7btVDdSLq4xlanFSG6mSp2v/GEJoDRy0m+omziH194O43UoZwWeoRJC2utXXNEH2uYzHDZvMhDLIsGuBYfIikmHrQHhvAaYraPsmC8R9vP6r8VAEEbrhKTTvXZiPVUurYnS1xYv5dNJeBBV6bDQEE8msltmXH9aDqCzJMUETAaK0/0gyFadI4hI0aQVg9MPFAHXfd31x0WB6ovhsb6Ri+6rEyopfiqFpzc/J2ma2OjL2DOTZjwQbPzhkwYku5d1/fdTq0lvM86g6MSypSqvMkk0oTOc8dQdWjWQw1O6oJhaKWi/dHrsdZ5CQYK5c4ePapVjQ0jXqc3bWRifmQ8f5vf7Vd4+qPupUMjurvOBPsAK9iBUaX1yVSmCh9AC4roorYEVQFsRueUlseg7k6tYwlGiy0iiUpgNaZiTWGI4HWsFSjCiREQ/vUCja2qJ3cfsz5w1hUeBc1E7ogb/kwW9SMVuVrdKR81iFUssrOuBExX8LU2VqibESLmnfeGYcsplJIbEwrOXPb+c5Y2XeUsmeg55z/SK7nOBDE1xALvoFY"
$sData &= "vMJJWvZVmR+dtnO08Xc93F6P/VDacF+gL60GReMDBOIAVvlz1P4aqv4eYikNhp9dFi/ExFibBEyYaKigplYkoDg5SQjIovoCBquHQhUp3TK7GGOUzu7lMSYN9x06D91wk9ufK2Vb/tzc79wSlJAJ18TYR6o3WFD6yMbtBUsQyeG8+WbuZ4XHTKTGdDSxyaSUHURz5DBkPOtf9vN2KAw+HZyNvJoNzh6u7HSoPGduQ16pC5rif8825dT6rJGnuYBgzzqqHBfcX0sGb20pcgABcOZJKYKopPSxE5tO974BQPJ6lin3h6WdEMalA2pncPTKq3q5XV7Z6/hqoJCoAoNYvr27WRLTECETNaeE/0I5nBhTa/T3wdxpstHE2uFyzhjZsJe7/j+bSO2Tx2tHL+S9PbOopWNQtAwJIXgHFFTSwOuT9FpH9ILAssSh17+oZb8bCiiStwkn4StcOEQ07xKZRNS7OFuNxxayosOQlO5kZGleahPG1C2Ylsc4v1IMb6NpiHmiMpKLefdFQ4thBcl8AWDKrest7un0EfREZ2rP1tTxetlmvUdI1MualNJAAyZ5uYBEPl1ao7CFNPPJipZC1urC4pn83agzae7XXjg+cYo6bpKHgUluKShqFAA2U+X45RavWdvnns65VWLl8OE3r3GCGXwV1+acbtHvFYyP5F6YxJr3Br5yzWPl3PcttkaSj9y5WaMDR+BQ0UZnYemhJF6Rg+Mc3El9uvQQ67ev1cvUY85mzmVBi8yLkwB3drmE3yQZmnFmBSK1ZYvO+2QRtd3lZkpjQh/uNbkrS5PoRerLt9QHWtZem36jY8iYbYgWMUhzobbd+imwDYPvUPY8lFPciZIAMo5upc+zHvfX1rOCo2gdQ+nVtJaPvonJXMdyEVM7wjyVKhDo2snB8rTU7HrkVWmh0wQokxriLqUPZ4JTEDeX7/nJjtOVA0RUVqt+1uSCblzACgtfs4dQ9DX6y6NwjOB6Lj19RznyqTx6NVcO22UJXNgjYagQs1J4q835" &  "PD0bkTgeNxxxmTabK8reA9QuQASd+X9gfH5h4C7+bSjpMvkSvsE3vSS6Lz5bM+3/ntQkgMCvBVA0bzb1XpxFrtBQeHc1Q5VjjJsoIfQ/RwZJP0j9SzOevbuTXMQeRPhrZkZ2aupOPHrnYPg5jdHm1wca9ZmdqOj4iXu1mO3vAf87lsxgMmUcmoo5jMlZm9H/68/jO3S474DWmNGXds4O/mh0bNQjQ1mJLUneVpaRFLau9nX7jvziZRIA0ECRByNH8UiIVhEdr7ZoGj8wMGOEH7Wk5XRJLO9O5PNiCre7HJyaSm0WCkMSSVDrASGJJ8P9wPGTS2IUCz2tBSc55zGnZ3UkKjBH/H2T4svWqEgDqS1TWWp8QpvcU3Znmku8lvUSEc52J/doMuksNixR1pJ/NqvnNHsHqLTu9vEHQA0JSd9zfV5XMe5VdgAIffAaW3qMYo8JBJgHxQbSUcEWR5VextT++T4TFE6G/GjzpBA13HnikezO/iYYGOg1NMo2D59XQ0kg0raB7kv2HnwSkBsmwinH21+3zeCchKuwTS5pNj9U9pjZFHbZkutPpNaJjxyxNIKSlXmKrt4GO1VLo0AiKjXHFfnZyqfhwWPBIbuGhSTxpbNLPzQ/QOvNb84Ucc6xCUMvk10u0vsSjqXryDDqDKhdO7pb7Xj/ovQWYPt403UYNPGNQaL+UidNVH/mMfM6BIkrhpuVbIINxvCXwRkvZ+L4bPPNErx6ZIqyJC2EUGkPqCML5g+rfeEWRuAugQExN74tAmfZ+tucEFBKjJVP9KzvuASJukZc8ZE+z3lsIV/dGIpMOkzbJHoU1OmSpj+gWal9232IkiMiFzUIBgzidghe+P6jeMbxt4EQ0f7G6fdM/M0UmcbH1vTegAje1X1XjaLiO3NjPfETBrNV5gjQ2oBU0VEr7FQF31FYn7la3BZGdg5ET8H4OG7z/Vioq72wgiUmMpW9SuW2c5rzT37DOAgiuvHlZ+wB7N4ovhp4nNwzdckezsWQQ649opK7aFkT" &  "rBls4+WMlOM4B0xM2bZBUfKmSqPtdb+nvJ2USCr4vMLOhsFkujftSTxbbzCt125Xm7JvbJDN6Z8adGhYrNl7q7MCpe1zz3mru1yFqzLDGU4o/8WiVr1U7RKm9eOMgZLvpQb/oxF/gJOQFVybIZoMcwF3kQwTwg8kR6/zZdJm/ORmzpYXpectAtfwXLcOe9gL4vCMYqD1J6xNxvt5Kh6fLr9ed6O1kTxRG/dY5byot30dV/zU6+aw3uOQTrOAoa7Yh/eNmvKMlNIPuMCvVIFmzc9jGCOCFSf6XYkwHaZyWULTuHr/HChb9Cg/uodmtLR8zw/34EzrK4VYWj753jimZOW91nG/vXYCbhYVRmmNi+H7KbvUAt9XbxHhP6oUwDLdT2PhvxXKG3HOisIR5ydweDQgvka3fnWyq5y/JJ8bmkjHm9YSIBh4B4+KlUnApBLyHybteNglZ1gHaH/I5r5jWConYHdnHYGwvZClkoL5uSH/9B5bbBYgfzG8FQKCLvmoz4XKWu7Ip2THZoNdf03knnJoOFywlt7vM5YOooxVA+WjzQPQcpD1BbatfmQkSXVaYW3w5G0LCo5F8AgQvHXZw+au5yADge+jM8ZRo/wq5prHeKGziow/QAEmQ2rXe4btCrL76OAlSTZgEK6YTyTCaqAqgs2MScfj6hJKsDjMs0nrZRQqGSyu1aBqXyP4Jv0pX/7D699wr2ZcCodbkHaG2aXHkcZCsqbHo4lx/XCijsTnoRPkEaQ4PCwgJcAwYzl5SwMnd5ZXl7OeU8ZUh8+l5ejWbCk1Gw8sf5PGTiRKXhv0fu4s07Ou56lepGs/3t+Q5nomFs2Qm1mKR1jEXWkh9OYYkNbpDKM+f0UhzxDPkI5mPTJj27vZxK/BiIDIFOHEf7XVQKuy8U58Uz5BVwulGCgZZFrATTeN6Rtd/83Mb9lOdakKPwe8heK0DITFQjA3qe6uMSezamh8HbJz+MKZejiXCwBy42VNn9WvtOTY6HVg4o8HY8MddLF2UPQroYg1"
$sData &= "kJtsnrzxRjJoHwDaNENmPYpic73scRSEwpXN5bwgiMXnwVcUpOFo3ZdsPmmm0FvBVp/M0IAlSQphzaFIlsMSdpLE4+M8QwUklyiCtxBHSlywc595VPKJZmGiCBh8Hkj4oStkHlmdUj79aR1iZHCNHIXxxdlW5iEwHJNM7c6t0WFjyzj4NgvqGOfYaSQ9EVicSbirxATjZGSLANN7hpw1MWREkvKsZI5eV6jWfZNyKpxIB6cQBsOk1QJReNDUrd6h6L9Bugx8f67iz+PaIxxsTmSPjWhNL/u0bvYSyCMbZqLFHJWvpp3u+UvvrWtw8w4sNRbfEmNbvqawGCCiWxbOjmQDqB2b/Koa7rbfGA9QeiZ9pjBCxwUAplAGhq+/9RyOvBS5HW7772WgHGUMyw7XIh+yDqR37D6Hri+jBdQmqRL8wDGbs6Meui/BwcNa+vAMFGwwOfi5mArfehBJVg0SxtZqpVttNgmYC0Rxmlczh82kFR78wk3RNtwW7TTvAaMx0VTdPLdBBH03AN/vH6cjBlYXR2buemUKGCA0n0tGiBHyb8eWDStwrRlLBDCn7SM2RcJh2FlfHgPJO5f45ioXeVh+yOoFJpECmwLSkLGLtEGF37kJs3wMwA7fOZcnQZf5XJZx3GFUuoRHO3whzIiMUlhIzH116vQFRoeACYBA+TGa2hSChiexEFl+JQQ2xfvOYnGGwTefrUF2Och8wuCILVex6QRG/NSrLZ8HPuppiMRrZ411fh0UF7k3my1P1A3gII3TC10KLMERuIHmDhBDEv43eWfZyxb72CWNodCs+nz9nqx8Rn0MWHoSTrq2B3eLFsQv76mJpfCuhU0Uf4DCpaYex4i0sfDjtA+86PXKgUE38VmHssEcI6H+in8fSqNHIC/9AfLA7RQcBGmtIIPGbvYNcSzQ4la4UafCyVEyIPLmKqVlG+Um7RWdLnP3WGVllbz9DD7ekyhODcZo5ArSFce/AvrJy80t4xSJ2o6iNdWLeRJTFbgjaJKub1shcxER" &  "+/0OvYcXzwr3ef4VRLpGq95FglwtNkPaMUq8tJFZqU4rVgS+FdHGuNjkj1UxDy5zezrzX2dDn8+U9ZgQf8tB8StoJaHXcjZX/gs8N0JA6ugbzVYerbpmGA6F6EjczrKg1oJGXdb9LZ0FdHe8CkL+4FWg92ualGvejxzeOSJS2sb1Kd2wTIimsB9ruLA/rj4u8xxlFvmqtFB2YgylltBUMiRAhuWtorx8vmzDPBwR8tvfHeGegI6+x49N1/Dt/BbhRv9no3qV9BkD3ugj8GieHWYNc6kmjtEk+E6fdsV8R8LiC040q+P6Rrd3lbBGc8WcVE3nAacgg9AWAOV+iVChKP3CBLiYcWbWJ5KpPXHHpYDuZKYqDwAdk2+zmyPZs1VNa5psCz/lOXQJZBe+H9aYFI3Z4z4R6PXD0JThPyOxwgfxBfgKOF9NuyhD0k/ZmNbH0Xe3M0HjRHyW5uBb5UPYcyv3iDe283vLWMhYnJIauMj6gISEPRzkStH4EYf9MrqQCLPMYgYsViqBHE0yMVBLIzqnqlW/fHItsxCHplWQ5sLIgId0/nkKckb7GKZMyeFLVD+kS/YK0tIKrB0FXUV/Aa9UjSWs0AP2DCSK7Oubk8psukz/B5Z8nKzaq1wASCXtXbvptrllVHS4/o8gD7VJsa0U/Gomecofz0FJ2a/Eb+6lLJ+vXv3h172qQiXvkN3bmmVgLkLF8FtZSSBk10Xu/7XvEZQi5ji8iW3jm+aGJ2JQucTdWJuN0ovmH7LJ3XzeZ1Bo/z0CXpGx7kWeAz/v9AQIU+KqJJi+xNXnlEHdB8x93UkRdwOv9+g5ntNVI+5cMjsMT8+fJfR88RJyugW8Vu3gLFj1XGBb/J0AAwvImx8IE9s40FQfghpRqS9lMVvFnF9GCVaDYvYVJHrrhsSXoMuowhD+Y2ieElcgrOBX2K2O2s/sAlJCzb/NBQFSH/PjzEuO2CFY7IZ22e9w/ReIpDtY8b9RXMoXYpwU0yGIQpo1zd1VlbVwqXVZvSyxnBSk" &  "0uxTIShW/h8FdmQLP5VxaQ6WRd6UCYl7x5S+b5DEsJP+EsjrnmCgVZ8U8w9ZzHxgXN/YylTjCtwn7qkM2O3XGW8XIsIeUsVSdsL9gWVfXNSsugRVbds3A0yQ+4bIHjdAMFBVtiivrMXWFdHr0tmrfvlkdHMZCugjSXfYL9CNM8VQ8YlOOnOmwHiOfCBaEs7Yrv67j8UrNIwkk2GNRveUul821y8kqlmVafMEZapsA1Ax9VHEUB6h+193TuWGgqd6d3lxZJAlpkkpK/gnwI9osmPu+cPc+jsCjSWndhmnPJSXcgCuM51NylJFnYrbX/bBHuO4auZcA8jvetkXTOqAsAsl3UcEt9vbukfKiCgDdnTnRUFmNKGzIYPW+BEer5D1ZdHNCX2Gbyi5UpLp4OsiV4k9d0aqHpKDFlFD+ofyvuJSh6apY3QQ8bnOgg2zCHOb27nc/cIL14jgBuHvDY/0NW2cpYjp3SFXT0+hyOyAQtHmMdujnPMlNGdQ1igKV0nlgtIL/z4asIMpa88IsqTeKVi6bkYuAR3P3282woQXhJWL4IoqQAwBy6KcOr0qUlLLQ+wqQQWhWYojzUmDR2BIw8rT+bLCxvw/6779/5+QdEn+HWS9ejTuO11AdhhRcTeiOWbqcPTOcpxrSTuRxy8P6SMstQZT+fnWWs5Ja+xUM6VMzF4N7Bh4GYROkT4cbpUsN6utaeflBqV4BUBQXIfBI1e4FfVjF/78fU0IoGnZn2U/lj8fafv3JZDF4VP9GYik+W0znl2xmn8AD7SN+U08Of55T1zgZ0f72mHbpp3QvZ8pVDe+KoR2HUKUTsOqww18higkWhE6+OIPSBD3KyAznOVy0pRfATMpxduM70c68PJGoHHML1YcyxSmOcAS4+P24t2YXfQ1U3fMAMcW2GWZNGhomRxM5itw8EA0wlUV68udXfzegZ5ZYoeE0BSMXRz7hVRhW54OXx6xcUKbhNNuB+zMarzeM+j7MZwfkLd1ihVtLw4Q7i5FeH4KhvAKsKdD"
$sData &= "JSDJ6NHtbQOjuJuLE5Eq8EnGvCP8ewU7NrVgy4Wbz4DkUGDn/owJvcfvKfyrJCeqGK+B2GWkLt9T6bT1HyPlKJXduZ3eMzAlbTCxlVeiOTf1MQKh2b5XLy+10tjb6KVBfn1W/9Vaa96c7nwdvki3skZ1a78r45JXIGSrfy0ItjcKEj4TzoB5+5OtrcviK23aTMWBC85zVgHQPPtpb8zWkKK92l4OigooVB97AhP2EnOTDZ/TE1whGQe6Myd/H8tadY5n50H/JZEFOCDmhR0eLYU7InV/kvGyTIjwocztnVuwykXH3+i8f6WveZqgiGl2mbp1HPfFg26+FezfRWehZ7QQlvSbqFAvkt1Np7Xa+7ERGipE5M3HW4JtBrJ1lEzTzZCNJuzX6tFh0hPWSm1qOzfq9MfxlCzlt09ilrbEYtgjfhFBnpM82f8GK8DP4hbk34FC9xxbZUK2ARF9X1SCSCG37hVI8WeqG06oaVgY3A027r4rm8ICREFlJ5mgjbZqeqf12ENXQ1EF3kSCsQ25EY3OHrOWmzBjNzijlYDXMpkLXc7cFIk3DV9qcDFyie6zkZtkFpLVssZ8i+i4CrxPMoFjHij7smWvugtlxkCQp86kziF+zAAQRmv9DurEVCLjvMmFx+qGrU8CsJ1pHbHVgHjQ0IhQboYol50fcx38RyPrn1kciGvDsjFI/+ufxPE8w7JyzDDwf9eaWhBEGsuXcdECakUSKsMEENlXTANwNr2bAPEbse3d1xupb+Lr3P6O91rPlAt0lhSMCbacrkXNbYGdSeiPCb5ERMhP5ysdrmbZSgyZpiLpvKPNCqImysnm1RuZhUhR4qODC9CxwYgyJeO2OSo+sKmqXY1nHLaPBQZolJ02gT8v6hU0GxR/5d6xjfBkL+7UOpyLS9T/zo+TRA3AydayzSfXKtTV2c2cf4mGpZNPrGKUDfMj4jmYNQigpmrZ7uoGW6apQmG2lYYX21HmB5SDT28ogUFX6riHzDl/UyFXlGQIKzAs1XJv3e/S" &  "WDoSzMZqSgknJkHRl2DkkG9BRcolNOxWKotH+nylfPzq2PT1FLiJWMdohpLZt9LasiaJnCkxRke83FhiSx9IZ6ZtGrzmLRRXeT0MIf1MMA7n58cy9egaNQcqPT1m5TIRrHQ8B+QC9DLj6AaIYQl5D083X6l1/hNaeY+OKEsOL/4EaDVxIcZPtE6yM52yN+fs3QtfDITsz7x3rUWKPwv7zlgWwgN3jbqaae64P7VPRv0mSh99j94scvvaiCu4Gjacbyv5lvJYBWdFDsZTVpLrv563P7xTha+R3GkqdpjNeCxndo4Hh0/CBhpbm+jHkkAiUS+BIcOlGfWDSYlmJXVu8ukYRwFyskQptNz68Qjw/vzSWtubAO8ejMoRsmwu+44Z3+tAPPsz95kqrDUNYd5W9uJ3Xs9yFi3hkpBRh83a9k0LJxxrRxLk8vofkYir3s4FvR9vg3BU7wbSsAM13w3yshGekbKH4JdT0HNddd+8hUYTklTKQkm/Qpx4BwuVahYsPb8arejMisgWD5hgItfu2+V0xjJCjijn+WuFUhZbsRW9FTtvOc5/f4Cl0yEt+yj4wMXUzwDJuvyCIZvaFEOkXtl/nWC0S9wf4IZOWUz1rKf8uJhPBWmglwAfiWHF5ZuPoymN0/PFSMjCVyuEgyMa0x3VPQymN5km6eF6m7prtghT/3ega0rOfhCWB2mKdjNV+vUbHgvSSiKgSbbB1NOnZyz9i3KO495urLrFBKtjzDMXUKFg5OzIcfRwKUCzc9y69X2v4rhvgiNcfoA48SjKsZO6oHE5Evb7kYwy5iNz0546+6LmludPIGSL5A5ZKyldbIM2HGSaWon8uM2BKJHnH3ZilGjBwvAQ1wXe0cVdTcJydJ+S55MalqG/lSEUVBVo4SfLG5+ddQUl9U63SW6DeMHYrfXevUCgLylAldpPtDurOb/PxWnuIEws8ecQFO3HPhs9mtvUl//phGKhOjfE6DJ0fRq4XkzRbT/nlVfOvBorrmnyYyyBGEYpZJEtnnDm" &  "zbz39jW7bRDxS69VNBkcACuw5vBDpzxZNLJmYkaSYwfR7+aGmoJlQsZD5lp6jAs4l3FWPvXry1HsAcMI+HeQoCfaY9Jd6mUf02MDAxZ4X9iSf9t6fFIzax1zgQeiz8Nn/S2+mWY25Gu95MDdT3FV3Z8W6HVxmqfLdpJndCbaiERYTHFDtHvZRvUyVttupiagXSV1/0vBb+DPRW8WFLM9qe+hz0cRex5VwUYQXr6glGPsRH9SxGT0tD8p1AKSmvc9Bb6HuGUvz1WVh0cPUFvsQs1NzTXf0CX/4jpYAm020P1Fibf2z3hEAiFTCIRI5oppUANDJ1xDW41rhOgq1Cxp2CfBktvV0A1jgfQCMA2J/ORIfVSL7dgAZOA7taV9xxMpsxTw2Xy9q3YhFgSoa7iCzBqeVTXrKFd7kON0ahe1+IUfGPRrt+axdTza6uZvZl86YT6WBoKgmm7JwggoA8XiDmbMYBslP6uxboJL09fF3PrzFdM+wO+3jGh7M1feg2HNMfY5/Pe8Gms51arF/SQGK8Sr0pOu5ctBho7L9+ZmHYI/AJ01Xy/t+wDD9xYz2qKT7liwff07xr5tlthTjwUjC/orEpMkrQ+Im+7nh4ptmpDGw0buJwrXo5JyPAFA2cgXxLlohjn1xCs89bQO9EDP4ky0hx0aKZjt5+r6fbLE/EbNY4FjrVjRJv/hZQzkpAAyjxRumU/xzbB7W8srK3plTBBSQCnvwzdSK1xQ1GQ19Ll74o2PIqmKVwfS/XT62Nq2l5TwohJbP8ESAJwrtIIp8kpG5g4UgQVAC11OGAzGKML13Ig3WK7hJ8tFjtrAm4g9MhIdo5yqq5DOBlkcdecO58kWicCib/MqyKfOGbl2GgJIgg8Y2D0HOLLRCqHzC4d50zcO9LQ0/dqyXRoxf77EB53lxyUGhaIBftan2rDREG01fQP+XZnOzpBU0MW7srgodjwCjxdPJ3xCyPqX6mP2yGvh0aEqr9BkQEAGYplqKCl0ceAyE6iQnK0eaf2uiO/U"
$sData &= "IyhDFFJ+oZoZ7z3NR8ESCHszTVBnrTir/H8+UbYG+sr+J9fGhmsmMwPP0c1Wx6TRgwQF7h9T8Vdn9w5Tan06fY2n7nMmJcNSt8cFdFka9yV/NZ3zrsCbO5QhEWNRAlvDMtRMz2oAxkNqGz/h4RUoUXkJwZD4WHIXiCEg5jZ8B3pVAtJD6vOQl/7c8jT+v68hQr9KMZ1pWrzllla3sQVw0Or6p1Pr9/zvm94bBp7+30080FDD5a91C7V8eYbJUcONLdnIrm9On01FnM6a5UAM97nDQDOuZbbIduBR05zX6TbxOu3tR4u4+2N0tNSExypeLUCQThYR21wjptihtvfLz6G28XPdKDaVMFeV4WOMP1gCuQ3bGQ4PovrIXGwJPYelNe5mMpfx9eOwdFQ2/13rzTiLiCAfG6m5k/grOkdaD/AvGX21w9WDjqjqX4N/+ZhDGXZaplZpF7ebGRBV+TdKg99aT83l49KFBroANz99aJ5o3Vy3vwPSG2zJQWcDVx6IZun53rfJyV2d5yqIy+KBdNyF34fszHzpLhow9j72uAoTOfXlQ7vcwv+hGOHZsydc6644aoa9tZAP/ugmlbY2TUnE0n4hac0Juco64PSGFRF28p5/7xaxRMbO1w+KxB8yRYqEDjoHPHttP5mGg0q/k9iGI29Fz5386vki4ipBI56a30MSSFZnB7/+LbNtlkXxrHSBAR1zq7jJ/bWnTI2x7bWnKkgQO+qHd4NIKzEkTdQ5uI+I3NqA9vjQn0PvfsUcYR/EywGqXErhaHgn2PQt1WLFSUNR7Kwp4TuDg979Y1oClBIuDHyY3dV490MpWzlGq1aSpt0kVhdLQRCBrMTUQY1jjGCVi+FnqwOjjkomRbLX7o8zwmWwQdlWp8e3SyGhCcbG5tebN4I7eD836u8ekbhwO3VSlPSCLM1ZWPC/glD+n+iQEXBWn3K7MZccUNmUe90zVx130BLjlVbl7BDx0MSgwl9xJev263obnV3i8zEOelcr931r7f4jrSk4+ZJ7" &  "L4/ap2bG/lPmyE75W2fmFtcKcC4ew136QdTUheTsg0j/kbxkFbbrahrtWKkfYVW/+VfXHsBNfyoTM7TB5i9DniUwdkfRrURnLAMgl49kdJzvzxcZKf1F1j5qac5oBBFVHxH8ivTrXdVWMlT8GdJVa1R+rsjdDndqg8Q5EEsfw4kMiXcMVZ6DnrnmY8lkv0lRt6nK1gKAwHOBYYY6RO3L1/SL8fAR6KvSVegGHuSCjlHhP1S2I4ce84OmSGGa7Dzj9Nx6vZ5Ojiu9QkaCH8U3ZruLqRKpOheznok5+gV/EIcwKoMvZdjYtkoktXXfbRqKK1oy9Rpj69szlCKkersPsKMoo8urymVvGHXWXyPUi3CT8QaauepY7/PhV2qcSwO27bUPPvKc8Drrx9QqprC/NSz/PJ5GViC8Y1XFGaLnKcH0S55/mGzukFZMFToepRNzD0s6qOb2ZrydY62Qr8R9hx/MfKGZ6lI0nu1Gqvr5xQ4USeyYxZengdLga63I/Cxsik1hKjCb76JCKmIuMg9I5kzY3jSoHcGESIHpLHQshFJ5XkC3DNgeBC0gdYrpe4YCoYzfIiNLMUCFw67MdgNs+eX5eKVgVHqoKloAZduoTmd+3A6WctOyh7EI9JIJIc5i43FwwLCXPC+gQgDXscGKyeaCe/RKMFqBCk8DLKN/t24GJhYdmEkoi+ex7PEfq566VhBIk6SQjPeR5aqwFdqTyIBNmzyt+PvUjj1KQ8tUX09TubwSvPjLswoGvoz++LdKXbhwsz4X5S7Jj8cGO/nF9dp1ciTgeQ7Tcg8gKdXuLiKlORMG7xe5v5zmi5LHz4d7edNBMNUs5bO8x+xZt6kR8mJU1jI2W5i9EkHsiwsljx08GTmgDmUe059YVMHGRg3u4IM6YvyeiFlpWfP8CVpC7m3bQqhb39oUZbuod8Q+wauUSg34OCJJd73m7NX5eqowSimG4vey+SUULD1k3bCCnIh72W47+zb6jfkBSIsy2P+VVjXe3J1AsNTkNUrIUghd" &  "w275yLdGm3/qwaehdjIte9l8K1iJvUOGxyyk3NfF3jL6F7bxYGoQMvrzYbu3Xd77SG4aPbh5b459NO/qSi/jtXR8f3k2vzv83WufGZ+EAnfb+9PYEYEetChX5zy8Q7iGxBA6eDE2GMCa01NErBvIhh8KKLVNVNYLP2qgddG7Ln5kWBbLDQdHw1cFhMHe6FmLl9zvWRJ/a6XnkJwhCVLrDNM3aVC2ky5tEOkdq6hr87nq9va9C4sepTmtfmfKDNldi6v4i4Z6O2gfq3hFJT8s9+wFI3yuMzWyQ5kEdSI2uM/dYbgHrFnJX322wq0E9Z41RF0H6uCShVqV0dFQzrdd9QysiMwWqYO83ZC9g8cxQI2cff7++KRUfoJhCi7j//Gk3lBwTlSWD7vkYCODsgx3PSZZN6Ftnch0OT/AsdyzHjq8K0fEm2c13bHsUQu2Q7qVutQf9ieyujzALbchFL2USEZtyqe81uEREySo3LeVm+ZuxfQAVL8lihvszwRdS/nIh+6nR+HgdpM59QZiiu28115tZnbFfxD1WacAwg2tRC1bsran3BhtrjYWT51PW2vhCFJKLQxXArH0O/KXzF/ilyLID0Cox3IPfuor4QGY2dkCUfiPINWeMSCanZ7PBxqtcG6WZoWhZnZMPozQr6XqBl8cOLBZNayPe8k1x61rOhE/jYUckBwlkHo24NXpm/1FG1kA5UgPQMFIi8jo4NX//0jHwf////9Mi/i4GAAAAEn35UgPQMFIi8jowtX//0UzwEyL6EGNRCT+ZkSJRCRwRYvgRY1QBEhjyEiJTY+JRCRgg/j/D44FDQAAJQEAAIB9B//Ig8j+/8CFwA+EXgwAAEQ5B3U2SItFZ0iNPElIiwi4CAAAAGY5BPkPhU0MAABIi0z5CP8VXFEAAIlFX0iLRWdIiwBIi3z4COsqSIvP6AAbAABMi9iLRYcrRCRgmSvC0fhIY8hJizzLSIvP/xUEUAAAiUVfSGNEJGRIjRxASY0E30iLyEiJRCRY/xX8UAAA"
$sData &= "SY103QBIi87/FfxQAABIi12fM8A5A4tEJGB0Cf/ImSvC0fjrAv/ISGPISItFZ0iLAEiNFElIi85IjRTQ/xV0UQAAi0VfuSoAAAD/yEiL10iJRfdmOQxHD4VVBQAAM8lmiQxHuQgAAADoPEMAALkqAAAARTPAD7fYSItF92aJDEdIi0QkWEQPt8tIi9BIi8j/FVRRAABIi1QkaEUzwA+3w7kAQAAAS408ZGYLwUWNSAhmQokEYkEPt0z9AEGLwGZBO8kPlMCJRV9mhdsPhE8LAABBjUARZjvYdUiNSPDoHtT//0iL2DPAOUVfdBRJi1T9CEmLzuhQJQAAiAPp7TEAAAAAAAAIS+1NAAAAAHjAAAABAAAAFAAAABQAAAAowAAAjcAAAC3CAAAIUAAA+E8AABBQAAAkVAAAHFYAALBPAACMTwAAaE8AADxRAAAYUAAAVFAAAABTAAAIUwAA3E8AAKxSAADIUQAAAFAAABBTAABoUgAAtFAAAEF1dG9JdE9iamVjdF9YNjQuZGxsAN3AAADlwAAA78AAAPvAAAAUwQAAL8EAAEHBAABUwQAAbMEAAIDBAACUwQAAqsEAALnBAADJwQAA1MEAAOTBAADzwQAAAMIAAAvCAAAcwgAAQWRkRW51bQBBZGRNZXRob2QAQWRkUHJvcGVydHkAQXV0b0l0T2JqZWN0Q3JlYXRlT2JqZWN0AEF1dG9JdE9iamVjdENyZWF0ZU9iamVjdEV4AENsb25lQXV0b0l0T2JqZWN0AENyZWF0ZUF1dG9JdE9iamVjdABDcmVhdGVBdXRvSXRPYmplY3RDbGFzcwBDcmVhdGVEbGxDYWxsT2JqZWN0AENyZWF0ZVdyYXBwZXJPYmplY3QAQ3JlYXRlV3JhcHBlck9iamVjdEV4AElVbmtub3duQWRkUmVmAElVbmtub3duUmVsZWFzZQBJbml0aWFsaXplAE1lbW9yeUNhbGxFbnRyeQBSZWdpc3Rlck9iamVjdABSZW1vdmVNZW1iZXIA" &  "UmV0dXJuVGhpcwBVblJlZ2lzdGVyT2JqZWN0AFdyYXBwZXJBZGRNZXRob2QAAAABAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATAAAAALzCAAAAAAAAAAAAAEDDAAC8wgAA1MIAAAAAAAAAAAAAScMAANTCAADkwgAAAAAAAAAAAABiwwAA5MIAAPTCAAAAAAAAAAAAAG/DAAD0wgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcwwAAAAAAAC/DAAAAAAAAAAAAAAAAAABTwwAAAAAAAAAAAAAAAAAABQEAAAAAAIAAAAAAAAAAAHvDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEdldE1vZHVsZUhhbmRsZUEAAABHZXRQcm9jQWRkcmVzcwBLRVJORUwzMgBvbGUzMi5kbGwAAABDb0luaXRpYWxpemUAT0xFQVVUMzIuZGxsAFNITFdBUEkuZGxsAAAAU3RyVG9JbnQ2NEV4VwBXVlNRUkFQSI0F3goAAEiLMEgD8EgrwEiL/matweAMSIvIUK0ryEgD8YvIV0SLwf/JikQ5BogEMXX1QVFVK8Csi8jB6QRRJA9QrIvIAgwkUEjHxQD9//9I0+VZWEjB4CBIA8hYSIvcSI2kbJDx//9QUUgryVFRSIvMUWaLF8HiDFJXTI1JCEmNSQhWWkiD7CDoyAAAAEiL411BWV5ageoAEAAAK8k7ynNKi9ms/8E8/3UNigYk/TwVdeus/8HrFzyNdQ2KBiTHPAV12qz/wesGJP486HXPUVuDwQStC8B4BjvCc8HrBgPDeLsDwivDiUb867JIjT0G////sOmquOIKAACrSI0F4gkAAItQDIt4CAv/dD1IizBIA/BIK/JIi95Ii0gUSCvLdCiLUBBIA/JIA/4rwCvSC9CsweIH0Ohy9gvQC9J0C0gD2kgpC0g793LhSI0FlAkAAOmKCQAATIlMJCBIiVQkEFNVVldBVEFVQVZBV0iD" &  "7Cgz9kyL8kiLwY1eAUyNaQyLSQhEi9OL00yL/kHT4otIBESK3tPiSIuMJKAAAABEK9Mr04vuRIvjiVQkDIsQSYkxiVQkCEiJMYtIBAPKugADAABEiVQkENPiiZwkgAAAAIlcJHCBwjYHAACJXCQEdA2LykmL/bgABAAA82arTYvOTQPwi/5Bg8j/i85NO84PhMoIAABBD7YBwecIA8sL+EwDy4P5BXzkSDm0JJgAAAAPhooIAACLxUGL97oIAAAAweAEQSPyQboAAAABSGPYSGPGSAPYRTvCcxpNO84PhD8IAABBD7YBwecIQcHgCAv4SYPBAUEPt0xdAEGLwMHoCw+vwTv4D4O1AQAARIvAuAAIAABBugEAAAArwcH4BWYDwYvKQQ+202ZBiURdAItcJAiLRCQMSSPHKstI0+qLy0jT4EgD0EiNBFJIweAJg/0HSY20BWwOAAAPjLsAAABBi8RJi89IK8hIi4QkkAAAAA+2HAgD20ljwkSL20GB4wABAABJY9NIA9BBgfgAAAABcxpNO84PhIgHAABBD7YBwecIQcHgCAv4SYPBAQ+3jFYAAgAAQYvAwegLD6/BO/hzKESLwLgACAAARQPSK8HB+AVmA8FmiYRWAAIAADPARDvYD4WbAAAA6yNEK8Ar+A+3wWbB6AVHjVQSAWYryDPARDvYZomMVgACAAB0dkGB+gABAAB9dula////QYH4AAAAAUlj0nMaTTvOD4T0BgAAQQ+2AcHnCEHB4AgL+EmDwQEPtwxWQYvAwegLD6/BO/hzGUSLwLgACAAAK8HB+AVmA8FFA9JmiQRW6xhEK8Ar+A+3wWbB6AVHjVQSAWYryGaJDFZBgfoAAQAAfI9Ii4QkkAAAAEWK2kaIFDhJg8cBg/0EfQkzwIvo6WMGAACD/Qp9CIPtA+lWBgAAg+0G6U4GAABEK8Ar+A+3wWbB6AVIY9VmK8hFO8JmQYlMXQBzIU07zg+EPAYAAEEPtgHB5whBuwEAAAAL+EHB4AhNA8vrBkG7"
$sData &= "AQAAAEEPt4xVgAEAAEGLwMHoCw+vwTv4c1FEi8C4AAgAACvBwfgFZgPBg/0HZkGJhFWAAQAAi0QkcEmNlWQGAACJRCQEi4QkgAAAAESJpCSAAAAAiUQkcLgDAAAAjVj9D0zDjWsI6U4CAABEK8Ar+A+3wWbB6AVmK8hFO8JmQYmMVYABAABzGU07zg+EmAUAAEEPtgHB5whBweAIC/hNA8tFD7eUVZgBAABBi8jB6QtBD6/KO/kPg8gAAAC4AAgAAESLwUErwsH4BWZBA8JBugAAAAFBO8pmQYmEVZgBAABzGU07zg+EPgUAAEEPtgHB5whBweAIC/hNA8tBD7eMXeABAABBi8DB6AsPr8E7+HNWRIvAuAAIAAArwcH4BWYDwWZBiYRd4AEAADPATDv4D4T0BAAASIuUJJAAAAC4CwAAAIP9B41I/g9MwUmLz4voQYvESCvIRIocCkaIHDpJg8cB6acEAABEK8Ar+A+3wWbB6AVmK8hmQYmMXeABAADpHgEAAEEPt8JEK8Er+WbB6AVmRCvQZkWJlFWYAQAAQboAAAABRTvCcxlNO84PhHcEAABBD7YBwecIQcHgCAv4TQPLQQ+3jFWwAQAAQYvAwegLD6/BO/hzJUSLwLgACAAAK8HB+AVmA8FmQYmEVbABAACLhCSAAAAA6ZoAAABEK8Ar+A+3wWbB6AVmK8hFO8JmQYmMVbABAABzGU07zg+EBgQAAEEPtgHB5whBweAIC/hNA8tBD7eMVcgBAABBi8DB6AsPr8E7+HMfRIvAuAAIAAArwcH4BWYDwWZBiYRVyAEAAItEJHDrJEQrwCv4D7fBZsHoBWYryItEJARmQYmMVcgBAACLTCRwiUwkBIuMJIAAAACJTCRwRImkJIAAAABEi+CD/Qe4CwAAAEmNlWgKAACNaP0PTMUz20U7wokEJHMZTTvOD4RfAwAAQQ+2AcHnCEHB4AgL+E0Dyw+3CkGLwMHoCw+vwTv4cyVEi8C4AAgAAESL0yvBwfgFZgPBZokC" &  "i8bB4ANIY8hMjVxKBOtoRCvAK/gPt8FmwegFZivIRTvCZokKcxlNO84PhPoCAABBD7YBwecIQcHgCAv4TQPLD7dKAkGLwMHoCw+vwTv4cy5Ei8C4AAgAAESL1SvBwfgFZgPBZolCAovGweADSGPITI2cSgQBAAC7AwAAAOsiRCvAK/gPt8FmwegFTI2aBAIAAEG6EAAAAGYryIvdZolKAovzvQEAAABBgfgAAAABSGPVcxpNO84PhGYCAABBD7YBwecIQcHgCAv4SYPBAUEPtwxTQYvAwegLD6/BO/hzGUSLwLgACAAAK8HB+AVmA8ED7WZBiQRT6xhEK8Ar+A+3wWbB6AWNbC0BZivIZkGJDFOD7gF1ko1GAYvL0+BEK9CLBCRBA+qD+AQPjaABAACDwAeD/QSNXgaJBCSNRgONVgEPTMXB4AZImE2NnEVgAwAAQYH4AAAAAUxj0nMaTTvOD4S9AQAAQQ+2AcHnCEHB4AgL+EmDwQFDD7cMU0GLwMHoCw+vwTv4cxlEi8C4AAgAACvBwfgFZgPBA9JmQ4kEU+sYRCvAK/gPt8FmwegFjVQSAWYryGZDiQxTg+sBdZKD6kCD+gREi+IPjPsAAABBg+QBRIvSQdH6QYPMAkGD6gGD+g59GUGLykhjwkHT5EGLzEgryEmNnE1eBQAA61BBg+oEQYH4AAAAAXMaTTvOD4QPAQAAQQ+2AcHnCEHB4AgL+EmDwQFB0ehFA+RBO/hyB0Er+EGDzAFBg+oBdcVJjZ1EBgAAQcHkBEG6BAAAAL4BAAAAi9ZBgfgAAAABTGPacxpNO84PhLkAAABBD7YBwecIQcHgCAv4SYPBAUIPtwxbQYvAwegLD6/BO/hzGUSLwLgACAAAK8HB+AVmA8ED0mZCiQRb6xtEK8Ar+A+3wWbB6AWNVBIBZivIRAvmZkKJDFsD9kGD6gF1jEGDxAF0YEGLxIPFAkljzEk7x3dGSIuUJJAAAABJi8dIK8FIA8JEihhIg8ABRogcOkmDxwGD7QF0" &  "Ckw7vCSYAAAAcuKLLCRMO7wkmAAAAHMWRItUJBDplPf//7gBAAAA6zhBi8PrM0GB+AAAAAFzCU07znTmSYPBAUiLhCSIAAAATCtMJHhMiQhIi4QkoAAAAEyJODPA6wKLw0iDxChBX0FeQV1BXF9eXVvD6e6O//+JQf///////0MAAAAAEAAAALAAAAAAAIABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAEAAAABgAAIAAAAAAAAAAAAAAAAAAAAEAAQAAADAAAIAAAAAAAAAAAAAAAAAAAAEACQQAAEgAAABY0AAAGAMAAAAAAAAAAAAAGAM0AAAAVgBTAF8AVgBFAFIAUwBJAE8ATgBfAEkATgBGAE8AAAAAAL0E7/4AAAEAAgABAAMACAACAAEAAwAIAAAAAAAAAAAABAAAAAIAAAAAAAAAAAAAAAAAAAB2AgAAAQBTAHQAcgBpAG4AZwBGAGkAbABlAEkAbgBmAG8AAABSAgAAAQAwADQAMAA5ADAANABCADAAAAAwAAgAAQBGAGkAbABlAFYA"
$sData &= "ZQByAHMAaQBvAG4AAAAAADEALgAyAC4AOAAuADMAAAA0AAgAAQBQAHIAbwBkAHUAYwB0AFYAZQByAHMAaQBvAG4AAAAxAC4AMgAuADgALgAzAAAAegApAAEARgBpAGwAZQBEAGUAcwBjAHIAaQBwAHQAaQBvAG4AAAAAAFAAcgBvAHYAaQBkAGUAcwAgAG8AYgBqAGUAYwB0ACAAZgB1AG4AYwB0AGkAbwBuAGEAbABpAHQAeQAgAGYAbwByACAAQQB1AHQAbwBJAHQAAAAAADoADQABAFAAcgBvAGQAdQBjAHQATgBhAG0AZQAAAAAAQQB1AHQAbwBJAHQATwBiAGoAZQBjAHQAAAAAAFgAGgABAEwAZQBnAGEAbABDAG8AcAB5AHIAaQBnAGgAdAAAACgAQwApACAAVABoAGUAIABBAHUAdABvAEkAdABPAGIAagBlAGMAdAAtAFQAZQBhAG0AAABKABEAAQBPAHIAaQBnAGkAbgBhAGwARgBpAGwAZQBuAGEAbQBlAAAAQQB1AHQAbwBJAHQATwBiAGoAZQBjAHQALgBkAGwAbAAAAAAAegAjAAEAVABoAGUAIABBAHUAdABvAEkAdABPAGIAagBlAGMAdAAtAFQAZQBhAG0AAAAAAG0AbwBuAG8AYwBlAHIAZQBzACwAIAB0AHIAYQBuAGMAZQB4AHgALAAgAEsAaQBwACwAIABQAHIAbwBnAEEAbgBkAHkAAAAAAEQAAAABAFYAYQByAEYAaQBsAGUASQBuAGYAbwAAAAAAJAAEAAAAVAByAGEAbgBzAGwAYQB0AGkAbwBuAAAAAAAJBLAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
Return __Au3Obj_Mem_Base64Decode($sData)
EndFunc
Func __Au3Obj_ObjStructMethod(ByRef $oSelf, $vParam1 = 0, $vParam2 = 0)
Local $sMethod = $oSelf.__name__
Local $tStructure = DllStructCreate($oSelf.__tag__, $oSelf.__pointer__)
Local $vOut
Switch @NumParams
Case 1
$vOut = DllStructGetData($tStructure, $sMethod)
Case 2
If $oSelf.__propcall__ Then
$vOut = DllStructSetData($tStructure, $sMethod, $vParam1)
Else
$vOut = DllStructGetData($tStructure, $sMethod, $vParam1)
EndIf
Case 3
$vOut = DllStructSetData($tStructure, $sMethod, $vParam2, $vParam1)
EndSwitch
If IsPtr($vOut) Then Return Number($vOut)
Return $vOut
EndFunc
Func __Au3Obj_ObjStructDestructor(ByRef $oSelf)
If $oSelf.__new__ Then __Au3Obj_GlobalFree($oSelf.__pointer__)
EndFunc
Func __Au3Obj_ObjStructPointer(ByRef $oSelf, $vParam = Default)
If $oSelf.__propcall__ Then Return SetError(1, 0, 0)
If @NumParams = 1 Or IsKeyword($vParam) Then Return $oSelf.__pointer__
Return Number(DllStructGetPtr(DllStructCreate($oSelf.__tag__, $oSelf.__pointer__), $vParam))
EndFunc
Global Enum $ELTYPE_NOTHING, $ELTYPE_METHOD, $ELTYPE_PROPERTY
Global Enum $ELSCOPE_PUBLIC, $ELSCOPE_READONLY, $ELSCOPE_PRIVATE
Func _AutoItObject_AddDestructor(ByRef $oObject, $sAutoItFunc)
Return _AutoItObject_AddMethod($oObject, "~", $sAutoItFunc, True)
EndFunc
Func _AutoItObject_AddEnum(ByRef $oObject, $sNextFunc, $sResetFunc, $sSkipFunc = '')
If Not IsObj($oObject) Then Return SetError(2, 0, 0)
DllCall($ghAutoItObjectDLL, "none", "AddEnum", "idispatch", $oObject, "wstr", $sNextFunc, "wstr", $sResetFunc, "wstr", $sSkipFunc)
If @error Then Return SetError(1, @error, 0)
Return True
EndFunc
Func _AutoItObject_AddMethod(ByRef $oObject, $sName, $sAutoItFunc, $fPrivate = False)
If Not IsObj($oObject) Then Return SetError(2, 0, 0)
Local $iFlags = 0
If $fPrivate Then $iFlags = $ELSCOPE_PRIVATE
DllCall($ghAutoItObjectDLL, "none", "AddMethod", "idispatch", $oObject, "wstr", $sName, "wstr", $sAutoItFunc, 'dword', $iFlags)
If @error Then Return SetError(1, @error, 0)
Return True
EndFunc
Func _AutoItObject_AddProperty(ByRef $oObject, $sName, $iFlags = $ELSCOPE_PUBLIC, $vData = "")
Local Static $tStruct = DllStructCreate($__Au3Obj_tagVARIANT)
If Not IsObj($oObject) Then Return SetError(2, 0, 0)
Local $pData = 0
If @NumParams = 4 Then
$pData = DllStructGetPtr($tStruct)
_AutoItObject_VariantInit($pData)
$oObject.__bridge__(Number($pData)) = $vData
EndIf
DllCall($ghAutoItObjectDLL, "none", "AddProperty", "idispatch", $oObject, "wstr", $sName, 'dword', $iFlags, 'ptr', $pData)
Local $error = @error
If $pData Then _AutoItObject_VariantClear($pData)
If $error Then Return SetError(1, $error, 0)
Return True
EndFunc
Func _AutoItObject_Class()
Local $aCall = DllCall($ghAutoItObjectDLL, "idispatch", "CreateAutoItObjectClass")
If @error Then Return SetError(1, @error, 0)
Return $aCall[0]
EndFunc
Func _AutoItObject_CLSIDFromString($sString)
Local $tCLSID = DllStructCreate("dword;word;word;byte[8]")
Local $aResult = DllCall($gh_AU3Obj_ole32dll, 'long', 'CLSIDFromString', 'wstr', $sString, 'ptr', DllStructGetPtr($tCLSID))
If @error Then Return SetError(1, @error, 0)
If $aResult[0] <> 0 Then Return SetError(2, $aResult[0], 0)
Return $tCLSID
EndFunc
Func _AutoItObject_CoCreateInstance($rclsid, $pUnkOuter, $dwClsContext, $riid, ByRef $ppv)
$ppv = 0
Local $aResult = DllCall($gh_AU3Obj_ole32dll, 'long', 'CoCreateInstance', 'ptr', $rclsid, 'ptr', $pUnkOuter, 'dword', $dwClsContext, 'ptr', $riid, 'ptr*', 0)
If @error Then Return SetError(1, @error, 0)
$ppv = $aResult[5]
Return SetError($aResult[0], 0, $aResult[0] = 0)
EndFunc
Func _AutoItObject_Create($oParent = 0)
Local $aResult
Switch IsObj($oParent)
Case True
$aResult = DllCall($ghAutoItObjectDLL, "idispatch", "CloneAutoItObject", 'idispatch', $oParent)
Case Else
$aResult = DllCall($ghAutoItObjectDLL, "idispatch", "CreateAutoItObject")
EndSwitch
If @error Then Return SetError(1, @error, 0)
Return $aResult[0]
EndFunc
Func _AutoItObject_DllOpen($sDll, $sTag = "", $iFlag = 0)
Local $sTypeTag = "wstr"
If $sTag = Default Or Not $sTag Then $sTypeTag = "ptr"
Local $aCall = DllCall($ghAutoItObjectDLL, "idispatch", "CreateDllCallObject", "wstr", $sDll, $sTypeTag, __Au3Obj_GetMethods($sTag), "dword", $iFlag)
If @error Or Not IsObj($aCall[0]) Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func _AutoItObject_DllStructCreate($sTag, $vParam = 0)
Local $fNew = False
Local $tSubStructure = DllStructCreate($sTag)
If @error Then Return SetError(@error, 0, 0)
Local $iSize = DllStructGetSize($tSubStructure)
Local $pPointer = $vParam
Select
Case @NumParams = 1
$pPointer = __Au3Obj_GlobalAlloc($iSize + 128, 64)
If @error Then Return SetError(3, 0, 0)
$fNew = True
Case IsDllStruct($vParam)
$pPointer = __Au3Obj_GlobalAlloc($iSize, 64)
If @error Then Return SetError(3, 0, 0)
$fNew = True
DllStructSetData(DllStructCreate("byte[" & $iSize & "]", $pPointer), 1, DllStructGetData(DllStructCreate("byte[" & $iSize & "]", DllStructGetPtr($vParam)), 1))
Case @NumParams = 2 And $vParam = 0
Return SetError(3, 0, 0)
EndSelect
Local $sAlignment
Local $sNamesString = __Au3Obj_ObjStructGetElements($sTag, $sAlignment)
Local $aElements = StringSplit($sNamesString, ";", 2)
Local $oObj = _AutoItObject_Class()
For $i = 0 To UBound($aElements) - 1
$oObj.AddMethod($aElements[$i], "__Au3Obj_ObjStructMethod")
Next
$oObj.AddProperty("__tag__", $ELSCOPE_READONLY, $sTag)
$oObj.AddProperty("__size__", $ELSCOPE_READONLY, $iSize)
$oObj.AddProperty("__alignment__", $ELSCOPE_READONLY, $sAlignment)
$oObj.AddProperty("__count__", $ELSCOPE_READONLY, UBound($aElements))
$oObj.AddProperty("__elements__", $ELSCOPE_READONLY, $sNamesString)
$oObj.AddProperty("__new__", $ELSCOPE_PRIVATE, $fNew)
$oObj.AddProperty("__pointer__", $ELSCOPE_READONLY, Number($pPointer))
$oObj.AddMethod("__default__", "__Au3Obj_ObjStructPointer")
$oObj.AddDestructor("__Au3Obj_ObjStructDestructor")
Return $oObj.Object
EndFunc
Func _AutoItObject_IDispatchToPtr($oIDispatch)
Local $aCall = DllCall($ghAutoItObjectDLL, "ptr", "ReturnThis", "idispatch", $oIDispatch)
If @error Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func _AutoItObject_IUnknownAddRef(Const $vUnknown)
Local $sType = "ptr"
If IsObj($vUnknown) Then $sType = "idispatch"
Local $aCall = DllCall($ghAutoItObjectDLL, "dword", "IUnknownAddRef", $sType, $vUnknown)
If @error Then Return SetError(1, @error, 0)
Return $aCall[0]
EndFunc
Func _AutoItObject_IUnknownRelease(Const $vUnknown)
Local $sType = "ptr"
If IsObj($vUnknown) Then $sType = "idispatch"
Local $aCall = DllCall($ghAutoItObjectDLL, "dword", "IUnknownRelease", $sType, $vUnknown)
If @error Then Return SetError(1, @error, 0)
Return $aCall[0]
EndFunc
Func _AutoItObject_ObjCreate($sID, $sRefId = Default, $tagInterface = Default)
Local $sTypeRef = "wstr"
If $sRefId = Default Or Not $sRefId Then $sTypeRef = "ptr"
Local $sTypeTag = "wstr"
If $tagInterface = Default Or Not $tagInterface Then $sTypeTag = "ptr"
Local $aCall = DllCall($ghAutoItObjectDLL, "idispatch", "AutoItObjectCreateObject", "wstr", $sID, $sTypeRef, $sRefId, $sTypeTag, __Au3Obj_GetMethods($tagInterface))
If @error Or Not IsObj($aCall[0]) Then Return SetError(1, 0, 0)
If $sTypeRef = "ptr" And $sTypeTag = "ptr" Then _AutoItObject_IUnknownRelease($aCall[0])
Return $aCall[0]
EndFunc
Func _AutoItObject_ObjCreateEx($sModule, $sID, $sRefId = Default, $tagInterface = Default, $fWrapp = False, $iTimeOut = Default)
Local $sTypeRef = "wstr"
If $sRefId = Default Or Not $sRefId Then $sTypeRef = "ptr"
Local $sTypeTag = "wstr"
If $tagInterface = Default Or Not $tagInterface Then
$sTypeTag = "ptr"
Else
$fWrapp = True
EndIf
If $iTimeOut = Default Then $iTimeOut = 0
Local $aCall = DllCall($ghAutoItObjectDLL, "idispatch", "AutoItObjectCreateObjectEx", "wstr", $sModule, "wstr", $sID, $sTypeRef, $sRefId, $sTypeTag, __Au3Obj_GetMethods($tagInterface), "bool", $fWrapp, "dword", $iTimeOut)
If @error Or Not IsObj($aCall[0]) Then Return SetError(1, 0, 0)
If Not $fWrapp Then _AutoItObject_IUnknownRelease($aCall[0])
Return $aCall[0]
EndFunc
Func _AutoItObject_ObjectFromDtag($sFunctionPrefix, $dtagInterface, $fNoUnknown = False)
Local $sMethods = __Au3Obj_GetMethods($dtagInterface)
$sMethods = StringReplace(StringReplace(StringReplace(StringReplace($sMethods, "object", "idispatch"), "variant*", "ptr"), "hresult", "long"), "bstr", "ptr")
Local $aMethods = StringSplit($sMethods, @LF, 3)
Local $iUbound = UBound($aMethods)
Local $sMethod, $aSplit, $sNamePart, $aTagPart, $sTagPart, $sRet, $sParams
Local $tInterface = DllStructCreate("ptr[" & $iUbound + 1 & "]", __Au3Obj_CoTaskMemAlloc($__Au3Obj_PTR_SIZE * ($iUbound + 1)))
If @error Then Return SetError(1, 0, 0)
For $i = 0 To $iUbound - 1
$aSplit = StringSplit($aMethods[$i], "|", 2)
If UBound($aSplit) <> 2 Then ReDim $aSplit[2]
$sNamePart = $aSplit[0]
$sTagPart = $aSplit[1]
$sMethod = $sFunctionPrefix & $sNamePart
$aTagPart = StringSplit($sTagPart, ";", 2)
$sRet = $aTagPart[0]
$sParams = StringReplace($sTagPart, $sRet, "", 1)
$sParams = "ptr" & $sParams
DllStructSetData($tInterface, 1, DllCallbackGetPtr(DllCallbackRegister($sMethod, $sRet, $sParams)), $i + 2)
Next
DllStructSetData($tInterface, 1, DllStructGetPtr($tInterface) + $__Au3Obj_PTR_SIZE)
Return _AutoItObject_WrapperCreate(DllStructGetPtr($tInterface), $dtagInterface, $fNoUnknown, True)
EndFunc
Func _AutoItObject_PtrToIDispatch($pIDispatch)
Local $aCall = DllCall($ghAutoItObjectDLL, "idispatch", "ReturnThis", "ptr", $pIDispatch)
If @error Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func _AutoItObject_RegisterObject($vObject, $sID)
Local $sTypeObj = "ptr"
If IsObj($vObject) Then $sTypeObj = "idispatch"
Local $aCall = DllCall($ghAutoItObjectDLL, "dword", "RegisterObject", $sTypeObj, $vObject, "wstr", $sID)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func _AutoItObject_RemoveMember(ByRef $oObject, $sMember)
If Not IsObj($oObject) Then Return SetError(2, 0, 0)
If $sMember = '__default__' Then Return SetError(3, 0, 0)
DllCall($ghAutoItObjectDLL, "none", "RemoveMember", "idispatch", $oObject, "wstr", $sMember)
If @error Then Return SetError(1, @error, 0)
Return True
EndFunc
Func _AutoItObject_Shutdown($fFinal = False)
If $giAutoItObjectDLLRef <= 0 Then Return 0
$giAutoItObjectDLLRef -= 1
If $fFinal Then $giAutoItObjectDLLRef = 0
If $giAutoItObjectDLLRef = 0 Then DllCall($ghAutoItObjectDLL, "ptr", "Initialize", "ptr", 0, "ptr", 0)
Return $giAutoItObjectDLLRef
EndFunc
Func _AutoItObject_Startup($fLoadDLL = False, $sDll = "AutoitObject.dll")
Local Static $__Au3Obj_FunctionProxy = DllCallbackGetPtr(DllCallbackRegister("__Au3Obj_FunctionProxy", "int", "wstr;idispatch"))
Local Static $__Au3Obj_EnumFunctionProxy = DllCallbackGetPtr(DllCallbackRegister("__Au3Obj_EnumFunctionProxy", "int", "dword;wstr;idispatch;ptr;ptr"))
If $ghAutoItObjectDLL = -1 Then
If $fLoadDLL Then
If $__Au3Obj_X64 And @NumParams = 1 Then $sDll = "AutoItObject_X64.dll"
$ghAutoItObjectDLL = DllOpen($sDll)
Else
$ghAutoItObjectDLL = __Au3Obj_Mem_DllOpen()
EndIf
If $ghAutoItObjectDLL = -1 Then Return SetError(1, 0, False)
EndIf
If $giAutoItObjectDLLRef <= 0 Then
$giAutoItObjectDLLRef = 0
DllCall($ghAutoItObjectDLL, "ptr", "Initialize", "ptr", $__Au3Obj_FunctionProxy, "ptr", $__Au3Obj_EnumFunctionProxy)
If @error Then
DllClose($ghAutoItObjectDLL)
$ghAutoItObjectDLL = -1
Return SetError(2, 0, False)
EndIf
EndIf
$giAutoItObjectDLLRef += 1
Return True
EndFunc
Func _AutoItObject_UnregisterObject($iHandle)
Local $aCall = DllCall($ghAutoItObjectDLL, "dword", "UnRegisterObject", "dword", $iHandle)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return 1
EndFunc
Func _AutoItObject_VariantClear($pvarg)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "long", "VariantClear", "ptr", $pvarg)
If @error Then Return SetError(1, 0, 1)
Return $aCall[0]
EndFunc
Func _AutoItObject_VariantCopy($pvargDest, $pvargSrc)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "long", "VariantCopy", "ptr", $pvargDest, 'ptr', $pvargSrc)
If @error Then Return SetError(1, 0, 1)
Return $aCall[0]
EndFunc
Func _AutoItObject_VariantFree($pvarg)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "long", "VariantClear", "ptr", $pvarg)
If @error Then Return SetError(1, 0, 1)
If $aCall[0] = 0 Then __Au3Obj_CoTaskMemFree($pvarg)
Return $aCall[0]
EndFunc
Func _AutoItObject_VariantInit($pvarg)
Local $aCall = DllCall($gh_AU3Obj_oleautdll, "long", "VariantInit", "ptr", $pvarg)
If @error Then Return SetError(1, 0, 1)
Return $aCall[0]
EndFunc
Func _AutoItObject_VariantRead($pVariant)
Local $var = DllStructCreate($__Au3Obj_tagVARIANT, $pVariant), $data
Local $VT = DllStructGetData($var, "vt"), $type
Switch $VT
Case $__Au3Obj_VT_I1, $__Au3Obj_VT_UI1
$type = "byte"
Case $__Au3Obj_VT_I2
$type = "short"
Case $__Au3Obj_VT_I4
$type = "int"
Case $__Au3Obj_VT_I8
$type = "int64"
Case $__Au3Obj_VT_R4
$type = "float"
Case $__Au3Obj_VT_R8
$type = "double"
Case $__Au3Obj_VT_UI2
$type = 'word'
Case $__Au3Obj_VT_UI4
$type = 'uint'
Case $__Au3Obj_VT_UI8
$type = 'uint64'
Case $__Au3Obj_VT_BSTR
Return __Au3Obj_SysReadString(DllStructGetData($var, "data"))
Case $__Au3Obj_VT_BOOL
$type = 'short'
Case BitOR($__Au3Obj_VT_ARRAY, $__Au3Obj_VT_UI1)
Local $pSafeArray = DllStructGetData($var, "data")
Local $bound, $pData, $lbound
If 0 = __Au3Obj_SafeArrayGetUBound($pSafeArray, 1, $bound) Then
__Au3Obj_SafeArrayGetLBound($pSafeArray, 1, $lbound)
$bound += 1 - $lbound
If 0 = __Au3Obj_SafeArrayAccessData($pSafeArray, $pData) Then
Local $tData = DllStructCreate("byte[" & $bound & "]", $pData)
$data = DllStructGetData($tData, 1)
__Au3Obj_SafeArrayUnaccessData($pSafeArray)
EndIf
EndIf
Return $data
Case BitOR($__Au3Obj_VT_ARRAY, $__Au3Obj_VT_VARIANT)
Return __Au3Obj_ReadSafeArrayVariant(DllStructGetData($var, "data"))
Case $__Au3Obj_VT_DISPATCH
Return _AutoItObject_PtrToIDispatch(DllStructGetData($var, "data"))
Case $__Au3Obj_VT_PTR
Return DllStructGetData($var, "data")
Case $__Au3Obj_VT_ERROR
Return Default
Case Else
Return SetError(1, 0, '')
EndSwitch
$data = DllStructCreate($type, DllStructGetPtr($var, "data"))
Switch $VT
Case $__Au3Obj_VT_BOOL
Return DllStructGetData($data, 1) <> 0
EndSwitch
Return DllStructGetData($data, 1)
EndFunc
Func _AutoItObject_VariantSet($pVar, $vVal, $iSpecialType = 0)
If Not $pVar Then
$pVar = __Au3Obj_CoTaskMemAlloc($__Au3Obj_VARIANT_SIZE)
_AutoItObject_VariantInit($pVar)
Else
_AutoItObject_VariantClear($pVar)
EndIf
Local $tVar = DllStructCreate($__Au3Obj_tagVARIANT, $pVar)
Local $iType = $__Au3Obj_VT_EMPTY, $vDataType = ''
Switch VarGetType($vVal)
Case "Int32"
$iType = $__Au3Obj_VT_I4
$vDataType = 'int'
Case "Int64"
$iType = $__Au3Obj_VT_I8
$vDataType = 'int64'
Case "String", 'Text'
$iType = $__Au3Obj_VT_BSTR
$vDataType = 'ptr'
$vVal = __Au3Obj_SysAllocString($vVal)
Case "Double"
$vDataType = 'double'
$iType = $__Au3Obj_VT_R8
Case "Float"
$vDataType = 'float'
$iType = $__Au3Obj_VT_R4
Case "Bool"
$vDataType = 'short'
$iType = $__Au3Obj_VT_BOOL
If $vVal Then
$vVal = 0xffff
Else
$vVal = 0
EndIf
Case 'Ptr'
If $__Au3Obj_X64 Then
$iType = $__Au3Obj_VT_UI8
Else
$iType = $__Au3Obj_VT_UI4
EndIf
$vDataType = 'ptr'
Case 'Object'
_AutoItObject_IUnknownAddRef($vVal)
$vDataType = 'ptr'
$iType = $__Au3Obj_VT_DISPATCH
Case "Binary"
Local $tSafeArrayBound = DllStructCreate($__Au3Obj_tagSAFEARRAYBOUND)
DllStructSetData($tSafeArrayBound, 1, BinaryLen($vVal))
Local $pSafeArray = __Au3Obj_SafeArrayCreate($__Au3Obj_VT_UI1, 1, DllStructGetPtr($tSafeArrayBound))
Local $pData
If 0 = __Au3Obj_SafeArrayAccessData($pSafeArray, $pData) Then
Local $tData = DllStructCreate("byte[" & BinaryLen($vVal) & "]", $pData)
DllStructSetData($tData, 1, $vVal)
__Au3Obj_SafeArrayUnaccessData($pSafeArray)
$vVal = $pSafeArray
$vDataType = 'ptr'
$iType = BitOR($__Au3Obj_VT_ARRAY, $__Au3Obj_VT_UI1)
EndIf
Case "Array"
$vDataType = 'ptr'
$vVal = __Au3Obj_CreateSafeArrayVariant($vVal)
$iType = BitOR($__Au3Obj_VT_ARRAY, $__Au3Obj_VT_VARIANT)
Case Else
$iType = $__Au3Obj_VT_ERROR
$vDataType = 'int'
EndSwitch
If $vDataType Then
DllStructSetData(DllStructCreate($vDataType, DllStructGetPtr($tVar, 'data')), 1, $vVal)
If @NumParams = 3 Then $iType = $iSpecialType
DllStructSetData($tVar, 'vt', $iType)
EndIf
Return $pVar
EndFunc
Func _AutoItObject_WrapperAddMethod(ByRef $oWrapper, $sReturnType, $sName, $sParamTypes, $ivtableIndex)
If Not IsObj($oWrapper) Then Return SetError(2, 0, 0)
DllCall($ghAutoItObjectDLL, "none", "WrapperAddMethod", 'idispatch', $oWrapper, 'wstr', $sName, "wstr", StringRegExpReplace($sReturnType & ';' & $sParamTypes, "\s|(;+\Z)", ''), 'dword', $ivtableIndex)
If @error Then Return SetError(1, @error, 0)
Return True
EndFunc
Func _AutoItObject_WrapperCreate($pUnknown, $tagInterface, $fNoUnknown = False, $fCallFree = False)
If Not $pUnknown Then Return SetError(1, 0, 0)
Local $sMethods = __Au3Obj_GetMethods($tagInterface)
Local $aResult
If $sMethods Then
$aResult = DllCall($ghAutoItObjectDLL, "idispatch", "CreateWrapperObjectEx", 'ptr', $pUnknown, 'wstr', $sMethods, "bool", $fNoUnknown, "bool", $fCallFree)
Else
$aResult = DllCall($ghAutoItObjectDLL, "idispatch", "CreateWrapperObject", 'ptr', $pUnknown, "bool", $fNoUnknown)
EndIf
If @error Then Return SetError(2, @error, 0)
Return $aResult[0]
EndFunc
#AutoIt3Wrapper_Au3Check_Parameters=-d -w 1 -w 2 -w 3 -w 4 -w 5 -w 6
Func __Element__($data, $nextEl = 0)
Local $oClassObj = _AutoItObject_Class()
$oClassObj.AddProperty("next", $ELSCOPE_PUBLIC, 0)
$oClassObj.AddProperty("data", $ELSCOPE_PUBLIC, 0)
Local $oObj = $oClassObj.Object
$oObj.next = $nextEl
$oObj.data = $data
Return $oObj
EndFunc
Func LinkedList()
Local $oClassObj = _AutoItObject_Class()
$oClassObj.AddProperty("first", $ELSCOPE_PUBLIC, 0)
$oClassObj.AddProperty("last", $ELSCOPE_PUBLIC, 0)
$oClassObj.AddProperty("size", $ELSCOPE_PUBLIC, 0)
$oClassObj.AddMethod("count", "_LinkedList_count")
$oClassObj.AddMethod("add", "_LinkedList_add")
$oClassObj.AddMethod("at", "_LinkedList_at")
$oClassObj.AddMethod("remove", "_LinkedList_remove")
$oClassObj.AddEnum("_LinkedList_Enumnext", "_LinkedList_EnumReset")
Return $oClassObj.Object
EndFunc
Func _LinkedList_remove($self, $index)
If $self.size = 0 Then Return SetError(1, 0, 0)
Local $current = $self.first
Local $previous = 0
Local $i = 0
Do
If $i = $index Then
If $self.size = 1 Then
$self.first = 0
$self.last = 0
ElseIf $i = 0 Then
$self.first = $current.next
Else
If $i = $self.size - 1 Then $self.last = $previous
$previous.next = $current.next
EndIf
$self.size = $self.size - 1
Return
EndIf
$i += 1
$previous = $current
$current = $current.next
Until $current = 0
Return SetError(2, 0, 0)
EndFunc
Func _LinkedList_add($self, $newdata)
Local $iSize = $self.size
Local $oLast = $self.last
If $iSize = 0 Then
$self.first = __Element__($newdata)
$self.last = $self.first
Else
$oLast.next = __Element__($newdata)
$self.last = $oLast.next
EndIf
$self.size = $iSize + 1
EndFunc
Func _LinkedList_at($self, $index)
Local $i = 0
For $Element In $self
If $i = $index Then Return $Element
$i += 1
next
Return SetError(1, 0, 0)
EndFunc
Func _LinkedList_count($self)
Return $self.size
EndFunc
Func _LinkedList_EnumReset(ByRef $self, ByRef $iterator)
#forceref $self
$iterator = 0
EndFunc
Func _LinkedList_Enumnext(ByRef $self, ByRef $iterator)
If $self.size = 0 Then Return SetError(1, 0, 0)
If Not IsObj($iterator) Then
$iterator = $self.first
Return $iterator.data
EndIf
If Not IsObj($iterator.next) Then Return SetError(1, 0, 0)
$iterator = $iterator.next
Return $iterator.data
EndFunc
_AutoItObject_StartUp()
Global Const $OPT_COORDSRELATIVE = 0
Global Const $OPT_COORDSABSOLUTE = 1
Global Const $OPT_COORDSCLIENT = 2
Global Const $OPT_ERRORSILENT = 0
Global Const $OPT_ERRORFATAL = 1
Global Const $OPT_CAPSNOSTORE = 0
Global Const $OPT_CAPSSTORE = 1
Global Const $OPT_MATCHSTART = 1
Global Const $OPT_MATCHANY = 2
Global Const $OPT_MATCHEXACT = 3
Global Const $OPT_MATCHADVANCED = 4
Global Const $CCS_TOP = 0x01
Global Const $CCS_NOMOVEY = 0x02
Global Const $CCS_BOTTOM = 0x03
Global Const $CCS_NORESIZE = 0x04
Global Const $CCS_NOPARENTALIGN = 0x08
Global Const $CCS_NOHILITE = 0x10
Global Const $CCS_ADJUSTABLE = 0x20
Global Const $CCS_NODIVIDER = 0x40
Global Const $CCS_VERT = 0x0080
Global Const $CCS_LEFT = 0x0081
Global Const $CCS_NOMOVEX = 0x0082
Global Const $CCS_RIGHT = 0x0083
Global Const $DT_DRIVETYPE = 1
Global Const $DT_SSDSTATUS = 2
Global Const $DT_BUSTYPE = 3
Global Const $PROXY_IE = 0
Global Const $PROXY_NONE = 1
Global Const $PROXY_SPECIFIED = 2
Global Const $OBJID_WINDOW = 0x00000000
Global Const $OBJID_TITLEBAR = 0xFFFFFFFE
Global Const $OBJID_SIZEGRIP = 0xFFFFFFF9
Global Const $OBJID_CARET = 0xFFFFFFF8
Global Const $OBJID_CURSOR = 0xFFFFFFF7
Global Const $OBJID_ALERT = 0xFFFFFFF6
Global Const $OBJID_SOUND = 0xFFFFFFF5
Global Const $DLG_CENTERONTOP = 0
Global Const $DLG_NOTITLE = 1
Global Const $DLG_NOTONTOP = 2
Global Const $DLG_TEXTLEFT = 4
Global Const $DLG_TEXTRIGHT = 8
Global Const $DLG_MOVEABLE = 16
Global Const $DLG_TEXTVCENTER = 32
Global Const $MCID_UNKNOWN = -1
Global Const $MCID_HAND = 0
Global Const $MCID_APPSTARTING = 1
Global Const $MCID_ARROW = 2
Global Const $MCID_CROSS = 3
Global Const $MCID_HELP = 4
Global Const $MCID_IBEAM = 5
Global Const $MCID_ICON = 6
Global Const $MCID_NO = 7
Global Const $MCID_SIZE = 8
Global Const $MCID_SIZEALL = 9
Global Const $MCID_SIZENESW = 10
Global Const $MCID_SIZENS = 11
Global Const $MCID_SIZENWSE = 12
Global Const $MCID_SIZEWE = 13
Global Const $MCID_UPARROW = 14
Global Const $MCID_WAIT = 15
Global Const $MCID_NONE = 16
Global Const $SD_LOGOFF = 0
Global Const $SD_SHUTDOWN = 1
Global Const $SD_REBOOT = 2
Global Const $SD_FORCE = 4
Global Const $SD_POWERDOWN = 8
Global Const $SD_FORCEHUNG = 16
Global Const $SD_STANDBY = 32
Global Const $SD_HIBERNATE = 64
Global Const $STDIN_CHILD = 1
Global Const $STDOUT_CHILD = 2
Global Const $STDERR_CHILD = 4
Global Const $STDERR_MERGED = 8
Global Const $STDIO_INHERIT_PARENT = 0x10
Global Const $RUN_CREATE_NEW_CONSOLE = 0x00010000
Global Const $UBOUND_DIMENSIONS = 0
Global Const $UBOUND_ROWS = 1
Global Const $UBOUND_COLUMNS = 2
Global Const $MOUSEEVENTF_ABSOLUTE = 0x8000
Global Const $MOUSEEVENTF_MOVE = 0x0001
Global Const $MOUSEEVENTF_LEFTDOWN = 0x0002
Global Const $MOUSEEVENTF_LEFTUP = 0x0004
Global Const $MOUSEEVENTF_RIGHTDOWN = 0x0008
Global Const $MOUSEEVENTF_RIGHTUP = 0x0010
Global Const $MOUSEEVENTF_MIDDLEDOWN = 0x0020
Global Const $MOUSEEVENTF_MIDDLEUP = 0x0040
Global Const $MOUSEEVENTF_WHEEL = 0x0800
Global Const $MOUSEEVENTF_XDOWN = 0x0080
Global Const $MOUSEEVENTF_XUP = 0x0100
Global Const $REG_NONE = 0
Global Const $REG_SZ = 1
Global Const $REG_EXPAND_SZ = 2
Global Const $REG_BINARY = 3
Global Const $REG_DWORD = 4
Global Const $REG_DWORD_LITTLE_ENDIAN = 4
Global Const $REG_DWORD_BIG_ENDIAN = 5
Global Const $REG_LINK = 6
Global Const $REG_MULTI_SZ = 7
Global Const $REG_RESOURCE_LIST = 8
Global Const $REG_FULL_RESOURCE_DESCRIPTOR = 9
Global Const $REG_RESOURCE_REQUIREMENTS_LIST = 10
Global Const $REG_QWORD = 11
Global Const $REG_QWORD_LITTLE_ENDIAN = 11
Global Const $HWND_BOTTOM = 1
Global Const $HWND_NOTOPMOST = -2
Global Const $HWND_TOP = 0
Global Const $HWND_TOPMOST = -1
Global Const $SWP_NOSIZE = 0x0001
Global Const $SWP_NOMOVE = 0x0002
Global Const $SWP_NOZORDER = 0x0004
Global Const $SWP_NOREDRAW = 0x0008
Global Const $SWP_NOACTIVATE = 0x0010
Global Const $SWP_FRAMECHANGED = 0x0020
Global Const $SWP_DRAWFRAME = 0x0020
Global Const $SWP_SHOWWINDOW = 0x0040
Global Const $SWP_HIDEWINDOW = 0x0080
Global Const $SWP_NOCOPYBITS = 0x0100
Global Const $SWP_NOOWNERZORDER = 0x0200
Global Const $SWP_NOREPOSITION = 0x0200
Global Const $SWP_NOSENDCHANGING = 0x0400
Global Const $SWP_DEFERERASE = 0x2000
Global Const $SWP_ASYNCWINDOWPOS = 0x4000
Global Const $KEYWORD_DEFAULT = 1
Global Const $KEYWORD_NULL = 2
Global Const $DECLARED_LOCAL = -1
Global Const $DECLARED_UNKNOWN = 0
Global Const $DECLARED_GLOBAL = 1
Global Const $ASSIGN_CREATE = 0
Global Const $ASSIGN_FORCELOCAL = 1
Global Const $ASSIGN_FORCEGLOBAL = 2
Global Const $ASSIGN_EXISTFAIL = 4
Global Const $BI_ENABLE = 0
Global Const $BI_DISABLE = 1
Global Const $BREAK_ENABLE = 1
Global Const $BREAK_DISABLE = 0
Global Const $CDTRAY_OPEN = "open"
Global Const $CDTRAY_CLOSED = "closed"
Global Const $SEND_DEFAULT = 0
Global Const $SEND_RAW = 1
Global Const $DIR_DEFAULT = 0
Global Const $DIR_EXTENDED = 1
Global Const $DIR_NORECURSE = 2
Global Const $DIR_REMOVE = 1
Global Const $DT_ALL = "ALL"
Global Const $DT_CDROM = "CDROM"
Global Const $DT_REMOVABLE = "REMOVABLE"
Global Const $DT_FIXED = "FIXED"
Global Const $DT_NETWORK = "NETWORK"
Global Const $DT_RAMDISK = "RAMDISK"
Global Const $DT_UNKNOWN = "UNKNOWN"
Global Const $DT_UNDEFINED = 1
Global Const $DT_FAT = "FAT"
Global Const $DT_FAT32 = "FAT32"
Global Const $DT_EXFAT = "exFAT"
Global Const $DT_NTFS = "NTFS"
Global Const $DT_NWFS = "NWFS"
Global Const $DT_CDFS = "CDFS"
Global Const $DT_UDF = "UDF"
Global Const $DMA_DEFAULT = 0
Global Const $DMA_PERSISTENT = 1
Global Const $DMA_AUTHENTICATION = 8
Global Const $DS_UNKNOWN = "UNKNOWN"
Global Const $DS_READY = "READY"
Global Const $DS_NOTREADY = "NOTREADY"
Global Const $DS_INVALID = "INVALID"
Global Const $MOUSE_CLICK_LEFT = "left"
Global Const $MOUSE_CLICK_RIGHT = "right"
Global Const $MOUSE_CLICK_MIDDLE = "middle"
Global Const $MOUSE_CLICK_MAIN = "main"
Global Const $MOUSE_CLICK_MENU = "menu"
Global Const $MOUSE_CLICK_PRIMARY = "primary"
Global Const $MOUSE_CLICK_SECONDARY = "secondary"
Global Const $MOUSE_WHEEL_UP = "up"
Global Const $MOUSE_WHEEL_DOWN = "down"
Global Const $NUMBER_AUTO = 0
Global Const $NUMBER_32BIT = 1
Global Const $NUMBER_64BIT = 2
Global Const $NUMBER_DOUBLE = 3
Global Const $OBJ_NAME = 1
Global Const $OBJ_STRING = 2
Global Const $OBJ_PROGID = 3
Global Const $OBJ_FILE = 4
Global Const $OBJ_MODULE = 5
Global Const $OBJ_CLSID = 6
Global Const $OBJ_IID = 7
Global Const $EXITCLOSE_NORMAL = 0
Global Const $EXITCLOSE_BYEXIT = 1
Global Const $EXITCLOSE_BYCLICK = 2
Global Const $EXITCLOSE_BYLOGOFF = 3
Global Const $EXITCLOSE_BYSHUTDOWN = 4
Global Const $PROCESS_STATS_MEMORY = 0
Global Const $PROCESS_STATS_IO = 1
Global Const $PROCESS_LOW = 0
Global Const $PROCESS_BELOWNORMAL = 1
Global Const $PROCESS_NORMAL = 2
Global Const $PROCESS_ABOVENORMAL = 3
Global Const $PROCESS_HIGH = 4
Global Const $PROCESS_REALTIME = 5
Global Const $RUN_LOGON_NOPROFILE = 0
Global Const $RUN_LOGON_PROFILE = 1
Global Const $RUN_LOGON_NETWORK = 2
Global Const $RUN_LOGON_INHERIT = 4
Global Const $SOUND_NOWAIT = 0
Global Const $SOUND_WAIT = 1
Global Const $SHEX_OPEN = "open"
Global Const $SHEX_EDIT = "edit"
Global Const $SHEX_PRINT = "print"
Global Const $SHEX_PROPERTIES = "properties"
Global Const $TCP_DATA_DEFAULT = 0
Global Const $TCP_DATA_BINARY = 1
Global Const $UDP_OPEN_DEFAULT = 0
Global Const $UDP_OPEN_BROADCAST = 1
Global Const $UDP_DATA_DEFAULT = 0
Global Const $UDP_DATA_BINARY = 1
Global Const $UDP_DATA_ARRAY = 2
Global Const $TIP_NOICON = 0
Global Const $TIP_INFOICON = 1
Global Const $TIP_WARNINGICON = 2
Global Const $TIP_ERRORICON = 3
Global Const $TIP_BALLOON = 1
Global Const $TIP_CENTER = 2
Global Const $TIP_FORCEVISIBLE = 4
Global Const $WINDOWS_NOONTOP = 0
Global Const $WINDOWS_ONTOP = 1
Global Const $WIN_STATE_EXISTS = 1
Global Const $WIN_STATE_VISIBLE = 2
Global Const $WIN_STATE_ENABLED = 4
Global Const $WIN_STATE_ACTIVE = 8
Global Const $WIN_STATE_MINIMIZED = 16
Global Const $WIN_STATE_MAXIMIZED = 32
Global Const $MB_OK = 0
Global Const $MB_OKCANCEL = 1
Global Const $MB_ABORTRETRYIGNORE = 2
Global Const $MB_YESNOCANCEL = 3
Global Const $MB_YESNO = 4
Global Const $MB_RETRYCANCEL = 5
Global Const $MB_CANCELTRYCONTINUE = 6
Global Const $MB_HELP = 0x4000
Global Const $MB_ICONNONE = 0
Global Const $MB_ICONSTOP = 16
Global Const $MB_ICONERROR = 16
Global Const $MB_ICONHAND = 16
Global Const $MB_ICONQUESTION = 32
Global Const $MB_ICONEXCLAMATION = 48
Global Const $MB_ICONWARNING = 48
Global Const $MB_ICONINFORMATION = 64
Global Const $MB_ICONASTERISK = 64
Global Const $MB_USERICON = 0x00000080
Global Const $MB_DEFBUTTON1 = 0
Global Const $MB_DEFBUTTON2 = 256
Global Const $MB_DEFBUTTON3 = 512
Global Const $MB_DEFBUTTON4 = 768
Global Const $MB_APPLMODAL = 0
Global Const $MB_SYSTEMMODAL = 4096
Global Const $MB_TASKMODAL = 8192
Global Const $MB_DEFAULT_DESKTOP_ONLY = 0x00020000
Global Const $MB_RIGHT = 0x00080000
Global Const $MB_RTLREADING = 0x00100000
Global Const $MB_SETFOREGROUND = 0x00010000
Global Const $MB_TOPMOST = 0x00040000
Global Const $MB_SERVICE_NOTIFICATION = 0x00200000
Global Const $MB_RIGHTJUSTIFIED = $MB_RIGHT
Global Const $IDTIMEOUT = -1
Global Const $IDOK = 1
Global Const $IDCANCEL = 2
Global Const $IDABORT = 3
Global Const $IDRETRY = 4
Global Const $IDIGNORE = 5
Global Const $IDYES = 6
Global Const $IDNO = 7
Global Const $IDCLOSE = 8
Global Const $IDHELP = 9
Global Const $IDTRYAGAIN = 10
Global Const $IDCONTINUE = 11
Global Const $STR_NOCASESENSE = 0
Global Const $STR_CASESENSE = 1
Global Const $STR_NOCASESENSEBASIC = 2
Global Const $STR_STRIPLEADING = 1
Global Const $STR_STRIPTRAILING = 2
Global Const $STR_STRIPSPACES = 4
Global Const $STR_STRIPALL = 8
Global Const $STR_CHRSPLIT = 0
Global Const $STR_ENTIRESPLIT = 1
Global Const $STR_NOCOUNT = 2
Global Const $STR_REGEXPMATCH = 0
Global Const $STR_REGEXPARRAYMATCH = 1
Global Const $STR_REGEXPARRAYFULLMATCH = 2
Global Const $STR_REGEXPARRAYGLOBALMATCH = 3
Global Const $STR_REGEXPARRAYGLOBALFULLMATCH = 4
Global Const $STR_ENDISSTART = 0
Global Const $STR_ENDNOTSTART = 1
Global Const $SB_ANSI = 1
Global Const $SB_UTF16LE = 2
Global Const $SB_UTF16BE = 3
Global Const $SB_UTF8 = 4
Global Const $SE_UTF16 = 0
Global Const $SE_ANSI = 1
Global Const $SE_UTF8 = 2
Global Const $STR_UTF16 = 0
Global Const $STR_UCS2 = 1
Global $_g_ArrayDisplay_hListView
Global $_g_ArrayDisplay_iTranspose
Global $_g_ArrayDisplay_iDisplayRow
Global $_g_ArrayDisplay_aArray
Global $_g_ArrayDisplay_iDims
Global $_g_ArrayDisplay_nRows
Global $_g_ArrayDisplay_nCols
Global $_g_ArrayDisplay_iItem_Start
Global $_g_ArrayDisplay_iItem_End
Global $_g_ArrayDisplay_iSubItem_Start
Global $_g_ArrayDisplay_iSubItem_End
Global $_g_ArrayDisplay_aIndex
Global $_g_ArrayDisplay_aIndexes[1]
Global $_g_ArrayDisplay_iSortDir
Global $_g_ArrayDisplay_asHeader
Global $_g_ArrayDisplay_aNumericSort
Global $ARRAYDISPLAY_ROWPREFIX = "#"
Global $ARRAYDISPLAY_NUMERICSORT = "*"
Global Const $ARRAYDISPLAY_COLALIGNLEFT = 0
Global Const $ARRAYDISPLAY_TRANSPOSE = 1
Global Const $ARRAYDISPLAY_COLALIGNRIGHT = 2
Global Const $ARRAYDISPLAY_COLALIGNCENTER = 4
Global Const $ARRAYDISPLAY_VERBOSE = 8
Global Const $ARRAYDISPLAY_NOROW = 64
Global Const $ARRAYDISPLAY_CHECKERROR = 128
Global Const $_ARRAYCONSTANT_tagLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" &  "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
Func __ArrayDisplay_Share(Const ByRef $aArray, $sTitle = Default, $sArrayRange = Default, $iFlags = Default, $vUser_Separator = Default, $sHeader = Default, $iMax_ColWidth = Default, $hUser_Function = Default, $bDebug = True, Const $_iScriptLineNumber = @ScriptLineNumber, Const $_iCallerError = @error, Const $_iCallerExtended = @extended)
Local $sMsgBoxTitle = (($bDebug) ? ("_DebugArrayDisplay") : ("_ArrayDisplay"))
If $sTitle = Default Then $sTitle = $sMsgBoxTitle
If $sArrayRange = Default Then $sArrayRange = ""
If $iFlags = Default Then $iFlags = 0
If $vUser_Separator = Default Then $vUser_Separator = ""
If $sHeader = Default Then $sHeader = ""
If $iMax_ColWidth = Default Then $iMax_ColWidth = 350
If $iMax_ColWidth > 4095 Then $iMax_ColWidth = 4095
If $hUser_Function = Default Then $hUser_Function = 0
$_g_ArrayDisplay_iTranspose = BitAND($iFlags, $ARRAYDISPLAY_TRANSPOSE)
Local $iColAlign = BitAND($iFlags, 6)
Local $iVerbose = Int(BitAND($iFlags, $ARRAYDISPLAY_VERBOSE))
$_g_ArrayDisplay_iDisplayRow = Int(BitAND($iFlags, $ARRAYDISPLAY_NOROW) = 0)
Local $iButtonBorder = (($bDebug) ? (40) : (20))
Local $sMsg = "", $iRet = 1
Local $fTimer = 0
If IsArray($aArray) Then
$_g_ArrayDisplay_aArray = $aArray
$_g_ArrayDisplay_iDims = UBound($_g_ArrayDisplay_aArray, $UBOUND_DIMENSIONS)
If $_g_ArrayDisplay_iDims = 1 Then $_g_ArrayDisplay_iTranspose = 0
$_g_ArrayDisplay_nRows = UBound($_g_ArrayDisplay_aArray, $UBOUND_ROWS)
$_g_ArrayDisplay_nCols = ($_g_ArrayDisplay_iDims = 2) ? UBound($_g_ArrayDisplay_aArray, $UBOUND_COLUMNS) : 1
Dim $_g_ArrayDisplay_aNumericSort[$_g_ArrayDisplay_nCols]
If $_g_ArrayDisplay_iDims > 2 Then
$sMsg = "Larger than 2D array passed to function"
$iRet = 2
EndIf
If $_iCallerError Then
If $bDebug Then
If IsDeclared("__g_sReportCallBack_DebugReport_Debug") Then
$sMsg = "@@ Debug( " & $_iScriptLineNumber & ") : @error = " & $_iCallerError & " in " & $sMsgBoxTitle & "( '" & $sTitle & "' )"
Execute('$__g_sReportCallBack_DebugReport_Debug("' & $sMsg & '")')
EndIf
$iRet = 3
ElseIf BitAND($iFlags, $ARRAYDISPLAY_CHECKERROR) Then
$sMsg = "@error = " & $_iCallerError & " when calling the function"
If $_iScriptLineNumber > 0 Then $sMsg &= " at line " & $_iScriptLineNumber
$iRet = 3
EndIf
EndIf
Else
$sMsg = "No array variable passed to function"
EndIf
If $sMsg Then
If $iVerbose And MsgBox($MB_SYSTEMMODAL + $MB_ICONERROR + $MB_YESNO,  $sMsgBoxTitle & "() Error: " & $sTitle, $sMsg & @CRLF & @CRLF & "Exit the script?") = $IDYES Then
Exit
Else
Return SetError($iRet, 0, 0)
EndIf
EndIf
Local $iCW_ColWidth = Number($vUser_Separator)
Local $sCurr_Separator = Opt("GUIDataSeparatorChar")
If $vUser_Separator = "" Then $vUser_Separator = $sCurr_Separator
$_g_ArrayDisplay_iItem_Start = 0
$_g_ArrayDisplay_iItem_End = $_g_ArrayDisplay_nRows - 1
$_g_ArrayDisplay_iSubItem_Start = 0
$_g_ArrayDisplay_iSubItem_End = (($_g_ArrayDisplay_iDims = 2) ? ($_g_ArrayDisplay_nCols - 1) : (0))
Local $avRangeSplit
If $sArrayRange Then
Local $vTmp, $aArray_Range = StringRegExp($sArrayRange & "||", "(?U)(.*)\|", $STR_REGEXPARRAYGLOBALMATCH)
If $aArray_Range[0] Then
$avRangeSplit = StringSplit($aArray_Range[0], ":")
If @error Then
$_g_ArrayDisplay_iItem_End = Number($aArray_Range[0])
Else
$_g_ArrayDisplay_iItem_Start = Number($avRangeSplit[1])
If $avRangeSplit[2] <> "" Then
$_g_ArrayDisplay_iItem_End = Number($avRangeSplit[2])
EndIf
EndIf
EndIf
If $_g_ArrayDisplay_iItem_Start < 0 Then $_g_ArrayDisplay_iItem_Start = 0
If $_g_ArrayDisplay_iItem_End >= $_g_ArrayDisplay_nRows Then $_g_ArrayDisplay_iItem_End = $_g_ArrayDisplay_nRows - 1
If ($_g_ArrayDisplay_iItem_Start > $_g_ArrayDisplay_iItem_End) And ($_g_ArrayDisplay_iItem_End > 0) Then
$vTmp = $_g_ArrayDisplay_iItem_Start
$_g_ArrayDisplay_iItem_Start = $_g_ArrayDisplay_iItem_End
$_g_ArrayDisplay_iItem_End = $vTmp
EndIf
If $_g_ArrayDisplay_iDims = 2 And $aArray_Range[1] Then
$avRangeSplit = StringSplit($aArray_Range[1], ":")
If @error Then
$_g_ArrayDisplay_iSubItem_End = Number($aArray_Range[1])
Else
$_g_ArrayDisplay_iSubItem_Start = Number($avRangeSplit[1])
If $avRangeSplit[2] <> "" Then
$_g_ArrayDisplay_iSubItem_End = Number($avRangeSplit[2])
EndIf
EndIf
If $_g_ArrayDisplay_iSubItem_Start > $_g_ArrayDisplay_iSubItem_End Then
$vTmp = $_g_ArrayDisplay_iSubItem_Start
$_g_ArrayDisplay_iSubItem_Start = $_g_ArrayDisplay_iSubItem_End
$_g_ArrayDisplay_iSubItem_End = $vTmp
EndIf
If $_g_ArrayDisplay_iSubItem_Start < 0 Then $_g_ArrayDisplay_iSubItem_Start = 0
If $_g_ArrayDisplay_iSubItem_End >= $_g_ArrayDisplay_nCols Then $_g_ArrayDisplay_iSubItem_End = $_g_ArrayDisplay_nCols - 1
EndIf
EndIf
Local $sDisplayData = "[" & $_g_ArrayDisplay_nRows & "]"
If $_g_ArrayDisplay_iDims = 2 Then
$sDisplayData &= " [" & $_g_ArrayDisplay_nCols & "]"
EndIf
Local $sTipData = ""
If $sArrayRange Then
If $sTipData Then $sTipData &= " - "
$sTipData &= "Range set " & $sArrayRange
EndIf
If $_g_ArrayDisplay_iTranspose Then
If $sTipData Then $sTipData &= " - "
$sTipData &= "Transposed"
EndIf
If $sArrayRange Or $_g_ArrayDisplay_iTranspose Then $_g_ArrayDisplay_aArray = __ArrayDisplay_CreateSubArray()
$_g_ArrayDisplay_asHeader = StringSplit($sHeader, $sCurr_Separator, $STR_NOCOUNT)
If UBound($_g_ArrayDisplay_asHeader) = 0 Then Dim $_g_ArrayDisplay_asHeader[1] = [""]
$sHeader = "Row"
Local $iIndex = $_g_ArrayDisplay_iSubItem_Start
If $_g_ArrayDisplay_iTranspose Then
$sHeader = "Row"
For $j = 0 To $_g_ArrayDisplay_nCols - 1
$sHeader &= $sCurr_Separator & $ARRAYDISPLAY_ROWPREFIX & " " & $j + $_g_ArrayDisplay_iSubItem_Start
Next
Else
If $_g_ArrayDisplay_asHeader[0] Then
For $iIndex = $_g_ArrayDisplay_iSubItem_Start To $_g_ArrayDisplay_iSubItem_End
If $iIndex >= UBound($_g_ArrayDisplay_asHeader) Then ExitLoop
If StringRight($_g_ArrayDisplay_asHeader[$iIndex], 1) = $ARRAYDISPLAY_NUMERICSORT Then
$_g_ArrayDisplay_asHeader[$iIndex] = StringTrimRight($_g_ArrayDisplay_asHeader[$iIndex], 1)
$_g_ArrayDisplay_aNumericSort[$iIndex - $_g_ArrayDisplay_iSubItem_Start] = 1
EndIf
$sHeader &= $sCurr_Separator & $_g_ArrayDisplay_asHeader[$iIndex]
Next
EndIf
For $j = $iIndex To $_g_ArrayDisplay_iSubItem_End
$sHeader &= $sCurr_Separator & "Col " & $j
Next
EndIf
If Not $_g_ArrayDisplay_iDisplayRow Then $sHeader = StringTrimLeft($sHeader, 4)
__ArrayDisplay_SortIndexes(0, -1)
Local $hTimer = TimerInit()
__ArrayDisplay_SortIndexes(1, 1)
$fTimer = TimerDiff($hTimer)
If $fTimer * $_g_ArrayDisplay_nCols < 1000 Then
__ArrayDisplay_SortIndexes(2, $_g_ArrayDisplay_nCols)
If $bDebug Then ConsoleWrite("Sorting all indexes = " & TimerDiff($hTimer) & @CRLF & @CRLF)
Else
If $bDebug Then ConsoleWrite("Sorting one index = " & TimerDiff($hTimer) & @CRLF)
EndIf
If $iVerbose And ($_g_ArrayDisplay_nRows * $_g_ArrayDisplay_nCols) > 1000 Then
SplashTextOn($sMsgBoxTitle, "Preparing display" & @CRLF & @CRLF & "Please be patient", 300, 100)
EndIf
Local Const $_ARRAYCONSTANT_GUI_DOCKBOTTOM = 64
Local Const $_ARRAYCONSTANT_GUI_DOCKBORDERS = 102
Local Const $_ARRAYCONSTANT_GUI_DOCKHEIGHT = 512
Local Const $_ARRAYCONSTANT_GUI_DOCKLEFT = 2
Local Const $_ARRAYCONSTANT_GUI_DOCKRIGHT = 4
Local Const $_ARRAYCONSTANT_GUI_DOCKHCENTER = 8
Local Const $_ARRAYCONSTANT_GUI_EVENT_CLOSE = -3
Local Const $_ARRAYCONSTANT_GUI_EVENT_ARRAY = 1
Local Const $_ARRAYCONSTANT_GUI_FOCUS = 256
Local Const $_ARRAYCONSTANT_SS_CENTER = 0x1
Local Const $_ARRAYCONSTANT_SS_CENTERIMAGE = 0x0200
Local Const $_ARRAYCONSTANT_LVM_GETITEMRECT = (0x1000 + 14)
Local Const $_ARRAYCONSTANT_LVM_GETITEMSTATE = (0x1000 + 44)
Local Const $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT = (0x1000 + 50)
Local Const $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE = (0x1000 + 54)
Local Const $_ARRAYCONSTANT_LVS_EX_GRIDLINES = 0x1
Local Const $_ARRAYCONSTANT_LVIS_SELECTED = 0x0002
Local Const $_ARRAYCONSTANT_LVS_SHOWSELALWAYS = 0x8
Local Const $_ARRAYCONSTANT_LVS_OWNERDATA = 0x1000
Local Const $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT = 0x20
Local Const $_ARRAYCONSTANT_LVS_EX_DOUBLEBUFFER = 0x00010000
Local Const $_ARRAYCONSTANT_WS_EX_CLIENTEDGE = 0x0200
Local Const $_ARRAYCONSTANT_WS_MAXIMIZEBOX = 0x00010000
Local Const $_ARRAYCONSTANT_WS_MINIMIZEBOX = 0x00020000
Local Const $_ARRAYCONSTANT_WS_SIZEBOX = 0x00040000
Local $iCoordMode = Opt("GUICoordMode", 1)
Local $iOrgWidth = 210, $iHeight = 200, $iMinSize = 250
Local $hGUI = GUICreate($sTitle, $iOrgWidth, $iHeight, Default, Default, BitOR($_ARRAYCONSTANT_WS_SIZEBOX, $_ARRAYCONSTANT_WS_MINIMIZEBOX, $_ARRAYCONSTANT_WS_MAXIMIZEBOX))
Local $aiGUISize = WinGetClientSize($hGUI)
Local $idListView = GUICtrlCreateListView($sHeader, 0, 0, $aiGUISize[0], $aiGUISize[1] - $iButtonBorder, BitOR($_ARRAYCONSTANT_LVS_SHOWSELALWAYS, $_ARRAYCONSTANT_LVS_OWNERDATA))
$_g_ArrayDisplay_hListView = GUICtrlGetHandle($idListView)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_GRIDLINES, $_ARRAYCONSTANT_LVS_EX_GRIDLINES)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_DOUBLEBUFFER, $_ARRAYCONSTANT_LVS_EX_DOUBLEBUFFER)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE)
Local $hHeader = HWnd(GUICtrlSendMsg($idListView, (0x1000 + 31), 0, 0))
GUICtrlSetResizing($idListView, $_ARRAYCONSTANT_GUI_DOCKBORDERS)
Local $iColFill = $_g_ArrayDisplay_nCols + $_g_ArrayDisplay_iDisplayRow
If $iColAlign Then
For $i = 0 To $iColFill - 1
__ArrayDisplay_JustifyColumn($idListView, $i, $iColAlign / 2)
Next
EndIf
GUICtrlSendMsg($idListView, (0x1000 + 47), $_g_ArrayDisplay_nRows, 0)
Local $tRECT = DllStructCreate("struct; long Left;long Top;long Right;long Bottom; endstruct")
DllCall("user32.dll", "struct*", "SendMessageW", "hwnd", $_g_ArrayDisplay_hListView, "uint", $_ARRAYCONSTANT_LVM_GETITEMRECT, "wparam", 0, "struct*", $tRECT)
Local $aiWin_Pos = WinGetPos($hGUI)
Local $aiLV_Pos = ControlGetPos($hGUI, "", $idListView)
$iHeight = (($_g_ArrayDisplay_nRows + 3) * (DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top"))) + $aiWin_Pos[3] - $aiLV_Pos[3]
If $iHeight > @DesktopHeight - 100 Then
$iHeight = @DesktopHeight - 100
ElseIf $iHeight < $iMinSize Then
$iHeight = $iMinSize
EndIf
If $iVerbose Then SplashOff()
$_g_ArrayDisplay_iSortDir = 0x00000400
Local $iColumn = 0, $iColumnPrev = -1
If $_g_ArrayDisplay_iDisplayRow Then
$iColumnPrev = $iColumn
__ArrayDisplay_HeaderSetItemFormat($hHeader, $iColumn, 0x00004000 + $_g_ArrayDisplay_iSortDir + $iColAlign / 2)
EndIf
$_g_ArrayDisplay_aIndex = $_g_ArrayDisplay_aIndexes[0]
Local $p__ArrayDisplay_NotifyHandler = DllCallbackGetPtr(DllCallbackRegister("__ArrayDisplay_NotifyHandler", "lresult", "hwnd;uint;wparam;lparam;uint_ptr;dword_ptr"))
DllCall("comctl32.dll", "bool", "SetWindowSubclass", "hwnd", $hGUI, "ptr", $p__ArrayDisplay_NotifyHandler, "uint_ptr", 0, "dword_ptr", 0)
Local $iWidth = 40, $iColWidth = 0, $aiColWidth[$iColFill], $iMin_ColWidth = 55
Local $iColWidthHeader
For $i = 0 To $iColFill - 1
GUICtrlSendMsg($idListView, (0x1000 + 30), $i, -1)
$iColWidth = GUICtrlSendMsg($idListView, (0x1000 + 29), $i, 0)
If $sHeader <> "" Then
If $iColWidth = 0 Then ExitLoop
GUICtrlSendMsg($idListView, (0x1000 + 30), $i, -2)
$iColWidthHeader = GUICtrlSendMsg($idListView, (0x1000 + 29), $i, 0)
If $iColWidth < $iMin_ColWidth And $iColWidthHeader < $iMin_ColWidth Then
GUICtrlSendMsg($idListView, (0x1000 + 30), $i, $iMin_ColWidth)
$iColWidth = $iMin_ColWidth
ElseIf $iColWidthHeader < $iColWidth Then
GUICtrlSendMsg($idListView, (0x1000 + 30), $i, $iColWidth)
Else
$iColWidth = $iColWidthHeader
EndIf
Else
If $iColWidth < $iMin_ColWidth Then
GUICtrlSendMsg($idListView, (0x1000 + 30), $i, $iMin_ColWidth)
$iColWidth = $iMin_ColWidth
EndIf
EndIf
$iWidth += $iColWidth
$aiColWidth[$i] = $iColWidth
Next
If $iWidth > @DesktopWidth - 100 Then
$iWidth = 40
For $i = 0 To $iColFill - 1
If $aiColWidth[$i] > $iMax_ColWidth Then
GUICtrlSendMsg($idListView, (0x1000 + 30), $i, $iMax_ColWidth)
$iWidth += $iMax_ColWidth
Else
$iWidth += $aiColWidth[$i]
EndIf
If $i < 20 And $bDebug Then ConsoleWrite('@@ Debug(' & @ScriptLineNumber & ') : $iWidth = ' & $iWidth & " $i = " & $i & @CRLF)
Next
EndIf
If $iWidth > @DesktopWidth - 100 Then
$iWidth = @DesktopWidth - 100
ElseIf $iWidth < $iMinSize Then
$iWidth = $iMinSize
EndIf
Local $iScrollBarSize = 0
If $iHeight = (@DesktopHeight - 100) Then $iScrollBarSize = 15
WinMove($hGUI, "", (@DesktopWidth - $iWidth + $iScrollBarSize) / 2, (@DesktopHeight - $iHeight) / 2, $iWidth + $iScrollBarSize, $iHeight)
$aiGUISize = WinGetClientSize($hGUI)
GUICtrlSetPos($idListView, 0, 0, $iWidth, $aiGUISize[1] - $iButtonBorder)
Local $iButtonWidth_1 = $aiGUISize[0] / 2
Local $iButtonWidth_2 = $aiGUISize[0] / 3
Local $idCopy_ID = 9999, $idCopy_Data = 99999, $idData_Label = 99999, $idUser_Func = 99999, $idExit_Script = 99999
If $bDebug Then
$idCopy_ID = GUICtrlCreateButton("Copy Data && Hdr/Row", 0, $aiGUISize[1] - $iButtonBorder, $iButtonWidth_1, 20)
$idCopy_Data = GUICtrlCreateButton("Copy Data Only", $iButtonWidth_1, $aiGUISize[1] - $iButtonBorder, $iButtonWidth_1, 20)
Local $iButtonWidth_Var = $iButtonWidth_1
Local $iOffset = $iButtonWidth_1
If IsFunc($hUser_Function) Then
$idUser_Func = GUICtrlCreateButton("Run User Func", $iButtonWidth_2, $aiGUISize[1] - 20, $iButtonWidth_2, 20)
$iButtonWidth_Var = $iButtonWidth_2
$iOffset = $iButtonWidth_2 * 2
EndIf
$idExit_Script = GUICtrlCreateButton("Exit Script", $iOffset, $aiGUISize[1] - 20, $iButtonWidth_Var, 20)
$idData_Label = GUICtrlCreateLabel($sDisplayData, 0, $aiGUISize[1] - 20, $iButtonWidth_Var, 18, BitOR($_ARRAYCONSTANT_SS_CENTER, $_ARRAYCONSTANT_SS_CENTERIMAGE))
Else
$idData_Label = GUICtrlCreateLabel($sDisplayData, 0, $aiGUISize[1] - 20, $aiGUISize[0], 18, BitOR($_ARRAYCONSTANT_SS_CENTER, $_ARRAYCONSTANT_SS_CENTERIMAGE))
EndIf
If $_g_ArrayDisplay_iTranspose Or $sArrayRange Then
GUICtrlSetColor($idData_Label, 0xFF0000)
GUICtrlSetTip($idData_Label, $sTipData)
EndIf
GUICtrlSetResizing($idCopy_ID, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idCopy_Data, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idData_Label, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idUser_Func, $_ARRAYCONSTANT_GUI_DOCKHCENTER + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idExit_Script, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUISetState(@SW_SHOW, $hGUI)
If $fTimer > 1000 And Not $sArrayRange Then
Beep(750, 250)
ToolTip("Sorting Action can take as long as " & Ceiling($fTimer / 1000) & " sec" & @CRLF & @CRLF & "Please be patient when you click to sort a column", 50, 50, $sMsgBoxTitle, $TIP_WARNINGICON, $TIP_BALLOON)
Sleep(3000)
ToolTip("")
EndIf
Local $iOnEventMode = Opt("GUIOnEventMode", 0), $aMsg
While 1
$aMsg = GUIGetMsg($_ARRAYCONSTANT_GUI_EVENT_ARRAY)
If $aMsg[1] = $hGUI Then
Switch $aMsg[0]
Case $_ARRAYCONSTANT_GUI_EVENT_CLOSE
ExitLoop
Case $idCopy_ID, $idCopy_Data
Local $iSel_Count = GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT, 0, 0)
If $iVerbose And (Not $iSel_Count) And ($_g_ArrayDisplay_iItem_End - $_g_ArrayDisplay_iItem_Start) * ($_g_ArrayDisplay_iSubItem_End - $_g_ArrayDisplay_iSubItem_Start) > 10000 Then
SplashTextOn($sMsgBoxTitle, "Copying data" & @CRLF & @CRLF & "Please be patient", 300, 100)
EndIf
Local $sClip = "", $sItem, $aSplit, $iFirstCol = 0
If $aMsg[0] = $idCopy_Data And $_g_ArrayDisplay_iDisplayRow Then $iFirstCol = 1
For $i = 0 To GUICtrlSendMsg($idListView, 0X1004, 0, 0) - 1
If $iSel_Count And Not (GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $i, $_ARRAYCONSTANT_LVIS_SELECTED) <> 0) Then
ContinueLoop
EndIf
$sItem = __ArrayDisplay_GetItemTextStringSelected($idListView, $i, $iFirstCol)
If $aMsg[0] = $idCopy_ID And Not $_g_ArrayDisplay_iDisplayRow Then
$sItem = $ARRAYDISPLAY_ROWPREFIX & " " & ($i + $_g_ArrayDisplay_iItem_Start) & $sCurr_Separator & $sItem
EndIf
If $iCW_ColWidth Then
$aSplit = StringSplit($sItem, $sCurr_Separator)
$sItem = ""
For $j = 1 To $aSplit[0]
$sItem &= StringFormat("%-" & $iCW_ColWidth + 1 & "s", StringLeft($aSplit[$j], $iCW_ColWidth))
Next
Else
$sItem = StringReplace($sItem, $sCurr_Separator, $vUser_Separator)
EndIf
$sClip &= $sItem & @CRLF
Next
$sItem = $sHeader
If $aMsg[0] = $idCopy_ID Then
$sItem = $sHeader
If Not $_g_ArrayDisplay_iDisplayRow Then
$sItem = "Row" & $sCurr_Separator & $sItem
EndIf
If $iCW_ColWidth Then
$aSplit = StringSplit($sItem, $sCurr_Separator)
$sItem = ""
For $j = 1 To $aSplit[0]
$sItem &= StringFormat("%-" & $iCW_ColWidth + 1 & "s", StringLeft($aSplit[$j], $iCW_ColWidth))
Next
Else
$sItem = StringReplace($sItem, $sCurr_Separator, $vUser_Separator)
EndIf
$sClip = $sItem & @CRLF & $sClip
EndIf
ClipPut($sClip)
SplashOff()
GUICtrlSetState($idListView, $_ARRAYCONSTANT_GUI_FOCUS)
Case $idListView
$iColumn = GUICtrlGetState($idListView)
If Not IsArray($_g_ArrayDisplay_aIndexes[$iColumn + Not $_g_ArrayDisplay_iDisplayRow]) Then
__ArrayDisplay_SortIndexes($iColumn + Not $_g_ArrayDisplay_iDisplayRow)
EndIf
If $iColumn <> $iColumnPrev Then
__ArrayDisplay_HeaderSetItemFormat($hHeader, $iColumnPrev, 0x00004000 + $iColAlign / 2)
If $_g_ArrayDisplay_iDisplayRow And $iColumn = 0 Then
$_g_ArrayDisplay_aIndex = $_g_ArrayDisplay_aIndexes[0]
Else
$_g_ArrayDisplay_aIndex = $_g_ArrayDisplay_aIndexes[$iColumn + Not $_g_ArrayDisplay_iDisplayRow]
EndIf
EndIf
$_g_ArrayDisplay_iSortDir = ($iColumn = $iColumnPrev) ? $_g_ArrayDisplay_iSortDir = 0x00000400 ? 0x00000200 : 0x00000400 : 0x00000400
__ArrayDisplay_HeaderSetItemFormat($hHeader, $iColumn, 0x00004000 + $_g_ArrayDisplay_iSortDir + $iColAlign / 2)
GUICtrlSendMsg($idListView, (0x1000 + 140), $iColumn, 0)
GUICtrlSendMsg($idListView, (0x1000 + 47), $_g_ArrayDisplay_nRows, 0)
$iColumnPrev = $iColumn
Case $idUser_Func
Local $aiSelItems[1] = [0]
For $i = 0 To GUICtrlSendMsg($idListView, 0x1004, 0, 0) - 1
If (GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $i, $_ARRAYCONSTANT_LVIS_SELECTED) <> 0) Then
$aiSelItems[0] += 1
ReDim $aiSelItems[$aiSelItems[0] + 1]
$aiSelItems[$aiSelItems[0]] = $i + $_g_ArrayDisplay_iItem_Start
EndIf
Next
$hUser_Function($_g_ArrayDisplay_aArray, $aiSelItems)
GUICtrlSetState($idListView, $_ARRAYCONSTANT_GUI_FOCUS)
Case $idExit_Script
GUIDelete($hGUI)
Exit
EndSwitch
EndIf
WEnd
DllCall("comctl32.dll", "bool", "RemoveWindowSubclass", "hwnd", $hGUI, "ptr", $p__ArrayDisplay_NotifyHandler, "uint_ptr", 0)
$_g_ArrayDisplay_aIndex = 0
Dim $_g_ArrayDisplay_aIndexes[1]
GUIDelete($hGUI)
Opt("GUICoordMode", $iCoordMode)
Opt("GUIOnEventMode", $iOnEventMode)
Return SetError($_iCallerError, $_iCallerExtended, 1)
EndFunc
Func __ArrayDisplay_NotifyHandler($hWnd, $iMsg, $wParam, $lParam, $iSubclassId, $pData)
If $iMsg <> 0x004E Then Return DllCall("comctl32.dll", "lresult", "DefSubclassProc", "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam, "lparam", $lParam)[0]
Local Static $tagNMHDR = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
Local Static $tagNMLVDISPINFO = $tagNMHDR & ";" & $_ARRAYCONSTANT_tagLVITEM
Local $tNMLVDISPINFO = DllStructCreate($tagNMLVDISPINFO, $lParam)
Switch HWnd(DllStructGetData($tNMLVDISPINFO, "hWndFrom"))
Case $_g_ArrayDisplay_hListView
Switch DllStructGetData($tNMLVDISPINFO, "Code")
Case -177
Local Static $tText = DllStructCreate("wchar[4096]"), $pText = DllStructGetPtr($tText)
Local $iItem = DllStructGetData($tNMLVDISPINFO, "Item")
Local $iRow = ($_g_ArrayDisplay_iSortDir = 0x00000400) ? $_g_ArrayDisplay_aIndex[$iItem] : $_g_ArrayDisplay_aIndex[$_g_ArrayDisplay_nRows - 1 - $iItem]
Local $iCol = DllStructGetData($tNMLVDISPINFO, "SubItem")
Local $sTemp
If $_g_ArrayDisplay_iDisplayRow = 0 Then
If $_g_ArrayDisplay_iDims = 2 Then
$sTemp = $_g_ArrayDisplay_aArray[$iRow][$iCol]
Else
$sTemp = $_g_ArrayDisplay_aArray[$iRow]
EndIf
Switch VarGetType($sTemp)
Case "Array"
$sTemp = "{Array}"
Case "Map"
$sTemp = "{Map}"
EndSwitch
If StringLen($sTemp) > 4095 Then $sTemp = StringLeft($sTemp, 4095)
DllStructSetData($tText, 1, $sTemp)
DllStructSetData($tNMLVDISPINFO, "Text", $pText)
Else
If $iCol = 0 Then
If $_g_ArrayDisplay_iTranspose Then
Local $sCaptionCplt = ""
If $iRow + $_g_ArrayDisplay_iItem_Start < UBound($_g_ArrayDisplay_asHeader)  And StringStripWS($_g_ArrayDisplay_asHeader[$iRow + $_g_ArrayDisplay_iItem_Start], 1 + 2) <> "" Then
$sCaptionCplt = " (" & StringStripWS($_g_ArrayDisplay_asHeader[$iRow + $_g_ArrayDisplay_iItem_Start], 1 + 2)
If StringRight($sCaptionCplt, 1) = $ARRAYDISPLAY_NUMERICSORT Then $sCaptionCplt = StringTrimRight($sCaptionCplt, 1)
$sCaptionCplt &= ")"
EndIf
DllStructSetData($tText, 1, "Col " & ($iRow + $_g_ArrayDisplay_iItem_Start) & $sCaptionCplt)
Else
DllStructSetData($tText, 1, $ARRAYDISPLAY_ROWPREFIX & " " & $iRow + $_g_ArrayDisplay_iItem_Start)
EndIf
DllStructSetData($tNMLVDISPINFO, "Text", $pText)
Else
If $_g_ArrayDisplay_iDims = 2 Then
$sTemp = $_g_ArrayDisplay_aArray[$iRow][$iCol - 1]
Else
$sTemp = $_g_ArrayDisplay_aArray[$iRow]
EndIf
Switch VarGetType($sTemp)
Case "Array"
$sTemp = "{Array}"
Case "Map"
$sTemp = "{Map}"
EndSwitch
If StringLen($sTemp) > 4095 Then $sTemp = StringLeft($sTemp, 4095)
DllStructSetData($tText, 1, $sTemp)
DllStructSetData($tNMLVDISPINFO, "Text", $pText)
EndIf
EndIf
Return
EndSwitch
EndSwitch
Return DllCall("comctl32.dll", "lresult", "DefSubclassProc", "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam, "lparam", $lParam)[0]
#forceref $iSubclassId, $pData
EndFunc
Func __ArrayDisplay_SortIndexes($iColStart, $iColEnd = $iColStart)
Dim $_g_ArrayDisplay_aIndex[$_g_ArrayDisplay_nRows]
If $iColEnd = -1 Then
Dim $_g_ArrayDisplay_aIndexes[$_g_ArrayDisplay_nCols + $_g_ArrayDisplay_iDisplayRow + 1]
For $i = 0 To $_g_ArrayDisplay_nRows - 1
$_g_ArrayDisplay_aIndex[$i] = $i
Next
$_g_ArrayDisplay_aIndexes[0] = $_g_ArrayDisplay_aIndex
EndIf
If $iColStart = -1 Then
$iColStart = 1
$iColEnd = $_g_ArrayDisplay_nCols
EndIf
If $iColStart Then
Local $tIndex
For $i = $iColStart To $iColEnd
$tIndex = __ArrayDisplay_GetSortColStruct($_g_ArrayDisplay_aArray, $i - 1)
For $j = 0 To $_g_ArrayDisplay_nRows - 1
$_g_ArrayDisplay_aIndex[$j] = DllStructGetData($tIndex, 1, $j + 1)
Next
$_g_ArrayDisplay_aIndexes[$i] = $_g_ArrayDisplay_aIndex
Next
EndIf
EndFunc
Func __ArrayDisplay_GetSortColStruct(Const ByRef $aArray, $iCol)
If UBound($aArray, $UBOUND_DIMENSIONS) < 1 Or UBound($aArray, $UBOUND_DIMENSIONS) > 2 Then
Return SetError(6, 0, 0)
EndIf
Return __ArrayDisplay_SortArrayStruct($aArray, $iCol)
EndFunc
Func __ArrayDisplay_SortArrayStruct(Const ByRef $aArray, $iCol)
Local $iDims = UBound($aArray, $UBOUND_DIMENSIONS)
Local $tIndex = DllStructCreate("uint[" & $_g_ArrayDisplay_nRows & "]")
Local $pIndex = DllStructGetPtr($tIndex)
Static $hDll = DllOpen("kernel32.dll")
Static $hDllComp = DllOpen("shlwapi.dll")
Local $lo, $hi, $mi, $r, $nVal1, $nVal2
For $i = 1 To $_g_ArrayDisplay_nRows - 1
$lo = 0
$hi = $i - 1
Do
$mi = Int(($lo + $hi) / 2)
If Not $_g_ArrayDisplay_iTranspose And $_g_ArrayDisplay_aNumericSort[$iCol] Then
If $iDims = 1 Then
$nVal1 = Number($aArray[$i])
$nVal2 = Number($aArray[DllStructGetData($tIndex, 1, $mi + 1)])
Else
$nVal1 = Number($aArray[$i][$iCol])
$nVal2 = Number($aArray[DllStructGetData($tIndex, 1, $mi + 1)][$iCol])
EndIf
$r = $nVal1 < $nVal2 ? -1 : $nVal1 > $nVal2 ? 1 : 0
Else
If $iDims = 1 Then
$r = DllCall($hDllComp, 'int', 'StrCmpLogicalW', 'wstr', $aArray[$i], 'wstr', $aArray[DllStructGetData($tIndex, 1, $mi + 1)])[0]
Else
$r = DllCall($hDllComp, 'int', 'StrCmpLogicalW', 'wstr', $aArray[$i][$iCol], 'wstr', $aArray[DllStructGetData($tIndex, 1, $mi + 1)][$iCol])[0]
EndIf
EndIf
Switch $r
Case -1
$hi = $mi - 1
Case 1
$lo = $mi + 1
Case 0
ExitLoop
EndSwitch
Until $lo > $hi
DllCall($hDll, "none", "RtlMoveMemory", "struct*", $pIndex + ($mi + 1) * 4, "struct*", $pIndex + $mi * 4, "ulong_ptr", ($i - $mi) * 4)
DllStructSetData($tIndex, 1, $i, $mi + 1 + ($lo = $mi + 1))
Next
Return $tIndex
EndFunc
Func __ArrayDisplay_CreateSubArray()
Local $nRows = $_g_ArrayDisplay_iItem_End - $_g_ArrayDisplay_iItem_Start + 1
Local $nCols = $_g_ArrayDisplay_iSubItem_End - $_g_ArrayDisplay_iSubItem_Start + 1
Local $iRow = -1, $iCol, $iTemp, $aTemp
If $_g_ArrayDisplay_iTranspose Then
Dim $aTemp[$nCols][$nRows]
For $i = $_g_ArrayDisplay_iItem_Start To $_g_ArrayDisplay_iItem_End
$iRow += 1
$iCol = -1
For $j = $_g_ArrayDisplay_iSubItem_Start To $_g_ArrayDisplay_iSubItem_End
$iCol += 1
$aTemp[$iCol][$iRow] = $_g_ArrayDisplay_aArray[$i][$j]
Next
Next
$iTemp = $_g_ArrayDisplay_iItem_Start
$_g_ArrayDisplay_iItem_Start = $_g_ArrayDisplay_iSubItem_Start
$_g_ArrayDisplay_iSubItem_Start = $iTemp
$iTemp = $_g_ArrayDisplay_iItem_End
$_g_ArrayDisplay_iItem_End = $_g_ArrayDisplay_iSubItem_End
$_g_ArrayDisplay_iSubItem_End = $iTemp
$_g_ArrayDisplay_nRows = $nCols
$_g_ArrayDisplay_nCols = $nRows
Else
If $_g_ArrayDisplay_iDims = 1 Then
Dim $aTemp[$nRows]
For $i = $_g_ArrayDisplay_iItem_Start To $_g_ArrayDisplay_iItem_End
$iRow += 1
$aTemp[$iRow] = $_g_ArrayDisplay_aArray[$i]
Next
Else
Dim $aTemp[$nRows][$nCols]
For $i = $_g_ArrayDisplay_iItem_Start To $_g_ArrayDisplay_iItem_End
$iRow += 1
$iCol = -1
For $j = $_g_ArrayDisplay_iSubItem_Start To $_g_ArrayDisplay_iSubItem_End
$iCol += 1
$aTemp[$iRow][$iCol] = $_g_ArrayDisplay_aArray[$i][$j]
Next
Next
$_g_ArrayDisplay_nCols = $nCols
EndIf
$_g_ArrayDisplay_nRows = $nRows
EndIf
Return $aTemp
EndFunc
Func __ArrayDisplay_HeaderSetItemFormat($hWnd, $iIndex, $iFormat)
Local Static $tHDItem = DllStructCreate("uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State")
DllStructSetData($tHDItem, "Mask", 0x00000004)
DllStructSetData($tHDItem, "Fmt", $iFormat)
Local $aResult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", 0x120C, "wparam", $iIndex, "struct*", $tHDItem)
Return $aResult[0] <> 0
EndFunc
Func __ArrayDisplay_GetItemText($idListView, $iIndex, $iSubItem = 0)
Local $tBuffer = DllStructCreate("wchar Text[4096]")
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($_ARRAYCONSTANT_tagLVITEM)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "TextMax", 4096)
DllStructSetData($tItem, "Text", $pBuffer)
If IsHWnd($idListView) Then
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $idListView, "uint", 0x1073, "wparam", $iIndex, "struct*", $tItem)
Else
Local $pItem = DllStructGetPtr($tItem)
GUICtrlSendMsg($idListView, 0x1073, $iIndex, $pItem)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func __ArrayDisplay_GetItemTextStringSelected($idListView, $iItem, $iFirstCol)
Local $sRow = "", $sSeparatorChar = Opt('GUIDataSeparatorChar')
Local $iSelected = $iItem
Local $hHeader = HWnd(GUICtrlSendMsg($idListView, 0x101F, 0, 0))
Local $nCol = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hHeader, "uint", 0x1200, "wparam", 0, "lparam", 0)[0]
For $x = $iFirstCol To $nCol - 1
$sRow &= __ArrayDisplay_GetItemText($idListView, $iSelected, $x) & $sSeparatorChar
Next
Return StringTrimRight($sRow, 1)
EndFunc
Func __ArrayDisplay_JustifyColumn($idListView, $iIndex, $iAlign = -1)
Local $tColumn = DllStructCreate("uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal")
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
DllStructSetData($tColumn, "Mask", 0x01)
DllStructSetData($tColumn, "Fmt", $iAlign)
Local $pColumn = DllStructGetPtr($tColumn)
Local $iRet = GUICtrlSendMsg($idListView, 0x1060, $iIndex, $pColumn)
Return $iRet <> 0
EndFunc
Global Enum $ARRAYFILL_FORCE_DEFAULT, $ARRAYFILL_FORCE_SINGLEITEM, $ARRAYFILL_FORCE_INT, $ARRAYFILL_FORCE_NUMBER,  $ARRAYFILL_FORCE_PTR, $ARRAYFILL_FORCE_HWND, $ARRAYFILL_FORCE_STRING, $ARRAYFILL_FORCE_BOOLEAN
Global Enum $ARRAYUNIQUE_NOCOUNT, $ARRAYUNIQUE_COUNT
Global Enum $ARRAYUNIQUE_AUTO, $ARRAYUNIQUE_FORCE32, $ARRAYUNIQUE_FORCE64, $ARRAYUNIQUE_MATCH, $ARRAYUNIQUE_DISTINCT
Func _ArrayAdd(ByRef $aArray, $vValue, $iStart = 0, $sDelim_Item = "|", $sDelim_Row = @CRLF, $iForce = $ARRAYFILL_FORCE_DEFAULT)
If $iStart = Default Then $iStart = 0
If $sDelim_Item = Default Then $sDelim_Item = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iForce = Default Then $iForce = $ARRAYFILL_FORCE_DEFAULT
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
Local $hDataType = 0
Switch $iForce
Case $ARRAYFILL_FORCE_INT
$hDataType = Int
Case $ARRAYFILL_FORCE_NUMBER
$hDataType = Number
Case $ARRAYFILL_FORCE_PTR
$hDataType = Ptr
Case $ARRAYFILL_FORCE_HWND
$hDataType = Hwnd
Case $ARRAYFILL_FORCE_STRING
$hDataType = String
Case $ARRAYFILL_FORCE_BOOLEAN
$hDataType = "Boolean"
EndSwitch
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iForce = $ARRAYFILL_FORCE_SINGLEITEM Then
ReDim $aArray[$iDim_1 + 1]
$aArray[$iDim_1] = $vValue
Return $iDim_1
EndIf
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(5, 0, -1)
$hDataType = 0
Else
Local $aTmp = StringSplit($vValue, $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
If UBound($aTmp, $UBOUND_ROWS) = 1 Then
$aTmp[0] = $vValue
EndIf
$vValue = $aTmp
EndIf
Local $iAdd = UBound($vValue, $UBOUND_ROWS)
ReDim $aArray[$iDim_1 + $iAdd]
For $i = 0 To $iAdd - 1
If String($hDataType) = "Boolean" Then
Switch $vValue[$i]
Case "True", "1"
$aArray[$iDim_1 + $i] = True
Case "False", "0", ""
$aArray[$iDim_1 + $i] = False
EndSwitch
ElseIf IsFunc($hDataType) Then
$aArray[$iDim_1 + $i] = $hDataType($vValue[$i])
Else
$aArray[$iDim_1 + $i] = $vValue[$i]
EndIf
Next
Return $iDim_1 + $iAdd - 1
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iStart < 0 Or $iStart > $iDim_2 - 1 Then Return SetError(4, 0, -1)
Local $iValDim_1, $iValDim_2 = 0, $iColCount
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(5, 0, -1)
$iValDim_1 = UBound($vValue, $UBOUND_ROWS)
$iValDim_2 = UBound($vValue, $UBOUND_COLUMNS)
$hDataType = 0
Else
Local $aSplit_1 = StringSplit($vValue, $sDelim_Row, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iValDim_1 = UBound($aSplit_1, $UBOUND_ROWS)
Local $aTmp[$iValDim_1][0], $aSplit_2
For $i = 0 To $iValDim_1 - 1
$aSplit_2 = StringSplit($aSplit_1[$i], $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iColCount = UBound($aSplit_2)
If $iColCount > $iValDim_2 Then
$iValDim_2 = $iColCount
ReDim $aTmp[$iValDim_1][$iValDim_2]
EndIf
For $j = 0 To $iColCount - 1
$aTmp[$i][$j] = $aSplit_2[$j]
Next
Next
$vValue = $aTmp
EndIf
If UBound($vValue, $UBOUND_COLUMNS) + $iStart > UBound($aArray, $UBOUND_COLUMNS) Then Return SetError(3, 0, -1)
ReDim $aArray[$iDim_1 + $iValDim_1][$iDim_2]
For $iWriteTo_Index = 0 To $iValDim_1 - 1
For $j = 0 To $iDim_2 - 1
If $j < $iStart Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = ""
ElseIf $j - $iStart > $iValDim_2 - 1 Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = ""
Else
If String($hDataType) = "Boolean" Then
Switch $vValue[$iWriteTo_Index][$j - $iStart]
Case "True", "1"
$aArray[$iWriteTo_Index + $iDim_1][$j] = True
Case "False", "0", ""
$aArray[$iWriteTo_Index + $iDim_1][$j] = False
EndSwitch
ElseIf IsFunc($hDataType) Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = $hDataType($vValue[$iWriteTo_Index][$j - $iStart])
Else
$aArray[$iWriteTo_Index + $iDim_1][$j] = $vValue[$iWriteTo_Index][$j - $iStart]
EndIf
EndIf
Next
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS) - 1
EndFunc
Func _ArrayBinarySearch(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iColumn = 0)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iColumn = Default Then $iColumn = 0
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If $iDim_1 = 0 Then Return SetError(6, 0, -1)
If $iEnd < 1 Or $iEnd > $iDim_1 - 1 Then $iEnd = $iDim_1 - 1
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Local $iMid = Int(($iEnd + $iStart) / 2)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $aArray[$iStart] > $vValue Or $aArray[$iEnd] < $vValue Then Return SetError(2, 0, -1)
While $iStart <= $iMid And $vValue <> $aArray[$iMid]
If $vValue < $aArray[$iMid] Then
$iEnd = $iMid - 1
Else
$iStart = $iMid + 1
EndIf
$iMid = Int(($iEnd + $iStart) / 2)
WEnd
If $iStart > $iEnd Then Return SetError(3, 0, -1)
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iColumn < 0 Or $iColumn > $iDim_2 Then Return SetError(7, 0, -1)
If $aArray[$iStart][$iColumn] > $vValue Or $aArray[$iEnd][$iColumn] < $vValue Then Return SetError(2, 0, -1)
While $iStart <= $iMid And $vValue <> $aArray[$iMid][$iColumn]
If $vValue < $aArray[$iMid][$iColumn] Then
$iEnd = $iMid - 1
Else
$iStart = $iMid + 1
EndIf
$iMid = Int(($iEnd + $iStart) / 2)
WEnd
If $iStart > $iEnd Then Return SetError(3, 0, -1)
Case Else
Return SetError(5, 0, -1)
EndSwitch
Return $iMid
EndFunc
Func _ArrayColDelete(ByRef $aArray, $iColumn, $bConvert = False)
If $bConvert = Default Then $bConvert = False
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(2, 0, -1)
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
Switch $iDim_2
Case 2
If $iColumn < 0 Or $iColumn > 1 Then Return SetError(3, 0, -1)
If $bConvert Then
Local $aTempArray[$iDim_1]
For $i = 0 To $iDim_1 - 1
$aTempArray[$i] = $aArray[$i][(Not $iColumn)]
Next
$aArray = $aTempArray
Else
ContinueCase
EndIf
Case Else
If $iColumn < 0 Or $iColumn > $iDim_2 - 1 Then Return SetError(3, 0, -1)
For $i = 0 To $iDim_1 - 1
For $j = $iColumn To $iDim_2 - 2
$aArray[$i][$j] = $aArray[$i][$j + 1]
Next
Next
ReDim $aArray[$iDim_1][$iDim_2 - 1]
EndSwitch
Return UBound($aArray, $UBOUND_COLUMNS)
EndFunc
Func _ArrayColInsert(ByRef $aArray, $iColumn)
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
Local $aTempArray[$iDim_1][2]
Switch $iColumn
Case 0, 1
For $i = 0 To $iDim_1 - 1
$aTempArray[$i][(Not $iColumn)] = $aArray[$i]
Next
Case Else
Return SetError(3, 0, -1)
EndSwitch
$aArray = $aTempArray
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iColumn < 0 Or $iColumn > $iDim_2 Then Return SetError(3, 0, -1)
ReDim $aArray[$iDim_1][$iDim_2 + 1]
For $i = 0 To $iDim_1 - 1
For $j = $iDim_2 To $iColumn + 1 Step -1
$aArray[$i][$j] = $aArray[$i][$j - 1]
Next
$aArray[$i][$iColumn] = ""
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_COLUMNS)
EndFunc
Func _ArrayCombinations(Const ByRef $aArray, $iSet, $sDelimiter = "")
If $sDelimiter = Default Then $sDelimiter = ""
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(2, 0, 0)
Local $iN = UBound($aArray)
Local $iR = $iSet
Local $aIdx[$iR]
For $i = 0 To $iR - 1
$aIdx[$i] = $i
Next
Local $iTotal = __Array_Combinations($iN, $iR)
Local $iLeft = $iTotal
Local $aResult[$iTotal + 1]
$aResult[0] = $iTotal
Local $iCount = 1
While $iLeft > 0
__Array_GetNext($iN, $iR, $iLeft, $iTotal, $aIdx)
For $i = 0 To $iSet - 1
$aResult[$iCount] &= $aArray[$aIdx[$i]] & $sDelimiter
Next
If $sDelimiter <> "" Then $aResult[$iCount] = StringTrimRight($aResult[$iCount], 1)
$iCount += 1
WEnd
Return $aResult
EndFunc
Func _ArrayConcatenate(ByRef $aArrayTarget, Const ByRef $aArraySource, $iStart = 0)
If $iStart = Default Then $iStart = 0
If Not IsArray($aArrayTarget) Then Return SetError(1, 0, -1)
If Not IsArray($aArraySource) Then Return SetError(2, 0, -1)
Local $iDim_Total_Tgt = UBound($aArrayTarget, $UBOUND_DIMENSIONS)
Local $iDim_Total_Src = UBound($aArraySource, $UBOUND_DIMENSIONS)
Local $iDim_1_Tgt = UBound($aArrayTarget, $UBOUND_ROWS)
Local $iDim_1_Src = UBound($aArraySource, $UBOUND_ROWS)
If $iStart < 0 Or $iStart > $iDim_1_Src - 1 Then Return SetError(6, 0, -1)
Switch $iDim_Total_Tgt
Case 1
If $iDim_Total_Src <> 1 Then Return SetError(4, 0, -1)
ReDim $aArrayTarget[$iDim_1_Tgt + $iDim_1_Src - $iStart]
For $i = $iStart To $iDim_1_Src - 1
$aArrayTarget[$iDim_1_Tgt + $i - $iStart] = $aArraySource[$i]
Next
Case 2
If $iDim_Total_Src <> 2 Then Return SetError(4, 0, -1)
Local $iDim_2_Tgt = UBound($aArrayTarget, $UBOUND_COLUMNS)
If UBound($aArraySource, $UBOUND_COLUMNS) <> $iDim_2_Tgt Then Return SetError(5, 0, -1)
ReDim $aArrayTarget[$iDim_1_Tgt + $iDim_1_Src - $iStart][$iDim_2_Tgt]
For $i = $iStart To $iDim_1_Src - 1
For $j = 0 To $iDim_2_Tgt - 1
$aArrayTarget[$iDim_1_Tgt + $i - $iStart][$j] = $aArraySource[$i][$j]
Next
Next
Case Else
Return SetError(3, 0, -1)
EndSwitch
Return UBound($aArrayTarget, $UBOUND_ROWS)
EndFunc
Func _ArrayDelete(ByRef $aArray, $vRange)
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If IsArray($vRange) Then
If UBound($vRange, $UBOUND_DIMENSIONS) <> 1 Or UBound($vRange, $UBOUND_ROWS) < 2 Then Return SetError(4, 0, -1)
Else
Local $iNumber, $aSplit_1, $aSplit_2
$vRange = StringStripWS($vRange, 8)
$aSplit_1 = StringSplit($vRange, ";")
$vRange = ""
For $i = 1 To $aSplit_1[0]
If Not StringRegExp($aSplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
$aSplit_2 = StringSplit($aSplit_1[$i], "-")
Switch $aSplit_2[0]
Case 1
$vRange &= $aSplit_2[1] & ";"
Case 2
If Number($aSplit_2[2]) >= Number($aSplit_2[1]) Then
$iNumber = $aSplit_2[1] - 1
Do
$iNumber += 1
$vRange &= $iNumber & ";"
Until $iNumber = $aSplit_2[2]
EndIf
EndSwitch
Next
$vRange = StringSplit(StringTrimRight($vRange, 1), ";")
EndIf
For $i = 1 To $vRange[0]
$vRange[$i] = Number($vRange[$i])
Next
If $vRange[1] < 0 Or $vRange[$vRange[0]] > $iDim_1 Then Return SetError(5, 0, -1)
Local $iCopyTo_Index = 0
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = 1 To $vRange[0]
$aArray[$vRange[$i]] = ChrW(0xFAB1)
Next
For $iReadFrom_Index = 0 To $iDim_1
If $aArray[$iReadFrom_Index] == ChrW(0xFAB1) Then
ContinueLoop
Else
If $iReadFrom_Index <> $iCopyTo_Index Then
$aArray[$iCopyTo_Index] = $aArray[$iReadFrom_Index]
EndIf
$iCopyTo_Index += 1
EndIf
Next
ReDim $aArray[$iDim_1 - $vRange[0] + 1]
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
For $i = 1 To $vRange[0]
$aArray[$vRange[$i]][0] = ChrW(0xFAB1)
Next
For $iReadFrom_Index = 0 To $iDim_1
If $aArray[$iReadFrom_Index][0] == ChrW(0xFAB1) Then
ContinueLoop
Else
If $iReadFrom_Index <> $iCopyTo_Index Then
For $j = 0 To $iDim_2
$aArray[$iCopyTo_Index][$j] = $aArray[$iReadFrom_Index][$j]
Next
EndIf
$iCopyTo_Index += 1
EndIf
Next
ReDim $aArray[$iDim_1 - $vRange[0] + 1][$iDim_2 + 1]
Case Else
Return SetError(2, 0, False)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS)
EndFunc
Func _ArrayDisplay(Const ByRef $aArray, $sTitle = Default, $sArrayRange = Default, $iFlags = Default, $vUser_Separator = Default, $sHeader = Default, $iMax_ColWidth = Default)
#forceref $vUser_Separator
Local $iRet = __ArrayDisplay_Share($aArray, $sTitle, $sArrayRange, $iFlags, Default, $sHeader, $iMax_ColWidth, 0, False)
Return SetError(@error, @extended, $iRet)
EndFunc
Func _ArrayExtract(Const ByRef $aArray, $iStart_Row = -1, $iEnd_Row = -1, $iStart_Col = -1, $iEnd_Col = -1)
If $iStart_Row = Default Then $iStart_Row = -1
If $iEnd_Row = Default Then $iEnd_Row = -1
If $iStart_Col = Default Then $iStart_Col = -1
If $iEnd_Col = Default Then $iEnd_Col = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iEnd_Row = -1 Then $iEnd_Row = $iDim_1
If $iStart_Row = -1 Then $iStart_Row = 0
If $iStart_Row < -1 Or $iEnd_Row < -1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iDim_1 Or $iEnd_Row > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
Local $aRetArray[$iEnd_Row - $iStart_Row + 1]
For $i = 0 To $iEnd_Row - $iStart_Row
$aRetArray[$i] = $aArray[$i + $iStart_Row]
Next
Return $aRetArray
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iEnd_Col = -1 Then $iEnd_Col = $iDim_2
If $iStart_Col = -1 Then $iStart_Col = 0
If $iStart_Col < -1 Or $iEnd_Col < -1 Then Return SetError(5, 0, -1)
If $iStart_Col > $iDim_2 Or $iEnd_Col > $iDim_2 Then Return SetError(5, 0, -1)
If $iStart_Col > $iEnd_Col Then Return SetError(6, 0, -1)
If $iStart_Col = $iEnd_Col Then
Local $aRetArray[$iEnd_Row - $iStart_Row + 1]
Else
Local $aRetArray[$iEnd_Row - $iStart_Row + 1][$iEnd_Col - $iStart_Col + 1]
EndIf
For $i = 0 To $iEnd_Row - $iStart_Row
For $j = 0 To $iEnd_Col - $iStart_Col
If $iStart_Col = $iEnd_Col Then
$aRetArray[$i] = $aArray[$i + $iStart_Row][$j + $iStart_Col]
Else
$aRetArray[$i][$j] = $aArray[$i + $iStart_Row][$j + $iStart_Col]
EndIf
Next
Next
Return $aRetArray
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func _ArrayFindAll(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iCase = 0, $iCompare = 0, $iSubItem = 0, $bRow = False)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iCase = Default Then $iCase = 0
If $iCompare = Default Then $iCompare = 0
If $iSubItem = Default Then $iSubItem = 0
If $bRow = Default Then $bRow = False
$iStart = _ArraySearch($aArray, $vValue, $iStart, $iEnd, $iCase, $iCompare, 1, $iSubItem, $bRow)
If @error Then Return SetError(@error, 0, -1)
Local $iIndex = 0, $avResult[UBound($aArray, ($bRow ? $UBOUND_COLUMNS : $UBOUND_ROWS))]
Do
$avResult[$iIndex] = $iStart
$iIndex += 1
$iStart = _ArraySearch($aArray, $vValue, $iStart + 1, $iEnd, $iCase, $iCompare, 1, $iSubItem, $bRow)
Until @error
ReDim $avResult[$iIndex]
Return $avResult
EndFunc
Func _ArrayFromString($sArrayStr, $sDelim_Col = "|", $sDelim_Row = @CRLF, $bForce2D = False, $iStripWS = $STR_STRIPLEADING + $STR_STRIPTRAILING)
If $sDelim_Col = Default Then $sDelim_Col = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $bForce2D = Default Then $bForce2D = False
If $iStripWS = Default Then $iStripWS = $STR_STRIPLEADING + $STR_STRIPTRAILING
Local $aRow, $aCol = StringSplit($sArrayStr, $sDelim_Row, $STR_ENTIRESPLIT + $STR_NOCOUNT)
$aRow = StringSplit($aCol[0], $sDelim_Col, $STR_ENTIRESPLIT + $STR_NOCOUNT)
If UBound($aCol) = 1 And Not $bForce2D Then
For $m = 0 To UBound($aRow) - 1
$aRow[$m] = ($iStripWS ? StringStripWS($aRow[$m], $iStripWS) : $aRow[$m])
Next
Return $aRow
EndIf
Local $aRet[UBound($aCol)][UBound($aRow)]
For $n = 0 To UBound($aCol) - 1
$aRow = StringSplit($aCol[$n], $sDelim_Col, $STR_ENTIRESPLIT + $STR_NOCOUNT)
If UBound($aRow) > UBound($aRet, 2) Then Return SetError(1)
For $m = 0 To UBound($aRow) - 1
$aRet[$n][$m] = ($iStripWS ? StringStripWS($aRow[$m], $iStripWS) : $aRow[$m])
Next
Next
Return $aRet
EndFunc
Func _ArrayInsert(ByRef $aArray, $vRange, $vValue = "", $iStart = 0, $sDelim_Item = "|", $sDelim_Row = @CRLF, $iForce = $ARRAYFILL_FORCE_DEFAULT)
If $vValue = Default Then $vValue = ""
If $iStart = Default Then $iStart = 0
If $sDelim_Item = Default Then $sDelim_Item = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iForce = Default Then $iForce = $ARRAYFILL_FORCE_DEFAULT
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
Local $hDataType = 0
Switch $iForce
Case $ARRAYFILL_FORCE_INT
$hDataType = Int
Case $ARRAYFILL_FORCE_NUMBER
$hDataType = Number
Case $ARRAYFILL_FORCE_PTR
$hDataType = Ptr
Case $ARRAYFILL_FORCE_HWND
$hDataType = Hwnd
Case $ARRAYFILL_FORCE_STRING
$hDataType = String
EndSwitch
Local $aSplit_1, $aSplit_2
If IsArray($vRange) Then
If UBound($vRange, $UBOUND_DIMENSIONS) <> 1 Or UBound($vRange, $UBOUND_ROWS) < 2 Then Return SetError(4, 0, -1)
Else
Local $iNumber
$vRange = StringStripWS($vRange, 8)
$aSplit_1 = StringSplit($vRange, ";")
$vRange = ""
For $i = 1 To $aSplit_1[0]
If Not StringRegExp($aSplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
$aSplit_2 = StringSplit($aSplit_1[$i], "-")
Switch $aSplit_2[0]
Case 1
$vRange &= $aSplit_2[1] & ";"
Case 2
If Number($aSplit_2[2]) >= Number($aSplit_2[1]) Then
$iNumber = $aSplit_2[1] - 1
Do
$iNumber += 1
$vRange &= $iNumber & ";"
Until $iNumber = $aSplit_2[2]
EndIf
EndSwitch
Next
$vRange = StringSplit(StringTrimRight($vRange, 1), ";")
EndIf
For $i = 1 To $vRange[0]
$vRange[$i] = Number($vRange[$i])
Next
If $vRange[1] < 0 Or $vRange[$vRange[0]] > $iDim_1 Then Return SetError(5, 0, -1)
For $i = 2 To $vRange[0]
If $vRange[$i] < $vRange[$i - 1] Then Return SetError(3, 0, -1)
Next
Local $iCopyTo_Index = $iDim_1 + $vRange[0]
Local $iInsertPoint_Index = $vRange[0]
Local $iInsert_Index = $vRange[$iInsertPoint_Index]
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iForce = $ARRAYFILL_FORCE_SINGLEITEM Then
ReDim $aArray[$iDim_1 + $vRange[0] + 1]
For $iReadFromIndex = $iDim_1 To 0 Step -1
$aArray[$iCopyTo_Index] = $aArray[$iReadFromIndex]
$iCopyTo_Index -= 1
$iInsert_Index = $vRange[$iInsertPoint_Index]
While $iReadFromIndex = $iInsert_Index
$aArray[$iCopyTo_Index] = $vValue
$iCopyTo_Index -= 1
$iInsertPoint_Index -= 1
If $iInsertPoint_Index < 1 Then ExitLoop 2
$iInsert_Index = $vRange[$iInsertPoint_Index]
WEnd
Next
Return $iDim_1 + $vRange[0] + 1
EndIf
ReDim $aArray[$iDim_1 + $vRange[0] + 1]
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(5, 0, -1)
$hDataType = 0
Else
Local $aTmp = StringSplit($vValue, $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
If UBound($aTmp, $UBOUND_ROWS) = 1 Then
$aTmp[0] = $vValue
$hDataType = 0
EndIf
$vValue = $aTmp
EndIf
For $iReadFromIndex = $iDim_1 To 0 Step -1
$aArray[$iCopyTo_Index] = $aArray[$iReadFromIndex]
$iCopyTo_Index -= 1
$iInsert_Index = $vRange[$iInsertPoint_Index]
While $iReadFromIndex = $iInsert_Index
If $iInsertPoint_Index <= UBound($vValue, $UBOUND_ROWS) Then
If IsFunc($hDataType) Then
$aArray[$iCopyTo_Index] = $hDataType($vValue[$iInsertPoint_Index - 1])
Else
$aArray[$iCopyTo_Index] = $vValue[$iInsertPoint_Index - 1]
EndIf
Else
$aArray[$iCopyTo_Index] = ""
EndIf
$iCopyTo_Index -= 1
$iInsertPoint_Index -= 1
If $iInsertPoint_Index = 0 Then ExitLoop 2
$iInsert_Index = $vRange[$iInsertPoint_Index]
WEnd
Next
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iStart < 0 Or $iStart > $iDim_2 - 1 Then Return SetError(6, 0, -1)
Local $iValDim_1, $iValDim_2
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(7, 0, -1)
$iValDim_1 = UBound($vValue, $UBOUND_ROWS)
$iValDim_2 = UBound($vValue, $UBOUND_COLUMNS)
$hDataType = 0
Else
$aSplit_1 = StringSplit($vValue, $sDelim_Row, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iValDim_1 = UBound($aSplit_1, $UBOUND_ROWS)
StringReplace($aSplit_1[0], $sDelim_Item, "")
$iValDim_2 = @extended + 1
Local $aTmp[$iValDim_1][$iValDim_2]
For $i = 0 To $iValDim_1 - 1
$aSplit_2 = StringSplit($aSplit_1[$i], $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
For $j = 0 To $iValDim_2 - 1
$aTmp[$i][$j] = $aSplit_2[$j]
Next
Next
$vValue = $aTmp
EndIf
If UBound($vValue, $UBOUND_COLUMNS) + $iStart > UBound($aArray, $UBOUND_COLUMNS) Then Return SetError(8, 0, -1)
ReDim $aArray[$iDim_1 + $vRange[0] + 1][$iDim_2]
For $iReadFromIndex = $iDim_1 To 0 Step -1
For $j = 0 To $iDim_2 - 1
$aArray[$iCopyTo_Index][$j] = $aArray[$iReadFromIndex][$j]
Next
$iCopyTo_Index -= 1
$iInsert_Index = $vRange[$iInsertPoint_Index]
While $iReadFromIndex = $iInsert_Index
For $j = 0 To $iDim_2 - 1
If $j < $iStart Then
$aArray[$iCopyTo_Index][$j] = ""
ElseIf $j - $iStart > $iValDim_2 - 1 Then
$aArray[$iCopyTo_Index][$j] = ""
Else
If $iInsertPoint_Index - 1 < $iValDim_1 Then
If IsFunc($hDataType) Then
$aArray[$iCopyTo_Index][$j] = $hDataType($vValue[$iInsertPoint_Index - 1][$j - $iStart])
Else
$aArray[$iCopyTo_Index][$j] = $vValue[$iInsertPoint_Index - 1][$j - $iStart]
EndIf
Else
$aArray[$iCopyTo_Index][$j] = ""
EndIf
EndIf
Next
$iCopyTo_Index -= 1
$iInsertPoint_Index -= 1
If $iInsertPoint_Index = 0 Then ExitLoop 2
$iInsert_Index = $vRange[$iInsertPoint_Index]
WEnd
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS)
EndFunc
Func _ArrayMax(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
Local $iResult = _ArrayMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem)
If @error Then Return SetError(@error, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then
Return $aArray[$iResult]
Else
Return $aArray[$iResult][$iSubItem]
EndIf
EndFunc
Func _ArrayMaxIndex(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If $iSubItem = Default Then $iSubItem = 0
Local $iRet = __Array_MinMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, __Array_GreaterThan)
Return SetError(@error, 0, $iRet)
EndFunc
Func _ArrayMin(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
Local $iResult = _ArrayMinIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem)
If @error Then Return SetError(@error, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then
Return $aArray[$iResult]
Else
Return $aArray[$iResult][$iSubItem]
EndIf
EndFunc
Func _ArrayMinIndex(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If $iSubItem = Default Then $iSubItem = 0
Local $iRet = __Array_MinMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, __Array_LessThan)
Return SetError(@error, 0, $iRet)
EndFunc
Func _ArrayPermute(ByRef $aArray, $sDelimiter = "")
If $sDelimiter = Default Then $sDelimiter = ""
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(2, 0, 0)
Local $iSize = UBound($aArray), $iFactorial = 1, $aIdx[$iSize], $aResult[1], $iCount = 1
If UBound($aArray) Then
For $i = 0 To $iSize - 1
$aIdx[$i] = $i
Next
For $i = $iSize To 1 Step -1
$iFactorial *= $i
Next
ReDim $aResult[$iFactorial + 1]
$aResult[0] = $iFactorial
__Array_ExeterInternal($aArray, 0, $iSize, $sDelimiter, $aIdx, $aResult, $iCount)
Else
$aResult[0] = 0
EndIf
Return $aResult
EndFunc
Func _ArrayPop(ByRef $aArray)
If (Not IsArray($aArray)) Then Return SetError(1, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(2, 0, "")
Local $iUBound = UBound($aArray) - 1
If $iUBound = -1 Then Return SetError(3, 0, "")
Local $sLastVal = $aArray[$iUBound]
If $iUBound > -1 Then
ReDim $aArray[$iUBound]
EndIf
Return $sLastVal
EndFunc
Func _ArrayPush(ByRef $aArray, $vValue, $iDirection = 0)
If $iDirection = Default Then $iDirection = 0
If (Not IsArray($aArray)) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(3, 0, 0)
Local $iUBound = UBound($aArray) - 1
If IsArray($vValue) Then
Local $iUBoundS = UBound($vValue)
If ($iUBoundS - 1) > $iUBound Then Return SetError(2, 0, 0)
If $iDirection Then
For $i = $iUBound To $iUBoundS Step -1
$aArray[$i] = $aArray[$i - $iUBoundS]
Next
For $i = 0 To $iUBoundS - 1
$aArray[$i] = $vValue[$i]
Next
Else
For $i = 0 To $iUBound - $iUBoundS
$aArray[$i] = $aArray[$i + $iUBoundS]
Next
For $i = 0 To $iUBoundS - 1
$aArray[$i + $iUBound - $iUBoundS + 1] = $vValue[$i]
Next
EndIf
Else
If $iUBound > -1 Then
If $iDirection Then
For $i = $iUBound To 1 Step -1
$aArray[$i] = $aArray[$i - 1]
Next
$aArray[0] = $vValue
Else
For $i = 0 To $iUBound - 1
$aArray[$i] = $aArray[$i + 1]
Next
$aArray[$iUBound] = $vValue
EndIf
EndIf
EndIf
Return 1
EndFunc
Func _ArrayReverse(ByRef $aArray, $iStart = 0, $iEnd = 0)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(3, 0, 0)
If Not UBound($aArray) Then Return SetError(4, 0, 0)
Local $vTmp, $iUBound = UBound($aArray) - 1
If $iEnd < 1 Or $iEnd > $iUBound Then $iEnd = $iUBound
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(2, 0, 0)
For $i = $iStart To Int(($iStart + $iEnd - 1) / 2)
$vTmp = $aArray[$i]
$aArray[$i] = $aArray[$iEnd]
$aArray[$iEnd] = $vTmp
$iEnd -= 1
Next
Return 1
EndFunc
Func _ArraySearch(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iCase = 0, $iCompare = 0, $iForward = 1, $iSubItem = -1, $bRow = False)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iCase = Default Then $iCase = 0
If $iCompare = Default Then $iCompare = 0
If $iForward = Default Then $iForward = 1
If $iSubItem = Default Then $iSubItem = -1
If $bRow = Default Then $bRow = False
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray) - 1
If $iDim_1 = -1 Then Return SetError(3, 0, -1)
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
Local $bCompType = False
If $iCompare = 2 Then
$iCompare = 0
$bCompType = True
EndIf
If $bRow Then
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then Return SetError(5, 0, -1)
If $iEnd < 1 Or $iEnd > $iDim_2 Then $iEnd = $iDim_2
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Else
If $iEnd < 1 Or $iEnd > $iDim_1 Then $iEnd = $iDim_1
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
EndIf
Local $iStep = 1
If Not $iForward Then
Local $iTmp = $iStart
$iStart = $iEnd
$iEnd = $iTmp
$iStep = -1
EndIf
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If Not $iCompare Then
If Not $iCase Then
For $i = $iStart To $iEnd Step $iStep
If $bCompType And VarGetType($aArray[$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i] = $vValue Then Return $i
Next
Else
For $i = $iStart To $iEnd Step $iStep
If $bCompType And VarGetType($aArray[$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i] == $vValue Then Return $i
Next
EndIf
Else
For $i = $iStart To $iEnd Step $iStep
If $iCompare = 3 Then
If StringRegExp($aArray[$i], $vValue) Then Return $i
Else
If StringInStr($aArray[$i], $vValue, $iCase) > 0 Then Return $i
EndIf
Next
EndIf
Case 2
Local $iDim_Sub
If $bRow Then
$iDim_Sub = $iDim_1
If $iSubItem > $iDim_Sub Then $iSubItem = $iDim_Sub
If $iSubItem < 0 Then
$iSubItem = 0
Else
$iDim_Sub = $iSubItem
EndIf
Else
$iDim_Sub = $iDim_2
If $iSubItem > $iDim_Sub Then $iSubItem = $iDim_Sub
If $iSubItem < 0 Then
$iSubItem = 0
Else
$iDim_Sub = $iSubItem
EndIf
EndIf
For $j = $iSubItem To $iDim_Sub
If Not $iCompare Then
If Not $iCase Then
For $i = $iStart To $iEnd Step $iStep
If $bRow Then
If $bCompType And VarGetType($aArray[$j][$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$j][$i] = $vValue Then Return $i
Else
If $bCompType And VarGetType($aArray[$i][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i][$j] = $vValue Then Return $i
EndIf
Next
Else
For $i = $iStart To $iEnd Step $iStep
If $bRow Then
If $bCompType And VarGetType($aArray[$j][$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$j][$i] == $vValue Then Return $i
Else
If $bCompType And VarGetType($aArray[$i][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i][$j] == $vValue Then Return $i
EndIf
Next
EndIf
Else
For $i = $iStart To $iEnd Step $iStep
If $iCompare = 3 Then
If $bRow Then
If StringRegExp($aArray[$j][$i], $vValue) Then Return $i
Else
If StringRegExp($aArray[$i][$j], $vValue) Then Return $i
EndIf
Else
If $bRow Then
If StringInStr($aArray[$j][$i], $vValue, $iCase) > 0 Then Return $i
Else
If StringInStr($aArray[$i][$j], $vValue, $iCase) > 0 Then Return $i
EndIf
EndIf
Next
EndIf
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return SetError(6, 0, -1)
EndFunc
Func _ArrayShuffle(ByRef $aArray, $iStart_Row = 0, $iEnd_Row = 0, $iCol = -1)
If $iStart_Row = Default Then $iStart_Row = 0
If $iEnd_Row = Default Then $iEnd_Row = 0
If $iCol = Default Then $iCol = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If $iEnd_Row = 0 Then $iEnd_Row = $iDim_1 - 1
If $iStart_Row < 0 Or $iStart_Row > $iDim_1 - 1 Then Return SetError(3, 0, -1)
If $iEnd_Row < 1 Or $iEnd_Row > $iDim_1 - 1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Local $vTmp, $iRand
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = $iEnd_Row To $iStart_Row + 1 Step -1
$iRand = Random($iStart_Row, $i, 1)
$vTmp = $aArray[$i]
$aArray[$i] = $aArray[$iRand]
$aArray[$iRand] = $vTmp
Next
Return 1
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iCol < -1 Or $iCol > $iDim_2 - 1 Then Return SetError(5, 0, -1)
Local $iCol_Start, $iCol_End
If $iCol = -1 Then
$iCol_Start = 0
$iCol_End = $iDim_2 - 1
Else
$iCol_Start = $iCol
$iCol_End = $iCol
EndIf
For $i = $iEnd_Row To $iStart_Row + 1 Step -1
$iRand = Random($iStart_Row, $i, 1)
For $j = $iCol_Start To $iCol_End
$vTmp = $aArray[$i][$j]
$aArray[$i][$j] = $aArray[$iRand][$j]
$aArray[$iRand][$j] = $vTmp
Next
Next
Return 1
Case Else
Return SetError(2, 0, -1)
EndSwitch
EndFunc
Func _ArraySort(ByRef $aArray, $iDescending = 0, $iStart = 0, $iEnd = 0, $iSubItem = 0, $iPivot = 0)
If $iDescending = Default Then $iDescending = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If $iPivot = Default Then $iPivot = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
Local $iUBound = UBound($aArray) - 1
If $iUBound = -1 Then Return SetError(5, 0, 0)
If $iEnd = Default Then $iEnd = 0
If $iEnd < 1 Or $iEnd > $iUBound Or $iEnd = Default Then $iEnd = $iUBound
If $iStart < 0 Or $iStart = Default Then $iStart = 0
If $iStart > $iEnd Then Return SetError(2, 0, 0)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iPivot Then
__ArrayDualPivotSort($aArray, $iStart, $iEnd)
Else
__ArrayQuickSort1D($aArray, $iStart, $iEnd)
EndIf
If $iDescending Then _ArrayReverse($aArray, $iStart, $iEnd)
Case 2
If $iPivot Then Return SetError(6, 0, 0)
Local $iSubMax = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iSubItem > $iSubMax Then Return SetError(3, 0, 0)
If $iDescending Then
$iDescending = -1
Else
$iDescending = 1
EndIf
__ArrayQuickSort2D($aArray, $iDescending, $iStart, $iEnd, $iSubItem, $iSubMax)
Case Else
Return SetError(4, 0, 0)
EndSwitch
Return 1
EndFunc
Func __ArrayQuickSort1D(ByRef $aArray, Const ByRef $iStart, Const ByRef $iEnd)
If $iEnd <= $iStart Then Return
Local $vTmp
If ($iEnd - $iStart) < 15 Then
Local $vCur
For $i = $iStart + 1 To $iEnd
$vTmp = $aArray[$i]
If IsNumber($vTmp) Then
For $j = $i - 1 To $iStart Step -1
$vCur = $aArray[$j]
If ($vTmp >= $vCur And IsNumber($vCur)) Or (Not IsNumber($vCur) And StringCompare($vTmp, $vCur) >= 0) Then ExitLoop
$aArray[$j + 1] = $vCur
Next
Else
For $j = $i - 1 To $iStart Step -1
If (StringCompare($vTmp, $aArray[$j]) >= 0) Then ExitLoop
$aArray[$j + 1] = $aArray[$j]
Next
EndIf
$aArray[$j + 1] = $vTmp
Next
Return
EndIf
Local $L = $iStart, $R = $iEnd, $vPivot = $aArray[Int(($iStart + $iEnd) / 2)], $bNum = IsNumber($vPivot)
Do
If $bNum Then
While ($aArray[$L] < $vPivot And IsNumber($aArray[$L])) Or (Not IsNumber($aArray[$L]) And StringCompare($aArray[$L], $vPivot) < 0)
$L += 1
WEnd
While ($aArray[$R] > $vPivot And IsNumber($aArray[$R])) Or (Not IsNumber($aArray[$R]) And StringCompare($aArray[$R], $vPivot) > 0)
$R -= 1
WEnd
Else
While (StringCompare($aArray[$L], $vPivot) < 0)
$L += 1
WEnd
While (StringCompare($aArray[$R], $vPivot) > 0)
$R -= 1
WEnd
EndIf
If $L <= $R Then
$vTmp = $aArray[$L]
$aArray[$L] = $aArray[$R]
$aArray[$R] = $vTmp
$L += 1
$R -= 1
EndIf
Until $L > $R
__ArrayQuickSort1D($aArray, $iStart, $R)
__ArrayQuickSort1D($aArray, $L, $iEnd)
EndFunc
Func __ArrayQuickSort2D(ByRef $aArray, Const ByRef $iStep, Const ByRef $iStart, Const ByRef $iEnd, Const ByRef $iSubItem, Const ByRef $iSubMax)
If $iEnd <= $iStart Then Return
Local $vTmp, $L = $iStart, $R = $iEnd, $vPivot = $aArray[Int(($iStart + $iEnd) / 2)][$iSubItem], $bNum = IsNumber($vPivot)
Do
If $bNum Then
While ($iStep * ($aArray[$L][$iSubItem] - $vPivot) < 0 And IsNumber($aArray[$L][$iSubItem])) Or (Not IsNumber($aArray[$L][$iSubItem]) And $iStep * StringCompare($aArray[$L][$iSubItem], $vPivot) < 0)
$L += 1
WEnd
While ($iStep * ($aArray[$R][$iSubItem] - $vPivot) > 0 And IsNumber($aArray[$R][$iSubItem])) Or (Not IsNumber($aArray[$R][$iSubItem]) And $iStep * StringCompare($aArray[$R][$iSubItem], $vPivot) > 0)
$R -= 1
WEnd
Else
While ($iStep * StringCompare($aArray[$L][$iSubItem], $vPivot) < 0)
$L += 1
WEnd
While ($iStep * StringCompare($aArray[$R][$iSubItem], $vPivot) > 0)
$R -= 1
WEnd
EndIf
If $L <= $R Then
For $i = 0 To $iSubMax
$vTmp = $aArray[$L][$i]
$aArray[$L][$i] = $aArray[$R][$i]
$aArray[$R][$i] = $vTmp
Next
$L += 1
$R -= 1
EndIf
Until $L > $R
__ArrayQuickSort2D($aArray, $iStep, $iStart, $R, $iSubItem, $iSubMax)
__ArrayQuickSort2D($aArray, $iStep, $L, $iEnd, $iSubItem, $iSubMax)
EndFunc
Func __ArrayDualPivotSort(ByRef $aArray, $iPivot_Left, $iPivot_Right, $bLeftMost = True)
If $iPivot_Left > $iPivot_Right Then Return
Local $iLength = $iPivot_Right - $iPivot_Left + 1
Local $i, $j, $k, $iAi, $iAk, $iA1, $iA2, $iLast
If $iLength < 45 Then
If $bLeftMost Then
$i = $iPivot_Left
While $i < $iPivot_Right
$j = $i
$iAi = $aArray[$i + 1]
While $iAi < $aArray[$j]
$aArray[$j + 1] = $aArray[$j]
$j -= 1
If $j + 1 = $iPivot_Left Then ExitLoop
WEnd
$aArray[$j + 1] = $iAi
$i += 1
WEnd
Else
While 1
If $iPivot_Left >= $iPivot_Right Then Return 1
$iPivot_Left += 1
If $aArray[$iPivot_Left] < $aArray[$iPivot_Left - 1] Then ExitLoop
WEnd
While 1
$k = $iPivot_Left
$iPivot_Left += 1
If $iPivot_Left > $iPivot_Right Then ExitLoop
$iA1 = $aArray[$k]
$iA2 = $aArray[$iPivot_Left]
If $iA1 < $iA2 Then
$iA2 = $iA1
$iA1 = $aArray[$iPivot_Left]
EndIf
$k -= 1
While $iA1 < $aArray[$k]
$aArray[$k + 2] = $aArray[$k]
$k -= 1
WEnd
$aArray[$k + 2] = $iA1
While $iA2 < $aArray[$k]
$aArray[$k + 1] = $aArray[$k]
$k -= 1
WEnd
$aArray[$k + 1] = $iA2
$iPivot_Left += 1
WEnd
$iLast = $aArray[$iPivot_Right]
$iPivot_Right -= 1
While $iLast < $aArray[$iPivot_Right]
$aArray[$iPivot_Right + 1] = $aArray[$iPivot_Right]
$iPivot_Right -= 1
WEnd
$aArray[$iPivot_Right + 1] = $iLast
EndIf
Return 1
EndIf
Local $iSeventh = BitShift($iLength, 3) + BitShift($iLength, 6) + 1
Local $iE1, $iE2, $iE3, $iE4, $iE5, $t
$iE3 = Ceiling(($iPivot_Left + $iPivot_Right) / 2)
$iE2 = $iE3 - $iSeventh
$iE1 = $iE2 - $iSeventh
$iE4 = $iE3 + $iSeventh
$iE5 = $iE4 + $iSeventh
If $aArray[$iE2] < $aArray[$iE1] Then
$t = $aArray[$iE2]
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
If $aArray[$iE3] < $aArray[$iE2] Then
$t = $aArray[$iE3]
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
If $aArray[$iE4] < $aArray[$iE3] Then
$t = $aArray[$iE4]
$aArray[$iE4] = $aArray[$iE3]
$aArray[$iE3] = $t
If $t < $aArray[$iE2] Then
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
EndIf
If $aArray[$iE5] < $aArray[$iE4] Then
$t = $aArray[$iE5]
$aArray[$iE5] = $aArray[$iE4]
$aArray[$iE4] = $t
If $t < $aArray[$iE3] Then
$aArray[$iE4] = $aArray[$iE3]
$aArray[$iE3] = $t
If $t < $aArray[$iE2] Then
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
EndIf
EndIf
Local $iLess = $iPivot_Left
Local $iGreater = $iPivot_Right
If (($aArray[$iE1] <> $aArray[$iE2]) And ($aArray[$iE2] <> $aArray[$iE3]) And ($aArray[$iE3] <> $aArray[$iE4]) And ($aArray[$iE4] <> $aArray[$iE5])) Then
Local $iPivot_1 = $aArray[$iE2]
Local $iPivot_2 = $aArray[$iE4]
$aArray[$iE2] = $aArray[$iPivot_Left]
$aArray[$iE4] = $aArray[$iPivot_Right]
Do
$iLess += 1
Until $aArray[$iLess] >= $iPivot_1
Do
$iGreater -= 1
Until $aArray[$iGreater] <= $iPivot_2
$k = $iLess
While $k <= $iGreater
$iAk = $aArray[$k]
If $iAk < $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
ElseIf $iAk > $iPivot_2 Then
While $aArray[$iGreater] > $iPivot_2
$iGreater -= 1
If $iGreater + 1 = $k Then ExitLoop 2
WEnd
If $aArray[$iGreater] < $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $aArray[$iGreater]
$iLess += 1
Else
$aArray[$k] = $aArray[$iGreater]
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
$aArray[$iPivot_Left] = $aArray[$iLess - 1]
$aArray[$iLess - 1] = $iPivot_1
$aArray[$iPivot_Right] = $aArray[$iGreater + 1]
$aArray[$iGreater + 1] = $iPivot_2
__ArrayDualPivotSort($aArray, $iPivot_Left, $iLess - 2, True)
__ArrayDualPivotSort($aArray, $iGreater + 2, $iPivot_Right, False)
If ($iLess < $iE1) And ($iE5 < $iGreater) Then
While $aArray[$iLess] = $iPivot_1
$iLess += 1
WEnd
While $aArray[$iGreater] = $iPivot_2
$iGreater -= 1
WEnd
$k = $iLess
While $k <= $iGreater
$iAk = $aArray[$k]
If $iAk = $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
ElseIf $iAk = $iPivot_2 Then
While $aArray[$iGreater] = $iPivot_2
$iGreater -= 1
If $iGreater + 1 = $k Then ExitLoop 2
WEnd
If $aArray[$iGreater] = $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iPivot_1
$iLess += 1
Else
$aArray[$k] = $aArray[$iGreater]
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
EndIf
__ArrayDualPivotSort($aArray, $iLess, $iGreater, False)
Else
Local $iPivot = $aArray[$iE3]
$k = $iLess
While $k <= $iGreater
If $aArray[$k] = $iPivot Then
$k += 1
ContinueLoop
EndIf
$iAk = $aArray[$k]
If $iAk < $iPivot Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
Else
While $aArray[$iGreater] > $iPivot
$iGreater -= 1
WEnd
If $aArray[$iGreater] < $iPivot Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $aArray[$iGreater]
$iLess += 1
Else
$aArray[$k] = $iPivot
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
__ArrayDualPivotSort($aArray, $iPivot_Left, $iLess - 1, True)
__ArrayDualPivotSort($aArray, $iGreater + 1, $iPivot_Right, False)
EndIf
EndFunc
Func _ArraySwap(ByRef $aArray, $iIndex_1, $iIndex_2, $bCol = False, $iStart = -1, $iEnd = -1)
If $bCol = Default Then $bCol = False
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iDim_2 = -1 Then
$bCol = False
$iStart = -1
$iEnd = -1
EndIf
If $iStart > $iEnd Then Return SetError(5, 0, -1)
If $bCol Then
If $iIndex_1 < 0 Or $iIndex_2 > $iDim_2 Then Return SetError(3, 0, -1)
If $iStart = -1 Then $iStart = 0
If $iEnd = -1 Then $iEnd = $iDim_1
Else
If $iIndex_1 < 0 Or $iIndex_2 > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart = -1 Then $iStart = 0
If $iEnd = -1 Then $iEnd = $iDim_2
EndIf
Local $vTmp
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
$vTmp = $aArray[$iIndex_1]
$aArray[$iIndex_1] = $aArray[$iIndex_2]
$aArray[$iIndex_2] = $vTmp
Case 2
If $iStart < -1 Or $iEnd < -1 Then Return SetError(4, 0, -1)
If $bCol Then
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(4, 0, -1)
For $j = $iStart To $iEnd
$vTmp = $aArray[$j][$iIndex_1]
$aArray[$j][$iIndex_1] = $aArray[$j][$iIndex_2]
$aArray[$j][$iIndex_2] = $vTmp
Next
Else
If $iStart > $iDim_2 Or $iEnd > $iDim_2 Then Return SetError(4, 0, -1)
For $j = $iStart To $iEnd
$vTmp = $aArray[$iIndex_1][$j]
$aArray[$iIndex_1][$j] = $aArray[$iIndex_2][$j]
$aArray[$iIndex_2][$j] = $vTmp
Next
EndIf
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func _ArrayToClip(Const ByRef $aArray, $sDelim_Col = "|", $iStart_Row = -1, $iEnd_Row = -1, $sDelim_Row = @CRLF, $iStart_Col = -1, $iEnd_Col = -1)
Local $sResult = _ArrayToString($aArray, $sDelim_Col, $iStart_Row, $iEnd_Row, $sDelim_Row, $iStart_Col, $iEnd_Col)
If @error Then Return SetError(@error, 0, 0)
If ClipPut($sResult) Then Return 1
Return SetError(-1, 0, 0)
EndFunc
Func _ArrayToString(Const ByRef $aArray, $sDelim_Col = "|", $iStart_Row = Default, $iEnd_Row = Default, $sDelim_Row = @CRLF, $iStart_Col = Default, $iEnd_Col = Default)
If $sDelim_Col = Default Then $sDelim_Col = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iStart_Row = Default Then $iStart_Row = -1
If $iEnd_Row = Default Then $iEnd_Row = -1
If $iStart_Col = Default Then $iStart_Col = -1
If $iEnd_Col = Default Then $iEnd_Col = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iDim_1 = -1 Then Return ""
If $iStart_Row = -1 Then $iStart_Row = 0
If $iEnd_Row = -1 Then $iEnd_Row = $iDim_1
If $iStart_Row < -1 Or $iEnd_Row < -1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iDim_1 Or $iEnd_Row > $iDim_1 Then Return SetError(3, 0, "")
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Local $sRet = ""
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = $iStart_Row To $iEnd_Row
$sRet &= $aArray[$i] & $sDelim_Col
Next
Return StringTrimRight($sRet, StringLen($sDelim_Col))
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iDim_2 = -1 Then Return ""
If $iStart_Col = -1 Then $iStart_Col = 0
If $iEnd_Col = -1 Then $iEnd_Col = $iDim_2
If $iStart_Col < -1 Or $iEnd_Col < -1 Then Return SetError(5, 0, -1)
If $iStart_Col > $iDim_2 Or $iEnd_Col > $iDim_2 Then Return SetError(5, 0, -1)
If $iStart_Col > $iEnd_Col Then Return SetError(6, 0, -1)
Local $iDelimColLen = StringLen($sDelim_Col)
For $i = $iStart_Row To $iEnd_Row
For $j = $iStart_Col To $iEnd_Col
$sRet &= $aArray[$i][$j] & $sDelim_Col
Next
$sRet = StringTrimRight($sRet, $iDelimColLen) & $sDelim_Row
Next
Return StringTrimRight($sRet, StringLen($sDelim_Row))
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func _ArrayTranspose(ByRef $aArray, $bForce1D = False)
Local $aTemp
Switch $bForce1D
Case Default
$bForce1D = False
Case True, False
Case Else
Return SetError(3, 0, 0)
EndSwitch
Switch UBound($aArray, 0)
Case 0
Return SetError(2, 0, 0)
Case 1
Local $aTemp[1][UBound($aArray)]
For $i = 0 To UBound($aArray) - 1
$aTemp[0][$i] = $aArray[$i]
Next
$aArray = $aTemp
Case 2
Local $iDim_1 = UBound($aArray, 1), $iDim_2 = UBound($aArray, 2)
If $iDim_1 <> $iDim_2 Then
Local $aTemp[$iDim_2][$iDim_1]
For $i = 0 To $iDim_1 - 1
For $j = 0 To $iDim_2 - 1
$aTemp[$j][$i] = $aArray[$i][$j]
Next
Next
$aArray = $aTemp
Else
Local $vElement
For $i = 0 To $iDim_1 - 1
For $j = $i + 1 To $iDim_2 - 1
$vElement = $aArray[$i][$j]
$aArray[$i][$j] = $aArray[$j][$i]
$aArray[$j][$i] = $vElement
Next
Next
EndIf
If $bForce1D = True And UBound($aArray, 2) = 1 Then
$aTemp = $aArray
ReDim $aArray[UBound($aTemp)]
For $i = 0 To UBound($aTemp) - 1
$aArray[$i] = $aTemp[$i][0]
Next
EndIf
Case Else
Return SetError(1, 0, 0)
EndSwitch
Return 1
EndFunc
Func _ArrayTrim(ByRef $aArray, $iTrimNum, $iDirection = 0, $iStart = 0, $iEnd = 0, $iSubItem = 0)
If $iDirection = Default Then $iDirection = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iEnd = 0 Then $iEnd = $iDim_1
If $iStart > $iEnd Then Return SetError(3, 0, -1)
If $iStart < 0 Or $iEnd < 0 Then Return SetError(3, 0, -1)
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iDirection Then
For $i = $iStart To $iEnd
$aArray[$i] = StringTrimRight($aArray[$i], $iTrimNum)
Next
Else
For $i = $iStart To $iEnd
$aArray[$i] = StringTrimLeft($aArray[$i], $iTrimNum)
Next
EndIf
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iSubItem < 0 Or $iSubItem > $iDim_2 Then Return SetError(5, 0, -1)
If $iDirection Then
For $i = $iStart To $iEnd
$aArray[$i][$iSubItem] = StringTrimRight($aArray[$i][$iSubItem], $iTrimNum)
Next
Else
For $i = $iStart To $iEnd
$aArray[$i][$iSubItem] = StringTrimLeft($aArray[$i][$iSubItem], $iTrimNum)
Next
EndIf
Case Else
Return SetError(2, 0, 0)
EndSwitch
Return 1
EndFunc
Func _ArrayUnique(Const ByRef $aArray, $iColumn = 0, $iBase = 0, $iCase = 0, $iCount = $ARRAYUNIQUE_COUNT, $iIntType = $ARRAYUNIQUE_AUTO)
If $iColumn = Default Then $iColumn = 0
If $iBase = Default Then $iBase = 0
If $iCase = Default Then $iCase = 0
If $iCount = Default Then $iCount = $ARRAYUNIQUE_COUNT
If $iIntType = Default Then $iIntType = $ARRAYUNIQUE_AUTO
If UBound($aArray, $UBOUND_ROWS) = 0 Then Return SetError(1, 0, 0)
Local $iDims = UBound($aArray, $UBOUND_DIMENSIONS), $iNumColumns = UBound($aArray, $UBOUND_COLUMNS)
If $iDims > 2 Then Return SetError(2, 0, 0)
If $iBase < 0 Or $iBase > 1 Or (Not IsInt($iBase)) Then Return SetError(3, 0, 0)
If $iCase < 0 Or $iCase > 1 Or (Not IsInt($iCase)) Then Return SetError(3, 0, 0)
If $iCount < 0 Or $iCount > 1 Or (Not IsInt($iCount)) Then Return SetError(4, 0, 0)
If $iIntType < 0 Or $iIntType > 4 Or (Not IsInt($iIntType)) Then Return SetError(5, 0, 0)
If $iColumn < 0 Or ($iNumColumns = 0 And $iColumn > 0) Or ($iNumColumns > 0 And $iColumn >= $iNumColumns) Then Return SetError(6, 0, 0)
If $iIntType = $ARRAYUNIQUE_AUTO Then
Local $bInt, $sVarType
If $iDims = 1 Then
$bInt = IsInt($aArray[$iBase])
$sVarType = VarGetType($aArray[$iBase])
Else
$bInt = IsInt($aArray[$iBase][$iColumn])
$sVarType = VarGetType($aArray[$iBase][$iColumn])
EndIf
If $bInt And $sVarType = "Int64" Then
$iIntType = $ARRAYUNIQUE_FORCE64
Else
$iIntType = $ARRAYUNIQUE_FORCE32
EndIf
EndIf
ObjEvent("AutoIt.Error", __ArrayUnique_AutoErrFunc)
Local $oDictionary = ObjCreate("Scripting.Dictionary")
$oDictionary.CompareMode = Number(Not $iCase)
Local $vElem, $sType, $vKey, $bCOMError = False
For $i = $iBase To UBound($aArray) - 1
If $iDims = 1 Then
$vElem = $aArray[$i]
Else
$vElem = $aArray[$i][$iColumn]
EndIf
Switch $iIntType
Case $ARRAYUNIQUE_FORCE32
$oDictionary.Item($vElem)
If @error Then
$bCOMError = True
ExitLoop
EndIf
Case $ARRAYUNIQUE_FORCE64
$sType = VarGetType($vElem)
If $sType = "Int32" Then
$bCOMError = True
ExitLoop
EndIf
$vKey = "#" & $sType & "#" & String($vElem)
If Not $oDictionary.Item($vKey) Then
$oDictionary($vKey) = $vElem
EndIf
Case $ARRAYUNIQUE_MATCH
$sType = VarGetType($vElem)
If StringLeft($sType, 3) = "Int" Then
$vKey = "#Int#" & String($vElem)
Else
$vKey = "#" & $sType & "#" & String($vElem)
EndIf
If Not $oDictionary.Item($vKey) Then
$oDictionary($vKey) = $vElem
EndIf
Case $ARRAYUNIQUE_DISTINCT
$vKey = "#" & VarGetType($vElem) & "#" & String($vElem)
If Not $oDictionary.Item($vKey) Then
$oDictionary($vKey) = $vElem
EndIf
EndSwitch
Next
Local $aValues, $j = 0
If $bCOMError Then
Return SetError(7, 0, 0)
ElseIf $iIntType <> $ARRAYUNIQUE_FORCE32 Then
Local $aValues[$oDictionary.Count]
For $vKey In $oDictionary.Keys()
$aValues[$j] = $oDictionary($vKey)
If StringLeft($vKey, 5) = "#Ptr#" Then
$aValues[$j] = Ptr($aValues[$j])
EndIf
$j += 1
Next
Else
$aValues = $oDictionary.Keys()
EndIf
If $iCount Then
_ArrayInsert($aValues, 0, $oDictionary.Count)
EndIf
Return $aValues
EndFunc
Func _Array1DToHistogram($aArray, $iSizing = 100)
If UBound($aArray, 0) > 1 Then Return SetError(1, 0, "")
$iSizing = $iSizing * 8
Local $t, $n, $iMin = 0, $iMax = 0, $iOffset = 0
For $i = 0 To UBound($aArray) - 1
$t = $aArray[$i]
$t = IsNumber($t) ? Round($t) : 0
If $t < $iMin Then $iMin = $t
If $t > $iMax Then $iMax = $t
Next
Local $iRange = Int(Round(($iMax - $iMin) / 8)) * 8
Local $iSpaceRatio = 4
For $i = 0 To UBound($aArray) - 1
$t = $aArray[$i]
If $t Then
$n = Abs(Round(($iSizing * $t) / $iRange) / 8)
$aArray[$i] = ""
If $t > 0 Then
If $iMin Then
$iOffset = Int(Abs(Round(($iSizing * $iMin) / $iRange) / 8) / 8 * $iSpaceRatio)
$aArray[$i] = __Array_StringRepeat(ChrW(0x20), $iOffset)
EndIf
Else
If $iMin <> $t Then
$iOffset = Int(Abs(Round(($iSizing * ($t - $iMin)) / $iRange) / 8) / 8 * $iSpaceRatio)
$aArray[$i] = __Array_StringRepeat(ChrW(0x20), $iOffset)
EndIf
EndIf
$aArray[$i] &= __Array_StringRepeat(ChrW(0x2588), Int($n / 8))
$n = Mod($n, 8)
If $n > 0 Then $aArray[$i] &= ChrW(0x2588 + 8 - $n)
$aArray[$i] &= ' ' & $t
Else
$aArray[$i] = ""
EndIf
Next
Return $aArray
EndFunc
Func _Array2DCreate($aCol0, $aCol1)
If (UBound($aCol0, 0) <> 1) Or (UBound($aCol1, 0) <> 1) Then Return SetError(1, 0, "")
Local $nRows = UBound($aCol0)
If $nRows <> UBound($aCol1) Then Return SetError(2, 0, "")
Local $aTmp[$nRows][2]
For $i = 0 To $nRows - 1
$aTmp[$i][0] = $aCol0[$i]
$aTmp[$i][1] = $aCol1[$i]
Next
Return $aTmp
EndFunc
Func __Array_StringRepeat($sString, $iRepeatCount)
$iRepeatCount = Int($iRepeatCount)
If StringLen($sString) < 1 Or $iRepeatCount <= 0 Then Return SetError(1, 0, "")
Local $sResult = ""
While $iRepeatCount > 1
If BitAND($iRepeatCount, 1) Then $sResult &= $sString
$sString &= $sString
$iRepeatCount = BitShift($iRepeatCount, 1)
WEnd
Return $sString & $sResult
EndFunc
Func __Array_ExeterInternal(ByRef $aArray, $iStart, $iSize, $sDelimiter, ByRef $aIdx, ByRef $aResult, ByRef $iCount)
If $iStart == $iSize - 1 Then
For $i = 0 To $iSize - 1
$aResult[$iCount] &= $aArray[$aIdx[$i]] & $sDelimiter
Next
If $sDelimiter <> "" Then $aResult[$iCount] = StringTrimRight($aResult[$iCount], StringLen($sDelimiter))
$iCount += 1
Else
Local $iTemp
For $i = $iStart To $iSize - 1
$iTemp = $aIdx[$i]
$aIdx[$i] = $aIdx[$iStart]
$aIdx[$iStart] = $iTemp
__Array_ExeterInternal($aArray, $iStart + 1, $iSize, $sDelimiter, $aIdx, $aResult, $iCount)
$aIdx[$iStart] = $aIdx[$i]
$aIdx[$i] = $iTemp
Next
EndIf
EndFunc
Func __Array_Combinations($iN, $iR)
Local $i_Total = 1
For $i = $iR To 1 Step -1
$i_Total *= ($iN / $i)
$iN -= 1
Next
Return Round($i_Total)
EndFunc
Func __Array_GetNext($iN, $iR, ByRef $iLeft, $iTotal, ByRef $aIdx)
If $iLeft == $iTotal Then
$iLeft -= 1
Return
EndIf
Local $i = $iR - 1
While $aIdx[$i] == $iN - $iR + $i
$i -= 1
WEnd
$aIdx[$i] += 1
For $j = $i + 1 To $iR - 1
$aIdx[$j] = $aIdx[$i] + $j - $i
Next
$iLeft -= 1
EndFunc
Func __Array_MinMaxIndex(Const ByRef $aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, $fuComparison)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iCompNumeric <> 1 Then $iCompNumeric = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iDim_1 < 0 Then Return SetError(1, 0, -1)
If $iEnd = -1 Then $iEnd = $iDim_1
If $iStart = -1 Then $iStart = 0
If $iStart < -1 Or $iEnd < -1 Then Return SetError(3, 0, -1)
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart > $iEnd Then Return SetError(4, 0, -1)
If $iDim_1 < 0 Then Return SetError(5, 0, -1)
Local $iMaxMinIndex = $iStart
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iCompNumeric Then
For $i = $iStart To $iEnd
If $fuComparison(Number($aArray[$i]), Number($aArray[$iMaxMinIndex])) Then $iMaxMinIndex = $i
Next
Else
For $i = $iStart To $iEnd
If $fuComparison($aArray[$i], $aArray[$iMaxMinIndex]) Then $iMaxMinIndex = $i
Next
EndIf
Case 2
If $iSubItem < 0 Or $iSubItem > UBound($aArray, $UBOUND_COLUMNS) - 1 Then Return SetError(6, 0, -1)
If $iCompNumeric Then
For $i = $iStart To $iEnd
If $fuComparison(Number($aArray[$i][$iSubItem]), Number($aArray[$iMaxMinIndex][$iSubItem])) Then $iMaxMinIndex = $i
Next
Else
For $i = $iStart To $iEnd
If $fuComparison($aArray[$i][$iSubItem], $aArray[$iMaxMinIndex][$iSubItem]) Then $iMaxMinIndex = $i
Next
EndIf
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return $iMaxMinIndex
EndFunc
Func __Array_GreaterThan($vValue1, $vValue2)
Return $vValue1 > $vValue2
EndFunc
Func __Array_LessThan($vValue1, $vValue2)
Return $vValue1 < $vValue2
EndFunc
Func __ArrayUnique_AutoErrFunc()
EndFunc
Global Const $ACS_CENTER = 1
Global Const $ACS_TRANSPARENT = 2
Global Const $ACS_AUTOPLAY = 4
Global Const $ACS_TIMER = 8
Global Const $ACS_NONTRANSPARENT = 16
Global Const $GUI_SS_DEFAULT_AVI = $ACS_TRANSPARENT
Global Const $__AVICONSTANT_WM_USER = 0x400
Global Const $ACM_OPENA = $__AVICONSTANT_WM_USER + 100
Global Const $ACM_PLAY = $__AVICONSTANT_WM_USER + 101
Global Const $ACM_STOP = $__AVICONSTANT_WM_USER + 102
Global Const $ACM_ISPLAYING = $__AVICONSTANT_WM_USER + 104
Global Const $ACM_OPENW = $__AVICONSTANT_WM_USER + 103
Global Const $ACN_START = 0x00000001
Global Const $ACN_STOP = 0x00000002
Global Const $BS_GROUPBOX = 0x0007
Global Const $BS_BOTTOM = 0x0800
Global Const $BS_CENTER = 0x0300
Global Const $BS_DEFPUSHBUTTON = 0x0001
Global Const $BS_LEFT = 0x0100
Global Const $BS_MULTILINE = 0x2000
Global Const $BS_PUSHBOX = 0x000A
Global Const $BS_PUSHLIKE = 0x1000
Global Const $BS_RIGHT = 0x0200
Global Const $BS_RIGHTBUTTON = 0x0020
Global Const $BS_TOP = 0x0400
Global Const $BS_VCENTER = 0x0C00
Global Const $BS_FLAT = 0x8000
Global Const $BS_ICON = 0x0040
Global Const $BS_BITMAP = 0x0080
Global Const $BS_NOTIFY = 0x4000
Global Const $BS_SPLITBUTTON = 0x0000000C
Global Const $BS_DEFSPLITBUTTON = 0x0000000D
Global Const $BS_COMMANDLINK = 0x0000000E
Global Const $BS_DEFCOMMANDLINK = 0x0000000F
Global Const $BCSIF_GLYPH = 0x0001
Global Const $BCSIF_IMAGE = 0x0002
Global Const $BCSIF_STYLE = 0x0004
Global Const $BCSIF_SIZE = 0x0008
Global Const $BCSS_NOSPLIT = 0x0001
Global Const $BCSS_STRETCH = 0x0002
Global Const $BCSS_ALIGNLEFT = 0x0004
Global Const $BCSS_IMAGE = 0x0008
Global Const $BUTTON_IMAGELIST_ALIGN_LEFT = 0
Global Const $BUTTON_IMAGELIST_ALIGN_RIGHT = 1
Global Const $BUTTON_IMAGELIST_ALIGN_TOP = 2
Global Const $BUTTON_IMAGELIST_ALIGN_BOTTOM = 3
Global Const $BUTTON_IMAGELIST_ALIGN_CENTER = 4
Global Const $BS_3STATE = 0x0005
Global Const $BS_AUTO3STATE = 0x0006
Global Const $BS_AUTOCHECKBOX = 0x0003
Global Const $BS_CHECKBOX = 0x0002
Global Const $BS_RADIOBUTTON = 0x4
Global Const $BS_AUTORADIOBUTTON = 0x0009
Global Const $BS_OWNERDRAW = 0xB
Global Const $GUI_SS_DEFAULT_BUTTON = 0
Global Const $GUI_SS_DEFAULT_CHECKBOX = 0
Global Const $GUI_SS_DEFAULT_GROUP = 0
Global Const $GUI_SS_DEFAULT_RADIO = 0
Global Const $BCM_FIRST = 0x1600
Global Const $BCM_GETIDEALSIZE = ($BCM_FIRST + 0x0001)
Global Const $BCM_GETIMAGELIST = ($BCM_FIRST + 0x0003)
Global Const $BCM_GETNOTE = ($BCM_FIRST + 0x000A)
Global Const $BCM_GETNOTELENGTH = ($BCM_FIRST + 0x000B)
Global Const $BCM_GETSPLITINFO = ($BCM_FIRST + 0x0008)
Global Const $BCM_GETTEXTMARGIN = ($BCM_FIRST + 0x0005)
Global Const $BCM_SETDROPDOWNSTATE = ($BCM_FIRST + 0x0006)
Global Const $BCM_SETIMAGELIST = ($BCM_FIRST + 0x0002)
Global Const $BCM_SETNOTE = ($BCM_FIRST + 0x0009)
Global Const $BCM_SETSHIELD = ($BCM_FIRST + 0x000C)
Global Const $BCM_SETSPLITINFO = ($BCM_FIRST + 0x0007)
Global Const $BCM_SETTEXTMARGIN = ($BCM_FIRST + 0x0004)
Global Const $BM_CLICK = 0xF5
Global Const $BM_GETCHECK = 0xF0
Global Const $BM_GETIMAGE = 0xF6
Global Const $BM_GETSTATE = 0xF2
Global Const $BM_SETCHECK = 0xF1
Global Const $BM_SETDONTCLICK = 0xF8
Global Const $BM_SETIMAGE = 0xF7
Global Const $BM_SETSTATE = 0xF3
Global Const $BM_SETSTYLE = 0xF4
Global Const $BCN_FIRST = -1250
Global Const $BCN_DROPDOWN = ($BCN_FIRST + 0x0002)
Global Const $BCN_HOTITEMCHANGE = ($BCN_FIRST + 0x0001)
Global Const $BN_CLICKED = 0
Global Const $BN_PAINT = 1
Global Const $BN_HILITE = 2
Global Const $BN_UNHILITE = 3
Global Const $BN_DISABLE = 4
Global Const $BN_DOUBLECLICKED = 5
Global Const $BN_SETFOCUS = 6
Global Const $BN_KILLFOCUS = 7
Global Const $BN_PUSHED = $BN_HILITE
Global Const $BN_UNPUSHED = $BN_UNHILITE
Global Const $BN_DBLCLK = $BN_DOUBLECLICKED
Global Const $BST_CHECKED = 0x1
Global Const $BST_INDETERMINATE = 0x2
Global Const $BST_UNCHECKED = 0x0
Global Const $BST_FOCUS = 0x8
Global Const $BST_PUSHED = 0x4
Global Const $BST_DONTCLICK = 0x000080
Global Const $COLOR_ALICEBLUE = 0xF0F8FF
Global Const $COLOR_ANTIQUEWHITE = 0xFAEBD7
Global Const $COLOR_AQUA = 0x00FFFF
Global Const $COLOR_AQUAMARINE = 0x7FFFD4
Global Const $COLOR_AZURE = 0xF0FFFF
Global Const $COLOR_BEIGE = 0xF5F5DC
Global Const $COLOR_BISQUE = 0xFFE4C4
Global Const $COLOR_BLACK = 0x000000
Global Const $COLOR_BLANCHEDALMOND = 0xFFEBCD
Global Const $COLOR_BLUE = 0x0000FF
Global Const $COLOR_BLUEVIOLET = 0x8A2BE2
Global Const $COLOR_BROWN = 0xA52A2A
Global Const $COLOR_BURLYWOOD = 0xDEB887
Global Const $COLOR_CADETBLUE = 0x5F9EA0
Global Const $COLOR_CHARTREUSE = 0x7FFF00
Global Const $COLOR_CHOCOLATE = 0xD2691E
Global Const $COLOR_CORAL = 0xFF7F50
Global Const $COLOR_CORNFLOWERBLUE = 0x6495ED
Global Const $COLOR_CORNSILK = 0xFFF8DC
Global Const $COLOR_CRIMSON = 0xDC143C
Global Const $COLOR_CYAN = 0x00FFFF
Global Const $COLOR_DARKBLUE = 0x00008B
Global Const $COLOR_DARKCYAN = 0x008B8B
Global Const $COLOR_DARKGOLDENROD = 0xB8860B
Global Const $COLOR_DARKGRAY = 0xA9A9A9
Global Const $COLOR_DARKGREEN = 0x006400
Global Const $COLOR_DARKKHAKI = 0xBDB76B
Global Const $COLOR_DARKMAGENTA = 0x8B008B
Global Const $COLOR_DARKOLIVEGREEN = 0x556B2F
Global Const $COLOR_DARKORANGE = 0xFF8C00
Global Const $COLOR_DARKORCHID = 0x9932CC
Global Const $COLOR_DARKRED = 0x8B0000
Global Const $COLOR_DARKSALMON = 0xE9967A
Global Const $COLOR_DARKSEAGREEN = 0x8FBC8F
Global Const $COLOR_DARKSLATEBLUE = 0x483D8B
Global Const $COLOR_DARKSLATEGRAY = 0x2F4F4F
Global Const $COLOR_DARKTURQUOISE = 0x00CED1
Global Const $COLOR_DARKVIOLET = 0x9400D3
Global Const $COLOR_DEEPPINK = 0xFF1493
Global Const $COLOR_DEEPSKYBLUE = 0x00BFFF
Global Const $COLOR_DIMGRAY = 0x696969
Global Const $COLOR_DODGERBLUE = 0x1E90FF
Global Const $COLOR_FIREBRICK = 0xB22222
Global Const $COLOR_FLORALWHITE = 0xFFFAF0
Global Const $COLOR_FORESTGREEN = 0x228B22
Global Const $COLOR_FUCHSIA = 0xFF00FF
Global Const $COLOR_GAINSBORO = 0xDCDCDC
Global Const $COLOR_GHOSTWHITE = 0xF8F8FF
Global Const $COLOR_GOLD = 0xFFD700
Global Const $COLOR_GOLDENROD = 0xDAA520
Global Const $COLOR_GRAY = 0x808080
Global Const $COLOR_GREEN = 0x008000
Global Const $COLOR_GREENYELLOW = 0xADFF2F
Global Const $COLOR_HONEYDEW = 0xF0FFF0
Global Const $COLOR_HOTPINK = 0xFF69B4
Global Const $COLOR_INDIANRED = 0xCD5C5C
Global Const $COLOR_INDIGO = 0x4B0082
Global Const $COLOR_IVORY = 0xFFFFF0
Global Const $COLOR_KHAKI = 0xF0E68C
Global Const $COLOR_LAVENDER = 0xE6E6FA
Global Const $COLOR_LAVENDERBLUSH = 0xFFF0F5
Global Const $COLOR_LAWNGREEN = 0x7CFC00
Global Const $COLOR_LEMONCHIFFON = 0xFFFACD
Global Const $COLOR_LIGHTBLUE = 0xADD8E6
Global Const $COLOR_LIGHTCORAL = 0xF08080
Global Const $COLOR_LIGHTCYAN = 0xE0FFFF
Global Const $COLOR_LIGHTGOLDENRODYELLOW = 0xFAFAD2
Global Const $COLOR_LIGHTGRAY = 0xD3D3D3
Global Const $COLOR_LIGHTGREEN = 0x90EE90
Global Const $COLOR_LIGHTPINK = 0xFFB6C1
Global Const $COLOR_LIGHTSALMON = 0xFFA07A
Global Const $COLOR_LIGHTSEAGREEN = 0x20B2AA
Global Const $COLOR_LIGHTSKYBLUE = 0x87CEFA
Global Const $COLOR_LIGHTSLATEGRAY = 0x778899
Global Const $COLOR_LIGHTSTEELBLUE = 0xB0C4DE
Global Const $COLOR_LIGHTYELLOW = 0xFFFFE0
Global Const $COLOR_LIME = 0x00FF00
Global Const $COLOR_LIMEGREEN = 0x32CD32
Global Const $COLOR_LINEN = 0xFAF0E6
Global Const $COLOR_MAGENTA = 0xFF00FF
Global Const $COLOR_MAROON = 0x800000
Global Const $COLOR_MEDIUMAQUAMARINE = 0x66CDAA
Global Const $COLOR_MEDIUMBLUE = 0x0000CD
Global Const $COLOR_MEDIUMORCHID = 0xBA55D3
Global Const $COLOR_MEDIUMPURPLE = 0x9370DB
Global Const $COLOR_MEDIUMSEAGREEN = 0x3CB371
Global Const $COLOR_MEDIUMSLATEBLUE = 0x7B68EE
Global Const $COLOR_MEDIUMSPRINGGREEN = 0x00FA9A
Global Const $COLOR_MEDIUMTURQUOISE = 0x48D1CC
Global Const $COLOR_MEDIUMVIOLETRED = 0xC71585
Global Const $COLOR_MIDNIGHTBLUE = 0x191970
Global Const $COLOR_MINTCREAM = 0xF5FFFA
Global Const $COLOR_MISTYROSE = 0xFFE4E1
Global Const $COLOR_MOCCASIN = 0xFFE4B5
Global Const $COLOR_NAVAJOWHITE = 0xFFDEAD
Global Const $COLOR_NAVY = 0x000080
Global Const $COLOR_OLDLACE = 0xFDF5E6
Global Const $COLOR_OLIVE = 0x808000
Global Const $COLOR_OLIVEDRAB = 0x6B8E23
Global Const $COLOR_ORANGE = 0xFFA500
Global Const $COLOR_ORANGERED = 0xFF4500
Global Const $COLOR_ORCHID = 0xDA70D6
Global Const $COLOR_PALEGOLDENROD = 0xEEE8AA
Global Const $COLOR_PALEGREEN = 0x98FB98
Global Const $COLOR_PALETURQUOISE = 0xAFEEEE
Global Const $COLOR_PALEVIOLETRED = 0xDB7093
Global Const $COLOR_PAPAYAWHIP = 0xFFEFD5
Global Const $COLOR_PEACHPUFF = 0xFFDAB9
Global Const $COLOR_PERU = 0xCD853F
Global Const $COLOR_PINK = 0xFFC0CB
Global Const $COLOR_PLUM = 0xDDA0DD
Global Const $COLOR_POWDERBLUE = 0xB0E0E6
Global Const $COLOR_PURPLE = 0x800080
Global Const $COLOR_RED = 0xFF0000
Global Const $COLOR_ROSYBROWN = 0xBC8F8F
Global Const $COLOR_ROYALBLUE = 0x4169E1
Global Const $COLOR_SADDLEBROWN = 0x8B4513
Global Const $COLOR_SALMON = 0xFA8072
Global Const $COLOR_SANDYBROWN = 0xF4A460
Global Const $COLOR_SEAGREEN = 0x2E8B57
Global Const $COLOR_SEASHELL = 0xFFF5EE
Global Const $COLOR_SIENNA = 0xA0522D
Global Const $COLOR_SILVER = 0xC0C0C0
Global Const $COLOR_SKYBLUE = 0x87CEEB
Global Const $COLOR_SLATEBLUE = 0x6A5ACD
Global Const $COLOR_SLATEGRAY = 0x708090
Global Const $COLOR_SNOW = 0xFFFAFA
Global Const $COLOR_SPRINGGREEN = 0x00FF7F
Global Const $COLOR_STEELBLUE = 0x4682B4
Global Const $COLOR_TAN = 0xD2B48C
Global Const $COLOR_TEAL = 0x008080
Global Const $COLOR_THISTLE = 0xD8BFD8
Global Const $COLOR_TOMATO = 0xFF6347
Global Const $COLOR_TURQUOISE = 0x40E0D0
Global Const $COLOR_VIOLET = 0xEE82EE
Global Const $COLOR_WHEAT = 0xF5DEB3
Global Const $COLOR_WHITE = 0xFFFFFF
Global Const $COLOR_WHITESMOKE = 0xF5F5F5
Global Const $COLOR_YELLOW = 0xFFFF00
Global Const $COLOR_YELLOWGREEN = 0x9ACD32
Global Const $CLR_NONE = 0xFFFFFFFF
Global Const $CLR_DEFAULT = 0xFF000000
Global Const $CLR_ALICEBLUE = 0xFFF8F0
Global Const $CLR_ANTIQUEWHITE = 0xD7EBFA
Global Const $CLR_AQUA = 0xFFFF00
Global Const $CLR_AQUAMARINE = 0xD4FF7F
Global Const $CLR_AZURE = 0xFFFFF0
Global Const $CLR_BEIGE = 0xDCF5F5
Global Const $CLR_BISQUE = 0xC4E4FF
Global Const $CLR_BLACK = 0x000000
Global Const $CLR_BLANCHEDALMOND = 0xCDEBFF
Global Const $CLR_BLUE = 0xFF0000
Global Const $CLR_BLUEVIOLET = 0xE22B8A
Global Const $CLR_BROWN = 0x2A2AA5
Global Const $CLR_BURLYWOOD = 0x87B8DE
Global Const $CLR_CADETBLUE = 0xA09E5F
Global Const $CLR_CHARTREUSE = 0x00FF7F
Global Const $CLR_CHOCOLATE = 0x1E69D2
Global Const $CLR_CORAL = 0x507FFF
Global Const $CLR_CORNFLOWERBLUE = 0xED9564
Global Const $CLR_CORNSILK = 0xDCF8FF
Global Const $CLR_CRIMSON = 0x3C14DC
Global Const $CLR_CYAN = 0xFFFF00
Global Const $CLR_DARKBLUE = 0x8B0000
Global Const $CLR_DARKCYAN = 0x8B8B00
Global Const $CLR_DARKGOLDENROD = 0x0B86B8
Global Const $CLR_DARKGRAY = 0xA9A9A9
Global Const $CLR_DARKGREEN = 0x006400
Global Const $CLR_DARKKHAKI = 0x6BB7BD
Global Const $CLR_DARKMAGENTA = 0x8B008B
Global Const $CLR_DARKOLIVEGREEN = 0x2F6B55
Global Const $CLR_DARKORANGE = 0x008CFF
Global Const $CLR_DARKORCHID = 0xCC3299
Global Const $CLR_DARKRED = 0x00008B
Global Const $CLR_DARKSALMON = 0x7A96E9
Global Const $CLR_DARKSEAGREEN = 0x8FBC8F
Global Const $CLR_DARKSLATEBLUE = 0x8B3D48
Global Const $CLR_DARKSLATEGRAY = 0x4F4F2F
Global Const $CLR_DARKTURQUOISE = 0xD1CE00
Global Const $CLR_DARKVIOLET = 0xD30094
Global Const $CLR_DEEPPINK = 0x9314FF
Global Const $CLR_DEEPSKYBLUE = 0xFFBF00
Global Const $CLR_DIMGRAY = 0x696969
Global Const $CLR_DODGERBLUE = 0xFF901E
Global Const $CLR_FIREBRICK = 0x2222B2
Global Const $CLR_FLORALWHITE = 0xF0FAFF
Global Const $CLR_FORESTGREEN = 0x228B22
Global Const $CLR_FUCHSIA = 0xFF00FF
Global Const $CLR_GAINSBORO = 0xDCDCDC
Global Const $CLR_GHOSTWHITE = 0xFFF8F8
Global Const $CLR_GOLD = 0x00D7FF
Global Const $CLR_GOLDENROD = 0x20A5DA
Global Const $CLR_GRAY = 0x808080
Global Const $CLR_GREEN = 0x008000
Global Const $CLR_GREENYELLOW = 0x2FFFAD
Global Const $CLR_HONEYDEW = 0xF0FFF0
Global Const $CLR_HOTPINK = 0xB469FF
Global Const $CLR_INDIANRED = 0x5C5CCD
Global Const $CLR_INDIGO = 0x82004B
Global Const $CLR_IVORY = 0xF0FFFF
Global Const $CLR_KHAKI = 0x8CE6F0
Global Const $CLR_LAVENDER = 0xFAE6E6
Global Const $CLR_LAVENDERBLUSH = 0xF5F0FF
Global Const $CLR_LAWNGREEN = 0x00FC7C
Global Const $CLR_LEMONCHIFFON = 0xCDFAFF
Global Const $CLR_LIGHTBLUE = 0xE6D8AD
Global Const $CLR_LIGHTCORAL = 0x8080F0
Global Const $CLR_LIGHTCYAN = 0xFFFFE0
Global Const $CLR_LIGHTGOLDENRODYELLOW = 0xD2FAFA
Global Const $CLR_LIGHTGRAY = 0xD3D3D3
Global Const $CLR_LIGHTGREEN = 0x90EE90
Global Const $CLR_LIGHTPINK = 0xC1B6FF
Global Const $CLR_LIGHTSALMON = 0x7AA0FF
Global Const $CLR_LIGHTSEAGREEN = 0xAAB220
Global Const $CLR_LIGHTSKYBLUE = 0xFACE87
Global Const $CLR_LIGHTSLATEGRAY = 0x998877
Global Const $CLR_LIGHTSTEELBLUE = 0xDEC4B0
Global Const $CLR_LIGHTYELLOW = 0xE0FFFF
Global Const $CLR_LIME = 0x00FF00
Global Const $CLR_LIMEGREEN = 0x32CD32
Global Const $CLR_LINEN = 0xE6F0FA
Global Const $CLR_MAGENTA = 0xFF00FF
Global Const $CLR_MAROON = 0x000080
Global Const $CLR_MEDIUMAQUAMARINE = 0xAACD66
Global Const $CLR_MEDIUMBLUE = 0xCD0000
Global Const $CLR_MEDIUMORCHID = 0xD355BA
Global Const $CLR_MEDIUMPURPLE = 0xDB7093
Global Const $CLR_MEDIUMSEAGREEN = 0x71B33C
Global Const $CLR_MEDIUMSLATEBLUE = 0xEE687B
Global Const $CLR_MEDIUMSPRINGGREEN = 0x9AFA00
Global Const $CLR_MEDIUMTURQUOISE = 0xCCD148
Global Const $CLR_MEDIUMVIOLETRED = 0x8515C7
Global Const $CLR_MIDNIGHTBLUE = 0x701919
Global Const $CLR_MINTCREAM = 0xFAFFF5
Global Const $CLR_MISTYROSE = 0xE1E4FF
Global Const $CLR_MOCCASIN = 0xB5E4FF
Global Const $CLR_NAVAJOWHITE = 0xADDEFF
Global Const $CLR_NAVY = 0x800000
Global Const $CLR_OLDLACE = 0xE6F5FD
Global Const $CLR_OLIVE = 0x008080
Global Const $CLR_OLIVEDRAB = 0x238E6B
Global Const $CLR_ORANGE = 0x00A5FF
Global Const $CLR_ORANGERED = 0x0045FF
Global Const $CLR_ORCHID = 0xD670DA
Global Const $CLR_PALEGOLDENROD = 0xAAE8EE
Global Const $CLR_PALEGREEN = 0x98FB98
Global Const $CLR_PALETURQUOISE = 0xEEEEAF
Global Const $CLR_PALEVIOLETRED = 0x9370DB
Global Const $CLR_PAPAYAWHIP = 0xD5EFFF
Global Const $CLR_PEACHPUFF = 0xB9DAFF
Global Const $CLR_PERU = 0x3F85CD
Global Const $CLR_PINK = 0xCBC0FF
Global Const $CLR_PLUM = 0xDDA0DD
Global Const $CLR_POWDERBLUE = 0xE6E0B0
Global Const $CLR_PURPLE = 0x800080
Global Const $CLR_RED = 0x0000FF
Global Const $CLR_ROSYBROWN = 0x8F8FBC
Global Const $CLR_ROYALBLUE = 0xE16941
Global Const $CLR_SADDLEBROWN = 0x13458B
Global Const $CLR_SALMON = 0x7280FA
Global Const $CLR_SANDYBROWN = 0x60A4F4
Global Const $CLR_SEAGREEN = 0x578B2E
Global Const $CLR_SEASHELL = 0xEEF5FF
Global Const $CLR_SIENNA = 0x2D52A0
Global Const $CLR_SILVER = 0xC0C0C0
Global Const $CLR_SKYBLUE = 0xEBCE87
Global Const $CLR_SLATEBLUE = 0xCD5A6A
Global Const $CLR_SLATEGRAY = 0x908070
Global Const $CLR_SNOW = 0xFAFAFF
Global Const $CLR_SPRINGGREEN = 0x7FFF00
Global Const $CLR_STEELBLUE = 0xB48246
Global Const $CLR_TAN = 0x8CB4D2
Global Const $CLR_TEAL = 0x808000
Global Const $CLR_THISTLE = 0xD8BFD8
Global Const $CLR_TOMATO = 0x4763FF
Global Const $CLR_TURQUOISE = 0xD0E040
Global Const $CLR_VIOLET = 0xEE82EE
Global Const $CLR_WHEAT = 0xB3DEF5
Global Const $CLR_WHITE = 0xFFFFFF
Global Const $CLR_WHITESMOKE = 0xF5F5F5
Global Const $CLR_YELLOW = 0x00FFFF
Global Const $CLR_YELLOWGREEN = 0x32CD9A
Global Const $CC_ANYCOLOR = 0x0100
Global Const $CC_FULLOPEN = 0x0002
Global Const $CC_RGBINIT = 0x0001
Global Const $DDL_ARCHIVE = 0x00000020
Global Const $DDL_DIRECTORY = 0x00000010
Global Const $DDL_DRIVES = 0x00004000
Global Const $DDL_EXCLUSIVE = 0x00008000
Global Const $DDL_HIDDEN = 0x00000002
Global Const $DDL_READONLY = 0x00000001
Global Const $DDL_READWRITE = 0x00000000
Global Const $DDL_SYSTEM = 0x00000004
Global Const $FC_NOOVERWRITE = 0
Global Const $FC_OVERWRITE = 1
Global Const $FC_CREATEPATH = 8
Global Const $FT_MODIFIED = 0
Global Const $FT_CREATED = 1
Global Const $FT_ACCESSED = 2
Global Const $FT_ARRAY = 0
Global Const $FT_STRING = 1
Global Const $FT_MSEC = 2
Global Const $FT_UTC = 4
Global Const $FSF_CREATEBUTTON = 1
Global Const $FSF_NEWDIALOG = 2
Global Const $FSF_EDITCONTROL = 4
Global Const $FT_NONRECURSIVE = 0
Global Const $FT_RECURSIVE = 1
Global Const $FO_READ = 0
Global Const $FO_APPEND = 1
Global Const $FO_OVERWRITE = 2
Global Const $FO_CREATEPATH = 8
Global Const $FO_BINARY = 16
Global Const $FO_UNICODE = 32
Global Const $FO_UTF16_LE = 32
Global Const $FO_UTF16_BE = 64
Global Const $FO_UTF8 = 128
Global Const $FO_UTF8_NOBOM = 256
Global Const $FO_ANSI = 512
Global Const $FO_UTF16_LE_NOBOM = 1024
Global Const $FO_UTF16_BE_NOBOM = 2048
Global Const $FO_UTF8_FULL = 16384
Global Const $FO_FULLFILE_DETECT = 16384
Global Const $EOF = -1
Global Const $FD_FILEMUSTEXIST = 1
Global Const $FD_PATHMUSTEXIST = 2
Global Const $FD_MULTISELECT = 4
Global Const $FD_PROMPTCREATENEW = 8
Global Const $FD_PROMPTOVERWRITE = 16
Global Const $CREATE_NEW = 1
Global Const $CREATE_ALWAYS = 2
Global Const $OPEN_EXISTING = 3
Global Const $OPEN_ALWAYS = 4
Global Const $TRUNCATE_EXISTING = 5
Global Const $INVALID_SET_FILE_POINTER = -1
Global Const $FILE_BEGIN = 0
Global Const $FILE_CURRENT = 1
Global Const $FILE_END = 2
Global Const $FILE_ATTRIBUTE_READONLY = 0x00000001
Global Const $FILE_ATTRIBUTE_HIDDEN = 0x00000002
Global Const $FILE_ATTRIBUTE_SYSTEM = 0x00000004
Global Const $FILE_ATTRIBUTE_DIRECTORY = 0x00000010
Global Const $FILE_ATTRIBUTE_ARCHIVE = 0x00000020
Global Const $FILE_ATTRIBUTE_DEVICE = 0x00000040
Global Const $FILE_ATTRIBUTE_NORMAL = 0x00000080
Global Const $FILE_ATTRIBUTE_TEMPORARY = 0x00000100
Global Const $FILE_ATTRIBUTE_SPARSE_FILE = 0x00000200
Global Const $FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400
Global Const $FILE_ATTRIBUTE_COMPRESSED = 0x00000800
Global Const $FILE_ATTRIBUTE_OFFLINE = 0x00001000
Global Const $FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x00002000
Global Const $FILE_ATTRIBUTE_ENCRYPTED = 0x00004000
Global Const $FILE_SHARE_READ = 0x00000001
Global Const $FILE_SHARE_WRITE = 0x00000002
Global Const $FILE_SHARE_DELETE = 0x00000004
Global Const $FILE_SHARE_READWRITE = BitOR($FILE_SHARE_READ, $FILE_SHARE_WRITE)
Global Const $FILE_SHARE_ANY = BitOR($FILE_SHARE_READ, $FILE_SHARE_WRITE, $FILE_SHARE_DELETE)
Global Const $GENERIC_ALL = 0x10000000
Global Const $GENERIC_EXECUTE = 0x20000000
Global Const $GENERIC_WRITE = 0x40000000
Global Const $GENERIC_READ = 0x80000000
Global Const $GENERIC_READWRITE = BitOR($GENERIC_READ, $GENERIC_WRITE)
Global Const $FILE_ENCODING_UTF16LE = 32
Global Const $FE_ENTIRE_UTF8 = 1
Global Const $FE_PARTIALFIRST_UTF8 = 2
Global Const $FN_FULLPATH = 0
Global Const $FN_RELATIVEPATH = 1
Global Const $FV_COMMENTS = "Comments"
Global Const $FV_COMPANYNAME = "CompanyName"
Global Const $FV_FILEDESCRIPTION = "FileDescription"
Global Const $FV_FILEVERSION = "FileVersion"
Global Const $FV_INTERNALNAME = "InternalName"
Global Const $FV_LEGALCOPYRIGHT = "LegalCopyright"
Global Const $FV_LEGALTRADEMARKS = "LegalTrademarks"
Global Const $FV_ORIGINALFILENAME = "OriginalFilename"
Global Const $FV_PRODUCTNAME = "ProductName"
Global Const $FV_PRODUCTVERSION = "ProductVersion"
Global Const $FV_PRIVATEBUILD = "PrivateBuild"
Global Const $FV_SPECIALBUILD = "SpecialBuild"
Global Const $FRTA_NOCOUNT = 0
Global Const $FRTA_COUNT = 1
Global Const $FRTA_INTARRAYS = 2
Global Const $FRTA_ENTIRESPLIT = 4
Global Const $FLTA_FILESFOLDERS = 0
Global Const $FLTA_FILES = 1
Global Const $FLTA_FOLDERS = 2
Global Const $FLTAR_FILESFOLDERS = 0
Global Const $FLTAR_FILES = 1
Global Const $FLTAR_FOLDERS = 2
Global Const $FLTAR_NOHIDDEN = 4
Global Const $FLTAR_NOSYSTEM = 8
Global Const $FLTAR_NOLINK = 16
Global Const $FLTAR_NORECUR = 0
Global Const $FLTAR_RECUR = 1
Global Const $FLTAR_NOSORT = 0
Global Const $FLTAR_SORT = 1
Global Const $FLTAR_FASTSORT = 2
Global Const $FLTAR_NOPATH = 0
Global Const $FLTAR_RELPATH = 1
Global Const $FLTAR_FULLPATH = 2
Global Const $PATH_ORIGINAL = 0
Global Const $PATH_DRIVE = 1
Global Const $PATH_DIRECTORY = 2
Global Const $PATH_FILENAME = 3
Global Const $PATH_EXTENSION = 4
Global Const $PROCESS_TERMINATE = 0x00000001
Global Const $PROCESS_CREATE_THREAD = 0x00000002
Global Const $PROCESS_SET_SESSIONID = 0x00000004
Global Const $PROCESS_VM_OPERATION = 0x00000008
Global Const $PROCESS_VM_READ = 0x00000010
Global Const $PROCESS_VM_WRITE = 0x00000020
Global Const $PROCESS_DUP_HANDLE = 0x00000040
Global Const $PROCESS_CREATE_PROCESS = 0x00000080
Global Const $PROCESS_SET_QUOTA = 0x00000100
Global Const $PROCESS_SET_INFORMATION = 0x00000200
Global Const $PROCESS_QUERY_INFORMATION = 0x00000400
Global Const $PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
Global Const $PROCESS_SUSPEND_RESUME = 0x00000800
Global Const $PROCESS_ALL_ACCESS = 0x001F0FFF
Global Const $TRAY_ITEM_EXIT = 3
Global Const $TRAY_ITEM_PAUSE = 4
Global Const $TRAY_ITEM_FIRST = 7
Global Const $TRAY_CHECKED = 1
Global Const $TRAY_UNCHECKED = 4
Global Const $TRAY_ENABLE = 64
Global Const $TRAY_DISABLE = 128
Global Const $TRAY_FOCUS = 256
Global Const $TRAY_DEFAULT = 512
Global Const $TRAY_EVENT_NONE = 0
Global Const $TRAY_EVENT_SHOWICON = -3
Global Const $TRAY_EVENT_HIDEICON = -4
Global Const $TRAY_EVENT_FLASHICON = -5
Global Const $TRAY_EVENT_NOFLASHICON = -6
Global Const $TRAY_EVENT_PRIMARYDOWN = -7
Global Const $TRAY_EVENT_PRIMARYUP = -8
Global Const $TRAY_EVENT_SECONDARYDOWN = -9
Global Const $TRAY_EVENT_SECONDARYUP = -10
Global Const $TRAY_EVENT_MOUSEOVER = -11
Global Const $TRAY_EVENT_MOUSEOUT = -12
Global Const $TRAY_EVENT_PRIMARYDOUBLE = -13
Global Const $TRAY_EVENT_SECONDARYDOUBLE = -14
Global Const $TIP_ICONNONE = 0
Global Const $TIP_ICONASTERISK = 1
Global Const $TIP_ICONEXCLAMATION = 2
Global Const $TIP_ICONHAND = 3
Global Const $TIP_NOSOUND = 16
Global Const $TRAY_ITEM_NORMAL = 0
Global Const $TRAY_ITEM_RADIO = 1
Global Const $TRAY_CLICK_SHOW = 0
Global Const $TRAY_CLICK_PRIMARYDOWN = 1
Global Const $TRAY_CLICK_PRIMARYUP = 2
Global Const $TRAY_DBLCLICK_PRIMARY = 4
Global Const $TRAY_CLICK_SECONDARYDOWN = 8
Global Const $TRAY_CLICK_SECONDARYUP = 16
Global Const $TRAY_DBLCLICK_SECONDARY = 32
Global Const $TRAY_CLICK_HOVERING = 64
Global Const $TRAY_ICONSTATE_SHOW = 1
Global Const $TRAY_ICONSTATE_HIDE = 2
Global Const $TRAY_ICONSTATE_FLASH = 4
Global Const $TRAY_ICONSTATE_STOPFLASH = 8
Global Const $TRAY_ICONSTATE_RESET = 16
Global Const $FW_DONTCARE = 0
Global Const $FW_THIN = 100
Global Const $FW_EXTRALIGHT = 200
Global Const $FW_ULTRALIGHT = 200
Global Const $FW_LIGHT = 300
Global Const $FW_NORMAL = 400
Global Const $FW_REGULAR = 400
Global Const $FW_MEDIUM = 500
Global Const $FW_SEMIBOLD = 600
Global Const $FW_DEMIBOLD = 600
Global Const $FW_BOLD = 700
Global Const $FW_EXTRABOLD = 800
Global Const $FW_ULTRABOLD = 800
Global Const $FW_HEAVY = 900
Global Const $FW_BLACK = 900
Global Const $CF_EFFECTS = 0x100
Global Const $CF_PRINTERFONTS = 0x2
Global Const $CF_SCREENFONTS = 0x1
Global Const $CF_NOSCRIPTSEL = 0x800000
Global Const $CF_INITTOLOGFONTSTRUCT = 0x40
Global Const $LOGPIXELSX = 88
Global Const $LOGPIXELSY = 90
Global Const $ANSI_CHARSET = 0
Global Const $ARABIC_CHARSET = 178
Global Const $BALTIC_CHARSET = 186
Global Const $CHINESEBIG5_CHARSET = 136
Global Const $DEFAULT_CHARSET = 1
Global Const $EASTEUROPE_CHARSET = 238
Global Const $GB2312_CHARSET = 134
Global Const $GREEK_CHARSET = 161
Global Const $HANGEUL_CHARSET = 129
Global Const $HEBREW_CHARSET = 177
Global Const $JOHAB_CHARSET = 130
Global Const $MAC_CHARSET = 77
Global Const $OEM_CHARSET = 255
Global Const $RUSSIAN_CHARSET = 204
Global Const $SHIFTJIS_CHARSET = 128
Global Const $SYMBOL_CHARSET = 2
Global Const $THAI_CHARSET = 222
Global Const $TURKISH_CHARSET = 162
Global Const $VIETNAMESE_CHARSET = 163
Global Const $OUT_CHARACTER_PRECIS = 2
Global Const $OUT_DEFAULT_PRECIS = 0
Global Const $OUT_DEVICE_PRECIS = 5
Global Const $OUT_OUTLINE_PRECIS = 8
Global Const $OUT_PS_ONLY_PRECIS = 10
Global Const $OUT_RASTER_PRECIS = 6
Global Const $OUT_STRING_PRECIS = 1
Global Const $OUT_STROKE_PRECIS = 3
Global Const $OUT_TT_ONLY_PRECIS = 7
Global Const $OUT_TT_PRECIS = 4
Global Const $CLIP_CHARACTER_PRECIS = 1
Global Const $CLIP_DEFAULT_PRECIS = 0
Global Const $CLIP_DFA_DISABLE = 0x0030
Global Const $CLIP_EMBEDDED = 128
Global Const $CLIP_LH_ANGLES = 16
Global Const $CLIP_MASK = 0xF
Global Const $CLIP_DFA_OVERRIDE = 0x0040
Global Const $CLIP_STROKE_PRECIS = 2
Global Const $CLIP_TT_ALWAYS = 32
Global Const $ANTIALIASED_QUALITY = 4
Global Const $DEFAULT_QUALITY = 0
Global Const $DRAFT_QUALITY = 1
Global Const $NONANTIALIASED_QUALITY = 3
Global Const $PROOF_QUALITY = 2
Global Const $CLEARTYPE_QUALITY = 5
Global Const $DEFAULT_PITCH = 0
Global Const $FIXED_PITCH = 1
Global Const $VARIABLE_PITCH = 2
Global Const $FF_DECORATIVE = 80
Global Const $FF_DONTCARE = 0
Global Const $FF_MODERN = 48
Global Const $FF_ROMAN = 16
Global Const $FF_SCRIPT = 64
Global Const $FF_SWISS = 32
Global Const $FS_REGULAR = 0x00
Global Const $FS_BOLD = 0x01
Global Const $FS_ITALIC = 0x02
Global Const $GUI_EVENT_SINGLE = 0
Global Const $GUI_EVENT_ARRAY = 1
Global Const $GUI_EVENT_NONE = 0
Global Const $GUI_EVENT_CLOSE = -3
Global Const $GUI_EVENT_MINIMIZE = -4
Global Const $GUI_EVENT_RESTORE = -5
Global Const $GUI_EVENT_MAXIMIZE = -6
Global Const $GUI_EVENT_PRIMARYDOWN = -7
Global Const $GUI_EVENT_PRIMARYUP = -8
Global Const $GUI_EVENT_SECONDARYDOWN = -9
Global Const $GUI_EVENT_SECONDARYUP = -10
Global Const $GUI_EVENT_MOUSEMOVE = -11
Global Const $GUI_EVENT_RESIZED = -12
Global Const $GUI_EVENT_DROPPED = -13
Global Const $GUI_RUNDEFMSG = 'GUI_RUNDEFMSG'
Global Const $GUI_AVISTOP = 0
Global Const $GUI_AVISTART = 1
Global Const $GUI_AVICLOSE = 2
Global Const $GUI_CHECKED = 1
Global Const $GUI_INDETERMINATE = 2
Global Const $GUI_UNCHECKED = 4
Global Const $GUI_DROPACCEPTED = 8
Global Const $GUI_NODROPACCEPTED = 4096
Global Const $GUI_ACCEPTFILES = $GUI_DROPACCEPTED
Global Const $GUI_SHOW = 16
Global Const $GUI_HIDE = 32
Global Const $GUI_ENABLE = 64
Global Const $GUI_DISABLE = 128
Global Const $GUI_FOCUS = 256
Global Const $GUI_NOFOCUS = 8192
Global Const $GUI_DEFBUTTON = 512
Global Const $GUI_EXPAND = 1024
Global Const $GUI_ONTOP = 2048
Global Const $GUI_FONTNORMAL = 0
Global Const $GUI_FONTITALIC = 2
Global Const $GUI_FONTUNDER = 4
Global Const $GUI_FONTSTRIKE = 8
Global Const $GUI_DOCKAUTO = 0x0001
Global Const $GUI_DOCKLEFT = 0x0002
Global Const $GUI_DOCKRIGHT = 0x0004
Global Const $GUI_DOCKHCENTER = 0x0008
Global Const $GUI_DOCKTOP = 0x0020
Global Const $GUI_DOCKBOTTOM = 0x0040
Global Const $GUI_DOCKVCENTER = 0x0080
Global Const $GUI_DOCKWIDTH = 0x0100
Global Const $GUI_DOCKHEIGHT = 0x0200
Global Const $GUI_DOCKSIZE = 0x0300
Global Const $GUI_DOCKMENUBAR = 0x0220
Global Const $GUI_DOCKSTATEBAR = 0x0240
Global Const $GUI_DOCKALL = 0x0322
Global Const $GUI_DOCKBORDERS = 0x0066
Global Const $GUI_GR_CLOSE = 1
Global Const $GUI_GR_LINE = 2
Global Const $GUI_GR_BEZIER = 4
Global Const $GUI_GR_MOVE = 6
Global Const $GUI_GR_COLOR = 8
Global Const $GUI_GR_RECT = 10
Global Const $GUI_GR_ELLIPSE = 12
Global Const $GUI_GR_PIE = 14
Global Const $GUI_GR_DOT = 16
Global Const $GUI_GR_PIXEL = 18
Global Const $GUI_GR_HINT = 20
Global Const $GUI_GR_REFRESH = 22
Global Const $GUI_GR_PENSIZE = 24
Global Const $GUI_GR_NOBKCOLOR = -2
Global Const $GUI_BKCOLOR_DEFAULT = -1
Global Const $GUI_BKCOLOR_TRANSPARENT = -2
Global Const $GUI_BKCOLOR_LV_ALTERNATE = 0xFE000000
Global Const $GUI_READ_DEFAULT = 0
Global Const $GUI_READ_EXTENDED = 1
Global Const $GUI_CURSOR_NOOVERRIDE = 0
Global Const $GUI_CURSOR_OVERRIDE = 1
Global Const $GUI_WS_EX_PARENTDRAG = 0x00100000
Global Const $CB_ERR = -1
Global Const $CB_ERRATTRIBUTE = -3
Global Const $CB_ERRREQUIRED = -4
Global Const $CB_ERRSPACE = -2
Global Const $CB_OKAY = 0
Global Const $STATE_SYSTEM_INVISIBLE = 0x8000
Global Const $STATE_SYSTEM_PRESSED = 0x8
Global Const $CBS_AUTOHSCROLL = 0x40
Global Const $CBS_DISABLENOSCROLL = 0x800
Global Const $CBS_DROPDOWN = 0x2
Global Const $CBS_DROPDOWNLIST = 0x3
Global Const $CBS_HASSTRINGS = 0x200
Global Const $CBS_LOWERCASE = 0x4000
Global Const $CBS_NOINTEGRALHEIGHT = 0x400
Global Const $CBS_OEMCONVERT = 0x80
Global Const $CBS_OWNERDRAWFIXED = 0x10
Global Const $CBS_OWNERDRAWVARIABLE = 0x20
Global Const $CBS_SIMPLE = 0x1
Global Const $CBS_SORT = 0x100
Global Const $CBS_UPPERCASE = 0x2000
Global Const $CBM_FIRST = 0x1700
Global Const $CB_ADDSTRING = 0x143
Global Const $CB_DELETESTRING = 0x144
Global Const $CB_DIR = 0x145
Global Const $CB_FINDSTRING = 0x14C
Global Const $CB_FINDSTRINGEXACT = 0x158
Global Const $CB_GETCOMBOBOXINFO = 0x164
Global Const $CB_GETCOUNT = 0x146
Global Const $CB_GETCUEBANNER = ($CBM_FIRST + 4)
Global Const $CB_GETCURSEL = 0x147
Global Const $CB_GETDROPPEDCONTROLRECT = 0x152
Global Const $CB_GETDROPPEDSTATE = 0x157
Global Const $CB_GETDROPPEDWIDTH = 0X15f
Global Const $CB_GETEDITSEL = 0x140
Global Const $CB_GETEXTENDEDUI = 0x156
Global Const $CB_GETHORIZONTALEXTENT = 0x15d
Global Const $CB_GETITEMDATA = 0x150
Global Const $CB_GETITEMHEIGHT = 0x154
Global Const $CB_GETLBTEXT = 0x148
Global Const $CB_GETLBTEXTLEN = 0x149
Global Const $CB_GETLOCALE = 0x15A
Global Const $CB_GETMINVISIBLE = 0x1702
Global Const $CB_GETTOPINDEX = 0x15b
Global Const $CB_INITSTORAGE = 0x161
Global Const $CB_LIMITTEXT = 0x141
Global Const $CB_RESETCONTENT = 0x14B
Global Const $CB_INSERTSTRING = 0x14A
Global Const $CB_SELECTSTRING = 0x14D
Global Const $CB_SETCUEBANNER = ($CBM_FIRST + 3)
Global Const $CB_SETCURSEL = 0x14E
Global Const $CB_SETDROPPEDWIDTH = 0x160
Global Const $CB_SETEDITSEL = 0x142
Global Const $CB_SETEXTENDEDUI = 0x155
Global Const $CB_SETHORIZONTALEXTENT = 0x15e
Global Const $CB_SETITEMDATA = 0x151
Global Const $CB_SETITEMHEIGHT = 0x153
Global Const $CB_SETLOCALE = 0x159
Global Const $CB_SETMINVISIBLE = 0x1701
Global Const $CB_SETTOPINDEX = 0x15c
Global Const $CB_SHOWDROPDOWN = 0x14F
Global Const $CBN_CLOSEUP = 8
Global Const $CBN_DBLCLK = 2
Global Const $CBN_DROPDOWN = 7
Global Const $CBN_EDITCHANGE = 5
Global Const $CBN_EDITUPDATE = 6
Global Const $CBN_ERRSPACE = (-1)
Global Const $CBN_KILLFOCUS = 4
Global Const $CBN_SELCHANGE = 1
Global Const $CBN_SELENDCANCEL = 10
Global Const $CBN_SELENDOK = 9
Global Const $CBN_SETFOCUS = 3
Global Const $CBES_EX_CASESENSITIVE = 0x10
Global Const $CBES_EX_NOEDITIMAGE = 0x1
Global Const $CBES_EX_NOEDITIMAGEINDENT = 0x2
Global Const $CBES_EX_NOSIZELIMIT = 0x8
Global Const $__COMBOBOXCONSTANT_WM_USER = 0X400
Global Const $CBEM_DELETEITEM = $CB_DELETESTRING
Global Const $CBEM_GETCOMBOCONTROL = ($__COMBOBOXCONSTANT_WM_USER + 6)
Global Const $CBEM_GETEDITCONTROL = ($__COMBOBOXCONSTANT_WM_USER + 7)
Global Const $CBEM_GETEXSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 9)
Global Const $CBEM_GETEXTENDEDSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 9)
Global Const $CBEM_GETIMAGELIST = ($__COMBOBOXCONSTANT_WM_USER + 3)
Global Const $CBEM_GETITEMA = ($__COMBOBOXCONSTANT_WM_USER + 4)
Global Const $CBEM_GETITEMW = ($__COMBOBOXCONSTANT_WM_USER + 13)
Global Const $CBEM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $CBEM_HASEDITCHANGED = ($__COMBOBOXCONSTANT_WM_USER + 10)
Global Const $CBEM_INSERTITEMA = ($__COMBOBOXCONSTANT_WM_USER + 1)
Global Const $CBEM_INSERTITEMW = ($__COMBOBOXCONSTANT_WM_USER + 11)
Global Const $CBEM_SETEXSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 8)
Global Const $CBEM_SETEXTENDEDSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 14)
Global Const $CBEM_SETIMAGELIST = ($__COMBOBOXCONSTANT_WM_USER + 2)
Global Const $CBEM_SETITEMA = ($__COMBOBOXCONSTANT_WM_USER + 5)
Global Const $CBEM_SETITEMW = ($__COMBOBOXCONSTANT_WM_USER + 12)
Global Const $CBEM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $CBEM_SETWINDOWTHEME = 0x2000 + 11
Global Const $CBEN_FIRST = (-800)
Global Const $CBEN_LAST = (-830)
Global Const $CBEN_BEGINEDIT = ($CBEN_FIRST - 4)
Global Const $CBEN_DELETEITEM = ($CBEN_FIRST - 2)
Global Const $CBEN_DRAGBEGINA = ($CBEN_FIRST - 8)
Global Const $CBEN_DRAGBEGINW = ($CBEN_FIRST - 9)
Global Const $CBEN_ENDEDITA = ($CBEN_FIRST - 5)
Global Const $CBEN_ENDEDITW = ($CBEN_FIRST - 6)
Global Const $CBEN_GETDISPINFO = ($CBEN_FIRST - 0)
Global Const $CBEN_GETDISPINFOA = ($CBEN_FIRST - 0)
Global Const $CBEN_GETDISPINFOW = ($CBEN_FIRST - 7)
Global Const $CBEN_INSERTITEM = ($CBEN_FIRST - 1)
Global Const $CBEIF_DI_SETITEM = 0x10000000
Global Const $CBEIF_IMAGE = 0x2
Global Const $CBEIF_INDENT = 0x10
Global Const $CBEIF_LPARAM = 0x20
Global Const $CBEIF_OVERLAY = 0x8
Global Const $CBEIF_SELECTEDIMAGE = 0x4
Global Const $CBEIF_TEXT = 0x1
Global Const $GUI_SS_DEFAULT_COMBO = 0x00200042
Func _SendMessage($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iReturn = 0, $wParamType = "wparam", $lParamType = "lparam", $sReturnType = "lresult")
Local $aCall = DllCall("user32.dll", $sReturnType, "SendMessageW", "hwnd", $hWnd, "uint", $iMsg, $wParamType, $wParam, $lParamType, $lParam)
If @error Then Return SetError(@error, @extended, "")
If $iReturn >= 0 And $iReturn <= 4 Then Return $aCall[$iReturn]
Return $aCall
EndFunc
Func _SendMessageA($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iReturn = 0, $wParamType = "wparam", $lParamType = "lparam", $sReturnType = "lresult")
Local $aCall = DllCall("user32.dll", $sReturnType, "SendMessageA", "hwnd", $hWnd, "uint", $iMsg, $wParamType, $wParam, $lParamType, $lParam)
If @error Then Return SetError(@error, @extended, "")
If $iReturn >= 0 And $iReturn <= 4 Then Return $aCall[$iReturn]
Return $aCall
EndFunc
Global Const $tagPOINT = "struct;long X;long Y;endstruct"
Global Const $tagRECT = "struct;long Left;long Top;long Right;long Bottom;endstruct"
Global Const $tagSIZE = "struct;long X;long Y;endstruct"
Global Const $tagMARGINS = "int cxLeftWidth;int cxRightWidth;int cyTopHeight;int cyBottomHeight"
Global Const $tagFILETIME = "struct;dword Lo;dword Hi;endstruct"
Global Const $tagSYSTEMTIME = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
Global Const $tagTIME_ZONE_INFORMATION = "struct;long Bias;wchar StdName[32];word StdDate[8];long StdBias;wchar DayName[32];word DayDate[8];long DayBias;endstruct"
Global Const $tagNMHDR = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
Global Const $tagCOMBOBOXEXITEM = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" &  "int Indent;lparam Param"
Global Const $tagNMCBEDRAGBEGIN = $tagNMHDR & ";int ItemID;wchar szText[260]"
Global Const $tagNMCBEENDEDIT = $tagNMHDR & ";bool fChanged;int NewSelection;wchar szText[260];int Why"
Global Const $tagNMCOMBOBOXEX = $tagNMHDR & ";uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;" &  "int SelectedImage;int OverlayImage;int Indent;lparam Param"
Global Const $tagDTPRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;" &  "word MinSecond;word MinMSecond;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;" &  "word MaxMinute;word MaxSecond;word MaxMSecond;bool MinValid;bool MaxValid"
Global Const $tagNMDATETIMECHANGE = $tagNMHDR & ";dword Flag;" & $tagSYSTEMTIME
Global Const $tagNMDATETIMEFORMAT = $tagNMHDR & ";ptr Format;" & $tagSYSTEMTIME & ";ptr pDisplay;wchar Display[64]"
Global Const $tagNMDATETIMEFORMATQUERY = $tagNMHDR & ";ptr Format;struct;long SizeX;long SizeY;endstruct"
Global Const $tagNMDATETIMEKEYDOWN = $tagNMHDR & ";int VirtKey;ptr Format;" & $tagSYSTEMTIME
Global Const $tagNMDATETIMESTRING = $tagNMHDR & ";ptr UserString;" & $tagSYSTEMTIME & ";dword Flags"
Global Const $tagEVENTLOGRECORD = "dword Length;dword Reserved;dword RecordNumber;dword TimeGenerated;dword TimeWritten;dword EventID;" &  "word EventType;word NumStrings;word EventCategory;word ReservedFlags;dword ClosingRecordNumber;dword StringOffset;" &  "dword UserSidLength;dword UserSidOffset;dword DataLength;dword DataOffset"
Global Const $tagGDIP_EFFECTPARAMS_Blur = "float Radius; bool ExpandEdge"
Global Const $tagGDIP_EFFECTPARAMS_BrightnessContrast = "int BrightnessLevel; int ContrastLevel"
Global Const $tagGDIP_EFFECTPARAMS_ColorBalance = "int CyanRed; int MagentaGreen; int YellowBlue"
Global Const $tagGDIP_EFFECTPARAMS_ColorCurve = "int Adjustment; int Channel; int AdjustValue"
Global Const $tagGDIP_EFFECTPARAMS_ColorLUT = "byte LutB[256]; byte LutG[256]; byte LutR[256]; byte LutA[256]"
Global Const $tagGDIP_EFFECTPARAMS_HueSaturationLightness = "int HueLevel; int SaturationLevel; int LightnessLevel"
Global Const $tagGDIP_EFFECTPARAMS_Levels = "int Highlight; int Midtone; int Shadow"
Global Const $tagGDIP_EFFECTPARAMS_RedEyeCorrection = "uint NumberOfAreas; ptr Areas"
Global Const $tagGDIP_EFFECTPARAMS_Sharpen = "float Radius; float Amount"
Global Const $tagGDIP_EFFECTPARAMS_Tint = "int Hue; int Amount"
Global Const $tagGDIPBITMAPDATA = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
Global Const $tagGDIPCOLORMATRIX = "float m[25]"
Global Const $tagGDIPENCODERPARAM = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
Global Const $tagGDIPENCODERPARAMS = "uint Count;" & $tagGDIPENCODERPARAM
Global Const $tagGDIPRECTF = "struct;float X;float Y;float Width;float Height;endstruct"
Global Const $tagGDIPSTARTUPINPUT = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
Global Const $tagGDIPSTARTUPOUTPUT = "ptr HookProc;ptr UnhookProc"
Global Const $tagGDIPIMAGECODECINFO = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" &  "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
Global Const $tagGDIPPENCODERPARAMS = "uint Count;byte Params[1]"
Global Const $tagHDITEM = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
Global Const $tagNMHDDISPINFO = $tagNMHDR & ";int Item;uint Mask;ptr Text;int TextMax;int Image;lparam lParam"
Global Const $tagNMHDFILTERBTNCLICK = $tagNMHDR & ";int Item;" & $tagRECT
Global Const $tagNMHEADER = $tagNMHDR & ";int Item;int Button;ptr pItem"
Global Const $tagGETIPAddress = "byte Field4;byte Field3;byte Field2;byte Field1"
Global Const $tagNMIPADDRESS = $tagNMHDR & ";int Field;int Value"
Global Const $tagLVFINDINFO = "struct;uint Flags;ptr Text;lparam Param;" & $tagPOINT & ";uint Direction;endstruct"
Global Const $tagLVHITTESTINFO = $tagPOINT & ";uint Flags;int Item;int SubItem;int iGroup"
Global Const $tagLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" &  "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
Global Const $tagNMLISTVIEW = $tagNMHDR & ";int Item;int SubItem;uint NewState;uint OldState;uint Changed;" &  "struct;long ActionX;long ActionY;endstruct;lparam Param"
Global Const $tagNMLVCUSTOMDRAW = "struct;" & $tagNMHDR & ";dword dwDrawStage;handle hdc;" & $tagRECT &  ";dword_ptr dwItemSpec;uint uItemState;lparam lItemlParam;endstruct" &  ";dword clrText;dword clrTextBk;int iSubItem;dword dwItemType;dword clrFace;int iIconEffect;" &  "int iIconPhase;int iPartID;int iStateID;struct;long TextLeft;long TextTop;long TextRight;long TextBottom;endstruct;uint uAlign"
Global Const $tagNMLVDISPINFO = $tagNMHDR & ";" & $tagLVITEM
Global Const $tagNMLVFINDITEM = $tagNMHDR & ";int Start;" & $tagLVFINDINFO
Global Const $tagNMLVGETINFOTIP = $tagNMHDR & ";dword Flags;ptr Text;int TextMax;int Item;int SubItem;lparam lParam"
Global Const $tagNMITEMACTIVATE = $tagNMHDR & ";int Index;int SubItem;uint NewState;uint OldState;uint Changed;" &  $tagPOINT & ";lparam lParam;uint KeyFlags"
Global Const $tagNMLVKEYDOWN = $tagNMHDR & ";align 2;word VKey;uint Flags"
Global Const $tagNMLVSCROLL = $tagNMHDR & ";int DX;int DY"
Global Const $tagMCHITTESTINFO = "uint Size;" & $tagPOINT & ";uint Hit;" & $tagSYSTEMTIME &  ";" & $tagRECT & ";int iOffset;int iRow;int iCol"
Global Const $tagMCMONTHRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" &  "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" &  "word MaxMSeconds;short Span"
Global Const $tagMCRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" &  "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" &  "word MaxMSeconds;short MinSet;short MaxSet"
Global Const $tagMCSELRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" &  "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" &  "word MaxMSeconds"
Global Const $tagNMDAYSTATE = $tagNMHDR & ";" & $tagSYSTEMTIME & ";int DayState;ptr pDayState"
Global Const $tagNMSELCHANGE = $tagNMHDR &  ";struct;word BegYear;word BegMonth;word BegDOW;word BegDay;word BegHour;word BegMinute;word BegSecond;word BegMSeconds;endstruct;" &  "struct;word EndYear;word EndMonth;word EndDOW;word EndDay;word EndHour;word EndMinute;word EndSecond;word EndMSeconds;endstruct"
Global Const $tagNMOBJECTNOTIFY = $tagNMHDR & ";int Item;ptr piid;ptr pObject;long Result;dword dwFlags"
Global Const $tagNMTCKEYDOWN = $tagNMHDR & ";align 2;word VKey;uint Flags"
Global Const $tagTVITEM = "struct;uint Mask;handle hItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;int SelectedImage;" &  "int Children;lparam Param;endstruct"
Global Const $tagTVITEMEX = "struct;" & $tagTVITEM & ";int Integral;uint uStateEx;hwnd hwnd;int iExpandedImage;int iReserved;endstruct"
Global Const $tagNMTREEVIEW = $tagNMHDR & ";uint Action;" &  "struct;uint OldMask;handle OldhItem;uint OldState;uint OldStateMask;" &  "ptr OldText;int OldTextMax;int OldImage;int OldSelectedImage;int OldChildren;lparam OldParam;endstruct;" &  "struct;uint NewMask;handle NewhItem;uint NewState;uint NewStateMask;" &  "ptr NewText;int NewTextMax;int NewImage;int NewSelectedImage;int NewChildren;lparam NewParam;endstruct;" &  "struct;long PointX;long PointY;endstruct"
Global Const $tagNMTVCUSTOMDRAW = "struct;" & $tagNMHDR & ";dword DrawStage;handle HDC;" & $tagRECT &  ";dword_ptr ItemSpec;uint ItemState;lparam ItemParam;endstruct" &  ";dword ClrText;dword ClrTextBk;int Level"
Global Const $tagNMTVDISPINFO = $tagNMHDR & ";" & $tagTVITEM
Global Const $tagNMTVGETINFOTIP = $tagNMHDR & ";ptr Text;int TextMax;handle hItem;lparam lParam"
Global Const $tagNMTVITEMCHANGE = $tagNMHDR & ";uint Changed;handle hItem;uint StateNew;uint StateOld;lparam lParam;"
Global Const $tagTVHITTESTINFO = $tagPOINT & ";uint Flags;handle Item"
Global Const $tagNMTVKEYDOWN = $tagNMHDR & ";align 2;word VKey;uint Flags"
Global Const $tagNMMOUSE = $tagNMHDR & ";dword_ptr ItemSpec;dword_ptr ItemData;" & $tagPOINT & ";lparam HitInfo"
Global Const $tagTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
Global Const $tagIMAGEINFO = "handle hBitmap;handle hMask;int Unused1;int Unused2;" & $tagRECT
Global Const $tagMENUINFO = "dword Size;INT Mask;dword Style;uint YMax;handle hBack;dword ContextHelpID;ulong_ptr MenuData"
Global Const $tagMENUITEMINFO = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" &  "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
Global Const $tagREBARBANDINFO = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" &  "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" &  "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" & ((@OSVersion = "WIN_XP") ? "" : ";" & $tagRECT & ";uint uChevronState")
Global Const $tagNMREBARAUTOBREAK = $tagNMHDR & ";uint uBand;uint wID;lparam lParam;uint uMsg;uint fStyleCurrent;bool fAutoBreak"
Global Const $tagNMRBAUTOSIZE = $tagNMHDR & ";bool fChanged;" &  "struct;long TargetLeft;long TargetTop;long TargetRight;long TargetBottom;endstruct;" &  "struct;long ActualLeft;long ActualTop;long ActualRight;long ActualBottom;endstruct"
Global Const $tagNMREBAR = $tagNMHDR & ";dword dwMask;uint uBand;uint fStyle;uint wID;lparam lParam"
Global Const $tagNMREBARCHEVRON = $tagNMHDR & ";uint uBand;uint wID;lparam lParam;" & $tagRECT & ";lparam lParamNM"
Global Const $tagNMREBARCHILDSIZE = $tagNMHDR & ";uint uBand;uint wID;" &  "struct;long CLeft;long CTop;long CRight;long CBottom;endstruct;" &  "struct;long BLeft;long BTop;long BRight;long BBottom;endstruct"
Global Const $tagCOLORSCHEME = "dword Size;dword BtnHighlight;dword BtnShadow"
Global Const $tagNMTOOLBAR = $tagNMHDR & ";int iItem;" &  "struct;int iBitmap;int idCommand;byte fsState;byte fsStyle;dword_ptr dwData;int_ptr iString;endstruct" &  ";int cchText;ptr pszText;" & $tagRECT
Global Const $tagNMTBHOTITEM = $tagNMHDR & ";int idOld;int idNew;dword dwFlags"
Global Const $tagTBBUTTON = "int Bitmap;int Command;byte State;byte Style;dword_ptr Param;int_ptr String"
Global Const $tagTBBUTTONINFO = "uint Size;dword Mask;int Command;int Image;byte State;byte Style;word CX;dword_ptr Param;ptr Text;int TextMax"
Global Const $tagNETRESOURCE = "dword Scope;dword Type;dword DisplayType;dword Usage;ptr LocalName;ptr RemoteName;ptr Comment;ptr Provider"
Global Const $tagOVERLAPPED = "ulong_ptr Internal;ulong_ptr InternalHigh;struct;dword Offset;dword OffsetHigh;endstruct;handle hEvent"
Global Const $tagOPENFILENAME = "dword StructSize;hwnd hwndOwner;handle hInstance;ptr lpstrFilter;ptr lpstrCustomFilter;" &  "dword nMaxCustFilter;dword nFilterIndex;ptr lpstrFile;dword nMaxFile;ptr lpstrFileTitle;dword nMaxFileTitle;" &  "ptr lpstrInitialDir;ptr lpstrTitle;dword Flags;word nFileOffset;word nFileExtension;ptr lpstrDefExt;lparam lCustData;" &  "ptr lpfnHook;ptr lpTemplateName;ptr pvReserved;dword dwReserved;dword FlagsEx"
Global Const $tagBITMAPINFOHEADER = "struct;dword biSize;long biWidth;long biHeight;word biPlanes;word biBitCount;" &  "dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;endstruct"
Global Const $tagBITMAPINFO = $tagBITMAPINFOHEADER & ";dword biRGBQuad[1]"
Global Const $tagBLENDFUNCTION = "byte Op;byte Flags;byte Alpha;byte Format"
Global Const $tagGUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Global Const $tagWINDOWPLACEMENT = "uint length;uint flags;uint showCmd;long ptMinPosition[2];long ptMaxPosition[2];long rcNormalPosition[4]"
Global Const $tagWINDOWPOS = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
Global Const $tagSCROLLINFO = "uint cbSize;uint fMask;int nMin;int nMax;uint nPage;int nPos;int nTrackPos"
Global Const $tagSCROLLBARINFO = "dword cbSize;" & $tagRECT & ";int dxyLineButton;int xyThumbTop;" &  "int xyThumbBottom;int reserved;dword rgstate[6]"
Global Const $tagLOGFONT = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" &  "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
Global Const $tagKBDLLHOOKSTRUCT = "dword vkCode;dword scanCode;dword flags;dword time;ulong_ptr dwExtraInfo"
Global Const $tagPROCESS_INFORMATION = "handle hProcess;handle hThread;dword ProcessID;dword ThreadID"
Global Const $tagSTARTUPINFO = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;" &  "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserved3;handle StdInput;" &  "handle StdOutput;handle StdError"
Global Const $tagSECURITY_ATTRIBUTES = "dword Length;ptr Descriptor;bool InheritHandle"
Global Const $tagWIN32_FIND_DATA = "dword dwFileAttributes;dword ftCreationTime[2];dword ftLastAccessTime[2];dword ftLastWriteTime[2];dword nFileSizeHigh;dword nFileSizeLow;dword dwReserved0;dword dwReserved1;wchar cFileName[260];wchar cAlternateFileName[14]"
Global Const $tagTEXTMETRIC = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" &  "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" &  "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" &  "byte tmPitchAndFamily;byte tmCharSet"
Global Const $_UDF_GlobalIDs_OFFSET = 2
Global Const $_UDF_GlobalID_MAX_WIN = 16
Global Const $_UDF_STARTID = 10000
Global Const $_UDF_GlobalID_MAX_IDS = 55535
Global Const $__UDFGUICONSTANT_WS_TABSTOP = 0x00010000
Global Const $__UDFGUICONSTANT_WS_VISIBLE = 0x10000000
Global Const $__UDFGUICONSTANT_WS_CHILD = 0x40000000
Global $__g_aUDF_GlobalIDs_Used[$_UDF_GlobalID_MAX_WIN][$_UDF_GlobalID_MAX_IDS + $_UDF_GlobalIDs_OFFSET + 1]
Func __UDF_GetNextGlobalID($hWnd)
Local $nCtrlID, $iUsedIndex = -1, $bAllUsed = True
If Not WinExists($hWnd) Then Return SetError(-1, -1, 0)
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] <> 0 Then
If Not WinExists($__g_aUDF_GlobalIDs_Used[$iIndex][0]) Then
For $x = 0 To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
$__g_aUDF_GlobalIDs_Used[$iIndex][$x] = 0
Next
$__g_aUDF_GlobalIDs_Used[$iIndex][1] = $_UDF_STARTID
$bAllUsed = False
EndIf
EndIf
Next
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd Then
$iUsedIndex = $iIndex
ExitLoop
EndIf
Next
If $iUsedIndex = -1 Then
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = 0 Then
$__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd
$__g_aUDF_GlobalIDs_Used[$iIndex][1] = $_UDF_STARTID
$bAllUsed = False
$iUsedIndex = $iIndex
ExitLoop
EndIf
Next
EndIf
If $iUsedIndex = -1 And $bAllUsed Then Return SetError(16, 0, 0)
If $__g_aUDF_GlobalIDs_Used[$iUsedIndex][1] = $_UDF_STARTID + $_UDF_GlobalID_MAX_IDS Then
For $iIDIndex = $_UDF_GlobalIDs_OFFSET To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
If $__g_aUDF_GlobalIDs_Used[$iUsedIndex][$iIDIndex] = 0 Then
$nCtrlID = ($iIDIndex - $_UDF_GlobalIDs_OFFSET) + 10000
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][$iIDIndex] = $nCtrlID
Return $nCtrlID
EndIf
Next
Return SetError(-1, $_UDF_GlobalID_MAX_IDS, 0)
EndIf
$nCtrlID = $__g_aUDF_GlobalIDs_Used[$iUsedIndex][1]
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][1] += 1
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][($nCtrlID - 10000) + $_UDF_GlobalIDs_OFFSET] = $nCtrlID
Return $nCtrlID
EndFunc
Func __UDF_FreeGlobalID($hWnd, $iGlobalID)
If $iGlobalID - $_UDF_STARTID < 0 Or $iGlobalID - $_UDF_STARTID > $_UDF_GlobalID_MAX_IDS Then Return SetError(-1, 0, False)
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd Then
For $x = $_UDF_GlobalIDs_OFFSET To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][$x] = $iGlobalID Then
$__g_aUDF_GlobalIDs_Used[$iIndex][$x] = 0
Return True
EndIf
Next
Return SetError(-3, 0, False)
EndIf
Next
Return SetError(-2, 0, False)
EndFunc
Global $__g_vEnum, $__g_vExt = 0
Global $__g_iRGBMode = 1
Global Const $tagOSVERSIONINFO = 'struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct'
Global Const $IMAGE_BITMAP = 0
Global Const $IMAGE_ICON = 1
Global Const $IMAGE_CURSOR = 2
Global Const $IMAGE_ENHMETAFILE = 3
Global Const $LR_DEFAULTCOLOR = 0x0000
Global Const $LR_MONOCHROME = 0x0001
Global Const $LR_COLOR = 0x0002
Global Const $LR_COPYRETURNORG = 0x0004
Global Const $LR_COPYDELETEORG = 0x0008
Global Const $LR_LOADFROMFILE = 0x0010
Global Const $LR_LOADTRANSPARENT = 0x0020
Global Const $LR_DEFAULTSIZE = 0x0040
Global Const $LR_VGACOLOR = 0x0080
Global Const $LR_LOADMAP3DCOLORS = 0x1000
Global Const $LR_CREATEDIBSECTION = 0x2000
Global Const $LR_COPYFROMRESOURCE = 0x4000
Global Const $LR_SHARED = 0x8000
Global Const $__tagCURSORINFO = "dword Size;dword Flags;handle hCursor;" & "struct;long X;long Y;endstruct"
Func _WinAPI_CreateFile($sFileName, $iCreation, $iAccess = 4, $iShare = 0, $iAttributes = 0, $tSecurity = 0)
Local $iDA = 0, $iSM = 0, $iCD = 0, $iFA = 0
If BitAND($iAccess, 1) <> 0 Then $iDA = BitOR($iDA, $GENERIC_EXECUTE)
If BitAND($iAccess, 2) <> 0 Then $iDA = BitOR($iDA, $GENERIC_READ)
If BitAND($iAccess, 4) <> 0 Then $iDA = BitOR($iDA, $GENERIC_WRITE)
If BitAND($iShare, 1) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_DELETE)
If BitAND($iShare, 2) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_READ)
If BitAND($iShare, 4) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_WRITE)
Switch $iCreation
Case 0
$iCD = $CREATE_NEW
Case 1
$iCD = $CREATE_ALWAYS
Case 2
$iCD = $OPEN_EXISTING
Case 3
$iCD = $OPEN_ALWAYS
Case 4
$iCD = $TRUNCATE_EXISTING
EndSwitch
If BitAND($iAttributes, 1) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_ARCHIVE)
If BitAND($iAttributes, 2) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_HIDDEN)
If BitAND($iAttributes, 4) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_READONLY)
If BitAND($iAttributes, 8) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_SYSTEM)
Local $aCall = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sFileName, "dword", $iDA, "dword", $iSM,  "struct*", $tSecurity, "dword", $iCD, "dword", $iFA, "ptr", 0)
If @error Or ($aCall[0] = Ptr(-1)) Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_FreeLibrary($hModule)
Local $aCall = DllCall("kernel32.dll", "bool", "FreeLibrary", "handle", $hModule)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_GetCursorInfo()
Local $tCursor = DllStructCreate($__tagCURSORINFO)
Local $iCursor = DllStructGetSize($tCursor)
DllStructSetData($tCursor, "Size", $iCursor)
Local $aCall = DllCall("user32.dll", "bool", "GetCursorInfo", "struct*", $tCursor)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aCursor[5]
$aCursor[0] = True
$aCursor[1] = DllStructGetData($tCursor, "Flags") <> 0
$aCursor[2] = DllStructGetData($tCursor, "hCursor")
$aCursor[3] = DllStructGetData($tCursor, "X")
$aCursor[4] = DllStructGetData($tCursor, "Y")
Return $aCursor
EndFunc
Func _WinAPI_GetDlgCtrlID($hWnd)
Local $aCall = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetModuleHandle($sModuleName)
If $sModuleName = "" Then $sModuleName = Null
Local $aCall = DllCall("kernel32.dll", "handle", "GetModuleHandleW", "wstr", $sModuleName)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetString($pString, $bUnicode = True)
Local $iLength = _WinAPI_StrLen($pString, $bUnicode)
If @error Or Not $iLength Then Return SetError(@error + 10, @extended, '')
Local $tString = DllStructCreate(($bUnicode ? 'wchar' : 'char') & '[' & ($iLength + 1) & ']', $pString)
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($iLength, DllStructGetData($tString, 1))
EndFunc
Func _WinAPI_GetVersion()
Local $tOSVI = DllStructCreate($tagOSVERSIONINFO)
DllStructSetData($tOSVI, 1, DllStructGetSize($tOSVI))
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetVersionExW', 'struct*', $tOSVI)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return Number(DllStructGetData($tOSVI, 2) & "." & DllStructGetData($tOSVI, 3), $NUMBER_DOUBLE)
EndFunc
Func _WinAPI_IsWow64Process($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (_WinAPI_GetVersion() < 6.0 ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, False)
Local $aCall = DllCall('kernel32.dll', 'bool', 'IsWow64Process', 'handle', $hProcess[0], 'bool*', 0)
If __CheckErrorCloseHandle($aCall, $hProcess[0]) Then Return SetError(@error, @extended, False)
Return $aCall[2]
EndFunc
Func _WinAPI_LoadImage($hInstance, $sImage, $iType, $iXDesired, $iYDesired, $iLoad)
Local $aCall, $sImageType = "int"
If IsString($sImage) Then $sImageType = "wstr"
$aCall = DllCall("user32.dll", "handle", "LoadImageW", "handle", $hInstance, $sImageType, $sImage, "uint", $iType,  "int", $iXDesired, "int", $iYDesired, "uint", $iLoad)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_LoadLibrary($sFileName)
Local $aCall = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $sFileName)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_PathIsDirectory($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathIsDirectoryW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ReadFile($hFile, $pBuffer, $iToRead, ByRef $iRead, $tOverlapped = 0)
Local $aCall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hFile, "struct*", $pBuffer, "dword", $iToRead,  "dword*", 0, "struct*", $tOverlapped)
If @error Then Return SetError(@error, @extended, False)
$iRead = $aCall[4]
Return $aCall[0]
EndFunc
Func _WinAPI_StrLen($pString, $bUnicode = True)
Local $W = ''
If $bUnicode Then $W = 'W'
Local $aCall = DllCall('kernel32.dll', 'int', 'lstrlen' & $W, 'struct*', $pString)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SwitchColor($iColor)
If $iColor = -1 Then Return $iColor
Return BitOR(BitAND($iColor, 0x00FF00), BitShift(BitAND($iColor, 0x0000FF), -16), BitShift(BitAND($iColor, 0xFF0000), 16))
EndFunc
Func _WinAPI_WriteFile($hFile, $pBuffer, $iToWrite, ByRef $iWritten, $tOverlapped = 0)
Local $aCall = DllCall("kernel32.dll", "bool", "WriteFile", "handle", $hFile, "struct*", $pBuffer, "dword", $iToWrite,  "dword*", 0, "struct*", $tOverlapped)
If @error Then Return SetError(@error, @extended, False)
$iWritten = $aCall[4]
Return $aCall[0]
EndFunc
Func __CheckErrorArrayBounds(Const ByRef $aData, ByRef $iStart, ByRef $iEnd, $nDim = 1, $iDim = $UBOUND_DIMENSIONS)
If Not IsArray($aData) Then Return SetError(1, 0, 1)
If UBound($aData, $iDim) <> $nDim Then Return SetError(2, 0, 1)
If $iStart < 0 Then $iStart = 0
Local $iUBound = UBound($aData) - 1
If $iEnd < 1 Or $iEnd > $iUBound Then $iEnd = $iUBound
If $iStart > $iEnd Then Return SetError(4, 0, 1)
Return 0
EndFunc
Func __CheckErrorCloseHandle($aCall, $hFile, $bLastError = False, $iCurErr = @error, $iCurExt = @extended)
If Not $iCurErr And Not $aCall[0] Then $iCurErr = 10
Local $aLastError = DllCall("kernel32.dll", "dword", "GetLastError")
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $iCurErr Then DllCall("kernel32.dll", "none", "SetLastError", "dword", $aLastError[0])
If $bLastError Then $iCurExt = $aLastError[0]
Return SetError($iCurErr, $iCurExt, $iCurErr)
EndFunc
Func __DLL($sPath, $bPin = False)
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetModuleHandleExW', 'dword', ($bPin ? 0x0001 : 0x0002), "wstr", $sPath, 'ptr*', 0)
If Not $aCall[3] Then
$aCall = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $sPath)
If @error Or Not $aCall[0] Then Return 0
EndIf
Return 1
EndFunc
Func __EnumWindowsProc($hWnd, $bVisible)
Local $aCall
If $bVisible Then
$aCall = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hWnd)
If Not $aCall[0] Then
Return 1
EndIf
EndIf
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = $hWnd
$aCall = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hWnd, "wstr", "", "int", 4096)
$__g_vEnum[$__g_vEnum[0][0]][1] = $aCall[2]
Return 1
EndFunc
Func __FatalExit($iCode, $sText = '')
If $sText Then MsgBox($MB_SYSTEMMODAL, 'AutoIt', $sText)
DllCall('kernel32.dll', 'none', 'FatalExit', 'int', $iCode)
EndFunc
Func __Inc(ByRef $aData, $iIncrement = 100)
Select
Case UBound($aData, $UBOUND_COLUMNS)
If $iIncrement < 0 Then
ReDim $aData[$aData[0][0] + 1][UBound($aData, $UBOUND_COLUMNS)]
Else
$aData[0][0] += 1
If $aData[0][0] > UBound($aData) - 1 Then
ReDim $aData[$aData[0][0] + $iIncrement][UBound($aData, $UBOUND_COLUMNS)]
EndIf
EndIf
Case UBound($aData, $UBOUND_ROWS)
If $iIncrement < 0 Then
ReDim $aData[$aData[0] + 1]
Else
$aData[0] += 1
If $aData[0] > UBound($aData) - 1 Then
ReDim $aData[$aData[0] + $iIncrement]
EndIf
EndIf
Case Else
Return 0
EndSelect
Return 1
EndFunc
Func __RGB($iColor)
If $__g_iRGBMode Then
$iColor = _WinAPI_SwitchColor($iColor)
EndIf
Return $iColor
EndFunc
Func _WinAPI_CharToOem($sStr)
Local $aCall, $sRetStr = "", $nLen = StringLen($sStr) + 1, $iStart = 1
While $iStart < $nLen
$aCall = DllCall('user32.dll', 'bool', 'CharToOemW', 'wstr', StringMid($sStr, $iStart, 65536), 'wstr', '')
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
$iStart += 65536
$sRetStr &= $aCall[2]
WEnd
Return $sRetStr
EndFunc
Func _WinAPI_ClientToScreen($hWnd, ByRef $tPoint)
Local $aCall = DllCall("user32.dll", "bool", "ClientToScreen", "hwnd", $hWnd, "struct*", $tPoint)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPoint
EndFunc
Func _WinAPI_DWordToFloat($iValue)
Local $tDWord = DllStructCreate('dword')
Local $tFloat = DllStructCreate('float', DllStructGetPtr($tDWord))
DllStructSetData($tDWord, 1, $iValue)
Return DllStructGetData($tFloat, 1)
EndFunc
Func _WinAPI_DWordToInt($iValue)
Local $tData = DllStructCreate('int')
DllStructSetData($tData, 1, $iValue)
Return DllStructGetData($tData, 1)
EndFunc
Func _WinAPI_FloatToDWord($iValue)
Local $tFloat = DllStructCreate('float')
Local $tDWord = DllStructCreate('dword', DllStructGetPtr($tFloat))
DllStructSetData($tFloat, 1, $iValue)
Return DllStructGetData($tDWord, 1)
EndFunc
Func _WinAPI_FloatToInt($nFloat)
Local $tFloat = DllStructCreate("float")
Local $tInt = DllStructCreate("int", DllStructGetPtr($tFloat))
DllStructSetData($tFloat, 1, $nFloat)
Return DllStructGetData($tInt, 1)
EndFunc
Func _WinAPI_GetXYFromPoint(ByRef $tPoint, ByRef $iX, ByRef $iY)
$iX = DllStructGetData($tPoint, "X")
$iY = DllStructGetData($tPoint, "Y")
EndFunc
Func _WinAPI_GUIDFromString($sGUID)
Local $tGUID = DllStructCreate($tagGUID)
If Not _WinAPI_GUIDFromStringEx($sGUID, $tGUID) Then Return SetError(@error, @extended, 0)
Return $tGUID
EndFunc
Func _WinAPI_GUIDFromStringEx($sGUID, $tGUID)
Local $aCall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sGUID, "struct*", $tGUID)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _WinAPI_HashData($pMemory, $iSize, $iLength = 32)
If ($iLength <= 0) Or ($iLength > 256) Then Return SetError(11, 0, 0)
Local $tData = DllStructCreate('byte[' & $iLength & ']')
Local $aCall = DllCall('shlwapi.dll', 'uint', 'HashData', 'struct*', $pMemory, 'dword', $iSize, 'struct*', $tData, 'dword', $iLength)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return DllStructGetData($tData, 1)
EndFunc
Func _WinAPI_HashString($sString, $bCaseSensitive = True, $iLength = 32)
Local $iLengthS = StringLen($sString)
If Not $iLengthS Or ($iLength > 256) Then Return SetError(12, 0, 0)
Local $tString = DllStructCreate('wchar[' & ($iLengthS + 1) & ']')
If Not $bCaseSensitive Then
$sString = StringLower($sString)
EndIf
DllStructSetData($tString, 1, $sString)
Local $sHash = _WinAPI_HashData($tString, 2 * $iLengthS, $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return $sHash
EndFunc
Func _WinAPI_HiByte($iValue)
Return BitAND(BitShift($iValue, 8), 0xFF)
EndFunc
Func _WinAPI_HiDWord($iValue)
Local $tInt64 = DllStructCreate('int64')
Local $tQWord = DllStructCreate('dword;dword', DllStructGetPtr($tInt64))
DllStructSetData($tInt64, 1, $iValue)
Return DllStructGetData($tQWord, 2)
EndFunc
Func _WinAPI_HiWord($iLong)
Return BitShift($iLong, 16)
EndFunc
Func _WinAPI_IntToDWord($iValue)
Local $tData = DllStructCreate('dword')
DllStructSetData($tData, 1, $iValue)
Return DllStructGetData($tData, 1)
EndFunc
Func _WinAPI_IntToFloat($iInt)
Local $tInt = DllStructCreate("int")
Local $tFloat = DllStructCreate("float", DllStructGetPtr($tInt))
DllStructSetData($tInt, 1, $iInt)
Return DllStructGetData($tFloat, 1)
EndFunc
Func _WinAPI_LoByte($iValue)
Return BitAND($iValue, 0xFF)
EndFunc
Func _WinAPI_LoDWord($iValue)
Local $tInt64 = DllStructCreate('int64')
Local $tQWord = DllStructCreate('dword;dword', DllStructGetPtr($tInt64))
DllStructSetData($tInt64, 1, $iValue)
Return DllStructGetData($tQWord, 1)
EndFunc
Func _WinAPI_LoWord($iLong)
Return BitAND($iLong, 0xFFFF)
EndFunc
Func _WinAPI_LongMid($iValue, $iStart, $iCount)
Return BitAND(BitShift($iValue, $iStart), BitOR(BitShift(BitShift(0x7FFFFFFF, 32 - ($iCount + 1)), 1), BitShift(1, -($iCount - 1))))
EndFunc
Func _WinAPI_MAKELANGID($iLngIDPrimary, $iLngIDSub)
Return BitOR(BitShift($iLngIDSub, -10), $iLngIDPrimary)
EndFunc
Func _WinAPI_MAKELCID($iLngID, $iSortID)
Return BitOR(BitShift($iSortID, -16), $iLngID)
EndFunc
Func _WinAPI_MakeLong($iLo, $iHi)
Return BitOR(BitShift($iHi, -16), BitAND($iLo, 0xFFFF))
EndFunc
Func _WinAPI_MakeQWord($iLoDWORD, $iHiDWORD)
Local $tInt64 = DllStructCreate("uint64")
Local $tDwords = DllStructCreate("dword;dword", DllStructGetPtr($tInt64))
DllStructSetData($tDwords, 1, $iLoDWORD)
DllStructSetData($tDwords, 2, $iHiDWORD)
Return DllStructGetData($tInt64, 1)
EndFunc
Func _WinAPI_MakeWord($iLo, $iHi)
Local $tWord = DllStructCreate('ushort')
Local $tByte = DllStructCreate('byte;byte', DllStructGetPtr($tWord))
DllStructSetData($tByte, 1, $iHi)
DllStructSetData($tByte, 2, $iLo)
Return DllStructGetData($tWord, 1)
EndFunc
Func _WinAPI_MultiByteToWideChar($vText, $iCodePage = 0, $iFlags = 0, $bRetString = False)
Local $sTextType = ""
If IsString($vText) Then $sTextType = "str"
If (IsDllStruct($vText) Or IsPtr($vText)) Then $sTextType = "struct*"
If $sTextType = "" Then Return SetError(1, 0, 0)
Local $aCall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $iCodePage, "dword", $iFlags,  $sTextType, $vText, "int", -1, "ptr", 0, "int", 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $iOut = $aCall[0]
Local $tOut = DllStructCreate("wchar[" & $iOut & "]")
$aCall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $iCodePage, "dword", $iFlags, $sTextType, $vText,  "int", -1, "struct*", $tOut, "int", $iOut)
If @error Or Not $aCall[0] Then Return SetError(@error + 20, @extended, 0)
If $bRetString Then Return DllStructGetData($tOut, 1)
Return $tOut
EndFunc
Func _WinAPI_MultiByteToWideCharEx($sText, $pText, $iCodePage = 0, $iFlags = 0)
Local $aCall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $iCodePage, "dword", $iFlags, "STR", $sText,  "int", -1, "struct*", $pText, "int", (StringLen($sText) + 1) * 2)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_OemToChar($sStr)
Local $aCall, $sRetStr = "", $nLen = StringLen($sStr) + 1, $iStart = 1
While $iStart < $nLen
$aCall = DllCall('user32.dll', 'bool', 'OemToCharA', 'str', StringMid($sStr, $iStart, 65536), 'str', '')
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
$sRetStr &= $aCall[2]
$iStart += 65536
WEnd
Return $sRetStr
EndFunc
Func _WinAPI_PointFromRect(ByRef $tRECT, $bCenter = True)
Local $iX1 = DllStructGetData($tRECT, "Left")
Local $iY1 = DllStructGetData($tRECT, "Top")
Local $iX2 = DllStructGetData($tRECT, "Right")
Local $iY2 = DllStructGetData($tRECT, "Bottom")
If $bCenter Then
$iX1 = $iX1 + (($iX2 - $iX1) / 2)
$iY1 = $iY1 + (($iY2 - $iY1) / 2)
EndIf
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $iX1)
DllStructSetData($tPoint, "Y", $iY1)
Return $tPoint
EndFunc
Func _WinAPI_PrimaryLangId($iLngID)
Return BitAND($iLngID, 0x3FF)
EndFunc
Func _WinAPI_ScreenToClient($hWnd, ByRef $tPoint)
Local $aCall = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hWnd, "struct*", $tPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ShortToWord($iValue)
Return BitAND($iValue, 0x0000FFFF)
EndFunc
Func _WinAPI_StrFormatByteSize($iSize)
Local $aCall = DllCall('shlwapi.dll', 'ptr', 'StrFormatByteSizeW', 'int64', $iSize, 'wstr', '', 'uint', 1024)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_StrFormatByteSizeEx($iSize)
Local $aSymbol = DllCall('kernel32.dll', 'int', 'GetLocaleInfoW', 'dword', 0x0400, 'dword', 0x000F, 'wstr', '', 'int', 2048)
If @error Then Return SetError(@error + 10, @extended, '')
Local $sSize = _WinAPI_StrFormatByteSize(0)
If @error Then Return SetError(@error, @extended, '')
Return StringReplace($sSize, '0', StringRegExpReplace(Number($iSize), '(?<=\d)(?=(\d{3})+\z)', $aSymbol[3]))
EndFunc
Func _WinAPI_StrFormatKBSize($iSize)
Local $aCall = DllCall('shlwapi.dll', 'ptr', 'StrFormatKBSizeW', 'int64', $iSize, 'wstr', '', 'uint', 1024)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_StrFromTimeInterval($iTime, $iDigits = 7)
Local $aCall = DllCall('shlwapi.dll', 'int', 'StrFromTimeIntervalW', 'wstr', '', 'uint', 1024, 'dword', $iTime,  'int', $iDigits)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
Return StringStripWS($aCall[1], $STR_STRIPLEADING + $STR_STRIPTRAILING)
EndFunc
Func _WinAPI_StringFromGUID($tGUID)
Local $aCall = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tGUID, "wstr", "", "int", 40)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, "")
Return SetExtended($aCall[0], $aCall[2])
EndFunc
Func _WinAPI_SubLangId($iLngID)
Return BitShift($iLngID, 10)
EndFunc
Func _WinAPI_SwapDWord($iValue)
Local $tStruct1 = DllStructCreate('dword;dword')
Local $tStruct2 = DllStructCreate('byte[4];byte[4]', DllStructGetPtr($tStruct1))
DllStructSetData($tStruct1, 1, $iValue)
For $i = 1 To 4
DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 5 - $i), $i)
Next
Return DllStructGetData($tStruct1, 2)
EndFunc
Func _WinAPI_SwapQWord($iValue)
Local $tStruct1 = DllStructCreate('int64;int64')
Local $tStruct2 = DllStructCreate('byte[8];byte[8]', DllStructGetPtr($tStruct1))
DllStructSetData($tStruct1, 1, $iValue)
For $i = 1 To 8
DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 9 - $i), $i)
Next
Return DllStructGetData($tStruct1, 2)
EndFunc
Func _WinAPI_SwapWord($iValue)
Local $tStruct1 = DllStructCreate('word;word')
Local $tStruct2 = DllStructCreate('byte[2];byte[2]', DllStructGetPtr($tStruct1))
DllStructSetData($tStruct1, 1, $iValue)
For $i = 1 To 2
DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 3 - $i), $i)
Next
Return DllStructGetData($tStruct1, 2)
EndFunc
Func _WinAPI_WideCharToMultiByte($vUnicode, $iCodePage = 0, $bRetNoStruct = True, $bRetBinary = False)
Local $sUnicodeType = "wstr"
If Not IsString($vUnicode) Then $sUnicodeType = "struct*"
Local $aCall = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $iCodePage, "dword", 0, $sUnicodeType, $vUnicode, "int", -1,  "ptr", 0, "int", 0, "ptr", 0, "ptr", 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 20, @extended, "")
Local $tMultiByte = DllStructCreate((($bRetBinary) ? ("byte") : ("char")) & "[" & $aCall[0] & "]")
$aCall = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $iCodePage, "dword", 0, $sUnicodeType, $vUnicode,  "int", -1, "struct*", $tMultiByte, "int", $aCall[0], "ptr", 0, "ptr", 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, "")
If $bRetNoStruct Then Return DllStructGetData($tMultiByte, 1)
Return $tMultiByte
EndFunc
Func _WinAPI_WordToShort($iValue)
If BitAND($iValue, 0x00008000) Then
Return BitOR($iValue, 0xFFFF8000)
EndIf
Return BitAND($iValue, 0x00007FFF)
EndFunc
Global Const $DUPLICATE_CLOSE_SOURCE = 0x00000001
Global Const $DUPLICATE_SAME_ACCESS = 0x00000002
Global Const $OBJ_BITMAP = 7
Global Const $OBJ_BRUSH = 2
Global Const $OBJ_COLORSPACE = 14
Global Const $OBJ_DC = 3
Global Const $OBJ_ENHMETADC = 12
Global Const $OBJ_ENHMETAFILE = 13
Global Const $OBJ_EXTPEN = 11
Global Const $OBJ_FONT = 6
Global Const $OBJ_MEMDC = 10
Global Const $OBJ_METADC = 4
Global Const $OBJ_METAFILE = 9
Global Const $OBJ_PAL = 5
Global Const $OBJ_PEN = 1
Global Const $OBJ_REGION = 8
Global Const $NULL_BRUSH = 5
Global Const $NULL_PEN = 8
Global Const $BLACK_BRUSH = 4
Global Const $DKGRAY_BRUSH = 3
Global Const $DC_BRUSH = 18
Global Const $GRAY_BRUSH = 2
Global Const $HOLLOW_BRUSH = $NULL_BRUSH
Global Const $LTGRAY_BRUSH = 1
Global Const $WHITE_BRUSH = 0
Global Const $BLACK_PEN = 7
Global Const $DC_PEN = 19
Global Const $WHITE_PEN = 6
Global Const $ANSI_FIXED_FONT = 11
Global Const $ANSI_VAR_FONT = 12
Global Const $DEVICE_DEFAULT_FONT = 14
Global Const $DEFAULT_GUI_FONT = 17
Global Const $OEM_FIXED_FONT = 10
Global Const $SYSTEM_FONT = 13
Global Const $SYSTEM_FIXED_FONT = 16
Global Const $DEFAULT_PALETTE = 15
Func _WinAPI_CloseHandle($hObject)
Local $aCall = DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hObject)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DeleteObject($hObject)
Local $aCall = DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hObject)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DuplicateHandle($hSourceProcessHandle, $hSourceHandle, $hTargetProcessHandle, $iDesiredAccess, $iInheritHandle, $iOptions)
Local $aCall = DllCall("kernel32.dll", "bool", "DuplicateHandle",  "handle", $hSourceProcessHandle,  "handle", $hSourceHandle,  "handle", $hTargetProcessHandle,  "handle*", 0,  "dword", $iDesiredAccess,  "bool", $iInheritHandle,  "dword", $iOptions)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[4]
EndFunc
Func _WinAPI_GetCurrentObject($hDC, $iType)
Local $aCall = DllCall('gdi32.dll', 'handle', 'GetCurrentObject', 'handle', $hDC, 'uint', $iType)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetCurrentProcess()
Local $aCall = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetObject($hObject, $iSize, $pObject)
Local $aCall = DllCall("gdi32.dll", "int", "GetObjectW", "handle", $hObject, "int", $iSize, "struct*", $pObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetObjectInfoByHandle($hObject)
Local $tagPUBLIC_OBJECT_BASIC_INFORMATION = 'ulong Attributes;ulong GrantedAcess;ulong HandleCount;ulong PointerCount;ulong Reserved[10]'
Local $tPOBI = DllStructCreate($tagPUBLIC_OBJECT_BASIC_INFORMATION)
Local $aCall = DllCall('ntdll.dll', 'long', 'ZwQueryObject', 'handle', $hObject, 'uint', 0, 'struct*', $tPOBI,  'ulong', DllStructGetSize($tPOBI), 'ptr', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Local $aRet[4]
For $i = 0 To 3
$aRet[$i] = DllStructGetData($tPOBI, $i + 1)
Next
Return $aRet
EndFunc
Func _WinAPI_GetObjectNameByHandle($hObject)
Local $tagUNICODE_STRING = 'struct;ushort Length;ushort MaximumLength;ptr Buffer;endstruct'
Local $tagPUBLIC_OBJECT_TYPE_INFORMATION = 'struct;' & $tagUNICODE_STRING & ';ulong Reserved[22];endstruct'
Local $tPOTI = DllStructCreate($tagPUBLIC_OBJECT_TYPE_INFORMATION & ';byte[32]')
Local $aCall = DllCall('ntdll.dll', 'long', 'ZwQueryObject', 'handle', $hObject, 'uint', 2, 'struct*', $tPOTI,  'ulong', DllStructGetSize($tPOTI), 'ulong*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
Local $pData = DllStructGetData($tPOTI, 3)
If Not $pData Then Return SetError(11, 0, '')
Return _WinAPI_GetString($pData)
EndFunc
Func _WinAPI_GetObjectType($hObject)
Local $aCall = DllCall('gdi32.dll', 'dword', 'GetObjectType', 'handle', $hObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetStdHandle($iStdHandle)
If $iStdHandle < 0 Or $iStdHandle > 2 Then Return SetError(2, 0, -1)
Local Const $aHandle[3] = [-10, -11, -12]
Local $aCall = DllCall("kernel32.dll", "handle", "GetStdHandle", "dword", $aHandle[$iStdHandle])
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_GetStockObject($iObject)
Local $aCall = DllCall("gdi32.dll", "handle", "GetStockObject", "int", $iObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SelectObject($hDC, $hGDIObj)
Local $aCall = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hGDIObj)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetHandleInformation($hObject, $iMask, $iFlags)
Local $aCall = DllCall("kernel32.dll", "bool", "SetHandleInformation", "handle", $hObject, "dword", $iMask, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Global $__g_aInProcess_WinAPI[64][2] = [[0, 0]]
Global $__g_aWinList_WinAPI[64][2] = [[0, 0]]
Global Const $GW_HWNDFIRST = 0
Global Const $GW_HWNDLAST = 1
Global Const $GW_HWNDNEXT = 2
Global Const $GW_HWNDPREV = 3
Global Const $GW_OWNER = 4
Global Const $GW_CHILD = 5
Global Const $GW_ENABLEDPOPUP = 6
Global Const $GWL_WNDPROC = 0xFFFFFFFC
Global Const $GWL_HINSTANCE = 0xFFFFFFFA
Global Const $GWL_HWNDPARENT = 0xFFFFFFF8
Global Const $GWL_ID = 0xFFFFFFF4
Global Const $GWL_STYLE = 0xFFFFFFF0
Global Const $GWL_EXSTYLE = 0xFFFFFFEC
Global Const $GWL_USERDATA = 0xFFFFFFEB
Global Const $__WINAPICONSTANT_WM_SETFONT = 0x0030
Func _WinAPI_CreateWindowEx($iExStyle, $sClass, $sName, $iStyle, $iX, $iY, $iWidth, $iHeight, $hParent, $hMenu = 0, $hInstance = 0, $pParam = 0)
If $hInstance = 0 Then $hInstance = _WinAPI_GetModuleHandle("")
Local $aCall = DllCall("user32.dll", "hwnd", "CreateWindowExW", "dword", $iExStyle, "wstr", $sClass, "wstr", $sName,  "dword", $iStyle, "int", $iX, "int", $iY, "int", $iWidth, "int", $iHeight, "hwnd", $hParent, "handle", $hMenu,  "handle", $hInstance, "struct*", $pParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetClientRect($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
Local $aCall = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hWnd, "struct*", $tRECT)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetDesktopWindow()
Local $aCall = DllCall("user32.dll", "hwnd", "GetDesktopWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_DestroyWindow($hWnd)
Local $aCall = DllCall("user32.dll", "bool", "DestroyWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_EnableWindow($hWnd, $bEnable = True)
Local $aCall = DllCall("user32.dll", "bool", "EnableWindow", "hwnd", $hWnd, "bool", $bEnable)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_EnumWindows($bVisible = True, $hWnd = Default)
__WinAPI_EnumWindowsInit()
If $hWnd = Default Then $hWnd = _WinAPI_GetDesktopWindow()
__WinAPI_EnumWindowsChild($hWnd, $bVisible)
Return $__g_aWinList_WinAPI
EndFunc
Func _WinAPI_EnumWindowsPopup()
__WinAPI_EnumWindowsInit()
Local $hWnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $GW_CHILD)
Local $sClass
While $hWnd <> 0
If _WinAPI_IsWindowVisible($hWnd) Then
$sClass = _WinAPI_GetClassName($hWnd)
If $sClass = "#32768" Then
__WinAPI_EnumWindowsAdd($hWnd)
ElseIf $sClass = "ToolbarWindow32" Then
__WinAPI_EnumWindowsAdd($hWnd)
ElseIf $sClass = "ToolTips_Class32" Then
__WinAPI_EnumWindowsAdd($hWnd)
ElseIf $sClass = "BaseBar" Then
__WinAPI_EnumWindowsChild($hWnd)
EndIf
EndIf
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
Return $__g_aWinList_WinAPI
EndFunc
Func _WinAPI_EnumWindowsTop()
__WinAPI_EnumWindowsInit()
Local $hWnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $GW_CHILD)
While $hWnd <> 0
If _WinAPI_IsWindowVisible($hWnd) Then __WinAPI_EnumWindowsAdd($hWnd)
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
Return $__g_aWinList_WinAPI
EndFunc
Func _WinAPI_GetClassName($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aCall = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hWnd, "wstr", "", "int", 4096)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return SetExtended($aCall[0], $aCall[2])
EndFunc
Func _WinAPI_GetFocus()
Local $aCall = DllCall("user32.dll", "hwnd", "GetFocus")
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetParent($hWnd)
Local $aCall = DllCall("user32.dll", "hwnd", "GetParent", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetSysColor($iIndex)
Local $aCall = DllCall("user32.dll", "INT", "GetSysColor", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetSystemMetrics($iIndex)
Local $aCall = DllCall("user32.dll", "int", "GetSystemMetrics", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetWindow($hWnd, $iCmd)
Local $aCall = DllCall("user32.dll", "hwnd", "GetWindow", "hwnd", $hWnd, "uint", $iCmd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetWindowHeight($hWnd)
Local $tRECT = _WinAPI_GetWindowRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top")
EndFunc
Func _WinAPI_GetWindowLong($hWnd, $iIndex)
Local $sFuncName = "GetWindowLongW"
If @AutoItX64 Then $sFuncName = "GetWindowLongPtrW"
Local $aCall = DllCall("user32.dll", "long_ptr", $sFuncName, "hwnd", $hWnd, "int", $iIndex)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetWindowRect($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
Local $aCall = DllCall("user32.dll", "bool", "GetWindowRect", "hwnd", $hWnd, "struct*", $tRECT)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetWindowText($hWnd)
Local $aCall = DllCall("user32.dll", "int", "GetWindowTextW", "hwnd", $hWnd, "wstr", "", "int", 4096)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, "")
Return SetExtended($aCall[0], $aCall[2])
EndFunc
Func _WinAPI_GetWindowThreadProcessId($hWnd, ByRef $iPID)
Local $aCall = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
If @error Then Return SetError(@error, @extended, 0)
$iPID = $aCall[2]
Return $aCall[0]
EndFunc
Func _WinAPI_GetWindowWidth($hWnd)
Local $tRECT = _WinAPI_GetWindowRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndFunc
Func _WinAPI_InProcess($hWnd, ByRef $hLastWnd)
If $hWnd = $hLastWnd Then Return True
For $iI = $__g_aInProcess_WinAPI[0][0] To 1 Step -1
If $hWnd = $__g_aInProcess_WinAPI[$iI][0] Then
If $__g_aInProcess_WinAPI[$iI][1] Then
$hLastWnd = $hWnd
Return True
Else
Return False
EndIf
EndIf
Next
Local $iPID
_WinAPI_GetWindowThreadProcessId($hWnd, $iPID)
Local $iCount = $__g_aInProcess_WinAPI[0][0] + 1
If $iCount >= 64 Then $iCount = 1
$__g_aInProcess_WinAPI[0][0] = $iCount
$__g_aInProcess_WinAPI[$iCount][0] = $hWnd
$__g_aInProcess_WinAPI[$iCount][1] = ($iPID = @AutoItPID)
Return $__g_aInProcess_WinAPI[$iCount][1]
EndFunc
Func _WinAPI_InvalidateRect($hWnd, $tRECT = 0, $bErase = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aCall = DllCall("user32.dll", "bool", "InvalidateRect", "hwnd", $hWnd, "struct*", $tRECT, "bool", $bErase)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_IsClassName($hWnd, $sClassName)
Local $sSeparator = Opt("GUIDataSeparatorChar")
Local $aClassName = StringSplit($sClassName, $sSeparator)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sClassCheck = _WinAPI_GetClassName($hWnd)
For $x = 1 To UBound($aClassName) - 1
If StringUpper(StringMid($sClassCheck, 1, StringLen($aClassName[$x]))) = StringUpper($aClassName[$x]) Then Return True
Next
Return False
EndFunc
Func _WinAPI_IsWindow($hWnd)
Local $aCall = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_IsWindowVisible($hWnd)
Local $aCall = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_MoveWindow($hWnd, $iX, $iY, $iWidth, $iHeight, $bRepaint = True)
Local $aCall = DllCall("user32.dll", "bool", "MoveWindow", "hwnd", $hWnd, "int", $iX, "int", $iY, "int", $iWidth,  "int", $iHeight, "bool", $bRepaint)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetFocus($hWnd)
Local $aCall = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetFont($hWnd, $hFont, $bRedraw = True)
_SendMessage($hWnd, $__WINAPICONSTANT_WM_SETFONT, $hFont, $bRedraw, 0, "hwnd")
EndFunc
Func _WinAPI_SetParent($hWndChild, $hWndParent)
Local $aCall = DllCall("user32.dll", "hwnd", "SetParent", "hwnd", $hWndChild, "hwnd", $hWndParent)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetWindowPos($hWnd, $hAfter, $iX, $iY, $iCX, $iCY, $iFlags)
Local $aCall = DllCall("user32.dll", "bool", "SetWindowPos", "hwnd", $hWnd, "hwnd", $hAfter, "int", $iX, "int", $iY,  "int", $iCX, "int", $iCY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetWindowText($hWnd, $sText)
Local $aCall = DllCall("user32.dll", "bool", "SetWindowTextW", "hwnd", $hWnd, "wstr", $sText)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ShowWindow($hWnd, $iCmdShow = 5)
Local $aCall = DllCall("user32.dll", "bool", "ShowWindow", "hwnd", $hWnd, "int", $iCmdShow)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_UpdateWindow($hWnd)
Local $aCall = DllCall("user32.dll", "bool", "UpdateWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func __WinAPI_EnumWindowsAdd($hWnd, $sClass = "")
If $sClass = "" Then $sClass = _WinAPI_GetClassName($hWnd)
$__g_aWinList_WinAPI[0][0] += 1
Local $iCount = $__g_aWinList_WinAPI[0][0]
If $iCount >= $__g_aWinList_WinAPI[0][1] Then
ReDim $__g_aWinList_WinAPI[$iCount + 64][2]
$__g_aWinList_WinAPI[0][1] += 64
EndIf
$__g_aWinList_WinAPI[$iCount][0] = $hWnd
$__g_aWinList_WinAPI[$iCount][1] = $sClass
EndFunc
Func __WinAPI_EnumWindowsChild($hWnd, $bVisible = True)
$hWnd = _WinAPI_GetWindow($hWnd, $GW_CHILD)
While $hWnd <> 0
If (Not $bVisible) Or _WinAPI_IsWindowVisible($hWnd) Then
__WinAPI_EnumWindowsAdd($hWnd)
__WinAPI_EnumWindowsChild($hWnd, $bVisible)
EndIf
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
EndFunc
Func __WinAPI_EnumWindowsInit()
ReDim $__g_aWinList_WinAPI[64][2]
$__g_aWinList_WinAPI[0][0] = 0
$__g_aWinList_WinAPI[0][1] = 64
EndFunc
Global $__g_hCBLastWnd
Global Const $__COMBOBOXCONSTANT_ClassName = "ComboBox"
Global Const $__COMBOBOXCONSTANT_EM_GETLINE = 0xC4
Global Const $__COMBOBOXCONSTANT_EM_LINEINDEX = 0xBB
Global Const $__COMBOBOXCONSTANT_EM_LINELENGTH = 0xC1
Global Const $__COMBOBOXCONSTANT_EM_REPLACESEL = 0xC2
Global Const $__COMBOBOXCONSTANT_WM_SETREDRAW = 0x000B
Global Const $__COMBOBOXCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $tagCOMBOBOXINFO = "dword Size;struct;long EditLeft;long EditTop;long EditRight;long EditBottom;endstruct;" &  "struct;long BtnLeft;long BtnTop;long BtnRight;long BtnBottom;endstruct;dword BtnState;hwnd hCombo;hwnd hEdit;hwnd hList"
Func _GUICtrlComboBox_AddDir($hWnd, $sFilePath, $iAttributes = 0, $bBrackets = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If BitAND($iAttributes, $DDL_DRIVES) = $DDL_DRIVES And Not $bBrackets Then
Local $sText
Local $hGui_no_brackets = GUICreate("no brackets")
Local $idCombo_no_brackets = GUICtrlCreateCombo("", 240, 40, 120, 120)
Local $iRet = GUICtrlSendMsg($idCombo_no_brackets, $CB_DIR, $iAttributes, $sFilePath)
For $i = 0 To _GUICtrlComboBox_GetCount($idCombo_no_brackets) - 1
_GUICtrlComboBox_GetLBText($idCombo_no_brackets, $i, $sText)
$sText = StringReplace(StringReplace(StringReplace($sText, "[", ""), "]", ":"), "-", "")
_GUICtrlComboBox_InsertString($hWnd, $sText)
Next
GUIDelete($hGui_no_brackets)
Return $iRet
Else
Return _SendMessage($hWnd, $CB_DIR, $iAttributes, $sFilePath, 0, "wparam", "wstr")
EndIf
EndFunc
Func _GUICtrlComboBox_AddString($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_ADDSTRING, 0, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBox_AutoComplete($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If Not __GUICtrlComboBox_IsPressed('08') And Not __GUICtrlComboBox_IsPressed("2E") Then
Local $sEditText = _GUICtrlComboBox_GetEditText($hWnd)
If StringLen($sEditText) Then
Local $sInputText
Local $iRet = _GUICtrlComboBox_FindString($hWnd, $sEditText)
If ($iRet <> $CB_ERR) Then
_GUICtrlComboBox_GetLBText($hWnd, $iRet, $sInputText)
_GUICtrlComboBox_SetEditText($hWnd, $sInputText)
_GUICtrlComboBox_SetEditSel($hWnd, StringLen($sEditText), StringLen($sInputText))
EndIf
EndIf
EndIf
EndFunc
Func _GUICtrlComboBox_BeginUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__COMBOBOXCONSTANT_WM_SETREDRAW, False) = 0
EndFunc
Func _GUICtrlComboBox_Create($hWnd, $sText, $iX, $iY, $iWidth = 100, $iHeight = 120, $iStyle = 0x00200042, $iExStyle = 0x00000000)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sText) Then Return SetError(2, 0, 0)
Local $aText, $sDelimiter = Opt("GUIDataSeparatorChar")
If $iWidth = -1 Then $iWidth = 100
If $iHeight = -1 Then $iHeight = 120
Local Const $WS_VSCROLL = 0x00200000
If $iStyle = -1 Then $iStyle = BitOR($WS_VSCROLL, $CBS_AUTOHSCROLL, $CBS_DROPDOWN)
If $iExStyle = -1 Then $iExStyle = 0x00000000
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_TABSTOP, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hCombo = _WinAPI_CreateWindowEx($iExStyle, $__COMBOBOXCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_WinAPI_SetFont($hCombo, _WinAPI_GetStockObject($__COMBOBOXCONSTANT_DEFAULT_GUI_FONT))
If StringLen($sText) Then
$aText = StringSplit($sText, $sDelimiter)
For $x = 1 To $aText[0]
_GUICtrlComboBox_AddString($hCombo, $aText[$x])
Next
EndIf
Return $hCombo
EndFunc
Func _GUICtrlComboBox_DeleteString($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_DELETESTRING, $iIndex)
EndFunc
Func _GUICtrlComboBox_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__COMBOBOXCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hCBLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlComboBox_EndUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__COMBOBOXCONSTANT_WM_SETREDRAW, True) = 0
EndFunc
Func _GUICtrlComboBox_FindString($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_FINDSTRING, $iIndex, $sText, 0, "int", "wstr")
EndFunc
Func _GUICtrlComboBox_FindStringExact($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_FINDSTRINGEXACT, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBox_GetComboBoxInfo($hWnd, ByRef $tInfo)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
$tInfo = DllStructCreate($tagCOMBOBOXINFO)
Local $iInfo = DllStructGetSize($tInfo)
DllStructSetData($tInfo, "Size", $iInfo)
Return _SendMessage($hWnd, $CB_GETCOMBOBOXINFO, 0, $tInfo, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlComboBox_GetCount($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETCOUNT)
EndFunc
Func _GUICtrlComboBox_GetCueBanner($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tText = DllStructCreate("wchar[4096]")
If _SendMessage($hWnd, $CB_GETCUEBANNER, $tText, 4096, 0, "struct*") <> 1 Then Return SetError(-1, 0, "")
Return DllStructGetData($tText, 1)
EndFunc
Func _GUICtrlComboBox_GetCurSel($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETCURSEL)
EndFunc
Func _GUICtrlComboBox_GetDroppedControlRect($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aRect[4]
Local $tRECT = _GUICtrlComboBox_GetDroppedControlRectEx($hWnd)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlComboBox_GetDroppedControlRectEx($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
_SendMessage($hWnd, $CB_GETDROPPEDCONTROLRECT, 0, $tRECT, 0, "wparam", "struct*")
Return $tRECT
EndFunc
Func _GUICtrlComboBox_GetDroppedState($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETDROPPEDSTATE) <> 0
EndFunc
Func _GUICtrlComboBox_GetDroppedWidth($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETDROPPEDWIDTH)
EndFunc
Func _GUICtrlComboBox_GetEditSel($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tStart = DllStructCreate("dword Start")
Local $tEnd = DllStructCreate("dword End")
Local $iRet = _SendMessage($hWnd, $CB_GETEDITSEL, $tStart, $tEnd, 0, "struct*", "struct*")
If $iRet = 0 Then Return SetError($CB_ERR, $CB_ERR, $CB_ERR)
Local $aSel[2]
$aSel[0] = DllStructGetData($tStart, "Start")
$aSel[1] = DllStructGetData($tEnd, "End")
Return $aSel
EndFunc
Func _GUICtrlComboBox_GetEditText($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tInfo
If _GUICtrlComboBox_GetComboBoxInfo($hWnd, $tInfo) Then
Local $hEdit = DllStructGetData($tInfo, "hEdit")
Local $iLine = 0
Local $iIndex = _SendMessage($hEdit, $__COMBOBOXCONSTANT_EM_LINEINDEX, $iLine)
Local $iLength = _SendMessage($hEdit, $__COMBOBOXCONSTANT_EM_LINELENGTH, $iIndex)
If $iLength = 0 Then Return ""
Local $tBuffer = DllStructCreate("short Len;wchar Text[" & $iLength & "]")
DllStructSetData($tBuffer, "Len", $iLength)
Local $iRet = _SendMessage($hEdit, $__COMBOBOXCONSTANT_EM_GETLINE, $iLine, $tBuffer, 0, "wparam", "struct*")
If $iRet = 0 Then Return SetError(-1, -1, "")
Local $tText = DllStructCreate("wchar Text[" & $iLength & "]", DllStructGetPtr($tBuffer))
Return DllStructGetData($tText, "Text")
Else
Return SetError(-1, -1, "")
EndIf
EndFunc
Func _GUICtrlComboBox_GetExtendedUI($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETEXTENDEDUI) <> 0
EndFunc
Func _GUICtrlComboBox_GetHorizontalExtent($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETHORIZONTALEXTENT)
EndFunc
Func _GUICtrlComboBox_GetItemHeight($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETITEMHEIGHT, $iIndex)
EndFunc
Func _GUICtrlComboBox_GetLBText($hWnd, $iIndex, ByRef $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLen = _GUICtrlComboBox_GetLBTextLen($hWnd, $iIndex)
Local $tBuffer = DllStructCreate("wchar Text[" & $iLen + 1 & "]")
Local $iRet = _SendMessage($hWnd, $CB_GETLBTEXT, $iIndex, $tBuffer, 0, "wparam", "struct*")
If ($iRet == $CB_ERR) Then Return SetError($CB_ERR, $CB_ERR, $CB_ERR)
$sText = DllStructGetData($tBuffer, "Text")
Return $iRet
EndFunc
Func _GUICtrlComboBox_GetLBTextLen($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETLBTEXTLEN, $iIndex)
EndFunc
Func _GUICtrlComboBox_GetList($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sDelimiter = Opt("GUIDataSeparatorChar")
Local $sResult = "", $sItem
For $i = 0 To _GUICtrlComboBox_GetCount($hWnd) - 1
_GUICtrlComboBox_GetLBText($hWnd, $i, $sItem)
$sResult &= $sItem & $sDelimiter
Next
Return StringTrimRight($sResult, StringLen($sDelimiter))
EndFunc
Func _GUICtrlComboBox_GetListArray($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sDelimiter = Opt("GUIDataSeparatorChar")
Return StringSplit(_GUICtrlComboBox_GetList($hWnd), $sDelimiter)
EndFunc
Func _GUICtrlComboBox_GetLocale($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETLOCALE)
EndFunc
Func _GUICtrlComboBox_GetLocaleCountry($hWnd)
Return _WinAPI_HiWord(_GUICtrlComboBox_GetLocale($hWnd))
EndFunc
Func _GUICtrlComboBox_GetLocaleLang($hWnd)
Return _WinAPI_LoWord(_GUICtrlComboBox_GetLocale($hWnd))
EndFunc
Func _GUICtrlComboBox_GetLocalePrimLang($hWnd)
Return _WinAPI_PrimaryLangId(_GUICtrlComboBox_GetLocaleLang($hWnd))
EndFunc
Func _GUICtrlComboBox_GetLocaleSubLang($hWnd)
Return _WinAPI_SubLangId(_GUICtrlComboBox_GetLocaleLang($hWnd))
EndFunc
Func _GUICtrlComboBox_GetMinVisible($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETMINVISIBLE)
EndFunc
Func _GUICtrlComboBox_GetTopIndex($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETTOPINDEX)
EndFunc
Func _GUICtrlComboBox_InitStorage($hWnd, $iNum, $iBytes)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_INITSTORAGE, $iNum, $iBytes)
EndFunc
Func _GUICtrlComboBox_InsertString($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_INSERTSTRING, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBox_LimitText($hWnd, $iLimit = 0)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $CB_LIMITTEXT, $iLimit)
EndFunc
Func _GUICtrlComboBox_ReplaceEditSel($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tInfo
If _GUICtrlComboBox_GetComboBoxInfo($hWnd, $tInfo) Then
Local $hEdit = DllStructGetData($tInfo, "hEdit")
_SendMessage($hEdit, $__COMBOBOXCONSTANT_EM_REPLACESEL, True, $sText, 0, "wparam", "wstr")
EndIf
EndFunc
Func _GUICtrlComboBox_ResetContent($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $CB_RESETCONTENT)
EndFunc
Func _GUICtrlComboBox_SelectString($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SELECTSTRING, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBox_SetCueBanner($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tText = _WinAPI_MultiByteToWideChar($sText)
Return _SendMessage($hWnd, $CB_SETCUEBANNER, 0, $tText, 0, "wparam", "struct*") = 1
EndFunc
Func _GUICtrlComboBox_SetCurSel($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETCURSEL, $iIndex)
EndFunc
Func _GUICtrlComboBox_SetDroppedWidth($hWnd, $iWidth)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETDROPPEDWIDTH, $iWidth)
EndFunc
Func _GUICtrlComboBox_SetEditSel($hWnd, $iStart, $iStop)
If Not HWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETEDITSEL, 0, _WinAPI_MakeLong($iStart, $iStop)) <> -1
EndFunc
Func _GUICtrlComboBox_SetEditText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_GUICtrlComboBox_SetEditSel($hWnd, 0, -1)
_GUICtrlComboBox_ReplaceEditSel($hWnd, $sText)
EndFunc
Func _GUICtrlComboBox_SetExtendedUI($hWnd, $bExtended = False)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETEXTENDEDUI, $bExtended) = 0
EndFunc
Func _GUICtrlComboBox_SetHorizontalExtent($hWnd, $iWidth)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $CB_SETHORIZONTALEXTENT, $iWidth)
EndFunc
Func _GUICtrlComboBox_SetItemHeight($hWnd, $iHeight, $iComponent = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETITEMHEIGHT, $iComponent, $iHeight)
EndFunc
Func _GUICtrlComboBox_SetLocale($hWnd, $iLocal)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETLOCALE, $iLocal)
EndFunc
Func _GUICtrlComboBox_SetMinVisible($hWnd, $iMinimum)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETMINVISIBLE, $iMinimum) <> 0
EndFunc
Func _GUICtrlComboBox_SetTopIndex($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETTOPINDEX, $iIndex) = 0
EndFunc
Func _GUICtrlComboBox_ShowDropDown($hWnd, $bShow = False)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $CB_SHOWDROPDOWN, $bShow)
EndFunc
Func __GUICtrlComboBox_IsPressed($sHexKey, $vDLL = 'user32.dll')
Local $a_R = DllCall($vDLL, "short", "GetAsyncKeyState", "int", '0x' & $sHexKey)
If @error Then Return SetError(@error, @extended, False)
Return BitAND($a_R[0], 0x8000) <> 0
EndFunc
Global Const $GMEM_FIXED = 0x0000
Global Const $GMEM_MOVEABLE = 0x0002
Global Const $GMEM_NOCOMPACT = 0x0010
Global Const $GMEM_NODISCARD = 0x0020
Global Const $GMEM_ZEROINIT = 0x0040
Global Const $GMEM_MODIFY = 0x0080
Global Const $GMEM_DISCARDABLE = 0x0100
Global Const $GMEM_NOT_BANKED = 0x1000
Global Const $GMEM_SHARE = 0x2000
Global Const $GMEM_DDESHARE = 0x2000
Global Const $GMEM_NOTIFY = 0x4000
Global Const $GMEM_LOWER = 0x1000
Global Const $GMEM_VALID_FLAGS = 0x7F72
Global Const $GMEM_INVALID_HANDLE = 0x8000
Global Const $GPTR = BitOR($GMEM_FIXED, $GMEM_ZEROINIT)
Global Const $GHND = BitOR($GMEM_MOVEABLE, $GMEM_ZEROINIT)
Global Const $MEM_COMMIT = 0x00001000
Global Const $MEM_RESERVE = 0x00002000
Global Const $MEM_TOP_DOWN = 0x00100000
Global Const $MEM_SHARED = 0x08000000
Global Const $PAGE_NOACCESS = 0x00000001
Global Const $PAGE_READONLY = 0x00000002
Global Const $PAGE_READWRITE = 0x00000004
Global Const $PAGE_EXECUTE = 0x00000010
Global Const $PAGE_EXECUTE_READ = 0x00000020
Global Const $PAGE_EXECUTE_READWRITE = 0x00000040
Global Const $PAGE_EXECUTE_WRITECOPY = 0x00000080
Global Const $PAGE_GUARD = 0x00000100
Global Const $PAGE_NOCACHE = 0x00000200
Global Const $PAGE_WRITECOMBINE = 0x00000400
Global Const $PAGE_WRITECOPY = 0x00000008
Global Const $MEM_DECOMMIT = 0x00004000
Global Const $MEM_RELEASE = 0x00008000
Global Enum $MEM_LOAD, $MEM_TOTALPHYSRAM, $MEM_AVAILPHYSRAM, $MEM_TOTALPAGEFILE, $MEM_AVAILPAGEFILE, $MEM_TOTALVIRTUAL, $MEM_AVAILVIRTUAL
Global Const $SE_ASSIGNPRIMARYTOKEN_NAME = "SeAssignPrimaryTokenPrivilege"
Global Const $SE_AUDIT_NAME = "SeAuditPrivilege"
Global Const $SE_BACKUP_NAME = "SeBackupPrivilege"
Global Const $SE_CHANGE_NOTIFY_NAME = "SeChangeNotifyPrivilege"
Global Const $SE_CREATE_GLOBAL_NAME = "SeCreateGlobalPrivilege"
Global Const $SE_CREATE_PAGEFILE_NAME = "SeCreatePagefilePrivilege"
Global Const $SE_CREATE_PERMANENT_NAME = "SeCreatePermanentPrivilege"
Global Const $SE_CREATE_SYMBOLIC_LINK_NAME = 'SeCreateSymbolicLinkPrivilege'
Global Const $SE_CREATE_TOKEN_NAME = "SeCreateTokenPrivilege"
Global Const $SE_DEBUG_NAME = "SeDebugPrivilege"
Global Const $SE_ENABLE_DELEGATION_NAME = "SeEnableDelegationPrivilege"
Global Const $SE_IMPERSONATE_NAME = "SeImpersonatePrivilege"
Global Const $SE_INC_BASE_PRIORITY_NAME = "SeIncreaseBasePriorityPrivilege"
Global Const $SE_INC_WORKING_SET_NAME = 'SeIncreaseWorkingSetPrivilege'
Global Const $SE_INCREASE_QUOTA_NAME = "SeIncreaseQuotaPrivilege"
Global Const $SE_LOAD_DRIVER_NAME = "SeLoadDriverPrivilege"
Global Const $SE_LOCK_MEMORY_NAME = "SeLockMemoryPrivilege"
Global Const $SE_MACHINE_ACCOUNT_NAME = "SeMachineAccountPrivilege"
Global Const $SE_MANAGE_VOLUME_NAME = "SeManageVolumePrivilege"
Global Const $SE_PROF_SINGLE_PROCESS_NAME = "SeProfileSingleProcessPrivilege"
Global Const $SE_RELABEL_NAME = 'SeRelabelPrivilege'
Global Const $SE_REMOTE_SHUTDOWN_NAME = "SeRemoteShutdownPrivilege"
Global Const $SE_RESTORE_NAME = "SeRestorePrivilege"
Global Const $SE_SECURITY_NAME = "SeSecurityPrivilege"
Global Const $SE_SHUTDOWN_NAME = "SeShutdownPrivilege"
Global Const $SE_SYNC_AGENT_NAME = "SeSyncAgentPrivilege"
Global Const $SE_SYSTEM_ENVIRONMENT_NAME = "SeSystemEnvironmentPrivilege"
Global Const $SE_SYSTEM_PROFILE_NAME = "SeSystemProfilePrivilege"
Global Const $SE_SYSTEMTIME_NAME = "SeSystemtimePrivilege"
Global Const $SE_TAKE_OWNERSHIP_NAME = "SeTakeOwnershipPrivilege"
Global Const $SE_TCB_NAME = "SeTcbPrivilege"
Global Const $SE_TIME_ZONE_NAME = 'SeTimeZonePrivilege'
Global Const $SE_TRUSTED_CREDMAN_ACCESS_NAME = 'SeTrustedCredManAccessPrivilege'
Global Const $SE_UNSOLICITED_INPUT_NAME = "SeUnsolicitedInputPrivilege"
Global Const $SE_UNDOCK_NAME = "SeUndockPrivilege"
Global Const $SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001
Global Const $SE_PRIVILEGE_ENABLED = 0x00000002
Global Const $SE_PRIVILEGE_REMOVED = 0x00000004
Global Const $SE_PRIVILEGE_USED_FOR_ACCESS = 0x80000000
Global Const $SE_GROUP_MANDATORY = 0x00000001
Global Const $SE_GROUP_ENABLED_BY_DEFAULT = 0x00000002
Global Const $SE_GROUP_ENABLED = 0x00000004
Global Const $SE_GROUP_OWNER = 0x00000008
Global Const $SE_GROUP_USE_FOR_DENY_ONLY = 0x00000010
Global Const $SE_GROUP_INTEGRITY = 0x00000020
Global Const $SE_GROUP_INTEGRITY_ENABLED = 0x00000040
Global Const $SE_GROUP_RESOURCE = 0x20000000
Global Const $SE_GROUP_LOGON_ID = 0xC0000000
Global Enum $TOKENPRIMARY = 1, $TOKENIMPERSONATION
Global Enum $SECURITYANONYMOUS = 0, $SECURITYIDENTIFICATION, $SECURITYIMPERSONATION, $SECURITYDELEGATION
Global Enum $TOKENUSER = 1, $TOKENGROUPS, $TOKENPRIVILEGES, $TOKENOWNER, $TOKENPRIMARYGROUP, $TOKENDEFAULTDACL, $TOKENSOURCE, $TOKENTYPE, $TOKENIMPERSONATIONLEVEL, $TOKENSTATISTICS, $TOKENRESTRICTEDSIDS, $TOKENSESSIONID, $TOKENGROUPSANDPRIVILEGES, $TOKENSESSIONREFERENCE, $TOKENSANDBOXINERT, $TOKENAUDITPOLICY, $TOKENORIGIN, $TOKENELEVATIONTYPE, $TOKENLINKEDTOKEN, $TOKENELEVATION, $TOKENHASRESTRICTIONS, $TOKENACCESSINFORMATION, $TOKENVIRTUALIZATIONALLOWED, $TOKENVIRTUALIZATIONENABLED, $TOKENINTEGRITYLEVEL, $TOKENUIACCESS, $TOKENMANDATORYPOLICY, $TOKENLOGONSID
Global Const $TOKEN_ASSIGN_PRIMARY = 0x00000001
Global Const $TOKEN_DUPLICATE = 0x00000002
Global Const $TOKEN_IMPERSONATE = 0x00000004
Global Const $TOKEN_QUERY = 0x00000008
Global Const $TOKEN_QUERY_SOURCE = 0x00000010
Global Const $TOKEN_ADJUST_PRIVILEGES = 0x00000020
Global Const $TOKEN_ADJUST_GROUPS = 0x00000040
Global Const $TOKEN_ADJUST_DEFAULT = 0x00000080
Global Const $TOKEN_ADJUST_SESSIONID = 0x00000100
Global Const $TOKEN_ALL_ACCESS = 0x000F01FF
Global Const $TOKEN_READ = 0x00020008
Global Const $TOKEN_WRITE = 0x000200E0
Global Const $TOKEN_EXECUTE = 0x00020000
Global Const $TOKEN_HAS_TRAVERSE_PRIVILEGE = 0x00000001
Global Const $TOKEN_HAS_BACKUP_PRIVILEGE = 0x00000002
Global Const $TOKEN_HAS_RESTORE_PRIVILEGE = 0x00000004
Global Const $TOKEN_HAS_ADMIN_GROUP = 0x00000008
Global Const $TOKEN_IS_RESTRICTED = 0x00000010
Global Const $TOKEN_SESSION_NOT_REFERENCED = 0x00000020
Global Const $TOKEN_SANDBOX_INERT = 0x00000040
Global Const $TOKEN_HAS_IMPERSONATE_PRIVILEGE = 0x00000080
Global Const $STANDARD_RIGHTS_DELETE = 0x00010000
Global Const $READ_CONTROL = 0x00020000
Global Const $WRITE_DAC = 0x00040000
Global Const $WRITE_OWNER = 0x00080000
Global Const $STANDARD_RIGHTS_SYNCHRONIZE = 0x00100000
Global Const $ACCESS_SYSTEM_SECURITY = 0x01000000
Global Const $STANDARD_RIGHTS_REQUIRED = 0x000f0000
Global Const $STANDARD_RIGHTS_READ = $READ_CONTROL
Global Const $STANDARD_RIGHTS_WRITE = $READ_CONTROL
Global Const $STANDARD_RIGHTS_EXECUTE = $READ_CONTROL
Global Const $STANDARD_RIGHTS_ALL = 0x001F0000
Global Const $SPECIFIC_RIGHTS_ALL = 0x0000FFFF
Global Enum $NOT_USED_ACCESS = 0, $GRANT_ACCESS, $SET_ACCESS, $DENY_ACCESS, $REVOKE_ACCESS, $SET_AUDIT_SUCCESS, $SET_AUDIT_FAILURE
Global Enum $TRUSTEE_IS_UNKNOWN = 0, $TRUSTEE_IS_USER, $TRUSTEE_IS_GROUP, $TRUSTEE_IS_DOMAIN, $TRUSTEE_IS_ALIAS, $TRUSTEE_IS_WELL_KNOWN_GROUP, $TRUSTEE_IS_DELETED, $TRUSTEE_IS_INVALID, $TRUSTEE_IS_COMPUTER
Global Const $LOGON_WITH_PROFILE = 0x00000001
Global Const $LOGON_NETCREDENTIALS_ONLY = 0x00000002
Global Enum $SIDTYPEUSER = 1, $SIDTYPEGROUP, $SIDTYPEDOMAIN, $SIDTYPEALIAS, $SIDTYPEWELLKNOWNGROUP, $SIDTYPEDELETEDACCOUNT, $SIDTYPEINVALID, $SIDTYPEUNKNOWN, $SIDTYPECOMPUTER, $SIDTYPELABEL
Global Const $SID_ADMINISTRATORS = "S-1-5-32-544"
Global Const $SID_USERS = "S-1-5-32-545"
Global Const $SID_GUESTS = "S-1-5-32-546"
Global Const $SID_ACCOUNT_OPERATORS = "S-1-5-32-548"
Global Const $SID_SERVER_OPERATORS = "S-1-5-32-549"
Global Const $SID_PRINT_OPERATORS = "S-1-5-32-550"
Global Const $SID_BACKUP_OPERATORS = "S-1-5-32-551"
Global Const $SID_REPLICATOR = "S-1-5-32-552"
Global Const $SID_OWNER = "S-1-3-0"
Global Const $SID_EVERYONE = "S-1-1-0"
Global Const $SID_NETWORK = "S-1-5-2"
Global Const $SID_INTERACTIVE = "S-1-5-4"
Global Const $SID_SYSTEM = "S-1-5-18"
Global Const $SID_AUTHENTICATED_USERS = "S-1-5-11"
Global Const $SID_SCHANNEL_AUTHENTICATION = "S-1-5-64-14"
Global Const $SID_DIGEST_AUTHENTICATION = "S-1-5-64-21"
Global Const $SID_NT_SERVICE = "S-1-5-80"
Global Const $SID_UNTRUSTED_MANDATORY_LEVEL = "S-1-16-0"
Global Const $SID_LOW_MANDATORY_LEVEL = "S-1-16-4096"
Global Const $SID_MEDIUM_MANDATORY_LEVEL = "S-1-16-8192"
Global Const $SID_MEDIUM_PLUS_MANDATORY_LEVEL = "S-1-16-8448"
Global Const $SID_HIGH_MANDATORY_LEVEL = "S-1-16-12288"
Global Const $SID_SYSTEM_MANDATORY_LEVEL = "S-1-16-16384"
Global Const $SID_PROTECTED_PROCESS_MANDATORY_LEVEL = "S-1-16-20480"
Global Const $SID_SECURE_PROCESS_MANDATORY_LEVEL = "S-1-16-28672"
Global Const $SID_ALL_SERVICES = "S-1-5-80-0"
Global Const $FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100
Global Const $FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200
Global Const $FORMAT_MESSAGE_FROM_STRING = 0x00000400
Global Const $FORMAT_MESSAGE_FROM_HMODULE = 0x00000800
Global Const $FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000
Global Const $FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000
Func _WinAPI_Beep($iFreq = 500, $iDuration = 1000)
Local $aCall = DllCall("kernel32.dll", "bool", "Beep", "dword", $iFreq, "dword", $iDuration)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_FormatMessage($iFlags, $pSource, $iMessageID, $iLanguageID, ByRef $pBuffer, $iSize, $vArguments)
Local $sBufferType = "struct*"
If IsString($pBuffer) Then $sBufferType = "wstr"
Local $aCall = DllCall("kernel32.dll", "dword", "FormatMessageW", "dword", $iFlags, "struct*", $pSource, "dword", $iMessageID,  "dword", $iLanguageID, $sBufferType, $pBuffer, "dword", $iSize, "ptr", $vArguments)
If @error Then Return SetError(@error, @extended, 0)
If Not $aCall[0] Then Return SetError(10, _WinAPI_GetLastError(), 0)
If $sBufferType = "wstr" Then $pBuffer = $aCall[5]
Return $aCall[0]
EndFunc
Func _WinAPI_GetErrorMessage($iCode, $iLanguage = 0, Const $_iCallerError = @error, Const $_iCallerExtended = @extended)
Local $aCall = DllCall('kernel32.dll', 'dword', 'FormatMessageW', 'dword', BitOR($FORMAT_MESSAGE_FROM_SYSTEM, $FORMAT_MESSAGE_IGNORE_INSERTS), 'ptr', 0, 'dword', $iCode,  'dword', $iLanguage, 'wstr', '', 'dword', 4096, 'ptr', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return SetError($_iCallerError, $_iCallerExtended, StringRegExpReplace($aCall[5], '[' & @LF & ',' & @CR & ']*\Z', ''))
EndFunc
Func _WinAPI_GetLastError(Const $_iCallerError = @error, Const $_iCallerExtended = @extended)
Local $aCall = DllCall("kernel32.dll", "dword", "GetLastError")
Return SetError($_iCallerError, $_iCallerExtended, $aCall[0])
EndFunc
Func _WinAPI_GetLastErrorMessage(Const $_iCallerError = @error, Const $_iCallerExtended = @extended)
Local $iLastError = _WinAPI_GetLastError()
Local $tBufferPtr = DllStructCreate("ptr")
Local $nCount = _WinAPI_FormatMessage(BitOR($FORMAT_MESSAGE_ALLOCATE_BUFFER, $FORMAT_MESSAGE_FROM_SYSTEM, $FORMAT_MESSAGE_IGNORE_INSERTS),  0, $iLastError, 0, $tBufferPtr, 0, 0)
If @error Then Return SetError(-@error, @extended, "")
Local $sText = ""
Local $pBuffer = DllStructGetData($tBufferPtr, 1)
If $pBuffer Then
If $nCount > 0 Then
Local $tBuffer = DllStructCreate("wchar[" & ($nCount + 1) & "]", $pBuffer)
$sText = DllStructGetData($tBuffer, 1)
If StringRight($sText, 2) = @CRLF Then $sText = StringTrimRight($sText, 2)
EndIf
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pBuffer)
EndIf
Return SetError($_iCallerError, $_iCallerExtended, $sText)
EndFunc
Func _WinAPI_MessageBeep($iType = 1)
Local $iSound
Switch $iType
Case 1
$iSound = 0
Case 2
$iSound = 16
Case 3
$iSound = 32
Case 4
$iSound = 48
Case 5
$iSound = 64
Case Else
$iSound = -1
EndSwitch
Local $aCall = DllCall("user32.dll", "bool", "MessageBeep", "uint", $iSound)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_MsgBox($iFlags, $sTitle, $sText)
BlockInput(0)
MsgBox($iFlags, $sTitle, $sText & "      ")
EndFunc
Func _WinAPI_SetLastError($iErrorCode, Const $_iCallerError = @error, Const $_iCallerExtended = @extended)
DllCall("kernel32.dll", "none", "SetLastError", "dword", $iErrorCode)
Return SetError($_iCallerError, $_iCallerExtended, Null)
EndFunc
Func _WinAPI_ShowError($sText, $bExit = True)
BlockInput(0)
MsgBox($MB_SYSTEMMODAL, "Error", $sText & "      ")
If $bExit Then Exit
EndFunc
Func _WinAPI_ShowLastError($sText = '', $bAbort = False, $iLanguage = 0, Const $_iCallerError = @error, Const $_iCallerExtended = @extended)
Local $sError
Local $iLastError = _WinAPI_GetLastError()
While 1
$sError = _WinAPI_GetErrorMessage($iLastError, $iLanguage)
If @error And $iLanguage Then
$iLanguage = 0
Else
ExitLoop
EndIf
WEnd
If StringStripWS($sText, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sText &= @CRLF & @CRLF
Else
$sText = ''
EndIf
_WinAPI_MsgBox(BitOR(0x00040000, BitShift(0x00000010, -2 * (Not $iLastError))), $iLastError, $sText & $sError)
If $iLastError Then
_WinAPI_SetLastError($iLastError)
If $bAbort Then
Exit $iLastError
EndIf
EndIf
Return SetError($_iCallerError, $_iCallerExtended, 1)
EndFunc
Func _WinAPI_ShowMsg($sText)
_WinAPI_MsgBox($MB_SYSTEMMODAL, "Information", $sText)
EndFunc
Func __COMErrorFormating(ByRef $oCOMError, $sPrefix = @TAB)
Local Const $STR_STRIPTRAILING = 2
Local $sError = "COM Error encountered in " & @ScriptName & " (" & $oCOMError.Scriptline & ") :" & @CRLF &  $sPrefix & "Number        " & @TAB & "= 0x" & Hex($oCOMError.Number, 8) & " (" & $oCOMError.Number & ")" & @CRLF &  $sPrefix & "WinDescription" & @TAB & "= " & StringStripWS($oCOMError.WinDescription, $STR_STRIPTRAILING) & @CRLF &  $sPrefix & "Description   " & @TAB & "= " & StringStripWS($oCOMError.Description, $STR_STRIPTRAILING) & @CRLF &  $sPrefix & "Source        " & @TAB & "= " & $oCOMError.Source & @CRLF &  $sPrefix & "HelpFile      " & @TAB & "= " & $oCOMError.HelpFile & @CRLF &  $sPrefix & "HelpContext   " & @TAB & "= " & $oCOMError.HelpContext & @CRLF &  $sPrefix & "LastDllError  " & @TAB & "= " & $oCOMError.LastDllError & @CRLF &  $sPrefix & "Retcode       " & @TAB & "= 0x" & Hex($oCOMError.retcode)
Return $sError
EndFunc
Func _Security__AdjustTokenPrivileges($hToken, $bDisableAll, $tNewState, $iBufferLen, $tPrevState = 0, $pRequired = 0)
Local $aCall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $hToken, "bool", $bDisableAll, "struct*", $tNewState, "dword", $iBufferLen, "struct*", $tPrevState, "struct*", $pRequired)
If @error Then Return SetError(@error, @extended, False)
Return Not ($aCall[0] = 0)
EndFunc
Func _Security__CreateProcessWithToken($hToken, $iLogonFlags, $sCommandLine, $iCreationFlags, $sCurDir, $tSTARTUPINFO, $tPROCESS_INFORMATION)
Local $aCall = DllCall("advapi32.dll", "bool", "CreateProcessWithTokenW", "handle", $hToken, "dword", $iLogonFlags, "ptr", 0, "wstr", $sCommandLine, "dword", $iCreationFlags, "struct*", 0, "wstr", $sCurDir, "struct*", $tSTARTUPINFO, "struct*", $tPROCESS_INFORMATION)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, False)
Return True
EndFunc
Func _Security__DuplicateTokenEx($hExistingToken, $iDesiredAccess, $iImpersonationLevel, $iTokenType)
Local $aCall = DllCall("advapi32.dll", "bool", "DuplicateTokenEx", "handle", $hExistingToken, "dword", $iDesiredAccess, "struct*", 0, "int", $iImpersonationLevel, "int", $iTokenType, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $aCall[6]
EndFunc
Func _Security__GetAccountSid($sAccount, $sSystem = "")
Local $aAcct = _Security__LookupAccountName($sAccount, $sSystem)
If @error Then Return SetError(@error, @extended, 0)
If IsArray($aAcct) Then Return _Security__StringSidToSid($aAcct[0])
Return ''
EndFunc
Func _Security__GetLengthSid($pSID)
If Not _Security__IsValidSid($pSID) Then Return SetError(@error + 10, @extended, 0)
Local $aCall = DllCall("advapi32.dll", "dword", "GetLengthSid", "struct*", $pSID)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _Security__GetTokenInformation($hToken, $iClass)
Local $aCall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $hToken, "int", $iClass, "struct*", 0, "dword", 0, "dword*", 0)
If @error Or Not $aCall[5] Then Return SetError(@error + 20, @extended, 0)
Local $iLen = $aCall[5]
Local $tBuffer = DllStructCreate("byte[" & $iLen & "]")
$aCall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $hToken, "int", $iClass, "struct*", $tBuffer, "dword", DllStructGetSize($tBuffer), "dword*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tBuffer
EndFunc
Func _Security__ImpersonateSelf($iLevel = $SECURITYIMPERSONATION)
Local $aCall = DllCall("advapi32.dll", "bool", "ImpersonateSelf", "int", $iLevel)
If @error Then Return SetError(@error, @extended, False)
Return Not ($aCall[0] = 0)
EndFunc
Func _Security__IsValidSid($pSID)
Local $aCall = DllCall("advapi32.dll", "bool", "IsValidSid", "struct*", $pSID)
If @error Then Return SetError(@error, @extended, False)
Return Not ($aCall[0] = 0)
EndFunc
Func _Security__LookupAccountName($sAccount, $sSystem = "")
Local $tData = DllStructCreate("byte SID[256]")
Local $aCall = DllCall("advapi32.dll", "bool", "LookupAccountNameW", "wstr", $sSystem, "wstr", $sAccount, "struct*", $tData, "dword*", DllStructGetSize($tData), "wstr", "", "dword*", DllStructGetSize($tData), "int*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aAcct[3]
$aAcct[0] = _Security__SidToStringSid(DllStructGetPtr($tData, "SID"))
$aAcct[1] = $aCall[5]
$aAcct[2] = $aCall[7]
Return $aAcct
EndFunc
Func _Security__LookupAccountSid($vSID, $sSystem = "")
Local $pSID, $aAcct[3]
If IsString($vSID) Then
$pSID = _Security__StringSidToSid($vSID)
Else
$pSID = $vSID
EndIf
If Not _Security__IsValidSid($pSID) Then Return SetError(@error + 20, @extended, 0)
If $sSystem = "" Then $sSystem = Null
Local $aCall = DllCall("advapi32.dll", "bool", "LookupAccountSidW", "wstr", $sSystem, "struct*", $pSID, "wstr", "", "dword*", 65536, "wstr", "", "dword*", 65536, "int*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aAcct[3]
$aAcct[0] = $aCall[3]
$aAcct[1] = $aCall[5]
$aAcct[2] = $aCall[7]
Return $aAcct
EndFunc
Func _Security__LookupPrivilegeValue($sSystem, $sName)
Local $aCall = DllCall("advapi32.dll", "bool", "LookupPrivilegeValueW", "wstr", $sSystem, "wstr", $sName, "int64*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $aCall[3]
EndFunc
Func _Security__OpenProcessToken($hProcess, $iAccess)
Local $aCall = DllCall("advapi32.dll", "bool", "OpenProcessToken", "handle", $hProcess, "dword", $iAccess, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $aCall[3]
EndFunc
Func _Security__OpenThreadToken($iAccess, $hThread = 0, $bOpenAsSelf = False)
Local $aCall
If $hThread = 0 Then
$aCall = DllCall("kernel32.dll", "handle", "GetCurrentThread")
If @error Then Return SetError(@error + 20, @extended, 0)
$hThread = $aCall[0]
EndIf
$aCall = DllCall("advapi32.dll", "bool", "OpenThreadToken", "handle", $hThread, "dword", $iAccess, "bool", $bOpenAsSelf, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $aCall[4]
EndFunc
Func _Security__OpenThreadTokenEx($iAccess, $hThread = 0, $bOpenAsSelf = False)
Local $hToken = _Security__OpenThreadToken($iAccess, $hThread, $bOpenAsSelf)
If $hToken = 0 Then
Local Const $ERROR_NO_TOKEN = 1008
If _WinAPI_GetLastError() <> $ERROR_NO_TOKEN Then Return SetError(20, _WinAPI_GetLastError(), 0)
If Not _Security__ImpersonateSelf() Then Return SetError(@error + 10, _WinAPI_GetLastError(), 0)
$hToken = _Security__OpenThreadToken($iAccess, $hThread, $bOpenAsSelf)
If $hToken = 0 Then Return SetError(@error, _WinAPI_GetLastError(), 0)
EndIf
Return $hToken
EndFunc
Func _Security__SetPrivilege($hToken, $sPrivilege, $bEnable)
Local $iLUID = _Security__LookupPrivilegeValue("", $sPrivilege)
If $iLUID = 0 Then Return SetError(@error + 10, @extended, False)
Local Const $tagTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
Local $tCurrState = DllStructCreate($tagTOKEN_PRIVILEGES)
Local $iCurrState = DllStructGetSize($tCurrState)
Local $tPrevState = DllStructCreate($tagTOKEN_PRIVILEGES)
Local $iPrevState = DllStructGetSize($tPrevState)
Local $tRequired = DllStructCreate("int Data")
DllStructSetData($tCurrState, "Count", 1)
DllStructSetData($tCurrState, "LUID", $iLUID)
If Not _Security__AdjustTokenPrivileges($hToken, False, $tCurrState, $iCurrState, $tPrevState, $tRequired) Then Return SetError(2, @error, False)
DllStructSetData($tPrevState, "Count", 1)
DllStructSetData($tPrevState, "LUID", $iLUID)
Local $iAttributes = DllStructGetData($tPrevState, "Attributes")
If $bEnable Then
$iAttributes = BitOR($iAttributes, $SE_PRIVILEGE_ENABLED)
Else
$iAttributes = BitAND($iAttributes, BitNOT($SE_PRIVILEGE_ENABLED))
EndIf
DllStructSetData($tPrevState, "Attributes", $iAttributes)
If Not _Security__AdjustTokenPrivileges($hToken, False, $tPrevState, $iPrevState, $tCurrState, $tRequired) Then  Return SetError(3, @error, False)
Return True
EndFunc
Func _Security__SetTokenInformation($hToken, $iTokenInformation, $vTokenInformation, $iTokenInformationLength)
Local $aCall = DllCall("advapi32.dll", "bool", "SetTokenInformation", "handle", $hToken, "int", $iTokenInformation, "struct*", $vTokenInformation, "dword", $iTokenInformationLength)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, False)
Return True
EndFunc
Func _Security__SidToStringSid($pSID)
If Not _Security__IsValidSid($pSID) Then Return SetError(@error + 10, 0, "")
Local $aCall = DllCall("advapi32.dll", "bool", "ConvertSidToStringSidW", "struct*", $pSID, "ptr*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, "")
Local $pStringSid = $aCall[2]
Local $aLen = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $pStringSid)
Local $sSID = DllStructGetData(DllStructCreate("wchar Text[" & $aLen[0] + 1 & "]", $pStringSid), "Text")
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pStringSid)
Return $sSID
EndFunc
Func _Security__SidTypeStr($iType)
Switch $iType
Case $SIDTYPEUSER
Return "User"
Case $SIDTYPEGROUP
Return "Group"
Case $SIDTYPEDOMAIN
Return "Domain"
Case $SIDTYPEALIAS
Return "Alias"
Case $SIDTYPEWELLKNOWNGROUP
Return "Well Known Group"
Case $SIDTYPEDELETEDACCOUNT
Return "Deleted Account"
Case $SIDTYPEINVALID
Return "Invalid"
Case $SIDTYPEUNKNOWN
Return "Unknown Type"
Case $SIDTYPECOMPUTER
Return "Computer"
Case $SIDTYPELABEL
Return "A mandatory integrity label SID"
Case Else
Return "Unknown SID Type"
EndSwitch
EndFunc
Func _Security__StringSidToSid($sSID)
Local $aCall = DllCall("advapi32.dll", "bool", "ConvertStringSidToSidW", "wstr", $sSID, "ptr*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $pSID = $aCall[2]
Local $tBuffer = DllStructCreate("byte Data[" & _Security__GetLengthSid($pSID) & "]", $pSID)
Local $tSID = DllStructCreate("byte Data[" & DllStructGetSize($tBuffer) & "]")
DllStructSetData($tSID, "Data", DllStructGetData($tBuffer, "Data"))
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pSID)
Return $tSID
EndFunc
Global Const $tagMEMMAP = "handle hProc;ulong_ptr Size;ptr Mem"
Func _MemFree(ByRef $tMemMap)
Local $pMemory = DllStructGetData($tMemMap, "Mem")
Local $hProcess = DllStructGetData($tMemMap, "hProc")
Local $bResult = _MemVirtualFreeEx($hProcess, $pMemory, 0, $MEM_RELEASE)
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If @error Then Return SetError(@error, @extended, False)
Return $bResult
EndFunc
Func _MemGlobalAlloc($iBytes, $iFlags = 0)
Local $aCall = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $iFlags, "ulong_ptr", $iBytes)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _MemGlobalFree($hMemory)
Local $aCall = DllCall("kernel32.dll", "ptr", "GlobalFree", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _MemGlobalLock($hMemory)
Local $aCall = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _MemGlobalRealloc($hMemory, $iBytes, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "handle", "GlobalReAlloc", "handle", $hMemory, "ulong_ptr", $iBytes, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalSize($hMemory)
Local $aCall = DllCall("kernel32.dll", "ulong_ptr", "GlobalSize", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _MemGlobalUnlock($hMemory)
Local $aCall = DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _MemInit($hWnd, $iSize, ByRef $tMemMap)
Local $aCall = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
If @error Then Return SetError(@error + 10, @extended, 0)
Local $iProcessID = $aCall[2]
If $iProcessID = 0 Then Return SetError(1, 0, 0)
Local $iAccess = BitOR($PROCESS_VM_OPERATION, $PROCESS_VM_READ, $PROCESS_VM_WRITE)
Local $hProcess = __Mem_OpenProcess($iAccess, False, $iProcessID, True)
Local $iAlloc = BitOR($MEM_RESERVE, $MEM_COMMIT)
Local $pMemory = _MemVirtualAllocEx($hProcess, 0, $iSize, $iAlloc, $PAGE_READWRITE)
If $pMemory = 0 Then Return SetError(2, 0, 0)
$tMemMap = DllStructCreate($tagMEMMAP)
DllStructSetData($tMemMap, "hProc", $hProcess)
DllStructSetData($tMemMap, "Size", $iSize)
DllStructSetData($tMemMap, "Mem", $pMemory)
Return $pMemory
EndFunc
Func _MemMoveMemory($pSource, $pDest, $iLength)
DllCall("kernel32.dll", "none", "RtlMoveMemory", "struct*", $pDest, "struct*", $pSource, "ulong_ptr", $iLength)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _MemRead(ByRef $tMemMap, $pSrce, $pDest, $iSize)
Local $aCall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", DllStructGetData($tMemMap, "hProc"),  "ptr", $pSrce, "struct*", $pDest, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _MemWrite(ByRef $tMemMap, $pSrce, $pDest = 0, $iSize = 0, $sSrce = "struct*")
If $pDest = 0 Then $pDest = DllStructGetData($tMemMap, "Mem")
If $iSize = 0 Then $iSize = DllStructGetData($tMemMap, "Size")
Local $aCall = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", DllStructGetData($tMemMap, "hProc"),  "ptr", $pDest, $sSrce, $pSrce, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _MemVirtualAlloc($pAddress, $iSize, $iAllocation, $iProtect)
Local $aCall = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iAllocation, "dword", $iProtect)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _MemVirtualAllocEx($hProcess, $pAddress, $iSize, $iAllocation, $iProtect)
Local $aCall = DllCall("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $hProcess, "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iAllocation, "dword", $iProtect)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _MemVirtualFree($pAddress, $iSize, $iFreeType)
Local $aCall = DllCall("kernel32.dll", "bool", "VirtualFree", "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iFreeType)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _MemVirtualFreeEx($hProcess, $pAddress, $iSize, $iFreeType)
Local $aCall = DllCall("kernel32.dll", "bool", "VirtualFreeEx", "handle", $hProcess, "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iFreeType)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func __Mem_OpenProcess($iAccess, $bInherit, $iPID, $bDebugPriv = False)
Local $aCall = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return $aCall[0]
If Not $bDebugPriv Then Return SetError(100, 0, 0)
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 10, @extended, 0)
_Security__SetPrivilege($hToken, $SE_DEBUG_NAME, True)
Local $iError = @error
Local $iExtended = @extended
Local $iRet = 0
If Not @error Then
$aCall = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
$iError = @error
$iExtended = @extended
If $aCall[0] Then $iRet = $aCall[0]
_Security__SetPrivilege($hToken, $SE_DEBUG_NAME, False)
If @error Then
$iError = @error + 20
$iExtended = @extended
EndIf
Else
$iError = @error + 30
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
Return SetError($iError, $iExtended, $iRet)
EndFunc
Global $__g_hGUICtrl_LastWnd
Func __GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, ByRef $tItem, $tBuffer = 0, $bRetItem = False, $iElement = -1, $bRetBuffer = False, $iElementMax = $iElement)
If $iElement > 0 Then
DllStructSetData($tItem, $iElement, DllStructGetPtr($tBuffer))
If $iElement = $iElementMax Then DllStructSetData($tItem, $iElement + 1, DllStructGetSize($tBuffer))
EndIf
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hGUICtrl_LastWnd) Then
$iRet = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", $iMsg, "wparam", $iIndex, "struct*", $tItem)[0]
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap, $pText
Local $iBuffer = 0
If ($iElement > 0) Or ($iElementMax = 0) Then $iBuffer = DllStructGetSize($tBuffer)
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
If $iBuffer Then
$pText = $pMemory + $iItem
If $iElementMax Then
DllStructSetData($tItem, $iElement, $pText)
Else
$iIndex = $pText
EndIf
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
EndIf
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
$iRet = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", $iMsg, "wparam", $iIndex, "ptr", $pMemory)[0]
If $iBuffer And $bRetBuffer Then _MemRead($tMemMap, $pText, $tBuffer, $iBuffer)
If $bRetItem Then _MemRead($tMemMap, $pMemory, $tItem, $iItem)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $iMsg, $iIndex, DllStructGetPtr($tItem))
EndIf
Return $iRet
EndFunc
Func __GUICtrl_SendMsg_Init($hWnd, $iMsg, $iIndex, ByRef $tItem, $tBuffer = 0, $bRetItem = False, $iElement = -1, $bRetBuffer = False, $iElementMax = $iElement)
#forceref $iMsg, $iIndex, $bRetItem, $bRetBuffer
DllStructSetData($tItem, $iElement, DllStructGetPtr($tBuffer))
If $iElement = $iElementMax Then DllStructSetData($tItem, $iElement + 1, DllStructGetSize($tBuffer))
Local $pFunc
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hGUICtrl_LastWnd) Then
$pFunc = __GUICtrl_SendMsg_InProcess
SetExtended(1)
Else
$pFunc = __GUICtrl_SendMsg_OutProcess
SetExtended(2)
EndIf
Else
$pFunc = __GUICtrl_SendMsg_Internal
SetExtended(3)
EndIf
Return $pFunc
EndFunc
Func __GUICtrl_SendMsg_InProcess($hWnd, $iMsg, $iIndex, ByRef $tItem, $tBuffer = 0, $bRetItem = False, $iElement = -1, $bRetBuffer = False, $iElementMax = $iElement)
#forceref $tBuffer, $bRetItem, $bRetBuffer, $iElementMax
Return DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", $iMsg, "wparam", $iIndex, "struct*", $tItem)[0]
EndFunc
Func __GUICtrl_SendMsg_OutProcess($hWnd, $iMsg, $iIndex, ByRef $tItem, $tBuffer = 0, $bRetItem = False, $iElement = -1, $bRetBuffer = False, $iElementMax = $iElement)
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap, $pText
Local $iBuffer = 0
If ($iElement > 0) Or ($iElementMax = 0) Then $iBuffer = DllStructGetSize($tBuffer)
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
If $iBuffer Then
$pText = $pMemory + $iItem
If $iElementMax Then
DllStructSetData($tItem, $iElement, $pText)
Else
$iIndex = $pText
EndIf
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
EndIf
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
Local $iRet = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", $iMsg, "wparam", $iIndex, "ptr", $pMemory)[0]
If $iBuffer And $bRetBuffer Then _MemRead($tMemMap, $pText, $tBuffer, $iBuffer)
If $bRetItem Then _MemRead($tMemMap, $pMemory, $tItem, $iItem)
_MemFree($tMemMap)
Return $iRet
EndFunc
Func __GUICtrl_SendMsg_Internal($hWnd, $iMsg, $iIndex, ByRef $tItem, $tBuffer = 0, $bRetItem = False, $iElement = -1, $bRetBuffer = False, $iElementMax = $iElement)
#forceref $tBuffer, $bRetItem, $bRetBuffer, $iElementMax
Return GUICtrlSendMsg($hWnd, $iMsg, $iIndex, DllStructGetPtr($tItem))
EndFunc
Global Const $TCS_EX_FLATSEPARATORS = 0x00000001
Global Const $TCS_EX_REGISTERDROP = 0x00000002
Global Const $TCHT_NOWHERE = 0x00000001
Global Const $TCHT_ONITEMICON = 0x00000002
Global Const $TCHT_ONITEMLABEL = 0x00000004
Global Const $TCHT_ONITEM = 0x00000006
Global Const $TCIF_TEXT = 0x00000001
Global Const $TCIF_IMAGE = 0x00000002
Global Const $TCIF_RTLREADING = 0x00000004
Global Const $TCIF_PARAM = 0x00000008
Global Const $TCIF_STATE = 0x00000010
Global Const $TCIF_ALLDATA = 0x0000001B
Global Const $TCIS_BUTTONPRESSED = 0x00000001
Global Const $TCIS_HIGHLIGHTED = 0x00000002
Global Const $TC_ERR = -1
Global Const $TCS_BOTTOM = 0x00000002
Global Const $TCS_BUTTONS = 0x00000100
Global Const $TCS_FIXEDWIDTH = 0x00000400
Global Const $TCS_FLATBUTTONS = 0x00000008
Global Const $TCS_FOCUSNEVER = 0x00008000
Global Const $TCS_FOCUSONBUTTONDOWN = 0x00001000
Global Const $TCS_FORCEICONLEFT = 0x00000010
Global Const $TCS_FORCELABELLEFT = 0x00000020
Global Const $TCS_HOTTRACK = 0x00000040
Global Const $TCS_MULTILINE = 0x00000200
Global Const $TCS_MULTISELECT = 0x00000004
Global Const $TCS_OWNERDRAWFIXED = 0x00002000
Global Const $TCS_RAGGEDRIGHT = 0x00000800
Global Const $TCS_RIGHT = 0x00000002
Global Const $TCS_RIGHTJUSTIFY = 0x00000000
Global Const $TCS_SCROLLOPPOSITE = 0x00000001
Global Const $TCS_SINGLELINE = 0x00000000
Global Const $TCS_TABS = 0x00000000
Global Const $TCS_TOOLTIPS = 0x00004000
Global Const $TCS_VERTICAL = 0x00000080
Global Const $GUI_SS_DEFAULT_TAB = 0
Global Const $TCM_FIRST = 0x1300
Global Const $TCCM_FIRST = 0X2000
Global Const $TCM_ADJUSTRECT = ($TCM_FIRST + 40)
Global Const $TCM_DELETEALLITEMS = ($TCM_FIRST + 9)
Global Const $TCM_DELETEITEM = ($TCM_FIRST + 8)
Global Const $TCM_DESELECTALL = ($TCM_FIRST + 50)
Global Const $TCM_GETCURFOCUS = ($TCM_FIRST + 47)
Global Const $TCM_GETCURSEL = ($TCM_FIRST + 11)
Global Const $TCM_GETEXTENDEDSTYLE = ($TCM_FIRST + 53)
Global Const $TCM_GETIMAGELIST = ($TCM_FIRST + 2)
Global Const $TCM_GETITEMA = ($TCM_FIRST + 5)
Global Const $TCM_GETITEMW = ($TCM_FIRST + 60)
Global Const $TCM_GETITEMCOUNT = ($TCM_FIRST + 4)
Global Const $TCM_GETITEMRECT = ($TCM_FIRST + 10)
Global Const $TCM_GETROWCOUNT = ($TCM_FIRST + 44)
Global Const $TCM_GETTOOLTIPS = ($TCM_FIRST + 45)
Global Const $TCCM_GETUNICODEFORMAT = ($TCCM_FIRST + 6)
Global Const $TCM_GETUNICODEFORMAT = $TCCM_GETUNICODEFORMAT
Global Const $TCM_HIGHLIGHTITEM = ($TCM_FIRST + 51)
Global Const $TCM_HITTEST = ($TCM_FIRST + 13)
Global Const $TCM_INSERTITEMA = ($TCM_FIRST + 7)
Global Const $TCM_INSERTITEMW = ($TCM_FIRST + 62)
Global Const $TCM_REMOVEIMAGE = ($TCM_FIRST + 42)
Global Const $TCM_SETITEMA = ($TCM_FIRST + 6)
Global Const $TCM_SETITEMW = ($TCM_FIRST + 61)
Global Const $TCM_SETITEMEXTRA = ($TCM_FIRST + 14)
Global Const $TCM_SETITEMSIZE = $TCM_FIRST + 41
Global Const $TCM_SETCURFOCUS = ($TCM_FIRST + 48)
Global Const $TCM_SETCURSEL = ($TCM_FIRST + 12)
Global Const $TCM_SETEXTENDEDSTYLE = ($TCM_FIRST + 52)
Global Const $TCM_SETIMAGELIST = $TCM_FIRST + 3
Global Const $TCM_SETMINTABWIDTH = ($TCM_FIRST + 49)
Global Const $TCM_SETPADDING = ($TCM_FIRST + 43)
Global Const $TCM_SETTOOLTIPS = ($TCM_FIRST + 46)
Global Const $TCCM_SETUNICODEFORMAT = ($TCCM_FIRST + 5)
Global Const $TCM_SETUNICODEFORMAT = $TCCM_SETUNICODEFORMAT
Global Const $TCN_FIRST = -550
Global Const $TCN_FOCUSCHANGE = ($TCN_FIRST - 4)
Global Const $TCN_GETOBJECT = ($TCN_FIRST - 3)
Global Const $TCN_KEYDOWN = ($TCN_FIRST - 0)
Global Const $TCN_SELCHANGE = ($TCN_FIRST - 1)
Global Const $TCN_SELCHANGING = ($TCN_FIRST - 2)
Global $__g_tTabBuffer, $__g_tTabBufferANSI
Global Const $__TABCONSTANT_ClassName = "SysTabControl32"
Global Const $__TABCONSTANT_WS_CLIPSIBLINGS = 0x04000000
Global Const $__TABCONSTANT_WM_NOTIFY = 0x004E
Global Const $__TABCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $tagTCITEM = "struct; uint Mask;dword State;dword StateMask;ptr Text;int TextMax;int Image;lparam Param; endstruct"
Global Const $tagTCHITTESTINFO = "struct;" & $tagPOINT & ";uint Flags; endstruct"
Func __GUICtrlTab_AdjustRect($hWnd, ByRef $tRECT, $bLarger = False)
If IsHWnd($hWnd) Then
__GUICtrl_SendMsg($hWnd, $TCM_ADJUSTRECT, $bLarger, $tRECT, 0, True)
EndIf
EndFunc
Func _GUICtrlTab_ActivateTab($hWnd, $iIndex)
Local $nIndX
If $hWnd = -1 Then $hWnd = GUICtrlGetHandle(-1)
If IsHWnd($hWnd) Then
$nIndX = _WinAPI_GetDlgCtrlID($hWnd)
Else
$nIndX = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
Local $hParent = _WinAPI_GetParent($hWnd)
If @error Then Return SetError(1, 0, -1)
Local $tNmhdr = DllStructCreate($tagNMHDR)
DllStructSetData($tNmhdr, 1, $hWnd)
DllStructSetData($tNmhdr, 2, $nIndX)
DllStructSetData($tNmhdr, 3, $TCN_SELCHANGING)
_SendMessage($hParent, $__TABCONSTANT_WM_NOTIFY, $nIndX, $tNmhdr, 0, "wparam", "struct*")
Local $iRet = _GUICtrlTab_SetCurSel($hWnd, $iIndex)
DllStructSetData($tNmhdr, 3, $TCN_SELCHANGE)
_SendMessage($hParent, $__TABCONSTANT_WM_NOTIFY, $nIndX, $tNmhdr, 0, "wparam", "struct*")
Return $iRet
EndFunc
Func _GUICtrlTab_ClickTab($hWnd, $iIndex, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iX, $iY
If Not $bMove Then
Local $hWinParent = _WinAPI_GetParent($hWnd)
Local $avTabPos = _GUICtrlTab_GetItemRect($hWnd, $iIndex)
$iX = $avTabPos[0] + (($avTabPos[2] - $avTabPos[0]) / 2)
$iY = $avTabPos[1] + (($avTabPos[3] - $avTabPos[1]) / 2)
ControlClick($hWinParent, "", $hWnd, $sButton, $iClicks, $iX, $iY)
Else
Local $tRECT = _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
Local $tPoint = _WinAPI_PointFromRect($tRECT, True)
$tPoint = _WinAPI_ClientToScreen($hWnd, $tPoint)
_WinAPI_GetXYFromPoint($tPoint, $iX, $iY)
Local $iMode = Opt("MouseCoordMode", 1)
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
Opt("MouseCoordMode", $iMode)
EndIf
EndFunc
Func _GUICtrlTab_Create($hWnd, $iX, $iY, $iWidth = 150, $iHeight = 150, $iStyle = 0x00000040, $iExStyle = 0x00000000)
If Not IsHWnd($hWnd) Then
Return SetError(1, 0, 0)
EndIf
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = $TCS_HOTTRACK
If $iExStyle = -1 Then $iExStyle = 0x00000000
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__TABCONSTANT_WS_CLIPSIBLINGS, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hTab = _WinAPI_CreateWindowEx($iExStyle, $__TABCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_WinAPI_SetFont($hTab, _WinAPI_GetStockObject($__TABCONSTANT_DEFAULT_GUI_FONT))
Return $hTab
EndFunc
Func _GUICtrlTab_DeleteAllItems($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_DELETEALLITEMS) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_DELETEALLITEMS, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlTab_DeleteItem($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_DELETEITEM, $iIndex) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_DELETEITEM, $iIndex, 0) <> 0
EndIf
EndFunc
Func _GUICtrlTab_DeselectAll($hWnd, $bExclude = True)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_DESELECTALL, $bExclude)
Else
GUICtrlSendMsg($hWnd, $TCM_DESELECTALL, $bExclude, 0)
EndIf
EndFunc
Func _GUICtrlTab_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__TABCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hGUICtrl_LastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlTab_FindTab($hWnd, $sText, $bInStr = False, $iStart = 0)
Local $sTab
For $iI = $iStart To _GUICtrlTab_GetItemCount($hWnd)
$sTab = _GUICtrlTab_GetItemText($hWnd, $iI)
Switch $bInStr
Case False
If $sTab = $sText Then Return $iI
Case True
If StringInStr($sTab, $sText) Then Return $iI
EndSwitch
Next
Return -1
EndFunc
Func _GUICtrlTab_GetCurFocus($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETCURFOCUS)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETCURFOCUS, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetCurSel($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETCURSEL)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETCURSEL, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetDisplayRect($hWnd)
Local $aRect[4]
Local $tRECT = _GUICtrlTab_GetDisplayRectEx($hWnd)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlTab_GetDisplayRectEx($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
__GUICtrlTab_AdjustRect($hWnd, $tRECT)
Return $tRECT
EndFunc
Func _GUICtrlTab_GetExtendedStyle($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETEXTENDEDSTYLE)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETEXTENDEDSTYLE, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetImageList($hWnd)
If IsHWnd($hWnd) Then
Return Ptr(_SendMessage($hWnd, $TCM_GETIMAGELIST))
Else
Return Ptr(GUICtrlSendMsg($hWnd, $TCM_GETIMAGELIST, 0, 0))
EndIf
EndFunc
Func _GUICtrlTab_GetItem($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tItem = DllStructCreate($tagTCITEM)
DllStructSetData($tItem, "Mask", $TCIF_ALLDATA)
DllStructSetData($tItem, "StateMask", BitOR($TCIS_HIGHLIGHTED, $TCIS_BUTTONPRESSED))
Local $tBuffer, $iMsg
If _GUICtrlTab_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tTabBuffer
$iMsg = $TCM_GETITEMW
Else
$tBuffer = $__g_tTabBufferANSI
$iMsg = $TCM_GETITEMA
EndIf
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, $tItem, $tBuffer, True, 4, True)
Local $aItem[4]
$aItem[0] = DllStructGetData($tItem, "State")
$aItem[1] = DllStructGetData($tBuffer, "Text")
$aItem[2] = DllStructGetData($tItem, "Image")
$aItem[3] = DllStructGetData($tItem, "Param")
Return SetError($iRet = 0, 0, $aItem)
EndFunc
Func _GUICtrlTab_GetItemCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETITEMCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETITEMCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetItemImage($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[2]
EndFunc
Func _GUICtrlTab_GetItemParam($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[3]
EndFunc
Func _GUICtrlTab_GetItemRect($hWnd, $iIndex)
Local $aRect[4]
Local $tRECT = _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
Local $tRECT = DllStructCreate($tagRECT)
__GUICtrl_SendMsg($hWnd, $TCM_GETITEMRECT, $iIndex, $tRECT, 0, True)
Return $tRECT
EndFunc
Func _GUICtrlTab_GetItemState($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[0]
EndFunc
Func _GUICtrlTab_GetItemText($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[1]
EndFunc
Func _GUICtrlTab_GetRowCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETROWCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETROWCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetToolTips($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $TCM_GETTOOLTIPS))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $TCM_GETTOOLTIPS, 0, 0))
EndIf
EndFunc
Func _GUICtrlTab_GetUnicodeFormat($hWnd)
If Not IsDllStruct($__g_tTabBuffer) Then
$__g_tTabBuffer = DllStructCreate("wchar Text[4096]")
$__g_tTabBufferANSI = DllStructCreate("char Text[4096]", DllStructGetPtr($__g_tTabBuffer))
EndIf
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETUNICODEFORMAT) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETUNICODEFORMAT, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlTab_HighlightItem($hWnd, $iIndex, $bHighlight = True)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_HIGHLIGHTITEM, $iIndex, $bHighlight) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_HIGHLIGHTITEM, $iIndex, $bHighlight) <> 0
EndIf
EndFunc
Func _GUICtrlTab_HitTest($hWnd, $iX, $iY)
Local $aHit[2] = [-1, 1]
Local $tHit = DllStructCreate($tagTCHITTESTINFO)
DllStructSetData($tHit, "X", $iX)
DllStructSetData($tHit, "Y", $iY)
Local $aHit[2] = [-1, 1]
$aHit[0] = __GUICtrl_SendMsg($hWnd, $TCM_HITTEST, 0, $tHit, 0, True)
$aHit[1] = DllStructGetData($tHit, "Flags")
Return $aHit
EndFunc
Func _GUICtrlTab_InsertItem($hWnd, $iIndex, $sText, $iImage = -1, $iParam = 0)
Local $tBuffer, $iMsg
If _GUICtrlTab_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tTabBuffer
$iMsg = $TCM_INSERTITEMW
Else
$tBuffer = $__g_tTabBufferANSI
$iMsg = $TCM_INSERTITEMA
EndIf
Local $tItem = DllStructCreate($tagTCITEM)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Mask", BitOR($TCIF_TEXT, $TCIF_IMAGE, $TCIF_PARAM))
DllStructSetData($tItem, "Image", $iImage)
DllStructSetData($tItem, "Param", $iParam)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, $tItem, $tBuffer, False, 4)
Return $iRet
EndFunc
Func _GUICtrlTab_RemoveImage($hWnd, $iIndex)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_REMOVEIMAGE, $iIndex)
_WinAPI_InvalidateRect($hWnd)
Else
GUICtrlSendMsg($hWnd, $TCM_REMOVEIMAGE, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetCurFocus($hWnd, $iIndex)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETCURFOCUS, $iIndex)
Else
GUICtrlSendMsg($hWnd, $TCM_SETCURFOCUS, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetCurSel($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETCURSEL, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETCURSEL, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetExtendedStyle($hWnd, $iStyle)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETEXTENDEDSTYLE, 0, $iStyle)
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETEXTENDEDSTYLE, 0, $iStyle)
EndIf
EndFunc
Func _GUICtrlTab_SetImageList($hWnd, $hImage)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETIMAGELIST, 0, $hImage, 0, "wparam", "handle", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $TCM_SETIMAGELIST, 0, $hImage))
EndIf
EndFunc
Func _GUICtrlTab_SetItem($hWnd, $iIndex, $sText = -1, $iState = -1, $iImage = -1, $iParam = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tItem = DllStructCreate($tagTCITEM)
Local $tBuffer, $iMask = 0, $iMsg
If _GUICtrlTab_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tTabBuffer
$iMsg = $TCM_SETITEMW
Else
$tBuffer = $__g_tTabBufferANSI
$iMsg = $TCM_SETITEMA
EndIf
If IsString($sText) Then
DllStructSetData($tBuffer, "Text", $sText)
$iMask = $TCIF_TEXT
Else
$tBuffer = 0
EndIf
If $iState <> -1 Then
DllStructSetData($tItem, "State", $iState)
DllStructSetData($tItem, "StateMask", $iState)
$iMask = BitOR($iMask, $TCIF_STATE)
EndIf
If $iImage <> -1 Then
DllStructSetData($tItem, "Image", $iImage)
$iMask = BitOR($iMask, $TCIF_IMAGE)
EndIf
If $iParam <> -1 Then
DllStructSetData($tItem, "Param", $iParam)
$iMask = BitOR($iMask, $TCIF_PARAM)
EndIf
DllStructSetData($tItem, "Mask", $iMask)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, $tItem, $tBuffer, False, 4)
Return $iRet <> 0
EndFunc
Func _GUICtrlTab_SetItemImage($hWnd, $iIndex, $iImage)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, -1, -1, $iImage)
EndFunc
Func _GUICtrlTab_SetItemParam($hWnd, $iIndex, $iParam)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, -1, -1, -1, $iParam)
EndFunc
Func _GUICtrlTab_SetItemSize($hWnd, $iWidth, $iHeight)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETITEMSIZE, 0, _WinAPI_MakeLong($iWidth, $iHeight))
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETITEMSIZE, 0, _WinAPI_MakeLong($iWidth, $iHeight))
EndIf
EndFunc
Func _GUICtrlTab_SetItemState($hWnd, $iIndex, $iState)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, -1, $iState)
EndFunc
Func _GUICtrlTab_SetItemText($hWnd, $iIndex, $sText)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, $sText)
EndFunc
Func _GUICtrlTab_SetMinTabWidth($hWnd, $iMinWidth)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETMINTABWIDTH, 0, $iMinWidth)
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETMINTABWIDTH, 0, $iMinWidth)
EndIf
EndFunc
Func _GUICtrlTab_SetPadding($hWnd, $iHorz, $iVert)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETPADDING, 0, _WinAPI_MakeLong($iHorz, $iVert))
Else
GUICtrlSendMsg($hWnd, $TCM_SETPADDING, 0, _WinAPI_MakeLong($iHorz, $iVert))
EndIf
EndFunc
Func _GUICtrlTab_SetToolTips($hWnd, $hToolTip)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETTOOLTIPS, $hToolTip, 0, 0, "hwnd")
Else
GUICtrlSendMsg($hWnd, $TCM_SETTOOLTIPS, $hToolTip, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetUnicodeFormat($hWnd, $bUnicode)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETUNICODEFORMAT, $bUnicode) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETUNICODEFORMAT, $bUnicode, 0) <> 0
EndIf
EndFunc
Global Const $HDF_LEFT = 0x00000000
Global Const $HDF_RIGHT = 0x00000001
Global Const $HDF_CENTER = 0x00000002
Global Const $HDF_JUSTIFYMASK = 0x00000003
Global Const $HDF_BITMAP_ON_RIGHT = 0x00001000
Global Const $HDF_BITMAP = 0x00002000
Global Const $HDF_STRING = 0x00004000
Global Const $HDF_OWNERDRAW = 0x00008000
Global Const $HDF_DISPLAYMASK = 0x0000F000
Global Const $HDF_RTLREADING = 0x00000004
Global Const $HDF_SORTDOWN = 0x00000200
Global Const $HDF_IMAGE = 0x00000800
Global Const $HDF_SORTUP = 0x00000400
Global Const $HDF_FLAGMASK = 0x00000E04
Global Const $HDI_WIDTH = 0x00000001
Global Const $HDI_TEXT = 0x00000002
Global Const $HDI_FORMAT = 0x00000004
Global Const $HDI_PARAM = 0x00000008
Global Const $HDI_BITMAP = 0x00000010
Global Const $HDI_IMAGE = 0x00000020
Global Const $HDI_DI_SETITEM = 0x00000040
Global Const $HDI_ORDER = 0x00000080
Global Const $HDI_FILTER = 0x00000100
Global Const $HHT_NOWHERE = 0x00000001
Global Const $HHT_ONHEADER = 0x00000002
Global Const $HHT_ONDIVIDER = 0x00000004
Global Const $HHT_ONDIVOPEN = 0x00000008
Global Const $HHT_ONFILTER = 0x00000010
Global Const $HHT_ONFILTERBUTTON = 0x00000020
Global Const $HHT_ABOVE = 0x00000100
Global Const $HHT_BELOW = 0x00000200
Global Const $HHT_TORIGHT = 0x00000400
Global Const $HHT_TOLEFT = 0x00000800
Global Const $HDM_FIRST = 0x1200
Global Const $HDM_CLEARFILTER = $HDM_FIRST + 24
Global Const $HDM_CREATEDRAGIMAGE = $HDM_FIRST + 16
Global Const $HDM_DELETEITEM = $HDM_FIRST + 2
Global Const $HDM_EDITFILTER = $HDM_FIRST + 23
Global Const $HDM_GETBITMAPMARGIN = $HDM_FIRST + 21
Global Const $HDM_GETFOCUSEDITEM = $HDM_FIRST + 27
Global Const $HDM_GETIMAGELIST = $HDM_FIRST + 9
Global Const $HDM_GETITEMA = $HDM_FIRST + 3
Global Const $HDM_GETITEMW = $HDM_FIRST + 11
Global Const $HDM_GETITEMCOUNT = $HDM_FIRST + 0
Global Const $HDM_GETITEMDROPDOWNRECT = $HDM_FIRST + 25
Global Const $HDM_GETITEMRECT = $HDM_FIRST + 7
Global Const $HDM_GETORDERARRAY = $HDM_FIRST + 17
Global Const $HDM_GETOVERFLOWRECT = $HDM_FIRST + 26
Global Const $HDM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $HDM_HITTEST = $HDM_FIRST + 6
Global Const $HDM_INSERTITEMA = $HDM_FIRST + 1
Global Const $HDM_INSERTITEMW = $HDM_FIRST + 10
Global Const $HDM_LAYOUT = $HDM_FIRST + 5
Global Const $HDM_ORDERTOINDEX = $HDM_FIRST + 15
Global Const $HDM_SETBITMAPMARGIN = $HDM_FIRST + 20
Global Const $HDM_SETFILTERCHANGETIMEOUT = $HDM_FIRST + 22
Global Const $HDM_SETFOCUSEDITEM = $HDM_FIRST + 28
Global Const $HDM_SETHOTDIVIDER = $HDM_FIRST + 19
Global Const $HDM_SETIMAGELIST = $HDM_FIRST + 8
Global Const $HDM_SETITEMA = $HDM_FIRST + 4
Global Const $HDM_SETITEMW = $HDM_FIRST + 12
Global Const $HDM_SETORDERARRAY = $HDM_FIRST + 18
Global Const $HDM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $HDN_FIRST = -300
Global Const $HDN_BEGINDRAG = $HDN_FIRST - 10
Global Const $HDN_BEGINTRACK = $HDN_FIRST - 6
Global Const $HDN_DIVIDERDBLCLICK = $HDN_FIRST - 5
Global Const $HDN_ENDDRAG = $HDN_FIRST - 11
Global Const $HDN_ENDTRACK = $HDN_FIRST - 7
Global Const $HDN_FILTERBTNCLICK = $HDN_FIRST - 13
Global Const $HDN_FILTERCHANGE = $HDN_FIRST - 12
Global Const $HDN_GETDISPINFO = $HDN_FIRST - 9
Global Const $HDN_ITEMCHANGED = $HDN_FIRST - 1
Global Const $HDN_ITEMCHANGING = $HDN_FIRST - 0
Global Const $HDN_ITEMCLICK = $HDN_FIRST - 2
Global Const $HDN_ITEMDBLCLICK = $HDN_FIRST - 3
Global Const $HDN_TRACK = $HDN_FIRST - 8
Global Const $HDN_BEGINTRACKW = $HDN_FIRST - 26
Global Const $HDN_DIVIDERDBLCLICKW = $HDN_FIRST - 25
Global Const $HDN_ENDTRACKW = $HDN_FIRST - 27
Global Const $HDN_GETDISPINFOW = $HDN_FIRST - 29
Global Const $HDN_ITEMCHANGEDW = $HDN_FIRST - 21
Global Const $HDN_ITEMCHANGINGW = $HDN_FIRST - 20
Global Const $HDN_ITEMCLICKW = $HDN_FIRST - 22
Global Const $HDN_ITEMDBLCLICKW = $HDN_FIRST - 23
Global Const $HDN_TRACKW = $HDN_FIRST - 28
Global Const $HDS_BUTTONS = 0x00000002
Global Const $HDS_CHECKBOXES = 0x00000400
Global Const $HDS_DRAGDROP = 0x00000040
Global Const $HDS_FILTERBAR = 0x00000100
Global Const $HDS_FLAT = 0x00000200
Global Const $HDS_FULLDRAG = 0x00000080
Global Const $HDS_HIDDEN = 0x00000008
Global Const $HDS_HORZ = 0x00000000
Global Const $HDS_HOTTRACK = 0x00000004
Global Const $HDS_NOSIZING = 0x0800
Global Const $HDS_OVERFLOW = 0x1000
Global Const $HDS_DEFAULT = 0x00000046
Global $__g_tHeaderBuffer, $__g_tHeaderBufferANSI
Global Const $__HEADERCONSTANT_ClassName = "SysHeader32"
Global Const $__HEADERCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__HEADERCONSTANT_SWP_SHOWWINDOW = 0x0040
Global Const $tagHDHITTESTINFO = $tagPOINT & ";uint Flags;int Item"
Global Const $tagHDLAYOUT = "ptr Rect;ptr WindowPos"
Global Const $tagHDTEXTFILTER = "ptr Text;int TextMax"
Func _GUICtrlHeader_AddItem($hWnd, $sText, $iWidth = 50, $iAlign = 0, $iImage = -1, $bOnRight = False)
Return _GUICtrlHeader_InsertItem($hWnd, _GUICtrlHeader_GetItemCount($hWnd), $sText, $iWidth, $iAlign, $iImage, $bOnRight)
EndFunc
Func _GUICtrlHeader_ClearFilter($hWnd, $iIndex)
Return _SendMessage($hWnd, $HDM_CLEARFILTER, $iIndex) <> 0
EndFunc
Func _GUICtrlHeader_ClearFilterAll($hWnd)
Return _SendMessage($hWnd, $HDM_CLEARFILTER, -1) <> 0
EndFunc
Func _GUICtrlHeader_Create($hWnd, $iStyle = 0x00000046)
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hHeader = _WinAPI_CreateWindowEx(0, $__HEADERCONSTANT_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd, $nCtrlID)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
Local $tWindowPos = _GUICtrlHeader_Layout($hHeader, $tRECT)
Local $iFlags = BitOR(DllStructGetData($tWindowPos, "Flags"), $__HEADERCONSTANT_SWP_SHOWWINDOW)
_WinAPI_SetWindowPos($hHeader, DllStructGetData($tWindowPos, "InsertAfter"),  DllStructGetData($tWindowPos, "X"), DllStructGetData($tWindowPos, "Y"),  DllStructGetData($tWindowPos, "CX"), DllStructGetData($tWindowPos, "CY"), $iFlags)
_WinAPI_SetFont($hHeader, _WinAPI_GetStockObject($__HEADERCONSTANT_DEFAULT_GUI_FONT))
Return $hHeader
EndFunc
Func _GUICtrlHeader_CreateDragImage($hWnd, $iIndex)
Return Ptr(_SendMessage($hWnd, $HDM_CREATEDRAGIMAGE, $iIndex))
EndFunc
Func _GUICtrlHeader_DeleteItem($hWnd, $iIndex)
Return _SendMessage($hWnd, $HDM_DELETEITEM, $iIndex) <> 0
EndFunc
Func _GUICtrlHeader_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__HEADERCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hGUICtrl_LastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlHeader_EditFilter($hWnd, $iIndex, $bDiscard = True)
Return _SendMessage($hWnd, $HDM_EDITFILTER, $iIndex, $bDiscard) <> 0
EndFunc
Func _GUICtrlHeader_GetFilterText($hWnd, $iIndex)
Local $tBuffer, $iMsg
If _GUICtrlHeader_GetUnicodeFormat($hWnd) Then
$tBuffer = DllStructCreate("wchar Text[64]")
$iMsg = $HDM_GETITEMW
Else
$tBuffer = DllStructCreate("char Text[64]")
$iMsg = $HDM_GETITEMA
EndIf
Local $tFilter = DllStructCreate($tagHDTEXTFILTER)
DllStructSetData($tFilter, "Text", DllStructGetPtr($tBuffer))
DllStructSetData($tFilter, "TextMax", DllStructGetSize($tBuffer))
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_FILTER)
DllStructSetData($tItem, "Type", 0)
DllStructSetData($tItem, "pFilter", DllStructGetPtr($tFilter))
__GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, $tItem, $tBuffer, False, -1, True)
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlHeader_GetBitmapMargin($hWnd)
Return _SendMessage($hWnd, $HDM_GETBITMAPMARGIN)
EndFunc
Func _GUICtrlHeader_GetImageList($hWnd)
Return Ptr(_SendMessage($hWnd, $HDM_GETIMAGELIST))
EndFunc
Func _GUICtrlHeader_GetItem($hWnd, $iIndex, ByRef $tItem)
Local $iMsg
If _GUICtrlHeader_GetUnicodeFormat($hWnd) Then
$iMsg = $HDM_GETITEMW
Else
$iMsg = $HDM_GETITEMA
EndIf
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, $tItem, 0, True)
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_GetItemAlign($hWnd, $iIndex)
Switch BitAND(_GUICtrlHeader_GetItemFormat($hWnd, $iIndex), $HDF_JUSTIFYMASK)
Case $HDF_LEFT
Return 0
Case $HDF_RIGHT
Return 1
Case $HDF_CENTER
Return 2
Case Else
Return -1
EndSwitch
EndFunc
Func _GUICtrlHeader_GetItemBitmap($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_BITMAP)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "hBmp")
EndFunc
Func _GUICtrlHeader_GetItemCount($hWnd)
Return _SendMessage($hWnd, $HDM_GETITEMCOUNT)
EndFunc
Func _GUICtrlHeader_GetItemDisplay($hWnd, $iIndex)
Local $iRet = 0
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
If BitAND($iFormat, $HDF_BITMAP) <> 0 Then $iRet = BitOR($iRet, 1)
If BitAND($iFormat, $HDF_BITMAP_ON_RIGHT) <> 0 Then $iRet = BitOR($iRet, 2)
If BitAND($iFormat, $HDF_OWNERDRAW) <> 0 Then $iRet = BitOR($iRet, 4)
If BitAND($iFormat, $HDF_STRING) <> 0 Then $iRet = BitOR($iRet, 8)
Return $iRet
EndFunc
Func _GUICtrlHeader_GetItemFlags($hWnd, $iIndex)
Local $iRet = 0
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
If BitAND($iFormat, $HDF_IMAGE) <> 0 Then $iRet = BitOR($iRet, 1)
If BitAND($iFormat, $HDF_RTLREADING) <> 0 Then $iRet = BitOR($iRet, 2)
If BitAND($iFormat, $HDF_SORTDOWN) <> 0 Then $iRet = BitOR($iRet, 4)
If BitAND($iFormat, $HDF_SORTUP) <> 0 Then $iRet = BitOR($iRet, 8)
Return $iRet
EndFunc
Func _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_FORMAT)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Fmt")
EndFunc
Func _GUICtrlHeader_GetItemImage($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_IMAGE)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Image")
EndFunc
Func _GUICtrlHeader_GetItemOrder($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_ORDER)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Order")
EndFunc
Func _GUICtrlHeader_GetItemParam($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_PARAM)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Param")
EndFunc
Func _GUICtrlHeader_GetItemRect($hWnd, $iIndex)
Local $aRect[4]
Local $tRECT = _GUICtrlHeader_GetItemRectEx($hWnd, $iIndex)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlHeader_GetItemRectEx($hWnd, $iIndex)
Local $tRECT = DllStructCreate($tagRECT)
__GUICtrl_SendMsg($hWnd, $HDM_GETITEMRECT, $iIndex, $tRECT, 0, True)
Return $tRECT
EndFunc
Func _GUICtrlHeader_GetItemText($hWnd, $iIndex)
Local $tBuffer, $iMsg
If _GUICtrlHeader_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tHeaderBuffer
$iMsg = $HDM_GETITEMW
Else
$tBuffer = $__g_tHeaderBufferANSI
$iMsg = $HDM_GETITEMA
EndIf
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_TEXT)
DllStructSetData($tItem, "TextMax", DllStructGetSize($tBuffer))
__GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, $tItem, $tBuffer, False, 3, True, 5)
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlHeader_GetItemWidth($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_WIDTH)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "XY")
EndFunc
Func _GUICtrlHeader_GetOrderArray($hWnd)
Local $iItems = _GUICtrlHeader_GetItemCount($hWnd)
Local $tBuffer = DllStructCreate("int[" & $iItems & "]")
__GUICtrl_SendMsg($hWnd, $HDM_GETORDERARRAY, $iItems, $tBuffer, 0, True)
Local $aBuffer[$iItems + 1]
$aBuffer[0] = $iItems
For $iI = 1 To $iItems
$aBuffer[$iI] = DllStructGetData($tBuffer, 1, $iI)
Next
Return $aBuffer
EndFunc
Func _GUICtrlHeader_GetUnicodeFormat($hWnd)
If Not IsDllStruct($__g_tHeaderBuffer) Then
$__g_tHeaderBuffer = DllStructCreate("wchar Text[4096]")
$__g_tHeaderBufferANSI = DllStructCreate("char Text[4096]", DllStructGetPtr($__g_tHeaderBuffer))
EndIf
Return _SendMessage($hWnd, $HDM_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlHeader_HitTest($hWnd, $iX, $iY)
Local $tTest = DllStructCreate($tagHDHITTESTINFO)
DllStructSetData($tTest, "X", $iX)
DllStructSetData($tTest, "Y", $iY)
Local $aTest[11]
$aTest[0] = __GUICtrl_SendMsg($hWnd, $HDM_HITTEST, 0, $tTest, 0, True)
Local $iFlags = DllStructGetData($tTest, "Flags")
$aTest[1] = BitAND($iFlags, $HHT_NOWHERE) <> 0
$aTest[2] = BitAND($iFlags, $HHT_ONHEADER) <> 0
$aTest[3] = BitAND($iFlags, $HHT_ONDIVIDER) <> 0
$aTest[4] = BitAND($iFlags, $HHT_ONDIVOPEN) <> 0
$aTest[5] = BitAND($iFlags, $HHT_ONFILTER) <> 0
$aTest[6] = BitAND($iFlags, $HHT_ONFILTERBUTTON) <> 0
$aTest[7] = BitAND($iFlags, $HHT_ABOVE) <> 0
$aTest[8] = BitAND($iFlags, $HHT_BELOW) <> 0
$aTest[9] = BitAND($iFlags, $HHT_TORIGHT) <> 0
$aTest[10] = BitAND($iFlags, $HHT_TOLEFT) <> 0
Return $aTest
EndFunc
Func _GUICtrlHeader_InsertItem($hWnd, $iIndex, $sText, $iWidth = 50, $iAlign = 0, $iImage = -1, $bOnRight = False)
Local $aAlign[3] = [$HDF_LEFT, $HDF_RIGHT, $HDF_CENTER]
Local $tBuffer, $pBuffer, $iMsg
If _GUICtrlHeader_GetUnicodeFormat($hWnd) Then
$iMsg = $HDM_INSERTITEMW
$tBuffer = $__g_tHeaderBuffer
Else
$tBuffer = $__g_tHeaderBufferANSI
$iMsg = $HDM_INSERTITEMA
EndIf
Local $iBuffer
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
DllStructSetData($tBuffer, "Text", $sText)
$pBuffer = DllStructGetPtr($tBuffer)
Else
$iBuffer = 0
$tBuffer = 0
$pBuffer = -1
EndIf
Local $iFmt = $aAlign[$iAlign]
Local $iMask = BitOR($HDI_WIDTH, $HDI_FORMAT)
If $sText <> "" Then
$iMask = BitOR($iMask, $HDI_TEXT)
$iFmt = BitOR($iFmt, $HDF_STRING)
EndIf
If $iImage <> -1 Then
$iMask = BitOR($iMask, $HDI_IMAGE)
$iFmt = BitOR($iFmt, $HDF_IMAGE)
EndIf
If $bOnRight Then $iFmt = BitOR($iFmt, $HDF_BITMAP_ON_RIGHT)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "XY", $iWidth)
DllStructSetData($tItem, "Fmt", $iFmt)
DllStructSetData($tItem, "Image", $iImage)
DllStructSetData($tItem, "Text", $pBuffer)
DllStructSetData($tItem, "TextMax", $iBuffer)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, $tItem, $tBuffer, False, -1)
Return $iRet
EndFunc
Func _GUICtrlHeader_Layout($hWnd, ByRef $tRECT)
Local $tLayout = DllStructCreate($tagHDLAYOUT)
Local $tWindowPos = DllStructCreate($tagWINDOWPOS)
If _WinAPI_InProcess($hWnd, $__g_hGUICtrl_LastWnd) Then
DllStructSetData($tLayout, "Rect", DllStructGetPtr($tRECT))
DllStructSetData($tLayout, "WindowPos", DllStructGetPtr($tWindowPos))
_SendMessage($hWnd, $HDM_LAYOUT, 0, $tLayout, 0, "wparam", "struct*")
Else
Local $iLayout = DllStructGetSize($tLayout)
Local $iRect = DllStructGetSize($tRECT)
Local $iWindowPos = DllStructGetSize($tWindowPos)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iLayout + $iRect + $iWindowPos, $tMemMap)
DllStructSetData($tLayout, "Rect", $pMemory + $iLayout)
DllStructSetData($tLayout, "WindowPos", $pMemory + $iLayout + $iRect)
_MemWrite($tMemMap, $tLayout, $pMemory, $iLayout)
_MemWrite($tMemMap, $tRECT, $pMemory + $iLayout, $iRect)
_SendMessage($hWnd, $HDM_LAYOUT, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory + $iLayout + $iRect, $tWindowPos, $iWindowPos)
_MemFree($tMemMap)
EndIf
Return $tWindowPos
EndFunc
Func _GUICtrlHeader_OrderToIndex($hWnd, $iOrder)
Return _SendMessage($hWnd, $HDM_ORDERTOINDEX, $iOrder)
EndFunc
Func _GUICtrlHeader_SetBitmapMargin($hWnd, $iWidth)
Return _SendMessage($hWnd, $HDM_SETBITMAPMARGIN, $iWidth)
EndFunc
Func _GUICtrlHeader_SetFilterChangeTimeout($hWnd, $iTimeOut)
Return _SendMessage($hWnd, $HDM_SETFILTERCHANGETIMEOUT, 0, $iTimeOut)
EndFunc
Func _GUICtrlHeader_SetHotDivider($hWnd, $iFlag, $iInputValue)
Return _SendMessage($hWnd, $HDM_SETHOTDIVIDER, $iFlag, $iInputValue)
EndFunc
Func _GUICtrlHeader_SetImageList($hWnd, $hImage)
Return _SendMessage($hWnd, $HDM_SETIMAGELIST, 0, $hImage, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlHeader_SetItem($hWnd, $iIndex, ByRef $tItem)
Local $iMsg
If _GUICtrlHeader_GetUnicodeFormat($hWnd) Then
$iMsg = $HDM_SETITEMW
Else
$iMsg = $HDM_SETITEMA
EndIf
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, $tItem)
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_SetItemAlign($hWnd, $iIndex, $iAlign)
Local $aAlign[3] = [$HDF_LEFT, $HDF_RIGHT, $HDF_CENTER]
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
$iFormat = BitAND($iFormat, BitNOT($HDF_JUSTIFYMASK))
$iFormat = BitOR($iFormat, $aAlign[$iAlign])
Return _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
EndFunc
Func _GUICtrlHeader_SetItemBitmap($hWnd, $iIndex, $hBitmap)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", BitOR($HDI_FORMAT, $HDI_BITMAP))
DllStructSetData($tItem, "Fmt", $HDF_BITMAP)
DllStructSetData($tItem, "hBMP", $hBitmap)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemDisplay($hWnd, $iIndex, $iDisplay)
Local $iFormat = BitAND(_GUICtrlHeader_GetItemFormat($hWnd, $iIndex), Not $HDF_DISPLAYMASK)
If BitAND($iDisplay, 1) <> 0 Then $iFormat = BitOR($iFormat, $HDF_BITMAP)
If BitAND($iDisplay, 2) <> 0 Then $iFormat = BitOR($iFormat, $HDF_BITMAP_ON_RIGHT)
If BitAND($iDisplay, 4) <> 0 Then $iFormat = BitOR($iFormat, $HDF_OWNERDRAW)
If BitAND($iDisplay, 8) <> 0 Then $iFormat = BitOR($iFormat, $HDF_STRING)
Return _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
EndFunc
Func _GUICtrlHeader_SetItemFlags($hWnd, $iIndex, $iFlags)
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
$iFormat = BitAND($iFormat, BitNOT($HDF_FLAGMASK))
If BitAND($iFlags, 1) <> 0 Then $iFormat = BitOR($iFormat, $HDF_IMAGE)
If BitAND($iFlags, 2) <> 0 Then $iFormat = BitOR($iFormat, $HDF_RTLREADING)
If BitAND($iFlags, 4) <> 0 Then $iFormat = BitOR($iFormat, $HDF_SORTDOWN)
If BitAND($iFlags, 8) <> 0 Then $iFormat = BitOR($iFormat, $HDF_SORTUP)
Return _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
EndFunc
Func _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_FORMAT)
DllStructSetData($tItem, "Fmt", $iFormat)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemImage($hWnd, $iIndex, $iImage)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_IMAGE)
DllStructSetData($tItem, "Image", $iImage)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemOrder($hWnd, $iIndex, $iOrder)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_ORDER)
DllStructSetData($tItem, "Order", $iOrder)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemParam($hWnd, $iIndex, $iParam)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_PARAM)
DllStructSetData($tItem, "Param", $iParam)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemText($hWnd, $iIndex, $sText)
Local $tBuffer, $iMsg
If _GUICtrlHeader_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tHeaderBuffer
$iMsg = $HDM_SETITEMW
Else
$tBuffer = $__g_tHeaderBufferANSI
$iMsg = $HDM_SETITEMA
EndIf
Local $iBuffer, $pBuffer
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
DllStructSetData($tBuffer, "Text", $sText)
$pBuffer = DllStructGetPtr($tBuffer)
Else
$iBuffer = 0
$tBuffer = 0
$pBuffer = -1
EndIf
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_TEXT)
DllStructSetData($tItem, "Text", $pBuffer)
DllStructSetData($tItem, "TextMax", $iBuffer)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, $tItem, $tBuffer, False, -1)
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_SetItemWidth($hWnd, $iIndex, $iWidth)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_WIDTH)
DllStructSetData($tItem, "XY", $iWidth)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetOrderArray($hWnd, ByRef $aOrder)
Local $tBuffer = DllStructCreate("int[" & $aOrder[0] & "]")
For $iI = 1 To $aOrder[0]
DllStructSetData($tBuffer, 1, $aOrder[$iI], $iI)
Next
Local $iRet = __GUICtrl_SendMsg($hWnd, $HDM_SETORDERARRAY, $aOrder[0], $tBuffer)
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_SetUnicodeFormat($hWnd, $bUnicode)
Return _SendMessage($hWnd, $HDM_SETUNICODEFORMAT, $bUnicode)
EndFunc
Global Const $LVGS_NORMAL = 0x00000000
Global Const $LVGS_COLLAPSED = 0x00000001
Global Const $LVGS_HIDDEN = 0x00000002
Global Const $LVGS_NOHEADER = 0x00000004
Global Const $LVGS_COLLAPSIBLE = 0x00000008
Global Const $LVGS_FOCUSED = 0x00000010
Global Const $LVGS_SELECTED = 0x00000020
Global Const $LVGS_SUBSETED = 0x00000040
Global Const $LVGS_SUBSETLINKFOCUSED = 0x00000080
Global Const $LVGGR_GROUP = 0
Global Const $LVGGR_HEADER = 1
Global Const $LVGGR_LABEL = 2
Global Const $LVGGR_SUBSETLINK = 3
Global Const $LV_ERR = -1
Global Const $LVBKIF_SOURCE_NONE = 0x00000000
Global Const $LVBKIF_SOURCE_HBITMAP = 0x00000001
Global Const $LVBKIF_SOURCE_URL = 0x00000002
Global Const $LVBKIF_SOURCE_MASK = 0x00000003
Global Const $LVBKIF_STYLE_NORMAL = 0x00000000
Global Const $LVBKIF_STYLE_TILE = 0x00000010
Global Const $LVBKIF_STYLE_MASK = 0x00000010
Global Const $LVBKIF_FLAG_TILEOFFSET = 0x00000100
Global Const $LVBKIF_TYPE_WATERMARK = 0x10000000
Global Const $LV_VIEW_DETAILS = 0x0001
Global Const $LV_VIEW_ICON = 0x0000
Global Const $LV_VIEW_LIST = 0x0003
Global Const $LV_VIEW_SMALLICON = 0x0002
Global Const $LV_VIEW_TILE = 0x0004
Global Const $LVA_ALIGNLEFT = 0x0001
Global Const $LVA_ALIGNTOP = 0x0002
Global Const $LVA_DEFAULT = 0x0000
Global Const $LVA_SNAPTOGRID = 0x0005
Global Const $LVCDI_ITEM = 0x00000000
Global Const $LVCDI_GROUP = 0x00000001
Global Const $LVCF_ALLDATA = 0X0000003F
Global Const $LVCF_FMT = 0x0001
Global Const $LVCF_IMAGE = 0x0010
Global Const $LVCFMT_JUSTIFYMASK = 0x0003
Global Const $LVCF_TEXT = 0x0004
Global Const $LVCF_WIDTH = 0x0002
Global Const $LVCFMT_BITMAP_ON_RIGHT = 0x1000
Global Const $LVCFMT_CENTER = 0x0002
Global Const $LVCFMT_COL_HAS_IMAGES = 0x8000
Global Const $LVCFMT_IMAGE = 0x0800
Global Const $LVCFMT_LEFT = 0x0000
Global Const $LVCFMT_RIGHT = 0x0001
Global Const $LVCFMT_LINE_BREAK = 0x100000
Global Const $LVCFMT_FILL = 0x200000
Global Const $LVCFMT_WRAP = 0x400000
Global Const $LVCFMT_NO_TITLE = 0x800000
Global Const $LVCFMT_TILE_PLACEMENTMASK = BitOR($LVCFMT_LINE_BREAK, $LVCFMT_FILL)
Global Const $LVFI_NEARESTXY = 0x0040
Global Const $LVFI_PARAM = 0x0001
Global Const $LVFI_PARTIAL = 0x0008
Global Const $LVFI_STRING = 0x0002
Global Const $LVFI_SUBSTRING = 0x0004
Global Const $LVFI_WRAP = 0x0020
Global Const $LVGA_FOOTER_LEFT = 0x00000008
Global Const $LVGA_FOOTER_CENTER = 0x00000010
Global Const $LVGA_FOOTER_RIGHT = 0x00000020
Global Const $LVGA_HEADER_LEFT = 0x00000001
Global Const $LVGA_HEADER_CENTER = 0x00000002
Global Const $LVGA_HEADER_RIGHT = 0x00000004
Global Const $LVGF_ALIGN = 0x00000008
Global Const $LVGF_DESCRIPTIONTOP = 0x00000400
Global Const $LVGF_DESCRIPTIONBOTTOM = 0x00000800
Global Const $LVGF_EXTENDEDIMAGE = 0x00002000
Global Const $LVGF_FOOTER = 0x00000002
Global Const $LVGF_GROUPID = 0x00000010
Global Const $LVGF_HEADER = 0x00000001
Global Const $LVGF_ITEMS = 0x00004000
Global Const $LVGF_NONE = 0x00000000
Global Const $LVGF_STATE = 0x00000004
Global Const $LVGF_SUBSET = 0x00008000
Global Const $LVGF_SUBSETITEMS = 0x00010000
Global Const $LVGF_SUBTITLE = 0x00000100
Global Const $LVGF_TASK = 0x00000200
Global Const $LVGF_TITLEIMAGE = 0x00001000
Global Const $LVHT_ABOVE = 0x00000008
Global Const $LVHT_BELOW = 0x00000010
Global Const $LVHT_NOWHERE = 0x00000001
Global Const $LVHT_ONITEMICON = 0x00000002
Global Const $LVHT_ONITEMLABEL = 0x00000004
Global Const $LVHT_ONITEMSTATEICON = 0x00000008
Global Const $LVHT_TOLEFT = 0x00000040
Global Const $LVHT_TORIGHT = 0x00000020
Global Const $LVHT_ONITEM = BitOR($LVHT_ONITEMICON, $LVHT_ONITEMLABEL, $LVHT_ONITEMSTATEICON)
Global Const $LVHT_EX_GROUP_HEADER = 0x10000000
Global Const $LVHT_EX_GROUP_FOOTER = 0x20000000
Global Const $LVHT_EX_GROUP_COLLAPSE = 0x40000000
Global Const $LVHT_EX_GROUP_BACKGROUND = 0x80000000
Global Const $LVHT_EX_GROUP_STATEICON = 0x01000000
Global Const $LVHT_EX_GROUP_SUBSETLINK = 0x02000000
Global Const $LVHT_EX_GROUP = BitOR($LVHT_EX_GROUP_BACKGROUND, $LVHT_EX_GROUP_COLLAPSE, $LVHT_EX_GROUP_FOOTER, $LVHT_EX_GROUP_HEADER, $LVHT_EX_GROUP_STATEICON, $LVHT_EX_GROUP_SUBSETLINK)
Global Const $LVHT_EX_ONCONTENTS = 0x04000000
Global Const $LVHT_EX_FOOTER = 0x08000000
Global Const $LVIF_COLFMT = 0x00010000
Global Const $LVIF_COLUMNS = 0x00000200
Global Const $LVIF_GROUPID = 0x00000100
Global Const $LVIF_IMAGE = 0x00000002
Global Const $LVIF_INDENT = 0x00000010
Global Const $LVIF_NORECOMPUTE = 0x00000800
Global Const $LVIF_PARAM = 0x00000004
Global Const $LVIF_STATE = 0x00000008
Global Const $LVIF_TEXT = 0x00000001
Global Const $LVIM_AFTER = 0x00000001
Global Const $LVIR_BOUNDS = 0
Global Const $LVIR_ICON = 1
Global Const $LVIR_LABEL = 2
Global Const $LVIR_SELECTBOUNDS = 3
Global Const $LVIS_CUT = 0x0004
Global Const $LVIS_DROPHILITED = 0x0008
Global Const $LVIS_FOCUSED = 0x0001
Global Const $LVIS_OVERLAYMASK = 0x0F00
Global Const $LVIS_SELECTED = 0x0002
Global Const $LVIS_STATEIMAGEMASK = 0xF000
Global Const $LVS_ALIGNLEFT = 0x0800
Global Const $LVS_ALIGNMASK = 0x0c00
Global Const $LVS_ALIGNTOP = 0x0000
Global Const $LVS_AUTOARRANGE = 0x0100
Global Const $LVS_DEFAULT = 0x0000000D
Global Const $LVS_EDITLABELS = 0x0200
Global Const $LVS_ICON = 0x0000
Global Const $LVS_LIST = 0x0003
Global Const $LVS_NOCOLUMNHEADER = 0x4000
Global Const $LVS_NOLABELWRAP = 0x0080
Global Const $LVS_NOSCROLL = 0x2000
Global Const $LVS_NOSORTHEADER = 0x8000
Global Const $LVS_OWNERDATA = 0x1000
Global Const $LVS_OWNERDRAWFIXED = 0x0400
Global Const $LVS_REPORT = 0x0001
Global Const $LVS_SHAREIMAGELISTS = 0x0040
Global Const $LVS_SHOWSELALWAYS = 0x0008
Global Const $LVS_SINGLESEL = 0x0004
Global Const $LVS_SMALLICON = 0x0002
Global Const $LVS_SORTASCENDING = 0x0010
Global Const $LVS_SORTDESCENDING = 0x0020
Global Const $LVS_TYPEMASK = 0x0003
Global Const $LVS_TYPESTYLEMASK = 0xfc00
Global Const $LVS_EX_AUTOAUTOARRANGE = 0x01000000
Global Const $LVS_EX_AUTOCHECKSELECT = 0x08000000
Global Const $LVS_EX_AUTOSIZECOLUMNS = 0x10000000
Global Const $LVS_EX_BORDERSELECT = 0x00008000
Global Const $LVS_EX_CHECKBOXES = 0x00000004
Global Const $LVS_EX_COLUMNOVERFLOW = 0x80000000
Global Const $LVS_EX_COLUMNSNAPPOINTS = 0x40000000
Global Const $LVS_EX_DOUBLEBUFFER = 0x00010000
Global Const $LVS_EX_FLATSB = 0x00000100
Global Const $LVS_EX_FULLROWSELECT = 0x00000020
Global Const $LVS_EX_GRIDLINES = 0x00000001
Global Const $LVS_EX_HEADERDRAGDROP = 0x00000010
Global Const $LVS_EX_HEADERINALLVIEWS = 0x02000000
Global Const $LVS_EX_HIDELABELS = 0x20000
Global Const $LVS_EX_INFOTIP = 0x00000400
Global Const $LVS_EX_JUSTIFYCOLUMNS = 0x00200000
Global Const $LVS_EX_LABELTIP = 0x00004000
Global Const $LVS_EX_MULTIWORKAREAS = 0x00002000
Global Const $LVS_EX_ONECLICKACTIVATE = 0x00000040
Global Const $LVS_EX_REGIONAL = 0x00000200
Global Const $LVS_EX_SIMPLESELECT = 0x00100000
Global Const $LVS_EX_SNAPTOGRID = 0x00080000
Global Const $LVS_EX_SUBITEMIMAGES = 0x00000002
Global Const $LVS_EX_TRACKSELECT = 0x00000008
Global Const $LVS_EX_TRANSPARENTBKGND = 0x00400000
Global Const $LVS_EX_TRANSPARENTSHADOWTEXT = 0x00800000
Global Const $LVS_EX_TWOCLICKACTIVATE = 0x00000080
Global Const $LVS_EX_UNDERLINECOLD = 0x00001000
Global Const $LVS_EX_UNDERLINEHOT = 0x00000800
Global Const $GUI_SS_DEFAULT_LISTVIEW = BitOR($LVS_SHOWSELALWAYS, $LVS_SINGLESEL)
Global Const $LVM_FIRST = 0x1000
Global Const $LVM_APPROXIMATEVIEWRECT = ($LVM_FIRST + 64)
Global Const $LVM_ARRANGE = ($LVM_FIRST + 22)
Global Const $LVM_CANCELEDITLABEL = ($LVM_FIRST + 179)
Global Const $LVM_CREATEDRAGIMAGE = ($LVM_FIRST + 33)
Global Const $LVM_DELETEALLITEMS = ($LVM_FIRST + 9)
Global Const $LVM_DELETECOLUMN = ($LVM_FIRST + 28)
Global Const $LVM_DELETEITEM = ($LVM_FIRST + 8)
Global Const $LVM_EDITLABELA = ($LVM_FIRST + 23)
Global Const $LVM_EDITLABELW = ($LVM_FIRST + 118)
Global Const $LVM_EDITLABEL = $LVM_EDITLABELA
Global Const $LVM_ENABLEGROUPVIEW = ($LVM_FIRST + 157)
Global Const $LVM_ENSUREVISIBLE = ($LVM_FIRST + 19)
Global Const $LVM_FINDITEM = ($LVM_FIRST + 13)
Global Const $LVM_GETBKCOLOR = ($LVM_FIRST + 0)
Global Const $LVM_GETBKIMAGEA = ($LVM_FIRST + 69)
Global Const $LVM_GETBKIMAGEW = ($LVM_FIRST + 139)
Global Const $LVM_GETCALLBACKMASK = ($LVM_FIRST + 10)
Global Const $LVM_GETCOLUMNA = ($LVM_FIRST + 25)
Global Const $LVM_GETCOLUMNW = ($LVM_FIRST + 95)
Global Const $LVM_GETCOLUMNORDERARRAY = ($LVM_FIRST + 59)
Global Const $LVM_GETCOLUMNWIDTH = ($LVM_FIRST + 29)
Global Const $LVM_GETCOUNTPERPAGE = ($LVM_FIRST + 40)
Global Const $LVM_GETEDITCONTROL = ($LVM_FIRST + 24)
Global Const $LVM_GETEMPTYTEXT = ($LVM_FIRST + 204)
Global Const $LVM_GETEXTENDEDLISTVIEWSTYLE = ($LVM_FIRST + 55)
Global Const $LVM_GETFOCUSEDGROUP = ($LVM_FIRST + 93)
Global Const $LVM_GETFOOTERINFO = ($LVM_FIRST + 206)
Global Const $LVM_GETFOOTERITEM = ($LVM_FIRST + 208)
Global Const $LVM_GETFOOTERITEMRECT = ($LVM_FIRST + 207)
Global Const $LVM_GETFOOTERRECT = ($LVM_FIRST + 205)
Global Const $LVM_GETGROUPCOUNT = ($LVM_FIRST + 152)
Global Const $LVM_GETGROUPINFO = ($LVM_FIRST + 149)
Global Const $LVM_GETGROUPINFOBYINDEX = ($LVM_FIRST + 153)
Global Const $LVM_GETGROUPMETRICS = ($LVM_FIRST + 156)
Global Const $LVM_GETGROUPRECT = ($LVM_FIRST + 98)
Global Const $LVM_GETGROUPSTATE = ($LVM_FIRST + 92)
Global Const $LVM_GETHEADER = ($LVM_FIRST + 31)
Global Const $LVM_GETHOTCURSOR = ($LVM_FIRST + 63)
Global Const $LVM_GETHOTITEM = ($LVM_FIRST + 61)
Global Const $LVM_GETHOVERTIME = ($LVM_FIRST + 72)
Global Const $LVM_GETIMAGELIST = ($LVM_FIRST + 2)
Global Const $LVM_GETINSERTMARK = ($LVM_FIRST + 167)
Global Const $LVM_GETINSERTMARKCOLOR = ($LVM_FIRST + 171)
Global Const $LVM_GETINSERTMARKRECT = ($LVM_FIRST + 169)
Global Const $LVM_GETISEARCHSTRINGA = ($LVM_FIRST + 52)
Global Const $LVM_GETISEARCHSTRINGW = ($LVM_FIRST + 117)
Global Const $LVM_GETITEMA = ($LVM_FIRST + 5)
Global Const $LVM_GETITEMW = ($LVM_FIRST + 75)
Global Const $LVM_GETITEMCOUNT = ($LVM_FIRST + 4)
Global Const $LVM_GETITEMINDEXRECT = ($LVM_FIRST + 209)
Global Const $LVM_GETITEMPOSITION = ($LVM_FIRST + 16)
Global Const $LVM_GETITEMRECT = ($LVM_FIRST + 14)
Global Const $LVM_GETITEMSPACING = ($LVM_FIRST + 51)
Global Const $LVM_GETITEMSTATE = ($LVM_FIRST + 44)
Global Const $LVM_GETITEMTEXTA = ($LVM_FIRST + 45)
Global Const $LVM_GETITEMTEXTW = ($LVM_FIRST + 115)
Global Const $LVM_GETNEXTITEM = ($LVM_FIRST + 12)
Global Const $LVM_GETNEXTITEMINDEX = ($LVM_FIRST + 211)
Global Const $LVM_GETNUMBEROFWORKAREAS = ($LVM_FIRST + 73)
Global Const $LVM_GETORIGIN = ($LVM_FIRST + 41)
Global Const $LVM_GETOUTLINECOLOR = ($LVM_FIRST + 176)
Global Const $LVM_GETSELECTEDCOLUMN = ($LVM_FIRST + 174)
Global Const $LVM_GETSELECTEDCOUNT = ($LVM_FIRST + 50)
Global Const $LVM_GETSELECTIONMARK = ($LVM_FIRST + 66)
Global Const $LVM_GETSTRINGWIDTHA = ($LVM_FIRST + 17)
Global Const $LVM_GETSTRINGWIDTHW = ($LVM_FIRST + 87)
Global Const $LVM_GETSUBITEMRECT = ($LVM_FIRST + 56)
Global Const $LVM_GETTEXTBKCOLOR = ($LVM_FIRST + 37)
Global Const $LVM_GETTEXTCOLOR = ($LVM_FIRST + 35)
Global Const $LVM_GETTILEINFO = ($LVM_FIRST + 165)
Global Const $LVM_GETTILEVIEWINFO = ($LVM_FIRST + 163)
Global Const $LVM_GETTOOLTIPS = ($LVM_FIRST + 78)
Global Const $LVM_GETTOPINDEX = ($LVM_FIRST + 39)
Global Const $LVM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $LVM_GETVIEW = ($LVM_FIRST + 143)
Global Const $LVM_GETVIEWRECT = ($LVM_FIRST + 34)
Global Const $LVM_GETWORKAREAS = ($LVM_FIRST + 70)
Global Const $LVM_HASGROUP = ($LVM_FIRST + 161)
Global Const $LVM_HITTEST = ($LVM_FIRST + 18)
Global Const $LVM_INSERTCOLUMNA = ($LVM_FIRST + 27)
Global Const $LVM_INSERTCOLUMNW = ($LVM_FIRST + 97)
Global Const $LVM_INSERTGROUP = ($LVM_FIRST + 145)
Global Const $LVM_INSERTGROUPSORTED = ($LVM_FIRST + 159)
Global Const $LVM_INSERTITEMA = ($LVM_FIRST + 7)
Global Const $LVM_INSERTITEMW = ($LVM_FIRST + 77)
Global Const $LVM_INSERTMARKHITTEST = ($LVM_FIRST + 168)
Global Const $LVM_ISGROUPVIEWENABLED = ($LVM_FIRST + 175)
Global Const $LVM_ISITEMVISIBLE = ($LVM_FIRST + 182)
Global Const $LVM_MAPIDTOINDEX = ($LVM_FIRST + 181)
Global Const $LVM_MAPINDEXTOID = ($LVM_FIRST + 180)
Global Const $LVM_MOVEGROUP = ($LVM_FIRST + 151)
Global Const $LVM_REDRAWITEMS = ($LVM_FIRST + 21)
Global Const $LVM_REMOVEALLGROUPS = ($LVM_FIRST + 160)
Global Const $LVM_REMOVEGROUP = ($LVM_FIRST + 150)
Global Const $LVM_SCROLL = ($LVM_FIRST + 20)
Global Const $LVM_SETBKCOLOR = ($LVM_FIRST + 1)
Global Const $LVM_SETBKIMAGEA = ($LVM_FIRST + 68)
Global Const $LVM_SETBKIMAGEW = ($LVM_FIRST + 138)
Global Const $LVM_SETCALLBACKMASK = ($LVM_FIRST + 11)
Global Const $LVM_SETCOLUMNA = ($LVM_FIRST + 26)
Global Const $LVM_SETCOLUMNW = ($LVM_FIRST + 96)
Global Const $LVM_SETCOLUMNORDERARRAY = ($LVM_FIRST + 58)
Global Const $LVM_SETCOLUMNWIDTH = ($LVM_FIRST + 30)
Global Const $LVM_SETEXTENDEDLISTVIEWSTYLE = ($LVM_FIRST + 54)
Global Const $LVM_SETGROUPINFO = ($LVM_FIRST + 147)
Global Const $LVM_SETGROUPMETRICS = ($LVM_FIRST + 155)
Global Const $LVM_SETHOTCURSOR = ($LVM_FIRST + 62)
Global Const $LVM_SETHOTITEM = ($LVM_FIRST + 60)
Global Const $LVM_SETHOVERTIME = ($LVM_FIRST + 71)
Global Const $LVM_SETICONSPACING = ($LVM_FIRST + 53)
Global Const $LVM_SETIMAGELIST = ($LVM_FIRST + 3)
Global Const $LVM_SETINFOTIP = ($LVM_FIRST + 173)
Global Const $LVM_SETINSERTMARK = ($LVM_FIRST + 166)
Global Const $LVM_SETINSERTMARKCOLOR = ($LVM_FIRST + 170)
Global Const $LVM_SETITEMA = ($LVM_FIRST + 6)
Global Const $LVM_SETITEMW = ($LVM_FIRST + 76)
Global Const $LVM_SETITEMCOUNT = ($LVM_FIRST + 47)
Global Const $LVM_SETITEMINDEXSTATE = ($LVM_FIRST + 210)
Global Const $LVM_SETITEMPOSITION = ($LVM_FIRST + 15)
Global Const $LVM_SETITEMPOSITION32 = ($LVM_FIRST + 49)
Global Const $LVM_SETITEMSTATE = ($LVM_FIRST + 43)
Global Const $LVM_SETITEMTEXTA = ($LVM_FIRST + 46)
Global Const $LVM_SETITEMTEXTW = ($LVM_FIRST + 116)
Global Const $LVM_SETOUTLINECOLOR = ($LVM_FIRST + 177)
Global Const $LVM_SETSELECTEDCOLUMN = ($LVM_FIRST + 140)
Global Const $LVM_SETSELECTIONMARK = ($LVM_FIRST + 67)
Global Const $LVM_SETTEXTBKCOLOR = ($LVM_FIRST + 38)
Global Const $LVM_SETTEXTCOLOR = ($LVM_FIRST + 36)
Global Const $LVM_SETTILEINFO = ($LVM_FIRST + 164)
Global Const $LVM_SETTILEVIEWINFO = ($LVM_FIRST + 162)
Global Const $LVM_SETTILEWIDTH = ($LVM_FIRST + 141)
Global Const $LVM_SETTOOLTIPS = ($LVM_FIRST + 74)
Global Const $LVM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $LVM_SETVIEW = ($LVM_FIRST + 142)
Global Const $LVM_SETWORKAREAS = ($LVM_FIRST + 65)
Global Const $LVM_SORTGROUPS = ($LVM_FIRST + 158)
Global Const $LVM_SORTITEMS = ($LVM_FIRST + 48)
Global Const $LVM_SORTITEMSEX = ($LVM_FIRST + 81)
Global Const $LVM_SUBITEMHITTEST = ($LVM_FIRST + 57)
Global Const $LVM_UPDATE = ($LVM_FIRST + 42)
Global Const $LVN_FIRST = -100
Global Const $LVN_LAST = -199
Global Const $LVN_BEGINDRAG = ($LVN_FIRST - 9)
Global Const $LVN_BEGINLABELEDITA = ($LVN_FIRST - 5)
Global Const $LVN_BEGINLABELEDITW = ($LVN_FIRST - 75)
Global Const $LVN_BEGINRDRAG = ($LVN_FIRST - 11)
Global Const $LVN_BEGINSCROLL = ($LVN_FIRST - 80)
Global Const $LVN_COLUMNCLICK = ($LVN_FIRST - 8)
Global Const $LVN_COLUMNDROPDOWN = ($LVN_FIRST - 64)
Global Const $LVN_COLUMNOVERFLOWCLICK = ($LVN_FIRST - 66)
Global Const $LVN_DELETEALLITEMS = ($LVN_FIRST - 4)
Global Const $LVN_DELETEITEM = ($LVN_FIRST - 3)
Global Const $LVN_ENDLABELEDITA = ($LVN_FIRST - 6)
Global Const $LVN_ENDLABELEDITW = ($LVN_FIRST - 76)
Global Const $LVN_ENDSCROLL = ($LVN_FIRST - 81)
Global Const $LVN_GETDISPINFOA = ($LVN_FIRST - 50)
Global Const $LVN_GETDISPINFOW = ($LVN_FIRST - 77)
Global Const $LVN_GETDISPINFO = $LVN_GETDISPINFOA
Global Const $LVN_GETEMPTYMARKUP = ($LVN_FIRST - 87)
Global Const $LVN_GETINFOTIPA = ($LVN_FIRST - 57)
Global Const $LVN_GETINFOTIPW = ($LVN_FIRST - 58)
Global Const $LVN_HOTTRACK = ($LVN_FIRST - 21)
Global Const $LVN_INCREMENTALSEARCHA = ($LVN_FIRST - 62)
Global Const $LVN_INCREMENTALSEARCHW = ($LVN_FIRST - 63)
Global Const $LVN_INSERTITEM = ($LVN_FIRST - 2)
Global Const $LVN_ITEMACTIVATE = ($LVN_FIRST - 14)
Global Const $LVN_ITEMCHANGED = ($LVN_FIRST - 1)
Global Const $LVN_ITEMCHANGING = ($LVN_FIRST - 0)
Global Const $LVN_KEYDOWN = ($LVN_FIRST - 55)
Global Const $LVN_LINKCLICK = ($LVN_FIRST - 84)
Global Const $LVN_MARQUEEBEGIN = ($LVN_FIRST - 56)
Global Const $LVN_ODCACHEHINT = ($LVN_FIRST - 13)
Global Const $LVN_ODFINDITEMA = ($LVN_FIRST - 52)
Global Const $LVN_ODFINDITEMW = ($LVN_FIRST - 79)
Global Const $LVN_ODFINDITEM = $LVN_ODFINDITEMA
Global Const $LVN_ODSTATECHANGED = ($LVN_FIRST - 15)
Global Const $LVN_SETDISPINFOA = ($LVN_FIRST - 51)
Global Const $LVN_SETDISPINFOW = ($LVN_FIRST - 78)
Global Const $LVNI_ABOVE = 0x0100
Global Const $LVNI_BELOW = 0x0200
Global Const $LVNI_TOLEFT = 0x0400
Global Const $LVNI_TORIGHT = 0x0800
Global Const $LVNI_ALL = 0x0000
Global Const $LVNI_CUT = 0x0004
Global Const $LVNI_DROPHILITED = 0x0008
Global Const $LVNI_FOCUSED = 0x0001
Global Const $LVNI_SELECTED = 0x0002
Global Const $LVSCW_AUTOSIZE = -1
Global Const $LVSCW_AUTOSIZE_USEHEADER = -2
Global Const $LVSICF_NOINVALIDATEALL = 0x00000001
Global Const $LVSICF_NOSCROLL = 0x00000002
Global Const $LVSIL_NORMAL = 0
Global Const $LVSIL_SMALL = 1
Global Const $LVSIL_STATE = 2
Global Const $LVFN_DIR_LEFT = 0
Global Const $LVFN_DIR_RIGHT = 1
Global Const $LVFN_DIR_UP = 2
Global Const $LVFN_DIR_DOWN = 3
Global Const $LVFN_DIR_START = 4
Global Const $LVFN_DIR_MEND = 5
Global Const $LVFN_DIR_PRIOR = 6
Global Const $LVFN_DIR_NEXT = 7
Global Const $FR_PRIVATE = 0x10
Global Const $FR_NOT_ENUM = 0x20
Global Const $COMPRESSION_BITMAP_PNG = 0
Global Const $COMPRESSION_BITMAP_JPEG = 1
Global Const $BS_DIBPATTERN = 5
Global Const $BS_DIBPATTERN8X8 = 8
Global Const $BS_DIBPATTERNPT = 6
Global Const $BS_HATCHED = 2
Global Const $BS_HOLLOW = 1
Global Const $BS_NULL = 1
Global Const $BS_PATTERN = 3
Global Const $BS_PATTERN8X8 = 7
Global Const $BS_SOLID = 0
Global Const $HS_BDIAGONAL = 3
Global Const $HS_CROSS = 4
Global Const $HS_DIAGCROSS = 5
Global Const $HS_FDIAGONAL = 2
Global Const $HS_HORIZONTAL = 0
Global Const $HS_VERTICAL = 1
Global Const $DIB_PAL_COLORS = 1
Global Const $DIB_RGB_COLORS = 0
Global Const $CA_NEGATIVE = 0x01
Global Const $CA_LOG_FILTER = 0x02
Global Const $ILLUMINANT_DEVICE_DEFAULT = 0
Global Const $ILLUMINANT_A = 1
Global Const $ILLUMINANT_B = 2
Global Const $ILLUMINANT_C = 3
Global Const $ILLUMINANT_D50 = 4
Global Const $ILLUMINANT_D55 = 5
Global Const $ILLUMINANT_D65 = 6
Global Const $ILLUMINANT_D75 = 7
Global Const $ILLUMINANT_F2 = 8
Global Const $ILLUMINANT_TUNGSTEN = $ILLUMINANT_A
Global Const $ILLUMINANT_DAYLIGHT = $ILLUMINANT_C
Global Const $ILLUMINANT_FLUORESCENT = $ILLUMINANT_F2
Global Const $ILLUMINANT_NTSC = $ILLUMINANT_C
Global Const $BI_RGB = 0
Global Const $BI_RLE8 = 1
Global Const $BI_RLE4 = 2
Global Const $BI_BITFIELDS = 3
Global Const $BI_JPEG = 4
Global Const $BI_PNG = 5
Global Const $ALTERNATE = 1
Global Const $WINDING = 2
Global Const $DWMWA_NCRENDERING_ENABLED = 1
Global Const $DWMWA_NCRENDERING_POLICY = 2
Global Const $DWMWA_TRANSITIONS_FORCEDISABLED = 3
Global Const $DWMWA_ALLOW_NCPAINT = 4
Global Const $DWMWA_CAPTION_BUTTON_BOUNDS = 5
Global Const $DWMWA_NONCLIENT_RTL_LAYOUT = 6
Global Const $DWMWA_FORCE_ICONIC_REPRESENTATION = 7
Global Const $DWMWA_FLIP3D_POLICY = 8
Global Const $DWMWA_EXTENDED_FRAME_BOUNDS = 9
Global Const $DWMWA_HAS_ICONIC_BITMAP = 10
Global Const $DWMWA_DISALLOW_PEEK = 11
Global Const $DWMWA_EXCLUDED_FROM_PEEK = 12
Global Const $DWMNCRP_USEWINDOWSTYLE = 0
Global Const $DWMNCRP_DISABLED = 1
Global Const $DWMNCRP_ENABLED = 2
Global Const $DWMFLIP3D_DEFAULT = 0
Global Const $DWMFLIP3D_EXCLUDEBELOW = 1
Global Const $DWMFLIP3D_EXCLUDEABOVE = 2
Global Const $DM_BITSPERPEL = 0x00040000
Global Const $DM_COLLATE = 0x0008000
Global Const $DM_COLOR = 0x00000800
Global Const $DM_COPIES = 0x00000100
Global Const $DM_DEFAULTSOURCE = 0x00000200
Global Const $DM_DISPLAYFIXEDOUTPUT = 0x20000000
Global Const $DM_DISPLAYFLAGS = 0x00200000
Global Const $DM_DISPLAYFREQUENCY = 0x00400000
Global Const $DM_DISPLAYORIENTATION = 0x00000080
Global Const $DM_DITHERTYPE = 0x04000000
Global Const $DM_DUPLEX = 0x0001000
Global Const $DM_FORMNAME = 0x00010000
Global Const $DM_ICMINTENT = 0x01000000
Global Const $DM_ICMMETHOD = 0x00800000
Global Const $DM_LOGPIXELS = 0x00020000
Global Const $DM_MEDIATYPE = 0x02000000
Global Const $DM_NUP = 0x00000040
Global Const $DM_ORIENTATION = 0x00000001
Global Const $DM_PANNINGHEIGHT = 0x10000000
Global Const $DM_PANNINGWIDTH = 0x08000000
Global Const $DM_PAPERLENGTH = 0x00000004
Global Const $DM_PAPERSIZE = 0x00000002
Global Const $DM_PAPERWIDTH = 0x00000008
Global Const $DM_PELSHEIGHT = 0x00100000
Global Const $DM_PELSWIDTH = 0x00080000
Global Const $DM_POSITION = 0x00000020
Global Const $DM_PRINTQUALITY = 0x00000400
Global Const $DM_SCALE = 0x00000010
Global Const $DM_TTOPTION = 0x0004000
Global Const $DM_YRESOLUTION = 0x0002000
Global Const $DMPAPER_LETTER = 1
Global Const $DMPAPER_LETTERSMALL = 2
Global Const $DMPAPER_TABLOID = 3
Global Const $DMPAPER_LEDGER = 4
Global Const $DMPAPER_LEGAL = 5
Global Const $DMPAPER_STATEMENT = 6
Global Const $DMPAPER_EXECUTIVE = 7
Global Const $DMPAPER_A3 = 8
Global Const $DMPAPER_A4 = 9
Global Const $DMPAPER_A4SMALL = 10
Global Const $DMPAPER_A5 = 11
Global Const $DMPAPER_B4 = 12
Global Const $DMPAPER_B5 = 13
Global Const $DMPAPER_FOLIO = 14
Global Const $DMPAPER_QUARTO = 15
Global Const $DMPAPER_10X14 = 16
Global Const $DMPAPER_11X17 = 17
Global Const $DMPAPER_NOTE = 18
Global Const $DMPAPER_ENV_9 = 19
Global Const $DMPAPER_ENV_10 = 20
Global Const $DMPAPER_ENV_11 = 21
Global Const $DMPAPER_ENV_12 = 22
Global Const $DMPAPER_ENV_14 = 23
Global Const $DMPAPER_CSHEET = 24
Global Const $DMPAPER_DSHEET = 25
Global Const $DMPAPER_ESHEET = 26
Global Const $DMPAPER_ENV_DL = 27
Global Const $DMPAPER_ENV_C5 = 28
Global Const $DMPAPER_ENV_C3 = 29
Global Const $DMPAPER_ENV_C4 = 30
Global Const $DMPAPER_ENV_C6 = 31
Global Const $DMPAPER_ENV_C65 = 32
Global Const $DMPAPER_ENV_B4 = 33
Global Const $DMPAPER_ENV_B5 = 34
Global Const $DMPAPER_ENV_B6 = 35
Global Const $DMPAPER_ENV_ITALY = 36
Global Const $DMPAPER_ENV_MONARCH = 37
Global Const $DMPAPER_ENV_PERSONAL = 38
Global Const $DMPAPER_FANFOLD_US = 39
Global Const $DMPAPER_FANFOLD_STD_GERMAN = 40
Global Const $DMPAPER_FANFOLD_LGL_GERMAN = 41
Global Const $DMPAPER_ISO_B4 = 42
Global Const $DMPAPER_JAPANESE_POSTCARD = 43
Global Const $DMPAPER_9X11 = 44
Global Const $DMPAPER_10X11 = 45
Global Const $DMPAPER_15X11 = 46
Global Const $DMPAPER_ENV_INVITE = 47
Global Const $DMPAPER_RESERVED_48 = 48
Global Const $DMPAPER_RESERVED_49 = 49
Global Const $DMPAPER_LETTER_EXTRA = 50
Global Const $DMPAPER_LEGAL_EXTRA = 51
Global Const $DMPAPER_TABLOID_EXTRA = 52
Global Const $DMPAPER_A4_EXTRA = 53
Global Const $DMPAPER_LETTER_TRANSVERSE = 54
Global Const $DMPAPER_A4_TRANSVERSE = 55
Global Const $DMPAPER_LETTER_EXTRA_TRANSVERSE = 56
Global Const $DMPAPER_A_PLUS = 57
Global Const $DMPAPER_B_PLUS = 58
Global Const $DMPAPER_LETTER_PLUS = 59
Global Const $DMPAPER_A4_PLUS = 60
Global Const $DMPAPER_A5_TRANSVERSE = 61
Global Const $DMPAPER_B5_TRANSVERSE = 62
Global Const $DMPAPER_A3_EXTRA = 63
Global Const $DMPAPER_A5_EXTRA = 64
Global Const $DMPAPER_B5_EXTRA = 65
Global Const $DMPAPER_A2 = 66
Global Const $DMPAPER_A3_TRANSVERSE = 67
Global Const $DMPAPER_A3_EXTRA_TRANSVERSE = 68
Global Const $DMPAPER_DBL_JAPANESE_POSTCARD = 69
Global Const $DMPAPER_A6 = 70
Global Const $DMPAPER_JENV_KAKU2 = 71
Global Const $DMPAPER_JENV_KAKU3 = 72
Global Const $DMPAPER_JENV_CHOU3 = 73
Global Const $DMPAPER_JENV_CHOU4 = 74
Global Const $DMPAPER_LETTER_ROTATED = 75
Global Const $DMPAPER_A3_ROTATED = 76
Global Const $DMPAPER_A4_ROTATED = 77
Global Const $DMPAPER_A5_ROTATED = 78
Global Const $DMPAPER_B4_JIS_ROTATED = 79
Global Const $DMPAPER_B5_JIS_ROTATED = 80
Global Const $DMPAPER_JAPANESE_POSTCARD_ROTATED = 81
Global Const $DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82
Global Const $DMPAPER_A6_ROTATED = 83
Global Const $DMPAPER_JENV_KAKU2_ROTATED = 84
Global Const $DMPAPER_JENV_KAKU3_ROTATED = 85
Global Const $DMPAPER_JENV_CHOU3_ROTATED = 86
Global Const $DMPAPER_JENV_CHOU4_ROTATED = 87
Global Const $DMPAPER_B6_JIS = 88
Global Const $DMPAPER_B6_JIS_ROTATED = 89
Global Const $DMPAPER_12X11 = 90
Global Const $DMPAPER_JENV_YOU4 = 91
Global Const $DMPAPER_JENV_YOU4_ROTATED = 92
Global Const $DMPAPER_P16K = 93
Global Const $DMPAPER_P32K = 94
Global Const $DMPAPER_P32KBIG = 95
Global Const $DMPAPER_PENV_1 = 96
Global Const $DMPAPER_PENV_2 = 97
Global Const $DMPAPER_PENV_3 = 98
Global Const $DMPAPER_PENV_4 = 99
Global Const $DMPAPER_PENV_5 = 100
Global Const $DMPAPER_PENV_6 = 101
Global Const $DMPAPER_PENV_7 = 102
Global Const $DMPAPER_PENV_8 = 103
Global Const $DMPAPER_PENV_9 = 104
Global Const $DMPAPER_PENV_10 = 105
Global Const $DMPAPER_P16K_ROTATED = 106
Global Const $DMPAPER_P32K_ROTATED = 107
Global Const $DMPAPER_P32KBIG_ROTATED = 108
Global Const $DMPAPER_PENV_1_ROTATED = 109
Global Const $DMPAPER_PENV_2_ROTATED = 110
Global Const $DMPAPER_PENV_3_ROTATED = 111
Global Const $DMPAPER_PENV_4_ROTATED = 112
Global Const $DMPAPER_PENV_5_ROTATED = 113
Global Const $DMPAPER_PENV_6_ROTATED = 114
Global Const $DMPAPER_PENV_7_ROTATED = 115
Global Const $DMPAPER_PENV_8_ROTATED = 116
Global Const $DMPAPER_PENV_9_ROTATED = 117
Global Const $DMPAPER_PENV_10_ROTATED = 118
Global Const $DMPAPER_USER = 256
Global Const $DMBIN_UPPER = 1
Global Const $DMBIN_LOWER = 2
Global Const $DMBIN_MIDDLE = 3
Global Const $DMBIN_MANUAL = 4
Global Const $DMBIN_ENVELOPE = 5
Global Const $DMBIN_ENVMANUAL = 6
Global Const $DMBIN_AUTO = 7
Global Const $DMBIN_TRACTOR = 8
Global Const $DMBIN_SMALLFMT = 9
Global Const $DMBIN_LARGEFMT = 10
Global Const $DMBIN_LARGECAPACITY = 11
Global Const $DMBIN_CASSETTE = 14
Global Const $DMBIN_FORMSOURCE = 15
Global Const $DMBIN_USER = 256
Global Const $DMRES_DRAFT = -1
Global Const $DMRES_LOW = -2
Global Const $DMRES_MEDIUM = -3
Global Const $DMRES_HIGH = -4
Global Const $DMDO_DEFAULT = 0
Global Const $DMDO_90 = 1
Global Const $DMDO_180 = 2
Global Const $DMDO_270 = 3
Global Const $DMDFO_DEFAULT = 0
Global Const $DMDFO_STRETCH = 1
Global Const $DMDFO_CENTER = 2
Global Const $DMCOLOR_MONOCHROME = 1
Global Const $DMCOLOR_COLOR = 2
Global Const $DMDUP_SIMPLEX = 1
Global Const $DMDUP_VERTICAL = 2
Global Const $DMDUP_HORIZONTAL = 3
Global Const $DMTT_BITMAP = 1
Global Const $DMTT_DOWNLOAD = 2
Global Const $DMTT_SUBDEV = 3
Global Const $DMTT_DOWNLOAD_OUTLINE = 4
Global Const $DMCOLLATE_FALSE = 0
Global Const $DMCOLLATE_TRUE = 1
Global Const $DM_GRAYSCALE = 1
Global Const $DM_INTERLACED = 2
Global Const $DMNUP_SYSTEM = 1
Global Const $DMNUP_ONEUP = 2
Global Const $DMICMMETHOD_NONE = 1
Global Const $DMICMMETHOD_SYSTEM = 2
Global Const $DMICMMETHOD_DRIVER = 3
Global Const $DMICMMETHOD_DEVICE = 4
Global Const $DMICMMETHOD_USER = 256
Global Const $DMICM_SATURATE = 1
Global Const $DMICM_CONTRAST = 2
Global Const $DMICM_COLORIMETRIC = 3
Global Const $DMICM_ABS_COLORIMETRIC = 4
Global Const $DMICM_USER = 256
Global Const $DMMEDIA_STANDARD = 1
Global Const $DMMEDIA_TRANSPARENCY = 2
Global Const $DMMEDIA_GLOSSY = 3
Global Const $DMMEDIA_USER = 256
Global Const $DMDITHER_NONE = 1
Global Const $DMDITHER_COARSE = 2
Global Const $DMDITHER_FINE = 3
Global Const $DMDITHER_LINEART = 4
Global Const $DMDITHER_ERRORDIFFUSION = 5
Global Const $DMDITHER_RESERVED6 = 6
Global Const $DMDITHER_RESERVED7 = 7
Global Const $DMDITHER_RESERVED8 = 8
Global Const $DMDITHER_RESERVED9 = 9
Global Const $DMDITHER_GRAYSCALE = 10
Global Const $DMDITHER_USER = 256
Global Const $ENUM_CURRENT_SETTINGS = -1
Global Const $ENUM_REGISTRY_SETTINGS = -2
Global Const $DEVICE_FONTTYPE = 0x2
Global Const $RASTER_FONTTYPE = 0x1
Global Const $TRUETYPE_FONTTYPE = 0x4
Global Const $NTM_BOLD = 0x00000020
Global Const $NTM_DSIG = 0x00200000
Global Const $NTM_ITALIC = 0x00000001
Global Const $NTM_MULTIPLEMASTER = 0x00080000
Global Const $NTM_NONNEGATIVE_AC = 0x00010000
Global Const $NTM_PS_OPENTYPE = 0x00020000
Global Const $NTM_REGULAR = 0x00000040
Global Const $NTM_TT_OPENTYPE = 0x00040000
Global Const $NTM_TYPE1 = 0x00100000
Global Const $FLOODFILLBORDER = 0
Global Const $FLOODFILLSURFACE = 1
Global Const $AD_COUNTERCLOCKWISE = 1
Global Const $AD_CLOCKWISE = 2
Global Const $DCB_ACCUMULATE = 0x02
Global Const $DCB_DISABLE = 0x08
Global Const $DCB_ENABLE = 0x04
Global Const $DCB_RESET = 0x01
Global Const $DCB_SET = BitOR($DCB_RESET, $DCB_ACCUMULATE)
Global Const $DCX_WINDOW = 0x00000001
Global Const $DCX_CACHE = 0x00000002
Global Const $DCX_PARENTCLIP = 0x00000020
Global Const $DCX_CLIPSIBLINGS = 0x00000010
Global Const $DCX_CLIPCHILDREN = 0x00000008
Global Const $DCX_NORESETATTRS = 0x00000004
Global Const $DCX_LOCKWINDOWUPDATE = 0x00000400
Global Const $DCX_EXCLUDERGN = 0x00000040
Global Const $DCX_INTERSECTRGN = 0x00000080
Global Const $DCX_INTERSECTUPDATE = 0x00000200
Global Const $DCX_VALIDATE = 0x00200000
Global Const $GGO_BEZIER = 3
Global Const $GGO_BITMAP = 1
Global Const $GGO_GLYPH_INDEX = 0x0080
Global Const $GGO_GRAY2_BITMAP = 4
Global Const $GGO_GRAY4_BITMAP = 5
Global Const $GGO_GRAY8_BITMAP = 6
Global Const $GGO_METRICS = 0
Global Const $GGO_NATIVE = 2
Global Const $GGO_UNHINTED = 0x0100
Global Const $GM_COMPATIBLE = 1
Global Const $GM_ADVANCED = 2
Global Const $MM_ANISOTROPIC = 8
Global Const $MM_HIENGLISH = 5
Global Const $MM_HIMETRIC = 3
Global Const $MM_ISOTROPIC = 7
Global Const $MM_LOENGLISH = 4
Global Const $MM_LOMETRIC = 2
Global Const $MM_TEXT = 1
Global Const $MM_TWIPS = 6
Global Const $R2_BLACK = 1
Global Const $R2_COPYPEN = 13
Global Const $R2_LAST = 16
Global Const $R2_MASKNOTPEN = 3
Global Const $R2_MASKPEN = 9
Global Const $R2_MASKPENNOT = 5
Global Const $R2_MERGENOTPEN = 12
Global Const $R2_MERGEPEN = 15
Global Const $R2_MERGEPENNOT = 14
Global Const $R2_NOP = 11
Global Const $R2_NOT = 6
Global Const $R2_NOTCOPYPEN = 4
Global Const $R2_NOTMASKPEN = 8
Global Const $R2_NOTMERGEPEN = 2
Global Const $R2_NOTXORPEN = 10
Global Const $R2_WHITE = 16
Global Const $R2_XORPEN = 7
Global Const $BLACKONWHITE = 1
Global Const $COLORONCOLOR = 3
Global Const $HALFTONE = 4
Global Const $WHITEONBLACK = 2
Global Const $STRETCH_ANDSCANS = $BLACKONWHITE
Global Const $STRETCH_DELETESCANS = $COLORONCOLOR
Global Const $STRETCH_HALFTONE = $HALFTONE
Global Const $STRETCH_ORSCANS = $WHITEONBLACK
Global Const $TA_BASELINE = 0x0018
Global Const $TA_BOTTOM = 0x0008
Global Const $TA_TOP = 0x0000
Global Const $TA_CENTER = 0x0006
Global Const $TA_LEFT = 0x0000
Global Const $TA_RIGHT = 0x0002
Global Const $TA_NOUPDATECP = 0x0000
Global Const $TA_RTLREADING = 0x0100
Global Const $TA_UPDATECP = 0x0001
Global Const $VTA_BASELINE = $TA_BASELINE
Global Const $VTA_BOTTOM = $TA_RIGHT
Global Const $VTA_TOP = $TA_LEFT
Global Const $VTA_CENTER = $TA_CENTER
Global Const $VTA_LEFT = $TA_BOTTOM
Global Const $VTA_RIGHT = $TA_TOP
Global Const $UDF_BGR = 1
Global Const $UDF_RGB = 0
Global Const $MWT_IDENTITY = 0x01
Global Const $MWT_LEFTMULTIPLY = 0x02
Global Const $MWT_RIGHTMULTIPLY = 0x03
Global Const $MWT_SET = 0x04
Global Const $MONITOR_DEFAULTTONEAREST = 2
Global Const $MONITOR_DEFAULTTONULL = 0
Global Const $MONITOR_DEFAULTTOPRIMARY = 1
Global Const $PT_BEZIERTO = 4
Global Const $PT_LINETO = 2
Global Const $PT_MOVETO = 6
Global Const $PT_CLOSEFIGURE = 1
Global Const $COINIT_APARTMENTTHREADED = 0x02
Global Const $COINIT_DISABLE_OLE1DDE = 0x04
Global Const $COINIT_MULTITHREADED = 0x00
Global Const $COINIT_SPEED_OVER_MEMORY = 0x08
Global Const $__tagWinAPICom_GUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Func _WinAPI_CLSIDFromProgID($sProgID)
Local $tGUID = DllStructCreate($__tagWinAPICom_GUID)
Local $aCall = DllCall('ole32.dll', 'long', 'CLSIDFromProgID', 'wstr', $sProgID, 'struct*', $tGUID)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
$aCall = DllCall('ole32.dll', 'int', 'StringFromGUID2', 'struct*', $tGUID, 'wstr', '', 'int', 39)
If @error Or Not $aCall[0] Then Return SetError(@error + 20, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_CoInitialize($iFlags = 0)
Local $aCall = DllCall('ole32.dll', 'long', 'CoInitializeEx', 'ptr', 0, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_CoTaskMemAlloc($iSize)
Local $aCall = DllCall('ole32.dll', 'ptr', 'CoTaskMemAlloc', 'uint_ptr', $iSize)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CoTaskMemFree($pMemory)
DllCall('ole32.dll', 'none', 'CoTaskMemFree', 'ptr', $pMemory)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_CoTaskMemRealloc($pMemory, $iSize)
Local $aCall = DllCall('ole32.dll', 'ptr', 'CoTaskMemRealloc', 'ptr', $pMemory, 'ulong_ptr', $iSize)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CoUninitialize()
DllCall('ole32.dll', 'none', 'CoUninitialize')
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_CreateGUID()
Local $tGUID = DllStructCreate($__tagWinAPICom_GUID)
Local $aCall = DllCall('ole32.dll', 'long', 'CoCreateGuid', 'struct*', $tGUID)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
$aCall = DllCall('ole32.dll', 'int', 'StringFromGUID2', 'struct*', $tGUID, 'wstr', '', 'int', 65536)
If @error Or Not $aCall[0] Then Return SetError(@error + 20, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_CreateStreamOnHGlobal($hGlobal = 0, $bDeleteOnRelease = True)
Local $aCall = DllCall('ole32.dll', 'long', 'CreateStreamOnHGlobal', 'handle', $hGlobal, 'bool', $bDeleteOnRelease, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _WinAPI_GetHGlobalFromStream($pStream)
Local $aCall = DllCall('ole32.dll', 'uint', 'GetHGlobalFromStream', 'ptr', $pStream, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _WinAPI_ProgIDFromCLSID($sCLSID)
Local $tGUID = DllStructCreate($__tagWinAPICom_GUID)
Local $aCall = DllCall('ole32.dll', 'uint', 'CLSIDFromString', 'wstr', $sCLSID, 'struct*', $tGUID)
If @error Or $aCall[0] Then Return SetError(@error + 20, @extended, '')
$aCall = DllCall('ole32.dll', 'uint', 'ProgIDFromCLSID', 'struct*', $tGUID, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
Local $sID = _WinAPI_GetString($aCall[2])
_WinAPI_CoTaskMemFree($aCall[2])
Return $sID
EndFunc
Func _WinAPI_ReleaseStream($pStream)
Local $aCall = DllCall('oleaut32.dll', 'long', 'DispCallFunc', 'ptr', $pStream, 'ulong_ptr', 8 * (1 + @AutoItX64), 'uint', 4,  'ushort', 23, 'uint', 0, 'ptr', 0, 'ptr', 0, 'str', '')
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Global $__g_hHeap = 0
Func _WinAPI_CreateBuffer($iLength, $pBuffer = 0, $bAbort = True)
$pBuffer = __HeapReAlloc($pBuffer, $iLength, 0, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
Return $pBuffer
EndFunc
Func _WinAPI_CreateBufferFromStruct($tStruct, $pBuffer = 0, $bAbort = True)
If Not IsDllStruct($tStruct) Then Return SetError(1, 0, 0)
$pBuffer = __HeapReAlloc($pBuffer, DllStructGetSize($tStruct), 0, $bAbort)
If @error Then Return SetError(@error + 100, @extended, 0)
_WinAPI_MoveMemory($pBuffer, $tStruct, DllStructGetSize($tStruct))
Return $pBuffer
EndFunc
Func _WinAPI_CreateString($sString, $pString = 0, $iLength = -1, $bUnicode = True, $bAbort = True)
$iLength = Number($iLength)
If $iLength >= 0 Then
$sString = StringLeft($sString, $iLength)
Else
$iLength = StringLen($sString)
EndIf
Local $iSize = $iLength + 1
If $bUnicode Then
$iSize *= 2
EndIf
$pString = __HeapReAlloc($pString, $iSize, 0, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
DllStructSetData(DllStructCreate(($bUnicode ? 'wchar' : 'char') & '[' & ($iLength + 1) & ']', $pString), 1, $sString)
Return SetExtended($iLength, $pString)
EndFunc
Func _WinAPI_EqualMemory($pSource1, $pSource2, $iLength)
If _WinAPI_IsBadReadPtr($pSource1, $iLength) Then Return SetError(11, @extended, 0)
If _WinAPI_IsBadReadPtr($pSource2, $iLength) Then Return SetError(12, @extended, 0)
Local $aCall = DllCall('ntdll.dll', 'ulong_ptr', 'RtlCompareMemory', 'struct*', $pSource1, 'struct*', $pSource2, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return Number($aCall[0] = $iLength)
EndFunc
Func _WinAPI_FillMemory($pMemory, $iLength, $iValue = 0)
If _WinAPI_IsBadWritePtr($pMemory, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlFillMemory', 'struct*', $pMemory, 'ulong_ptr', $iLength, 'byte', $iValue)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_FreeMemory($pMemory)
If Not __HeapFree($pMemory, 1) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_GetMemorySize($pMemory)
Local $iResult = __HeapSize($pMemory, 1)
If @error Then Return SetError(@error, @extended, 0)
Return $iResult
EndFunc
Func _WinAPI_GlobalMemoryStatus()
Local Const $tagMEMORYSTATUSEX = "dword Length;dword MemoryLoad;" &  "uint64 TotalPhys;uint64 AvailPhys;uint64 TotalPageFile;uint64 AvailPageFile;" &  "uint64 TotalVirtual;uint64 AvailVirtual;uint64 AvailExtendedVirtual"
Local $tMem = DllStructCreate($tagMEMORYSTATUSEX)
DllStructSetData($tMem, 1, DllStructGetSize($tMem))
Local $aCall = DllCall("kernel32.dll", "bool", "GlobalMemoryStatusEx", "struct*", $tMem)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aMem[7]
$aMem[0] = DllStructGetData($tMem, 2)
$aMem[1] = DllStructGetData($tMem, 3)
$aMem[2] = DllStructGetData($tMem, 4)
$aMem[3] = DllStructGetData($tMem, 5)
$aMem[4] = DllStructGetData($tMem, 6)
$aMem[5] = DllStructGetData($tMem, 7)
$aMem[6] = DllStructGetData($tMem, 8)
Return $aMem
EndFunc
Func _WinAPI_IsBadCodePtr($pAddress)
Local $aCall = DllCall('kernel32.dll', 'bool', 'IsBadCodePtr', 'struct*', $pAddress)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_IsBadReadPtr($pAddress, $iLength)
Local $aCall = DllCall('kernel32.dll', 'bool', 'IsBadReadPtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_IsBadStringPtr($pAddress, $iLength)
Local $aCall = DllCall('kernel32.dll', 'bool', 'IsBadStringPtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_IsBadWritePtr($pAddress, $iLength)
Local $aCall = DllCall('kernel32.dll', 'bool', 'IsBadWritePtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_IsMemory($pMemory)
Local $bResult = __HeapValidate($pMemory)
Return SetError(@error, @extended, $bResult)
EndFunc
Func _WinAPI_LocalFree($hMemory)
Local $aCall = DllCall("kernel32.dll", "handle", "LocalFree", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_MoveMemory($pDestination, $pSource, $iLength)
If _WinAPI_IsBadReadPtr($pSource, $iLength) Then Return SetError(10, @extended, 0)
If _WinAPI_IsBadWritePtr($pDestination, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlMoveMemory', 'struct*', $pDestination, 'struct*', $pSource, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_ReadProcessMemory($hProcess, $pBaseAddress, $pBuffer, $iSize, ByRef $iRead)
Local $aCall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hProcess,  "ptr", $pBaseAddress, "struct*", $pBuffer, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
$iRead = $aCall[5]
Return $aCall[0]
EndFunc
Func _WinAPI_WriteProcessMemory($hProcess, $pBaseAddress, $pBuffer, $iSize, ByRef $iWritten, $sBufferType = "ptr")
Local $aCall = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", $hProcess, "ptr", $pBaseAddress,  $sBufferType, $pBuffer, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
$iWritten = $aCall[5]
Return $aCall[0]
EndFunc
Func _WinAPI_ZeroMemory($pMemory, $iLength)
If _WinAPI_IsBadWritePtr($pMemory, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlZeroMemory', 'struct*', $pMemory, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func __HeapAlloc($iSize, $bAbort = False)
Local $aCall
If Not $__g_hHeap Then
$aCall = DllCall('kernel32.dll', 'handle', 'HeapCreate', 'dword', 0, 'ulong_ptr', 0, 'ulong_ptr', 0)
If @error Or Not $aCall[0] Then __FatalExit(1, 'Error allocating memory.')
$__g_hHeap = $aCall[0]
EndIf
$aCall = DllCall('kernel32.dll', 'ptr', 'HeapAlloc', 'handle', $__g_hHeap, 'dword', 0x00000008, 'ulong_ptr', $iSize)
If @error Or Not $aCall[0] Then
If $bAbort Then __FatalExit(1, 'Error allocating memory.')
Return SetError(@error + 30, @extended, 0)
EndIf
Return $aCall[0]
EndFunc
Func __HeapFree(ByRef $pMemory, $bCheck = False, $iCurErr = @error, $iCurExt = @extended)
If $bCheck And (Not __HeapValidate($pMemory)) Then Return SetError(@error, @extended, 0)
Local $aCall = DllCall('kernel32.dll', 'int', 'HeapFree', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Or Not $aCall[0] Then Return SetError(@error + 40, @extended, 0)
$pMemory = 0
Return SetError($iCurErr, $iCurExt, 1)
EndFunc
Func __HeapReAlloc($pMemory, $iSize, $bAmount = False, $bAbort = False)
Local $pRet
If __HeapValidate($pMemory) Then
If $bAmount And (__HeapSize($pMemory) >= $iSize) Then Return SetExtended(1, Ptr($pMemory))
Local $aCall = DllCall('kernel32.dll', 'ptr', 'HeapReAlloc', 'handle', $__g_hHeap, 'dword', 0x00000008, 'ptr', $pMemory,  'ulong_ptr', $iSize)
If @error Or Not $aCall[0] Then
If $bAbort Then __FatalExit(1, 'Error allocating memory.')
Return SetError(@error + 20, @extended, Ptr($pMemory))
EndIf
$pRet = $aCall[0]
Else
$pRet = __HeapAlloc($iSize, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
EndIf
Return $pRet
EndFunc
Func __HeapSize($pMemory, $bCheck = False)
If $bCheck And (Not __HeapValidate($pMemory)) Then Return SetError(@error, @extended, 0)
Local $aCall = DllCall('kernel32.dll', 'ulong_ptr', 'HeapSize', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Or ($aCall[0] = Ptr(-1)) Then Return SetError(@error + 50, @extended, 0)
Return $aCall[0]
EndFunc
Func __HeapValidate($pMemory)
If (Not $__g_hHeap) Or (Not Ptr($pMemory)) Then Return SetError(9, 0, False)
Local $aCall = DllCall('kernel32.dll', 'int', 'HeapValidate', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Global Const $SND_APPLICATION = 0x00000080
Global Const $SND_ALIAS = 0x00010000
Global Const $SND_ALIAS_ID = 0x00110000
Global Const $SND_ASYNC = 0x00000001
Global Const $SND_FILENAME = 0x00020000
Global Const $SND_LOOP = 0x00000008
Global Const $SND_MEMORY = 0x00000004
Global Const $SND_NODEFAULT = 0x00000002
Global Const $SND_NOSTOP = 0x00000010
Global Const $SND_NOWAIT = 0x00002000
Global Const $SND_PURGE = 0x00000040
Global Const $SND_RESOURCE = 0x00040004
Global Const $SND_SENTRY = 0x00080000
Global Const $SND_SYNC = 0x00000000
Global Const $SND_SYSTEM = 0x00200000
Global Const $SND_SYSTEM_NOSTOP = 0x00200010
Global Const $SND_ALIAS_SYSTEMASTERISK = 'SystemAsterisk'
Global Const $SND_ALIAS_SYSTEMDEFAULT = 'SystemDefault'
Global Const $SND_ALIAS_SYSTEMEXCLAMATION = 'SystemExclamation'
Global Const $SND_ALIAS_SYSTEMEXIT = 'SystemExit'
Global Const $SND_ALIAS_SYSTEMHAND = 'SystemHand'
Global Const $SND_ALIAS_SYSTEMQUESTION = 'SystemQuestion'
Global Const $SND_ALIAS_SYSTEMSTART = 'SystemStart'
Global Const $SND_ALIAS_SYSTEMWELCOME = 'SystemWelcome'
Func _WinAPI_ArrayToStruct(Const ByRef $aData, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aData, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'wchar[' & (StringLen($aData[$i]) + 1) & '];'
Next
Local $tData = DllStructCreate($tagStruct & 'wchar[1]')
Local $iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tData, $iCount, $aData[$i])
$iCount += 1
Next
DllStructSetData($tData, $iCount, ChrW(0))
Return $tData
EndFunc
Func _WinAPI_CreateMargins($iLeftWidth, $iRightWidth, $iTopHeight, $iBottomHeight)
Local $tMARGINS = DllStructCreate($tagMARGINS)
DllStructSetData($tMARGINS, 1, $iLeftWidth)
DllStructSetData($tMARGINS, 2, $iRightWidth)
DllStructSetData($tMARGINS, 3, $iTopHeight)
DllStructSetData($tMARGINS, 4, $iBottomHeight)
Return $tMARGINS
EndFunc
Func _WinAPI_CreatePoint($iX, $iY)
Local $tPOINT = DllStructCreate($tagPOINT)
DllStructSetData($tPOINT, 1, $iX)
DllStructSetData($tPOINT, 2, $iY)
Return $tPOINT
EndFunc
Func _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, $iLeft)
DllStructSetData($tRECT, 2, $iTop)
DllStructSetData($tRECT, 3, $iRight)
DllStructSetData($tRECT, 4, $iBottom)
Return $tRECT
EndFunc
Func _WinAPI_CreateRectEx($iX, $iY, $iWidth, $iHeight)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, $iX)
DllStructSetData($tRECT, 2, $iY)
DllStructSetData($tRECT, 3, $iX + $iWidth)
DllStructSetData($tRECT, 4, $iY + $iHeight)
Return $tRECT
EndFunc
Func _WinAPI_CreateSize($iWidth, $iHeight)
Local $tSIZE = DllStructCreate($tagSIZE)
DllStructSetData($tSIZE, 1, $iWidth)
DllStructSetData($tSIZE, 2, $iHeight)
Return $tSIZE
EndFunc
Func _WinAPI_CopyStruct($tStruct, $sStruct = '')
Local $iSize = DllStructGetSize($tStruct)
If Not $iSize Then Return SetError(1, 0, 0)
Local $tResult
If Not StringStripWS($sStruct, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES) Then
$tResult = DllStructCreate('byte[' & $iSize & ']')
Else
$tResult = DllStructCreate($sStruct)
EndIf
If DllStructGetSize($tResult) < $iSize Then Return SetError(2, 0, 0)
_WinAPI_MoveMemory($tResult, $tStruct, $iSize)
Return $tResult
EndFunc
Func _WinAPI_GetExtended()
Return $__g_vExt
EndFunc
Func _WinAPI_GetMousePos($bToClient = False, $hWnd = 0)
Local $iMode = Opt("MouseCoordMode", 1)
Local $aPos = MouseGetPos()
Opt("MouseCoordMode", $iMode)
Local $tPOINT = DllStructCreate($tagPOINT)
DllStructSetData($tPOINT, "X", $aPos[0])
DllStructSetData($tPOINT, "Y", $aPos[1])
If $bToClient And Not _WinAPI_ScreenToClient($hWnd, $tPOINT) Then Return SetError(@error + 20, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_GetMousePosX($bToClient = False, $hWnd = 0)
Local $tPOINT = _WinAPI_GetMousePos($bToClient, $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPOINT, "X")
EndFunc
Func _WinAPI_GetMousePosY($bToClient = False, $hWnd = 0)
Local $tPOINT = _WinAPI_GetMousePos($bToClient, $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPOINT, "Y")
EndFunc
Func _WinAPI_MulDiv($iNumber, $iNumerator, $iDenominator)
Local $aCall = DllCall("kernel32.dll", "int", "MulDiv", "int", $iNumber, "int", $iNumerator, "int", $iDenominator)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_PlaySound($sSound, $iFlags = $SND_SYSTEM_NOSTOP, $hInstance = 0)
Local $sTypeOfSound = 'ptr'
If $sSound Then
If IsString($sSound) Then
$sTypeOfSound = 'wstr'
EndIf
Else
$sSound = 0
$iFlags = 0
EndIf
Local $aCall = DllCall('winmm.dll', 'bool', 'PlaySoundW', $sTypeOfSound, $sSound, 'handle', $hInstance, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_StringLenA(Const ByRef $tString)
Local $aCall = DllCall("kernel32.dll", "int", "lstrlenA", "struct*", $tString)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_StringLenW(Const ByRef $tString)
Local $aCall = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $tString)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_StructToArray(ByRef $tStruct, $iItems = 0)
Local $iSize = 2 * Floor(DllStructGetSize($tStruct) / 2)
Local $pStruct = DllStructGetPtr($tStruct)
If Not $iSize Or Not $pStruct Then Return SetError(1, 0, 0)
Local $tData, $iLength, $iOffset = 0
Local $aRet[101] = [0]
While 1
$iLength = _WinAPI_StrLen($pStruct + $iOffset)
If Not $iLength Then
ExitLoop
EndIf
If 2 * (1 + $iLength) + $iOffset > $iSize Then Return SetError(3, 0, 0)
$tData = DllStructCreate('wchar[' & (1 + $iLength) & ']', $pStruct + $iOffset)
If @error Then Return SetError(@error + 10, 0, 0)
__Inc($aRet)
$aRet[$aRet[0]] = DllStructGetData($tData, 1)
If $aRet[0] = $iItems Then
ExitLoop
EndIf
$iOffset += 2 * (1 + $iLength)
If $iOffset >= $iSize Then Return SetError(3, 0, 0)
WEnd
If Not $aRet[0] Then Return SetError(2, 0, 0)
__Inc($aRet, -1)
Return $aRet
EndFunc
Func _WinAPI_UnionStruct($tStruct1, $tStruct2, $sStruct = '')
Local $aSize[2] = [DllStructGetSize($tStruct1), DllStructGetSize($tStruct2)]
If Not $aSize[0] Or Not $aSize[1] Then Return SetError(1, 0, 0)
Local $tResult
If Not StringStripWS($sStruct, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES) Then
$tResult = DllStructCreate('byte[' & ($aSize[0] + $aSize[1]) & ']')
Else
$tResult = DllStructCreate($sStruct)
EndIf
If DllStructGetSize($tResult) < ($aSize[0] + $aSize[1]) Then Return SetError(2, 0, 0)
_WinAPI_MoveMemory($tResult, $tStruct1, $aSize[0])
_WinAPI_MoveMemory(DllStructGetPtr($tResult) + $aSize[0], $tStruct2, $aSize[1])
Return $tResult
EndFunc
Global Const $tagBITMAP = 'struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct'
Global Const $tagBITMAPV5HEADER = 'struct;dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[9];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;endstruct'
Global Const $tagDIBSECTION = $tagBITMAP & ';' & $tagBITMAPINFOHEADER & ';dword dsBitfields[3];ptr dshSection;dword dsOffset'
Global Const $TMPF_FIXED_PITCH = 0x01
Global Const $TMPF_VECTOR = 0x02
Global Const $TMPF_TRUETYPE = 0x04
Global Const $TMPF_DEVICE = 0x08
Global Const $__WINAPICONSTANT_FW_NORMAL = 400
Global Const $__WINAPICONSTANT_DEFAULT_CHARSET = 1
Global Const $__WINAPICONSTANT_OUT_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_DEFAULT_QUALITY = 0
Func _WinAPI_BitBlt($hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $iROP)
Local $aCall = DllCall("gdi32.dll", "bool", "BitBlt", "handle", $hDestDC, "int", $iXDest, "int", $iYDest, "int", $iWidth,  "int", $iHeight, "handle", $hSrcDC, "int", $iXSrc, "int", $iYSrc, "dword", $iROP)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_CombineRgn($hRgnDest, $hRgnSrc1, $hRgnSrc2, $iCombineMode)
Local $aCall = DllCall("gdi32.dll", "int", "CombineRgn", "handle", $hRgnDest, "handle", $hRgnSrc1, "handle", $hRgnSrc2,  "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CopyBitmap($hBitmap)
$hBitmap = _WinAPI_CopyImage($hBitmap, 0, 0, 0, 0x2000)
Return SetError(@error, @extended, $hBitmap)
EndFunc
Func _WinAPI_CopyImage($hImage, $iType = 0, $iXDesiredPixels = 0, $iYDesiredPixels = 0, $iFlags = 0)
Local $aCall = DllCall('user32.dll', 'handle', 'CopyImage', 'handle', $hImage, 'uint', $iType,  'int', $iXDesiredPixels, 'int', $iYDesiredPixels, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateANDBitmap($hBitmap)
Local $iError = 0, $hDib = 0
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
If Not $hBitmap Then Return SetError(@error + 20, @extended, 0)
Do
Local $atDIB[2]
$atDIB[0] = DllStructCreate($tagDIBSECTION)
If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($atDIB[0]), $atDIB[0]))  Or (DllStructGetData($atDIB[0], 'bmBitsPixel') <> 32) Or (DllStructGetData($atDIB[0], 'biCompression')) Then
$iError = 10
ExitLoop
EndIf
$atDIB[1] = DllStructCreate($tagBITMAP)
$hDib = _WinAPI_CreateDIB(DllStructGetData($atDIB[0], 'bmWidth'), DllStructGetData($atDIB[0], 'bmHeight'), 1)
If Not _WinAPI_GetObject($hDib, DllStructGetSize($atDIB[1]), $atDIB[1]) Then
$iError = 11
ExitLoop
EndIf
Local $aCall = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'ptr', __ANDProc(), 'ptr', 0, 'uint', 0,  'wparam', DllStructGetPtr($atDIB[0]), 'lparam', DllStructGetPtr($atDIB[1]))
If @error Then
$iError = @error
ExitLoop
EndIf
If Not $aCall[0] Then
$iError = 12
ExitLoop
EndIf
$iError = 0
Until 1
_WinAPI_DeleteObject($hBitmap)
If $iError Then
If $hDib Then
_WinAPI_DeleteObject($hDib)
EndIf
$hDib = 0
EndIf
Return SetError($iError, 0, $hDib)
EndFunc
Func _WinAPI_CreateBitmap($iWidth, $iHeight, $iPlanes = 1, $iBitsPerPel = 1, $pBits = 0)
Local $aCall = DllCall("gdi32.dll", "handle", "CreateBitmap", "int", $iWidth, "int", $iHeight, "uint", $iPlanes,  "uint", $iBitsPerPel, "struct*", $pBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateCompatibleBitmap($hDC, $iWidth, $iHeight)
Local $aCall = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hDC, "int", $iWidth, "int", $iHeight)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateDIB($iWidth, $iHeight, $iBitsPerPel = 32, $tColorTable = 0, $iColorCount = 0)
Local $aRGBQ[2], $iColors, $tagRGBQ
Switch $iBitsPerPel
Case 1
$iColors = 2
Case 4
$iColors = 16
Case 8
$iColors = 256
Case Else
$iColors = 0
EndSwitch
If $iColors Then
If Not IsDllStruct($tColorTable) Then
Switch $iBitsPerPel
Case 1
$aRGBQ[0] = 0
$aRGBQ[1] = 0xFFFFFF
$tColorTable = _WinAPI_CreateDIBColorTable($aRGBQ)
Case Else
EndSwitch
Else
If $iColors > $iColorCount Then
$iColors = $iColorCount
EndIf
If (Not $iColors) Or ((4 * $iColors) > DllStructGetSize($tColorTable)) Then
Return SetError(20, 0, 0)
EndIf
EndIf
$tagRGBQ = ';dword aRGBQuad[' & $iColors & ']'
Else
$tagRGBQ = ''
EndIf
Local $tBITMAPINFO = DllStructCreate($tagBITMAPINFOHEADER & $tagRGBQ)
DllStructSetData($tBITMAPINFO, 'biSize', 40)
DllStructSetData($tBITMAPINFO, 'biWidth', $iWidth)
DllStructSetData($tBITMAPINFO, 'biHeight', $iHeight)
DllStructSetData($tBITMAPINFO, 'biPlanes', 1)
DllStructSetData($tBITMAPINFO, 'biBitCount', $iBitsPerPel)
DllStructSetData($tBITMAPINFO, 'biCompression', 0)
DllStructSetData($tBITMAPINFO, 'biSizeImage', 0)
DllStructSetData($tBITMAPINFO, 'biXPelsPerMeter', 0)
DllStructSetData($tBITMAPINFO, 'biYPelsPerMeter', 0)
DllStructSetData($tBITMAPINFO, 'biClrUsed', $iColors)
DllStructSetData($tBITMAPINFO, 'biClrImportant', 0)
If $iColors Then
If IsDllStruct($tColorTable) Then
_WinAPI_MoveMemory(DllStructGetPtr($tBITMAPINFO, 'aRGBQuad'), $tColorTable, 4 * $iColors)
Else
_WinAPI_ZeroMemory(DllStructGetPtr($tBITMAPINFO, 'aRGBQuad'), 4 * $iColors)
EndIf
EndIf
Local $hBitmap = _WinAPI_CreateDIBSection(0, $tBITMAPINFO, 0, $__g_vExt)
If Not $hBitmap Then Return SetError(@error, @extended, 0)
Return $hBitmap
EndFunc
Func _WinAPI_CreateDIBSection($hDC, $tBITMAPINFO, $iUsage, ByRef $pBits, $hSection = 0, $iOffset = 0)
$pBits = 0
Local $aCall = DllCall('gdi32.dll', 'handle', 'CreateDIBSection', 'handle', $hDC, 'struct*', $tBITMAPINFO, 'uint', $iUsage,  'ptr*', 0, 'handle', $hSection, 'dword', $iOffset)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
$pBits = $aCall[4]
Return $aCall[0]
EndFunc
Func _WinAPI_CreateDIBColorTable(Const ByRef $aColorTable, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aColorTable, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $tColorTable = DllStructCreate('dword[' & ($iEnd - $iStart + 1) & ']')
Local $iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tColorTable, 1, _WinAPI_SwitchColor(__RGB($aColorTable[$i])), $iCount)
$iCount += 1
Next
Return $tColorTable
EndFunc
Func _WinAPI_CreateFont($iHeight, $iWidth, $iEscape = 0, $iOrientn = 0, $iWeight = $__WINAPICONSTANT_FW_NORMAL, $bItalic = False, $bUnderline = False, $bStrikeout = False, $iCharset = $__WINAPICONSTANT_DEFAULT_CHARSET, $iOutputPrec = $__WINAPICONSTANT_OUT_DEFAULT_PRECIS, $iClipPrec = $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS, $iQuality = $__WINAPICONSTANT_DEFAULT_QUALITY, $iPitch = 0, $sFace = 'Arial')
Local $aCall = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iHeight, "int", $iWidth, "int", $iEscape,  "int", $iOrientn, "int", $iWeight, "dword", $bItalic, "dword", $bUnderline, "dword", $bStrikeout,  "dword", $iCharset, "dword", $iOutputPrec, "dword", $iClipPrec, "dword", $iQuality, "dword", $iPitch, "wstr", $sFace)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateFontIndirect($tLogFont)
Local $aCall = DllCall("gdi32.dll", "handle", "CreateFontIndirectW", "struct*", $tLogFont)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateRectRgn($iLeftRect, $iTopRect, $iRightRect, $iBottomRect)
Local $aCall = DllCall("gdi32.dll", "handle", "CreateRectRgn", "int", $iLeftRect, "int", $iTopRect, "int", $iRightRect,  "int", $iBottomRect)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateRoundRectRgn($iLeftRect, $iTopRect, $iRightRect, $iBottomRect, $iWidthEllipse, $iHeightEllipse)
Local $aCall = DllCall("gdi32.dll", "handle", "CreateRoundRectRgn", "int", $iLeftRect, "int", $iTopRect,  "int", $iRightRect, "int", $iBottomRect, "int", $iWidthEllipse, "int", $iHeightEllipse)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateSolidBrush($iColor)
Local $aCall = DllCall("gdi32.dll", "handle", "CreateSolidBrush", "INT", $iColor)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetBitmapDimension($hBitmap)
Local $tObj = DllStructCreate($tagBITMAP)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return _WinAPI_CreateSize(DllStructGetData($tObj, 'bmWidth'), DllStructGetData($tObj, 'bmHeight'))
EndFunc
Func _WinAPI_GetSysColorBrush($iIndex)
Local $aCall = DllCall("user32.dll", "handle", "GetSysColorBrush", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetTextExtentPoint32($hDC, $sText)
Local $tSize = DllStructCreate($tagSIZE)
Local $iSize = StringLen($sText)
Local $aCall = DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $sText, "int", $iSize, "struct*", $tSize)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tSize
EndFunc
Func _WinAPI_GetTextMetrics($hDC)
Local $tTEXTMETRIC = DllStructCreate($tagTEXTMETRIC)
Local $aCall = DllCall('gdi32.dll', 'bool', 'GetTextMetricsW', 'handle', $hDC, 'struct*', $tTEXTMETRIC)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tTEXTMETRIC
EndFunc
Func _WinAPI_GetWindowRgn($hWnd, $hRgn)
Local $aCall = DllCall("user32.dll", "int", "GetWindowRgn", "hwnd", $hWnd, "handle", $hRgn)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_IsAlphaBitmap($hBitmap)
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
If Not $hBitmap Then Return SetError(@error + 20, @extended, 0)
Local $aCall, $iError = 0
Do
Local $tDIB = DllStructCreate($tagDIBSECTION)
If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), $tDIB)) Or (DllStructGetData($tDIB, 'bmBitsPixel') <> 32) Or (DllStructGetData($tDIB, 'biCompression')) Then
$iError = 1
ExitLoop
EndIf
$aCall = DllCall('user32.dll', 'int', 'CallWindowProc', 'ptr', __AlphaProc(), 'ptr', 0, 'uint', 0, 'struct*', $tDIB, 'ptr', 0)
If @error Or ($aCall[0] = -1) Then
$iError = @error + 10
ExitLoop
EndIf
Until 1
_WinAPI_DeleteObject($hBitmap)
If $iError Then Return SetError($iError, 0, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_PtInRect(ByRef $tRECT, ByRef $tPoint)
Local $aCall = DllCall("user32.dll", "bool", "PtInRect", "struct*", $tRECT, "struct", $tPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_RedrawWindow($hWnd, $tRECT = 0, $hRegion = 0, $iFlags = 5)
Local $aCall = DllCall("user32.dll", "bool", "RedrawWindow", "hwnd", $hWnd, "struct*", $tRECT, "handle", $hRegion,  "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetWindowRgn($hWnd, $hRgn, $bRedraw = True)
Local $aCall = DllCall("user32.dll", "int", "SetWindowRgn", "hwnd", $hWnd, "handle", $hRgn, "bool", $bRedraw)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func __AlphaProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' &  '48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883' &  '7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB' &  '034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B' &  '6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24' &  '287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080' &  '7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB' &  '034831C04883C438415F5DC3'))
Else
$pProc = __Init(Binary(  '0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D' &  '1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407' &  'B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302' &  '83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00' &  '007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func __ANDProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C2420554157415648C7C009000000' &  '4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405' &  '4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405' &  '4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405' &  '4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405' &  '4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048' &  '21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000' &  'EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7' &  '44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100' &  '0048C74424380000000048C74424400000000048C744244800000000488BAC24' &  'A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B' &  '7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440' &  '4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24' &  '4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7' &  '442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C' &  '24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845' &  '0048FF4424604883442458F871B948C74424380000000048C744244000000000' &  '48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7' &  'D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C' &  '244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D' &  '184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24' &  '585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0' &  '010000004863C0EB034831C04883C470415E415F5DC3'))
Else
$pProc = __Init(Binary(  '0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05' &  'B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24' &  '38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0' &  'EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000' &  '00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7' &  '042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000' &  'C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B' &  '3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480' &  '7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24' &  '0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000' &  '31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' &  'FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424' &  '0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3' &  '8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000' &  '31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' &  'FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8' &  '01000000EB0231C083C4205F5B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func __XORProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' &  '48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074' &  '054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0' &  '4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C' &  '3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405' &  '4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C' &  '897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB' &  '034831C04883C438415F5DC3'))
Else
$pProc = __Init(Binary(  '0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074' &  '0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB' &  '5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B' &  '6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303' &  '895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D' &  'C21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func __Init($dData)
Local $iLength = BinaryLen($dData)
Local $aCall = DllCall('kernel32.dll', 'ptr', 'VirtualAlloc', 'ptr', 0, 'ulong_ptr', $iLength, 'dword', 0x00001000, 'dword', 0x00000040)
If @error Or Not $aCall[0] Then __FatalExit(1, 'Error allocating memory.')
Local $tData = DllStructCreate('byte[' & $iLength & "]", $aCall[0])
DllStructSetData($tData, 1, $dData)
Return $aCall[0]
EndFunc
Global Const $DI_MASK = 0x0001
Global Const $DI_IMAGE = 0x0002
Global Const $DI_NORMAL = 0x0003
Global Const $DI_COMPAT = 0x0004
Global Const $DI_DEFAULTSIZE = 0x0008
Global Const $DI_NOMIRROR = 0x0010
Global Const $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP = 0x00000001
Global Const $DISPLAY_DEVICE_MULTI_DRIVER = 0x00000002
Global Const $DISPLAY_DEVICE_PRIMARY_DEVICE = 0x00000004
Global Const $DISPLAY_DEVICE_MIRRORING_DRIVER = 0x00000008
Global Const $DISPLAY_DEVICE_VGA_COMPATIBLE = 0x00000010
Global Const $DISPLAY_DEVICE_REMOVABLE = 0x00000020
Global Const $DISPLAY_DEVICE_DISCONNECT = 0x02000000
Global Const $DISPLAY_DEVICE_REMOTE = 0x04000000
Global Const $DISPLAY_DEVICE_MODESPRUNED = 0x08000000
Func _WinAPI_CreateCompatibleDC($hDC)
Local $aCall = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_DeleteDC($hDC)
Local $aCall = DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DrawEdge($hDC, $tRECT, $iEdgeType, $iFlags)
Local $aCall = DllCall("user32.dll", "bool", "DrawEdge", "handle", $hDC, "struct*", $tRECT, "uint", $iEdgeType,  "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DrawFrameControl($hDC, $tRECT, $iType, $iState)
Local $aCall = DllCall("user32.dll", "bool", "DrawFrameControl", "handle", $hDC, "struct*", $tRECT, "uint", $iType,  "uint", $iState)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DrawIcon($hDC, $iX, $iY, $hIcon)
Local $aCall = DllCall("user32.dll", "bool", "DrawIcon", "handle", $hDC, "int", $iX, "int", $iY, "handle", $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DrawIconEx($hDC, $iX, $iY, $hIcon, $iWidth = 0, $iHeight = 0, $iStep = 0, $hBrush = 0, $iFlags = 3)
Local $iOptions
Switch $iFlags
Case 1
$iOptions = $DI_MASK
Case 2
$iOptions = $DI_IMAGE
Case 3
$iOptions = $DI_NORMAL
Case 4
$iOptions = $DI_COMPAT
Case 5
$iOptions = $DI_DEFAULTSIZE
Case Else
$iOptions = $DI_NOMIRROR
EndSwitch
Local $aCall = DllCall("user32.dll", "bool", "DrawIconEx", "handle", $hDC, "int", $iX, "int", $iY, "handle", $hIcon,  "int", $iWidth, "int", $iHeight, "uint", $iStep, "handle", $hBrush, "uint", $iOptions)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DrawText($hDC, $sText, ByRef $tRECT, $iFlags)
Local $aCall = DllCall("user32.dll", "int", "DrawTextW", "handle", $hDC, "wstr", $sText, "int", -1, "struct*", $tRECT,  "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_EnumDisplayDevices($sDevice, $iDevNum)
Local $tName = 0, $iFlags = 0, $aDevice[5]
If $sDevice <> "" Then
$tName = DllStructCreate("wchar Text[" & StringLen($sDevice) + 1 & "]")
DllStructSetData($tName, "Text", $sDevice)
EndIf
Local Const $tagDISPLAY_DEVICE = "dword Size;wchar Name[32];wchar String[128];dword Flags;wchar ID[128];wchar Key[128]"
Local $tDevice = DllStructCreate($tagDISPLAY_DEVICE)
Local $iDevice = DllStructGetSize($tDevice)
DllStructSetData($tDevice, "Size", $iDevice)
Local $aCall = DllCall("user32.dll", "bool", "EnumDisplayDevicesW", "struct*", $tName, "dword", $iDevNum, "struct*", $tDevice, "dword", 1)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $iN = DllStructGetData($tDevice, "Flags")
If BitAND($iN, $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) <> 0 Then $iFlags = BitOR($iFlags, 1)
If BitAND($iN, $DISPLAY_DEVICE_PRIMARY_DEVICE) <> 0 Then $iFlags = BitOR($iFlags, 2)
If BitAND($iN, $DISPLAY_DEVICE_MIRRORING_DRIVER) <> 0 Then $iFlags = BitOR($iFlags, 4)
If BitAND($iN, $DISPLAY_DEVICE_VGA_COMPATIBLE) <> 0 Then $iFlags = BitOR($iFlags, 8)
If BitAND($iN, $DISPLAY_DEVICE_REMOVABLE) <> 0 Then $iFlags = BitOR($iFlags, 16)
If BitAND($iN, $DISPLAY_DEVICE_MODESPRUNED) <> 0 Then $iFlags = BitOR($iFlags, 32)
$aDevice[0] = True
$aDevice[1] = DllStructGetData($tDevice, "Name")
$aDevice[2] = DllStructGetData($tDevice, "String")
$aDevice[3] = $iFlags
$aDevice[4] = DllStructGetData($tDevice, "ID")
Return $aDevice
EndFunc
Func _WinAPI_FillRect($hDC, $tRECT, $hBrush)
Local $aCall
If IsPtr($hBrush) Then
$aCall = DllCall("user32.dll", "int", "FillRect", "handle", $hDC, "struct*", $tRECT, "handle", $hBrush)
Else
$aCall = DllCall("user32.dll", "int", "FillRect", "handle", $hDC, "struct*", $tRECT, "dword_ptr", $hBrush)
EndIf
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_FrameRect($hDC, $tRECT, $hBrush)
Local $aCall = DllCall("user32.dll", "int", "FrameRect", "handle", $hDC, "struct*", $tRECT, "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_GetBkMode($hDC)
Local $aCall = DllCall("gdi32.dll", "int", "GetBkMode", "handle", $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetDC($hWnd)
Local $aCall = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetDCEx($hWnd, $hRgn, $iFlags)
Local $aCall = DllCall('user32.dll', 'handle', 'GetDCEx', 'hwnd', $hWnd, 'handle', $hRgn, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetDeviceCaps($hDC, $iIndex)
Local $aCall = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetTextColor($hDC)
Local $aCall = DllCall('gdi32.dll', 'dword', 'GetTextColor', 'handle', $hDC)
If @error Or ($aCall[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aCall[0])
EndFunc
Func _WinAPI_GetWindowDC($hWnd)
Local $aCall = DllCall("user32.dll", "handle", "GetWindowDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_PrintWindow($hWnd, $hDC, $bClient = False)
Local $aCall = DllCall('user32.dll', 'bool', 'PrintWindow', 'hwnd', $hWnd, 'handle', $hDC, 'uint', $bClient)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ReleaseDC($hWnd, $hDC)
Local $aCall = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_RestoreDC($hDC, $iID)
Local $aCall = DllCall('gdi32.dll', 'bool', 'RestoreDC', 'handle', $hDC, 'int', $iID)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SaveDC($hDC)
Local $aCall = DllCall('gdi32.dll', 'int', 'SaveDC', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetBkColor($hDC, $iColor)
Local $aCall = DllCall("gdi32.dll", "INT", "SetBkColor", "handle", $hDC, "INT", $iColor)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_SetBkMode($hDC, $iBkMode)
Local $aCall = DllCall("gdi32.dll", "int", "SetBkMode", "handle", $hDC, "int", $iBkMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetTextColor($hDC, $iColor)
Local $aCall = DllCall("gdi32.dll", "INT", "SetTextColor", "handle", $hDC, "INT", $iColor)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_TwipsPerPixelX()
Local $hDC, $iTwipsPerPixelX
$hDC = _WinAPI_GetDC(0)
Local Const $__WINAPICONSTANT_LOGPIXELSX = 88
$iTwipsPerPixelX = 1440 / _WinAPI_GetDeviceCaps($hDC, $__WINAPICONSTANT_LOGPIXELSX)
_WinAPI_ReleaseDC(0, $hDC)
Return $iTwipsPerPixelX
EndFunc
Func _WinAPI_TwipsPerPixelY()
Local $hDC, $iTwipsPerPixelY
$hDC = _WinAPI_GetDC(0)
Local Const $__WINAPICONSTANT_LOGPIXELSY = 90
$iTwipsPerPixelY = 1440 / _WinAPI_GetDeviceCaps($hDC, $__WINAPICONSTANT_LOGPIXELSY)
_WinAPI_ReleaseDC(0, $hDC)
Return $iTwipsPerPixelY
EndFunc
Global Const $IDC_UNKNOWN = 0
Global Const $IDC_APPSTARTING = 32650
Global Const $IDC_ARROW = 32512
Global Const $IDC_CROSS = 32515
Global Const $IDC_HAND = 32649
Global Const $IDC_HELP = 32651
Global Const $IDC_IBEAM = 32513
Global Const $IDC_NO = 32648
Global Const $IDC_SIZEALL = 32646
Global Const $IDC_SIZENESW = 32643
Global Const $IDC_SIZENS = 32645
Global Const $IDC_SIZENWSE = 32642
Global Const $IDC_SIZEWE = 32644
Global Const $IDC_UPARROW = 32516
Global Const $IDC_WAIT = 32514
Global Const $IDI_APPLICATION = 32512
Global Const $IDI_ASTERISK = 32516
Global Const $IDI_EXCLAMATION = 32515
Global Const $IDI_HAND = 32513
Global Const $IDI_QUESTION = 32514
Global Const $IDI_WINLOGO = 32517
Global Const $IDI_SHIELD = 32518
Global Const $IDI_ERROR = $IDI_HAND
Global Const $IDI_INFORMATION = $IDI_ASTERISK
Global Const $IDI_WARNING = $IDI_EXCLAMATION
Global Const $tagICONINFO = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"
Func _WinAPI_AddIconTransparency($hIcon, $iPercent = 50, $bDelete = False)
Local $tBITMAP, $hDib = 0, $hResult = 0
Local $ahBitmap[2]
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aCall = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hIcon, 'struct*', $tICONINFO)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
For $i = 0 To 1
$ahBitmap[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
Local $iError = 0
Do
$hDib = _WinAPI_CopyBitmap($ahBitmap[1])
If Not $hDib Then
$iError = 20
ExitLoop
EndIf
$tBITMAP = DllStructCreate($tagBITMAP)
If (Not _WinAPI_GetObject($hDib, DllStructGetSize($tBITMAP), $tBITMAP)) Or (DllStructGetData($tBITMAP, 'bmBitsPixel') <> 32) Then
$iError = 21
ExitLoop
EndIf
$aCall = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'PTR', __TransparencyProc(), 'hwnd', 0,  'uint', $iPercent, 'wparam', DllStructGetPtr($tBITMAP), 'lparam', 0)
If @error Or Not $aCall[0] Then
$iError = @error + 30
ExitLoop
EndIf
If $aCall[0] = -1 Then
$hResult = _WinAPI_CreateEmptyIcon(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'))
Else
$hResult = _WinAPI_CreateIconIndirect($hDib, $ahBitmap[0])
EndIf
If Not $hResult Then $iError = 22
Until 1
If $hDib Then
_WinAPI_DeleteObject($hDib)
EndIf
For $i = 0 To 1
If $ahBitmap[$i] Then
_WinAPI_DeleteObject($ahBitmap[$i])
EndIf
Next
If $iError Then Return SetError($iError, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hResult
EndFunc
Func _WinAPI_CopyIcon($hIcon)
Local $aCall = DllCall("user32.dll", "handle", "CopyIcon", "handle", $hIcon)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_Create32BitHICON($hIcon, $bDelete = False)
Local $ahBitmap[2], $hResult = 0
Local $aDIB[2][2] = [[0, 0], [0, 0]]
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aCall = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hIcon, 'struct*', $tICONINFO)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
For $i = 0 To 1
$ahBitmap[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
If _WinAPI_IsAlphaBitmap($ahBitmap[1]) Then
$aDIB[0][0] = _WinAPI_CreateANDBitmap($ahBitmap[1])
If Not @error Then
$hResult = _WinAPI_CreateIconIndirect($ahBitmap[1], $aDIB[0][0])
EndIf
Else
Local $tSIZE = _WinAPI_GetBitmapDimension($ahBitmap[1])
Local $aSize[2]
For $i = 0 To 1
$aSize[$i] = DllStructGetData($tSIZE, $i + 1)
Next
Local $hSrcDC = _WinAPI_CreateCompatibleDC(0)
Local $hDstDC = _WinAPI_CreateCompatibleDC(0)
Local $hSrcSv, $hDstSv
For $i = 0 To 1
$aDIB[$i][0] = _WinAPI_CreateDIB($aSize[0], $aSize[1])
$aDIB[$i][1] = $__g_vExt
$hSrcSv = _WinAPI_SelectObject($hSrcDC, $ahBitmap[$i])
$hDstSv = _WinAPI_SelectObject($hDstDC, $aDIB[$i][0])
_WinAPI_BitBlt($hDstDC, 0, 0, $aSize[0], $aSize[1], $hSrcDC, 0, 0, 0x00C000CA)
_WinAPI_SelectObject($hSrcDC, $hSrcSv)
_WinAPI_SelectObject($hDstDC, $hDstSv)
Next
_WinAPI_DeleteDC($hSrcDC)
_WinAPI_DeleteDC($hDstDC)
$aCall = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'ptr', __XORProc(), 'ptr', 0,  'uint', $aSize[0] * $aSize[1] * 4, 'wparam', $aDIB[0][1], 'lparam', $aDIB[1][1])
If Not @error And $aCall[0] Then
$hResult = _WinAPI_CreateIconIndirect($aDIB[1][0], $ahBitmap[0])
EndIf
EndIf
For $i = 0 To 1
_WinAPI_DeleteObject($ahBitmap[$i])
If $aDIB[$i][0] Then
_WinAPI_DeleteObject($aDIB[$i][0])
EndIf
Next
If Not $hResult Then Return SetError(11, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hResult
EndFunc
Func _WinAPI_CreateEmptyIcon($iWidth, $iHeight, $iBitsPerPel = 32)
Local $hXOR = _WinAPI_CreateDIB($iWidth, $iHeight, $iBitsPerPel)
Local $hAND = _WinAPI_CreateDIB($iWidth, $iHeight, 1)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hAND)
Local $hBrush = _WinAPI_CreateSolidBrush(0xFFFFFF)
Local $tRECT = _WinAPI_CreateRect(0, 0, $iWidth, $iHeight)
_WinAPI_FillRect($hDC, $tRECT, $hBrush)
_WinAPI_DeleteObject($hBrush)
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
Local $hIcon = _WinAPI_CreateIconIndirect($hXOR, $hAND)
Local $iError = @error
If $hXOR Then
_WinAPI_DeleteObject($hXOR)
EndIf
If $hAND Then
_WinAPI_DeleteObject($hAND)
EndIf
If Not $hIcon Then Return SetError($iError + 10, 0, 0)
Return $hIcon
EndFunc
Func _WinAPI_CreateIcon($hInstance, $iWidth, $iHeight, $iPlanes, $iBitsPixel, $pANDBits, $pXORBits)
Local $aCall = DllCall('user32.dll', 'handle', 'CreateIcon', 'handle', $hInstance, 'int', $iWidth, 'int', $iHeight,  'byte', $iPlanes, 'byte', $iBitsPixel, 'struct*', $pANDBits, 'struct*', $pXORBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateIconFromResourceEx($pData, $iSize, $bIcon = True, $iXDesiredPixels = 0, $iYDesiredPixels = 0, $iFlags = 0)
Local $aCall = DllCall('user32.dll', 'handle', 'CreateIconFromResourceEx', 'ptr', $pData, 'dword', $iSize, 'bool', $bIcon,  'dword', 0x00030000, 'int', $iXDesiredPixels, 'int', $iYDesiredPixels, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateIconIndirect($hBitmap, $hMask, $iXHotspot = 0, $iYHotspot = 0, $bIcon = True)
Local $tICONINFO = DllStructCreate($tagICONINFO)
DllStructSetData($tICONINFO, 1, $bIcon)
DllStructSetData($tICONINFO, 2, $iXHotspot)
DllStructSetData($tICONINFO, 3, $iYHotspot)
DllStructSetData($tICONINFO, 4, $hMask)
DllStructSetData($tICONINFO, 5, $hBitmap)
Local $aCall = DllCall('user32.dll', 'handle', 'CreateIconIndirect', 'struct*', $tICONINFO)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_DestroyIcon($hIcon)
Local $aCall = DllCall("user32.dll", "bool", "DestroyIcon", "handle", $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ExtractIcon($sIcon, $iIndex, $bSmall = False)
Local $pLarge, $pSmall, $tPtr = DllStructCreate('ptr')
If $bSmall Then
$pLarge = 0
$pSmall = DllStructGetPtr($tPtr)
Else
$pLarge = DllStructGetPtr($tPtr)
$pSmall = 0
EndIf
DllCall('shell32.dll', 'uint', 'ExtractIconExW', 'wstr', $sIcon, 'int', $iIndex, 'ptr', $pLarge, 'ptr', $pSmall, 'uint', 1)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPtr, 1)
EndFunc
Func _WinAPI_ExtractIconEx($sFilePath, $iIndex, $paLarge, $paSmall, $iIcons)
Local $aCall = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sFilePath, "int", $iIndex, "struct*", $paLarge,  "struct*", $paSmall, "uint", $iIcons)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_FileIconInit($bRestore = True)
Local $aCall = DllCall('shell32.dll', 'int', 660, 'int', $bRestore)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return 1
EndFunc
Func _WinAPI_GetIconDimension($hIcon)
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aCall = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hIcon, 'struct*', $tICONINFO)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $tSIZE = _WinAPI_GetBitmapDimension(DllStructGetData($tICONINFO, 5))
For $i = 4 To 5
_WinAPI_DeleteObject(DllStructGetData($tICONINFO, $i))
Next
If Not IsDllStruct($tSIZE) Then Return SetError(20, 0, 0)
Return $tSIZE
EndFunc
Func _WinAPI_GetIconInfo($hIcon)
Local $tInfo = DllStructCreate($tagICONINFO)
Local $aCall = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hIcon, "struct*", $tInfo)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aIcon[6]
$aIcon[0] = True
$aIcon[1] = DllStructGetData($tInfo, "Icon") <> 0
$aIcon[2] = DllStructGetData($tInfo, "XHotSpot")
$aIcon[3] = DllStructGetData($tInfo, "YHotSpot")
$aIcon[4] = DllStructGetData($tInfo, "hMask")
$aIcon[5] = DllStructGetData($tInfo, "hColor")
Return $aIcon
EndFunc
Func _WinAPI_GetIconInfoEx($hIcon)
Local $tIIEX = DllStructCreate('dword;int;dword;dword;ptr;ptr;ushort;wchar[260];wchar[260]')
DllStructSetData($tIIEX, 1, DllStructGetSize($tIIEX))
Local $aCall = DllCall('user32.dll', 'bool', 'GetIconInfoExW', 'handle', $hIcon, 'struct*', $tIIEX)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aRet[8]
For $i = 0 To 7
$aRet[$i] = DllStructGetData($tIIEX, $i + 2)
Next
Return $aRet
EndFunc
Func _WinAPI_LoadIcon($hInstance, $sName)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aCall = DllCall('user32.dll', 'handle', 'LoadIconW', 'handle', $hInstance, $sTypeOfName, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_LoadIconMetric($hInstance, $sName, $iMetric)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aCall = DllCall('comctl32.dll', 'long', 'LoadIconMetric', 'handle', $hInstance, $sTypeOfName, $sName, 'int', $iMetric, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[4]
EndFunc
Func _WinAPI_LoadIconWithScaleDown($hInstance, $sName, $iWidth, $iHeight)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aCall = DllCall('comctl32.dll', 'long', 'LoadIconWithScaleDown', 'handle', $hInstance, $sTypeOfName, $sName,  'int', $iWidth, 'int', $iHeight, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[5]
EndFunc
Func _WinAPI_LoadShell32Icon($iIconID)
Local $tIcons = DllStructCreate("ptr Data")
Local $iIcons = _WinAPI_ExtractIconEx("shell32.dll", $iIconID, 0, $tIcons, 1)
If @error Then Return SetError(@error, @extended, 0)
If $iIcons <= 0 Then Return SetError(10, 0, 0)
Return DllStructGetData($tIcons, "Data")
EndFunc
Func _WinAPI_LookupIconIdFromDirectoryEx($pData, $bIcon = True, $iXDesiredPixels = 0, $iYDesiredPixels = 0, $iFlags = 0)
Local $aCall = DllCall('user32.dll', 'int', 'LookupIconIdFromDirectoryEx', 'ptr', $pData, 'bool', $bIcon,  'int', $iXDesiredPixels, 'int', $iYDesiredPixels, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_MirrorIcon($hIcon, $bDelete = False)
If Not $bDelete Then
$hIcon = _WinAPI_CopyIcon($hIcon)
EndIf
Local $aCall = DllCall('comctl32.dll', 'int', 414, 'ptr', 0, 'ptr*', $hIcon)
If @error Or Not $aCall[0] Then
Local $iError = @error + 10
If $hIcon And Not $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return SetError($iError, 0, 0)
EndIf
Return $aCall[2]
EndFunc
Func __TransparencyProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C24205541574831C0505050505050' &  '4883EC284883BC24800000000074054831C0EB0748C7C0010000004821C07522' &  '488BAC248000000048837D180074054831C0EB0748C7C0010000004821C07502' &  'EB0948C7C001000000EB034831C04821C0740B4831C04863C0E93C0100004C63' &  '7C24784983FF647E0F48C7C0010000004863C0E9220100004C637C24784D21FF' &  '7D08C74424780000000048C74424280100000048C74424300000000048C74424' &  '3800000000488BAC24800000004C637D04488BAC2480000000486345084C0FAF' &  'F849C1E7024983C7FC4C3B7C24380F8C88000000488BAC24800000004C8B7D18' &  '4C037C24384983C7034C897C2440488B6C2440480FB64500505888442448807C' &  '244800744B4C0FB67C244848634424784C0FAFF84C89F848C7C1640000004899' &  '48F7F94989C74C89F850488B6C244858884500488B6C2440807D0000740948C7' &  '4424280000000048C7442430010000004883442438040F8149FFFFFF48837C24' &  '3000741148837C242800740948C7C001000000EB034831C04821C0740E48C7C0' &  'FFFFFFFF4863C0EB11EB0C48C7C0010000004863C0EB034831C04883C458415F' &  '5DC3'))
Else
$pProc = __Init(Binary(  '0x555331C05050505050837C242800740431C0EB05B80100000021C075198B6C24' &  '28837D1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021' &  'C0740731C0E9E50000008B5C242483FB647E0AB801000000E9D20000008B5C24' &  '2421DB7D08C744242400000000C7042401000000C744240400000000C7442408' &  '000000008B6C24288B5D048B6C24280FAF5D08C1E30283C3FC3B5C24087C648B' &  '6C24288B5D14035C240883C303895C240C8B6C240C0FB6450088442410807C24' &  '100074380FB65C24100FAF5C242489D8B96400000099F7F989C3538B6C241058' &  '8845008B6C240C807D00007407C7042400000000C74424040100000083442408' &  '047181837C240400740D833C24007407B801000000EB0231C021C07409B8FFFF' &  'FFFFEB0BEB07B801000000EB0231C083C4145B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
Global Const $tagBITMAPV4HEADER = 'struct;dword bV4Size;long bV4Width;long bV4Height;ushort bV4Planes;ushort bV4BitCount;dword bV4Compression;dword bV4SizeImage;long bV4XPelsPerMeter;long bV4YPelsPerMeter;dword bV4ClrUsed;dword bV4ClrImportant;dword bV4RedMask;dword bV4GreenMask;dword bV4BlueMask;dword bV4AlphaMask;dword bV4CSType;int bV4Endpoints[9];dword bV4GammaRed;dword bV4GammaGreen;dword bV4GammaBlue;endstruct'
Global Const $tagCOLORADJUSTMENT = 'ushort Size;ushort Flags;ushort IlluminantIndex;ushort RedGamma;ushort GreenGamma;ushort BlueGamma;ushort ReferenceBlack;ushort ReferenceWhite;short Contrast;short Brightness;short Colorfulness;short RedGreenTint'
Global Const $tagDEVMODE = 'wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;short Orientation;short PaperSize;short PaperLength;short PaperWidth;short Scale;short Copies;short DefaultSource;short PrintQuality;short Color;short Duplex;short YResolution;short TTOption;short Collate;wchar FormName[32];ushort Unused1;dword Unused2[3];dword Nup;dword Unused3;dword ICMMethod;dword ICMIntent;dword MediaType;dword DitherType;dword Reserved1;dword Reserved2;dword PanningWidth;dword PanningHeight'
Global Const $tagDEVMODE_DISPLAY = 'wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;' & $tagPOINT & ';dword DisplayOrientation;dword DisplayFixedOutput;short Unused1[5];wchar Unused2[32];ushort LogPixels;dword BitsPerPel;dword PelsWidth;dword PelsHeight;dword DisplayFlags;dword DisplayFrequency'
Global Const $tagDWM_COLORIZATION_PARAMETERS = 'dword Color;dword AfterGlow;uint ColorBalance;uint AfterGlowBalance;uint BlurBalance;uint GlassReflectionIntensity; uint OpaqueBlend'
Global Const $tagENHMETAHEADER = 'struct;dword Type;dword Size;long rcBounds[4];long rcFrame[4];dword Signature;dword Version;dword Bytes;dword Records;ushort Handles;ushort Reserved;dword Description;dword OffDescription;dword PalEntries;long Device[2];long Millimeters[2];dword PixelFormat;dword OffPixelFormat;dword OpenGL;long Micrometers[2];endstruct'
Global Const $tagEXTLOGPEN = 'dword PenStyle;dword Width;uint BrushStyle;dword Color;ulong_ptr Hatch;dword NumEntries'
Global Const $tagFONTSIGNATURE = 'dword fsUsb[4];dword fsCsb[2]'
Global Const $tagGLYPHMETRICS = 'uint BlackBoxX;uint BlackBoxY;' & $tagPOINT & ';short CellIncX;short CellIncY'
Global Const $tagLOGBRUSH = 'uint Style;dword Color;ulong_ptr Hatch'
Global Const $tagLOGPEN = 'uint Style;dword Width;dword Color'
Global Const $tagMAT2 = 'short eM11[2];short eM12[2];short eM21[2];short eM22[2]'
Global Const $tagNEWTEXTMETRIC = $tagTEXTMETRIC & ';dword ntmFlags;uint ntmSizeEM;uint ntmCellHeight;uint ntmAvgWidth'
Global Const $tagNEWTEXTMETRICEX = $tagNEWTEXTMETRIC & ';' & $tagFONTSIGNATURE
Global Const $tagPANOSE = 'struct;byte bFamilyType;byte bSerifStyle;byte bWeight;byte bProportion;byte bContrast;byte bStrokeVariation;byte bArmStyle;byte bLetterform;byte bMidline;byte bXHeight;endstruct'
Global Const $tagOUTLINETEXTMETRIC = 'struct;uint otmSize;' & $tagTEXTMETRIC & ';byte otmFiller;' & $tagPANOSE & ';byte bugFiller[3];uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffse[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName;endstruct'
Global Const $tagPAINTSTRUCT = 'hwnd hDC;int fErase;dword rPaint[4];int fRestore;int fIncUpdate;byte rgbReserved[32]'
Global Const $tagRGNDATAHEADER = 'struct;dword Size;dword Type;dword Count;dword RgnSize;' & $tagRECT & ';endstruct'
Global Const $tagXFORM = 'float eM11;float eM12;float eM21;float eM22;float eDx;float eDy'
Func _WinAPI_AbortPath($hDC)
Local $aCall = DllCall('gdi32.dll', 'bool', 'AbortPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_AddFontMemResourceEx($pData, $iSize)
Local $aCall = DllCall('gdi32.dll', 'handle', 'AddFontMemResourceEx', 'ptr', $pData, 'dword', $iSize, 'ptr', 0, 'dword*', 0)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aCall[4], $aCall[0])
EndFunc
Func _WinAPI_AddFontResourceEx($sFont, $iFlag = 0, $bNotify = False)
Local $aCall = DllCall('gdi32.dll', 'int', 'AddFontResourceExW', 'wstr', $sFont, 'dword', $iFlag, 'ptr', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
If $bNotify Then
Local Const $WM_FONTCHANGE = 0x001D
Local Const $HWND_BROADCAST = 0xFFFF
DllCall('user32.dll', 'lresult', 'SendMessage', 'hwnd', $HWND_BROADCAST, 'uint', $WM_FONTCHANGE, 'wparam', 0,  'lparam', 0)
EndIf
Return $aCall[0]
EndFunc
Func _WinAPI_AddIconOverlay($hIcon, $hOverlay)
Local $aCall, $hResult = 0, $iError = 0
Local $ahDev[2] = [0, 0]
Local $tSIZE = _WinAPI_GetIconDimension($hIcon)
Local $hIL = DllCall('comctl32.dll', 'handle', 'ImageList_Create', 'int', DllStructGetData($tSIZE, 1),  'int', DllStructGetData($tSIZE, 2), 'uint', 0x0021, 'int', 2, 'int', 2)
If @error Or Not $hIL[0] Then Return SetError(@error + 10, @extended, 0)
Do
$ahDev[0] = _WinAPI_Create32BitHICON($hIcon)
If @error Then
$iError = @error + 100
ExitLoop
EndIf
$aCall = DllCall('comctl32.dll', 'int', 'ImageList_ReplaceIcon', 'handle', $hIL[0], 'int', -1, 'handle', $ahDev[0])
If @error Or ($aCall[0] = -1) Then
$iError = @error + 200
ExitLoop
EndIf
$ahDev[1] = _WinAPI_Create32BitHICON($hOverlay)
If @error Then
$iError = @error + 300
ExitLoop
EndIf
$aCall = DllCall('comctl32.dll', 'int', 'ImageList_ReplaceIcon', 'handle', $hIL[0], 'int', -1, 'handle', $ahDev[1])
If @error Or ($aCall[0] = -1) Then
$iError = @error + 400
ExitLoop
EndIf
$aCall = DllCall('comctl32.dll', 'bool', 'ImageList_SetOverlayImage', 'handle', $hIL[0], 'int', 1, 'int', 1)
If @error Or Not $aCall[0] Then
$iError = @error + 500
ExitLoop
EndIf
$aCall = DllCall('comctl32.dll', 'handle', 'ImageList_GetIcon', 'handle', $hIL[0], 'int', 0, 'uint', 0x00000100)
If @error Or Not $aCall[0] Then
$iError = @error + 600
ExitLoop
EndIf
$hResult = $aCall[0]
Until 1
DllCall('comctl32.dll', 'bool', 'ImageList_Destroy', 'handle', $hIL[0])
For $i = 0 To 1
If $ahDev[$i] Then
_WinAPI_DestroyIcon($ahDev[$i])
EndIf
Next
If Not $hResult Then Return SetError($iError, 0, 0)
Return $hResult
EndFunc
Func _WinAPI_AdjustBitmap($hBitmap, $iWidth, $iHeight, $iMode = 3, $tAdjustment = 0)
Local $tObj = DllStructCreate($tagBITMAP)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
If $iWidth = -1 Then
$iWidth = DllStructGetData($tObj, 'bmWidth')
EndIf
If $iHeight = -1 Then
$iHeight = DllStructGetData($tObj, 'bmHeight')
EndIf
$aCall = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', 0)
Local $hDC = $aCall[0]
$aCall = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hDestDC = $aCall[0]
$aCall = DllCall('gdi32.dll', 'handle', 'CreateCompatibleBitmap', 'handle', $hDC, 'int', $iWidth, 'int', $iHeight)
Local $hBmp = $aCall[0]
$aCall = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hBmp)
Local $hDestSv = $aCall[0]
$aCall = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hSrcDC = $aCall[0]
$aCall = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hBitmap)
Local $hSrcSv = $aCall[0]
If _WinAPI_SetStretchBltMode($hDestDC, $iMode) Then
Switch $iMode
Case 4
If IsDllStruct($tAdjustment) Then
If Not _WinAPI_SetColorAdjustment($hDestDC, $tAdjustment) Then
EndIf
EndIf
Case Else
EndSwitch
EndIf
$aCall = _WinAPI_StretchBlt($hDestDC, 0, 0, $iWidth, $iHeight, $hSrcDC, 0, 0, DllStructGetData($tObj, 'bmWidth'), DllStructGetData($tObj, 'bmHeight'), 0x00CC0020)
DllCall('user32.dll', 'int', 'ReleaseDC', 'hwnd', 0, 'handle', $hDC)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hDestSv)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hSrcSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hDestDC)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hSrcDC)
If Not $aCall Then Return SetError(10, 0, 0)
Return $hBmp
EndFunc
Func _WinAPI_AlphaBlend($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iAlpha, $bAlpha = False)
Local $iBlend = BitOR(BitShift(Not ($bAlpha = False), -24), BitShift(BitAND($iAlpha, 0xFF), -16))
Local $aCall = DllCall('gdi32.dll', 'bool', 'GdiAlphaBlend', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidthDest, 'int', $iHeightDest, 'handle', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', $iBlend)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_AngleArc($hDC, $iX, $iY, $iRadius, $nStartAngle, $nSweepAngle)
Local $aCall = DllCall('gdi32.dll', 'bool', 'AngleArc', 'handle', $hDC, 'int', $iX, 'int', $iY, 'dword', $iRadius,  'float', $nStartAngle, 'float', $nSweepAngle)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_Arc($hDC, $tRECT, $iXStartArc, $iYStartArc, $iXEndArc, $iYEndArc)
Local $aCall = DllCall('gdi32.dll', 'bool', 'Arc', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4),  'int', $iXStartArc, 'int', $iYStartArc, 'int', $iXEndArc, 'int', $iYEndArc)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ArcTo($hDC, $tRECT, $iXRadial1, $iYRadial1, $iXRadial2, $iYRadial2)
Local $aCall = DllCall('gdi32.dll', 'bool', 'ArcTo', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4),  'int', $iXRadial1, 'int', $iYRadial1, 'int', $iXRadial2, 'int', $iYRadial2)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_BeginPaint($hWnd, ByRef $tPAINTSTRUCT)
$tPAINTSTRUCT = DllStructCreate($tagPAINTSTRUCT)
Local $aCall = DllCall('user32.dll', 'handle', 'BeginPaint', 'hwnd', $hWnd, 'struct*', $tPAINTSTRUCT)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_BeginPath($hDC)
Local $aCall = DllCall('gdi32.dll', 'bool', 'BeginPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_CloseEnhMetaFile($hDC)
Local $aCall = DllCall('gdi32.dll', 'handle', 'CloseEnhMetaFile', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CloseFigure($hDC)
Local $aCall = DllCall('gdi32.dll', 'bool', 'CloseFigure', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ColorAdjustLuma($iRGB, $iPercent, $bScale = True)
If $iRGB = -1 Then Return SetError(10, 0, -1)
If $bScale Then
$iPercent = Floor($iPercent * 10)
EndIf
Local $aCall = DllCall('shlwapi.dll', 'dword', 'ColorAdjustLuma', 'dword', __RGB($iRGB), 'int', $iPercent, 'bool', $bScale)
If @error Then Return SetError(@error, @extended, -1)
Return __RGB($aCall[0])
EndFunc
Func _WinAPI_ColorHLSToRGB($iHue, $iLuminance, $iSaturation)
If Not $iSaturation Then $iHue = 160
Local $aCall = DllCall('shlwapi.dll', 'dword', 'ColorHLSToRGB', 'word', $iHue, 'word', $iLuminance, 'word', $iSaturation)
If @error Then Return SetError(@error, @extended, -1)
Return __RGB($aCall[0])
EndFunc
Func _WinAPI_ColorRGBToHLS($iRGB, ByRef $iHue, ByRef $iLuminance, ByRef $iSaturation)
Local $aCall = DllCall('shlwapi.dll', 'none', 'ColorRGBToHLS', 'dword', __RGB($iRGB), 'word*', 0, 'word*', 0, 'word*', 0)
If @error Then Return SetError(@error, @extended, 0)
$iHue = $aCall[2]
$iLuminance = $aCall[3]
$iSaturation = $aCall[4]
Return 1
EndFunc
Func _WinAPI_CombineTransform($tXFORM1, $tXFORM2)
Local $tXFORM = DllStructCreate($tagXFORM)
Local $aCall = DllCall('gdi32.dll', 'bool', 'CombineTransform', 'struct*', $tXFORM, 'struct*', $tXFORM1, 'struct*', $tXFORM2)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tXFORM
EndFunc
Func _WinAPI_CompressBitmapBits($hBitmap, ByRef $pBuffer, $iCompression = 0, $iQuality = 100)
If Not __DLL('gdiplus.dll') Then Return SetError(103, 0, 0)
Local $aSize[2], $iCount, $iFormat, $iLength, $sMime, $aCall, $hDC, $hSv, $hMem, $tBits, $tData, $pData, $iError = 1
Local $hSource = 0, $hImage = 0, $hToken = 0, $pStream = 0, $tParam = 0
Local $tDIB = DllStructCreate($tagDIBSECTION)
Do
Switch $iCompression
Case 0
$sMime = 'image/png'
Case 1
$sMime = 'image/jpeg'
Case Else
$iError = 10
ExitLoop
EndSwitch
While $hBitmap
If Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), $tDIB) Then
$iError = 11
ExitLoop 2
EndIf
If (DllStructGetData($tDIB, 'bmBitsPixel') = 32) And (Not DllStructGetData($tDIB, 'biCompression')) Then
$iError = 12
ExitLoop
EndIf
If $hSource Then
$iError = 13
ExitLoop 2
EndIf
$hSource = _WinAPI_CreateDIB(DllStructGetData($tDIB, 'bmWidth'), DllStructGetData($tDIB, 'bmHeight'))
If Not $hSource Then
$iError = @error + 100
ExitLoop 2
EndIf
$hDC = _WinAPI_CreateCompatibleDC(0)
$hSv = _WinAPI_SelectObject($hDC, $hSource)
If _WinAPI_DrawBitmap($hDC, 0, 0, $hBitmap) Then
$hBitmap = $hSource
Else
$iError = @error + 200
$hBitmap = 0
EndIf
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
WEnd
If Not $hBitmap Then
ExitLoop
EndIf
For $i = 0 To 1
$aSize[$i] = DllStructGetData($tDIB, $i + 2)
Next
$tBits = DllStructCreate('byte[' & ($aSize[0] * $aSize[1] * 4) & ']')
If Not _WinAPI_GetBitmapBits($hBitmap, DllStructGetSize($tBits), $tBits) Then
$iError = @error + 300
ExitLoop
EndIf
$tData = DllStructCreate($tagGDIPSTARTUPINPUT)
DllStructSetData($tData, "Version", 1)
$aCall = DllCall('gdiplus.dll', 'int', 'GdiplusStartup', 'ulong_ptr*', 0, 'struct*', $tData, 'ptr', 0)
If @error Or $aCall[0] Then
$iError = @error + 400
ExitLoop
EndIf
If _WinAPI_IsAlphaBitmap($hBitmap) Then
$iFormat = 0x0026200A
Else
$iFormat = 0x00022009
EndIf
$hToken = $aCall[1]
$aCall = DllCall('gdiplus.dll', 'int', 'GdipCreateBitmapFromScan0', 'int', $aSize[0], 'int', $aSize[1],  'uint', $aSize[0] * 4, 'int', $iFormat, 'struct*', $tBits, 'ptr*', 0)
If @error Or $aCall[0] Then
$iError = @error + 500
ExitLoop
EndIf
$hImage = $aCall[6]
$aCall = DllCall('gdiplus.dll', 'int', 'GdipGetImageEncodersSize', 'uint*', 0, 'uint*', 0)
If @error Or $aCall[0] Then
$iError = @error + 600
ExitLoop
EndIf
$iCount = $aCall[1]
$tData = DllStructCreate('byte[' & $aCall[2] & ']')
If @error Then
$iError = @error + 700
ExitLoop
EndIf
$pData = DllStructGetPtr($tData)
$aCall = DllCall('gdiplus.dll', 'int', 'GdipGetImageEncoders', 'uint', $iCount, 'uint', $aCall[2], 'struct*', $tData)
If @error Or $aCall[0] Then
$iError = @error + 800
ExitLoop
EndIf
Local $tCodec, $pEncoder = 0
For $i = 1 To $iCount
$tCodec = DllStructCreate($tagGDIPIMAGECODECINFO, $pData)
If Not StringInStr(_WinAPI_GetString(DllStructGetData($tCodec, 'MimeType')), $sMime) Then
$pData += DllStructGetSize($tagGDIPIMAGECODECINFO)
Else
$pEncoder = $pData
$iError = 0
ExitLoop
EndIf
Next
If Not $pEncoder Then
$iError = 15
ExitLoop
EndIf
Switch $iCompression
Case 0
Case 1
Local Const $tagENCODERPARAMETER = 'byte[16] GUID;ulong NumberOfValues;dword Type;ptr pValue'
$tParam = DllStructCreate('dword Count;' & $tagENCODERPARAMETER & ';ulong Quality')
DllStructSetData($tParam, 'Count', 1)
DllStructSetData($tParam, 'NumberOfValues', 1)
DllStructSetData($tParam, 'Type', 4)
DllStructSetData($tParam, 'pValue', DllStructGetPtr($tParam, 'Quality'))
DllStructSetData($tParam, 'Quality', $iQuality)
$aCall = DllCall('ole32.dll', 'long', 'CLSIDFromString', 'wstr', '{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}',  'ptr', DllStructGetPtr($tParam, 2))
If @error Or $aCall[0] Then
$tParam = 0
EndIf
EndSwitch
$pStream = _WinAPI_CreateStreamOnHGlobal()
$aCall = DllCall('gdiplus.dll', 'int', 'GdipSaveImageToStream', 'handle', $hImage, 'ptr', $pStream,  'ptr', $pEncoder, 'struct*', $tParam)
If @error Or $aCall[0] Then
$iError = @error + 900
ExitLoop
EndIf
$hMem = _WinAPI_GetHGlobalFromStream($pStream)
$aCall = DllCall('kernel32.dll', 'ulong_ptr', 'GlobalSize', 'handle', $hMem)
If @error Or Not $aCall[0] Then
$iError = @error + 1000
ExitLoop
EndIf
$iLength = $aCall[0]
$aCall = DllCall('kernel32.dll', 'ptr', 'GlobalLock', 'handle', $hMem)
If @error Or Not $aCall[0] Then
$iError = @error + 1100
ExitLoop
EndIf
$pBuffer = __HeapReAlloc($pBuffer, $iLength, 1)
If Not @error Then
_WinAPI_MoveMemory($pBuffer, $aCall[0], $iLength)
Else
$iError = @error + 1300
EndIf
Until 1
If $pStream Then
_WinAPI_ReleaseStream($pStream)
EndIf
If $hImage Then
DllCall('gdiplus.dll', 'int', 'GdipDisposeImage', 'handle', $hImage)
EndIf
If $hToken Then
DllCall('gdiplus.dll', 'none', 'GdiplusShutdown', 'ulong_ptr', $hToken)
EndIf
If $hSource Then
_WinAPI_DeleteObject($hSource)
EndIf
If $iError Then Return SetError($iError, 0, 0)
Return $iLength
EndFunc
Func _WinAPI_CopyEnhMetaFile($hEmf, $sFilePath = '')
If Not StringStripWS($sFilePath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sFilePath = Null
Local $aCall = DllCall('gdi32.dll', 'handle', 'CopyEnhMetaFileW', 'handle', $hEmf, 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CopyRect($tRECT)
Local $tData = DllStructCreate($tagRECT)
Local $aCall = DllCall('user32.dll', 'bool', 'CopyRect', 'struct*', $tData, 'struct*', $tRECT)
If @error Or Not $aCall[0] Then SetError(@error + 10, @extended, 0)
Return $tData
EndFunc
Func _WinAPI_Create32BitHBITMAP($hIcon, $bDib = False, $bDelete = False)
Local $hBitmap = 0
Local $aDIB[2] = [0, 0]
Local $hTemp = _WinAPI_Create32BitHICON($hIcon)
If @error Then Return SetError(@error, @extended, 0)
Local $iError = 0
Do
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aCall = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hTemp, 'struct*', $tICONINFO)
If @error Or Not $aCall[0] Then
$iError = @error + 10
ExitLoop
EndIf
For $i = 0 To 1
$aDIB[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
Local $tBITMAP = DllStructCreate($tagBITMAP)
If Not _WinAPI_GetObject($aDIB[0], DllStructGetSize($tBITMAP), $tBITMAP) Then
$iError = @error + 20
ExitLoop
EndIf
If $bDib Then
$hBitmap = _WinAPI_CreateDIB(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'))
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hBitmap)
_WinAPI_DrawIconEx($hDC, 0, 0, $hTemp)
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
Else
$hBitmap = $aDIB[1]
$aDIB[1] = 0
EndIf
Until 1
For $i = 0 To 1
If $aDIB[$i] Then
_WinAPI_DeleteObject($aDIB[$i])
EndIf
Next
_WinAPI_DestroyIcon($hTemp)
If $iError Then Return SetError($iError, 0, 0)
If Not $hBitmap Then Return SetError(12, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hBitmap
EndFunc
Func _WinAPI_CreateBitmapIndirect(ByRef $tBITMAP)
Local $aCall = DllCall('gdi32.dll', 'handle', 'CreateBitmapIndirect', 'struct*', $tBITMAP)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateBrushIndirect($iStyle, $iRGB, $iHatch = 0)
Local $tLOGBRUSH = DllStructCreate($tagLOGBRUSH)
DllStructSetData($tLOGBRUSH, 1, $iStyle)
DllStructSetData($tLOGBRUSH, 2, __RGB($iRGB))
DllStructSetData($tLOGBRUSH, 3, $iHatch)
Local $aCall = DllCall('gdi32.dll', 'handle', 'CreateBrushIndirect', 'struct*', $tLOGBRUSH)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateColorAdjustment($iFlags = 0, $iIlluminant = 0, $iGammaR = 10000, $iGammaG = 10000, $iGammaB = 10000, $iBlack = 0, $iWhite = 10000, $iContrast = 0, $iBrightness = 0, $iColorfulness = 0, $iTint = 0)
Local $tCA = DllStructCreate($tagCOLORADJUSTMENT)
DllStructSetData($tCA, 1, DllStructGetSize($tCA))
DllStructSetData($tCA, 2, $iFlags)
DllStructSetData($tCA, 3, $iIlluminant)
DllStructSetData($tCA, 4, $iGammaR)
DllStructSetData($tCA, 5, $iGammaG)
DllStructSetData($tCA, 6, $iGammaB)
DllStructSetData($tCA, 7, $iBlack)
DllStructSetData($tCA, 8, $iWhite)
DllStructSetData($tCA, 9, $iContrast)
DllStructSetData($tCA, 10, $iBrightness)
DllStructSetData($tCA, 11, $iColorfulness)
DllStructSetData($tCA, 12, $iTint)
Return $tCA
EndFunc
Func _WinAPI_CreateCompatibleBitmapEx($hDC, $iWidth, $iHeight, $iRGB)
Local $hBrush = _WinAPI_CreateBrushIndirect(0, $iRGB)
Local $aCall = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hDestDC = $aCall[0]
$aCall = DllCall('gdi32.dll', 'handle', 'CreateCompatibleBitmap', 'handle', $hDC, 'int', $iWidth, 'int', $iHeight)
Local $hBmp = $aCall[0]
$aCall = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hBmp)
Local $hDestSv = $aCall[0]
Local $tRECT = _WinAPI_CreateRectEx(0, 0, $iWidth, $iHeight)
Local $iError = 0
$aCall = DllCall('user32.dll', 'int', 'FillRect', 'handle', $hDestDC, 'struct*', $tRECT, 'handle', $hBrush)
If @error Or Not $aCall[0] Then
$iError = @error + 10
_WinAPI_DeleteObject($hBmp)
EndIf
_WinAPI_DeleteObject($hBrush)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hDestSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hDestDC)
If $iError Then Return SetError($iError, 0, 0)
Return $hBmp
EndFunc
Func _WinAPI_CreateDIBitmap($hDC, ByRef $tBITMAPINFO, $iUsage, $pBits = 0)
Local $iInit = 0
If $pBits Then
$iInit = 0x04
EndIf
Local $aCall = DllCall('gdi32.dll', 'handle', 'CreateDIBitmap', 'handle', $hDC, 'struct*', $tBITMAPINFO, 'dword', $iInit, 'struct*', $pBits,  'struct*', $tBITMAPINFO, 'uint', $iUsage)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateEllipticRgn($tRECT)
Local $aCall = DllCall('gdi32.dll', 'handle', 'CreateEllipticRgnIndirect', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateEnhMetaFile($hDC = 0, $tRECT = 0, $bPixels = False, $sFilePath = '', $sDescription = '')
If Not StringStripWS($sFilePath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sFilePath = Null
Local $tData = 0, $aData = StringSplit($sDescription, '|', $STR_NOCOUNT)
If UBound($aData) < 2 Then
ReDim $aData[2]
$aData[1] = ''
EndIf
For $i = 0 To 1
$aData[$i] = StringStripWS($aData[$i], $STR_STRIPLEADING + $STR_STRIPTRAILING)
Next
If ($aData[0]) Or ($aData[1]) Then
$tData = _WinAPI_ArrayToStruct($aData)
EndIf
Local $iXp, $iYp, $iXm, $iYm, $hRef = 0
If $bPixels And (IsDllStruct($tRECT)) Then
If Not $hDC Then
$hRef = _WinAPI_GetDC(0)
EndIf
$iXp = _WinAPI_GetDeviceCaps($hRef, 8)
$iYp = _WinAPI_GetDeviceCaps($hRef, 10)
$iXm = _WinAPI_GetDeviceCaps($hRef, 4)
$iYm = _WinAPI_GetDeviceCaps($hRef, 6)
If $hRef Then
_WinAPI_ReleaseDC(0, $hRef)
EndIf
For $i = 1 To 3 Step 2
DllStructSetData($tRECT, $i, Round(DllStructGetData($tRECT, $i) * $iXm / $iXp * 100))
Next
For $i = 2 To 4 Step 2
DllStructSetData($tRECT, $i, Round(DllStructGetData($tRECT, $i) * $iYm / $iYp * 100))
Next
EndIf
Local $aCall = DllCall('gdi32.dll', 'handle', 'CreateEnhMetaFileW', 'handle', $hDC, 'wstr', $sFilePath, 'struct*', $tRECT,  'struct*', $tData)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateFontEx($iHeight, $iWidth = 0, $iEscapement = 0, $iOrientation = 0, $iWeight = 400, $bItalic = False, $bUnderline = False, $bStrikeOut = False, $iCharSet = 1, $iOutPrecision = 0, $iClipPrecision = 0, $iQuality = 0, $iPitchAndFamily = 0, $sFaceName = '', $iStyle = 0)
Local $aCall = DllCall('gdi32.dll', 'handle', 'CreateFontW', 'int', $iHeight, 'int', $iWidth, 'int', $iEscapement,  'int', $iOrientation, 'int', $iWeight, 'dword', $bItalic, 'dword', $bUnderline, 'dword', $bStrikeOut,  'dword', $iCharSet, 'dword', $iOutPrecision, 'dword', $iClipPrecision, 'dword', $iQuality,  'dword', $iPitchAndFamily, 'wstr', _WinAPI_GetFontName($sFaceName, $iStyle, $iCharSet))
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateNullRgn()
Local $aCall = DllCall('gdi32.dll', 'handle', 'CreateRectRgn', 'int', 0, 'int', 0, 'int', 0, 'int', 0)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreatePen($iPenStyle, $iWidth, $iColor)
Local $aCall = DllCall("gdi32.dll", "handle", "CreatePen", "int", $iPenStyle, "int", $iWidth, "INT", $iColor)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreatePolygonRgn(Const ByRef $aPoint, $iStart = 0, $iEnd = -1, $iMode = 1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, 0)
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'int[2];'
Next
Local $tData = DllStructCreate($tagStruct)
Local $iCount = 1
For $i = $iStart To $iEnd
For $j = 0 To 1
DllStructSetData($tData, $iCount, $aPoint[$i][$j], $j + 1)
Next
$iCount += 1
Next
Local $aCall = DllCall('gdi32.dll', 'handle', 'CreatePolygonRgn', 'struct*', $tData, 'int', $iCount - 1, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateRectRgnIndirect($tRECT)
Local $aCall = DllCall('gdi32.dll', 'handle', 'CreateRectRgnIndirect', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateSolidBitmap($hWnd, $iColor, $iWidth, $iHeight, $bRGB = 1)
Local $hDC = _WinAPI_GetDC($hWnd)
Local $hDestDC = _WinAPI_CreateCompatibleDC($hDC)
Local $hBitmap = _WinAPI_CreateCompatibleBitmap($hDC, $iWidth, $iHeight)
Local $hOld = _WinAPI_SelectObject($hDestDC, $hBitmap)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, 0)
DllStructSetData($tRECT, 2, 0)
DllStructSetData($tRECT, 3, $iWidth)
DllStructSetData($tRECT, 4, $iHeight)
If $bRGB Then
$iColor = BitOR(BitAND($iColor, 0x00FF00), BitShift(BitAND($iColor, 0x0000FF), -16), BitShift(BitAND($iColor, 0xFF0000), 16))
EndIf
Local $hBrush = _WinAPI_CreateSolidBrush($iColor)
If Not _WinAPI_FillRect($hDestDC, $tRECT, $hBrush) Then
_WinAPI_DeleteObject($hBitmap)
$hBitmap = 0
EndIf
_WinAPI_DeleteObject($hBrush)
_WinAPI_ReleaseDC($hWnd, $hDC)
_WinAPI_SelectObject($hDestDC, $hOld)
_WinAPI_DeleteDC($hDestDC)
If Not $hBitmap Then Return SetError(1, 0, 0)
Return $hBitmap
EndFunc
Func _WinAPI_CreateTransform($nM11 = 1, $nM12 = 0, $nM21 = 0, $nM22 = 1, $nDX = 0, $nDY = 0)
Local $tXFORM = DllStructCreate($tagXFORM)
DllStructSetData($tXFORM, 1, $nM11)
DllStructSetData($tXFORM, 2, $nM12)
DllStructSetData($tXFORM, 3, $nM21)
DllStructSetData($tXFORM, 4, $nM22)
DllStructSetData($tXFORM, 5, $nDX)
DllStructSetData($tXFORM, 6, $nDY)
Return $tXFORM
EndFunc
Func _WinAPI_DeleteEnhMetaFile($hEmf)
Local $aCall = DllCall('gdi32.dll', 'bool', 'DeleteEnhMetaFile', 'handle', $hEmf)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DPtoLP($hDC, ByRef $tPOINT, $iCount = 1)
Local $aCall = DllCall('gdi32.dll', 'bool', 'DPtoLP', 'handle', $hDC, 'struct*', $tPOINT, 'int', $iCount)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DrawAnimatedRects($hWnd, $tRectFrom, $tRectTo)
Local $aCall = DllCall('user32.dll', 'bool', 'DrawAnimatedRects', 'hwnd', $hWnd, 'int', 3, 'struct*', $tRectFrom,  'struct*', $tRectTo)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_DrawBitmap($hDC, $iX, $iY, $hBitmap, $iRop = 0x00CC0020)
Local $tObj = DllStructCreate($tagBITMAP)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
If @error Or Not $aCall[0] Then Return SetError(@error + 20, @extended, 0)
$aCall = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', 0)
Local $_hDC = $aCall[0]
$aCall = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $_hDC)
Local $hSrcDC = $aCall[0]
$aCall = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hBitmap)
Local $hSrcSv = $aCall[0]
Local $iError = 0
$aCall = DllCall('gdi32.dll', 'int', 'BitBlt', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'int', DllStructGetData($tObj, 'bmWidth'), 'int', DllStructGetData($tObj, 'bmHeight'), 'hwnd', $hSrcDC, 'int', 0, 'int', 0, 'int', $iRop)
If @error Or Not $aCall[0] Then
$iError = @error + 1
EndIf
DllCall('user32.dll', 'int', 'ReleaseDC', 'hwnd', 0, 'handle', $_hDC)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hSrcSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hSrcDC)
If $iError Then Return SetError(10, 0, 0)
Return 1
EndFunc
Func _WinAPI_DrawFocusRect($hDC, $tRECT)
Local $aCall = DllCall('user32.dll', 'bool', 'DrawFocusRect', 'handle', $hDC, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_DrawLine($hDC, $iX1, $iY1, $iX2, $iY2)
_WinAPI_MoveTo($hDC, $iX1, $iY1)
If @error Then Return SetError(@error, @extended, False)
_WinAPI_LineTo($hDC, $iX2, $iY2)
If @error Then Return SetError(@error + 10, @extended, False)
Return True
EndFunc
Func _WinAPI_DrawShadowText($hDC, $sText, $iRGBText, $iRGBShadow, $iXOffset = 0, $iYOffset = 0, $tRECT = 0, $iFlags = 0)
Local $aCall
If Not IsDllStruct($tRECT) Then
$tRECT = DllStructCreate($tagRECT)
$aCall = DllCall('user32.dll', 'bool', 'GetClientRect', 'hwnd', _WinAPI_WindowFromDC($hDC), 'struct*', $tRECT)
If @error Then Return SetError(@error + 10, @extended, 0)
If Not $aCall[0] Then Return SetError(10, 0, 0)
EndIf
$aCall = DllCall('comctl32.dll', 'int', 'DrawShadowText', 'handle', $hDC, 'wstr', $sText, 'uint', -1, 'struct*', $tRECT,  'dword', $iFlags, 'int', __RGB($iRGBText), 'int', __RGB($iRGBShadow), 'int', $iXOffset, 'int', $iYOffset)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_DwmDefWindowProc($hWnd, $iMsg, $wParam, $lParam)
Local $aCall = DllCall('dwmapi.dll', 'bool', 'DwmDefWindowProc', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam, 'lparam', $lParam, 'lresult*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $aCall[5]
EndFunc
Func _WinAPI_DwmEnableBlurBehindWindow($hWnd, $bEnable = True, $bTransition = False, $hRgn = 0)
Local $tBLURBEHIND = DllStructCreate('dword;bool;handle;bool')
Local $iFlags = 0
If $hRgn Then
$iFlags += 2
DllStructSetData($tBLURBEHIND, 3, $hRgn)
EndIf
DllStructSetData($tBLURBEHIND, 1, BitOR($iFlags, 0x05))
DllStructSetData($tBLURBEHIND, 2, $bEnable)
DllStructSetData($tBLURBEHIND, 4, $bTransition)
Local $aCall = DllCall('dwmapi.dll', 'long', 'DwmEnableBlurBehindWindow', 'hwnd', $hWnd, 'struct*', $tBLURBEHIND)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmEnableComposition($bEnable)
If $bEnable Then $bEnable = 1
Local $aCall = DllCall('dwmapi.dll', 'long', 'DwmEnableComposition', 'uint', $bEnable)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmExtendFrameIntoClientArea($hWnd, $tMARGINS = 0)
If Not IsDllStruct($tMARGINS) Then
$tMARGINS = _WinAPI_CreateMargins(-1, -1, -1, -1)
EndIf
Local $aCall = DllCall('dwmapi.dll', 'long', 'DwmExtendFrameIntoClientArea', 'hwnd', $hWnd, 'struct*', $tMARGINS)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmGetColorizationColor()
Local $aCall = DllCall('dwmapi.dll', 'long', 'DwmGetColorizationColor', 'dword*', 0, 'bool*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return SetExtended($aCall[2], $aCall[1])
EndFunc
Func _WinAPI_DwmGetColorizationParameters()
Local $tDWMCP = DllStructCreate($tagDWM_COLORIZATION_PARAMETERS)
Local $aCall = DllCall('dwmapi.dll', 'uint', 127, 'struct*', $tDWMCP)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $tDWMCP
EndFunc
Func _WinAPI_DwmGetWindowAttribute($hWnd, $iAttribute)
Local $tagStruct
Switch $iAttribute
Case 5, 9
$tagStruct = $tagRECT
Case 1
$tagStruct = 'uint'
Case Else
Return SetError(11, 0, 0)
EndSwitch
Local $tData = DllStructCreate($tagStruct)
Local $aCall = DllCall('dwmapi.dll', 'long', 'DwmGetWindowAttribute', 'hwnd', $hWnd, 'dword', $iAttribute,  'struct*', $tData, 'dword', DllStructGetSize($tData))
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Switch $iAttribute
Case 1
Return DllStructGetData($tData, 1)
Case Else
Return $tData
EndSwitch
EndFunc
Func _WinAPI_DwmInvalidateIconicBitmaps($hWnd)
Local $aCall = DllCall('dwmapi.dll', 'long', 'DwmInvalidateIconicBitmaps', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmIsCompositionEnabled()
Local $aCall = DllCall('dwmapi.dll', 'long', 'DwmIsCompositionEnabled', 'bool*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[1]
EndFunc
Func _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aCall = DllCall('dwmapi.dll', 'long', 'DwmQueryThumbnailSourceSize', 'handle', $hThumbnail, 'struct*', $tSIZE)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $tSIZE
EndFunc
Func _WinAPI_DwmRegisterThumbnail($hDestination, $hSource)
Local $aCall = DllCall('dwmapi.dll', 'long', 'DwmRegisterThumbnail', 'hwnd', $hDestination, 'hwnd', $hSource, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _WinAPI_DwmSetColorizationParameters($tDWMCP)
Local $aCall = DllCall('dwmapi.dll', 'uint', 131, 'struct*', $tDWMCP, 'uint', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmSetIconicLivePreviewBitmap($hWnd, $hBitmap, $bFrame = False, $tClient = 0)
Local $iFlags
If $bFrame Then
$iFlags = 0x00000001
Else
$iFlags = 0
EndIf
Local $aCall = DllCall('dwmapi.dll', 'uint', 'DwmSetIconicLivePreviewBitmap', 'hwnd', $hWnd, 'handle', $hBitmap,  'struct*', $tClient, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmSetIconicThumbnail($hWnd, $hBitmap, $bFrame = False)
Local $iFlags
If $bFrame Then
$iFlags = 0x00000001
Else
$iFlags = 0
EndIf
Local $aCall = DllCall('dwmapi.dll', 'long', 'DwmSetIconicThumbnail', 'hwnd', $hWnd, 'handle', $hBitmap, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmSetWindowAttribute($hWnd, $iAttribute, $iData)
Switch $iAttribute
Case 2, 3, 4, 6, 7, 8, 10, 11, 12
Case Else
Return SetError(1, 0, 0)
EndSwitch
Local $aCall = DllCall('dwmapi.dll', 'long', 'DwmSetWindowAttribute', 'hwnd', $hWnd, 'dword', $iAttribute,  'dword*', $iData, 'dword', 4)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmUnregisterThumbnail($hThumbnail)
Local $aCall = DllCall('dwmapi.dll', 'long', 'DwmUnregisterThumbnail', 'handle', $hThumbnail)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmUpdateThumbnailProperties($hThumbnail, $bVisible = True, $bClientAreaOnly = False, $iOpacity = 255, $tRectDest = 0, $tRectSrc = 0)
Local Const $tagDWM_THUMBNAIL_PROPERTIES = 'struct;dword dwFlags;int rcDestination[4];int rcSource[4];byte opacity;bool opacity;bool fSourceClientAreaOnly;endstruct'
Local $tTHUMBNAILPROPERTIES = DllStructCreate($tagDWM_THUMBNAIL_PROPERTIES)
Local $tSIZE, $iFlags = 0
If Not IsDllStruct($tRectDest) Then
$tSIZE = _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
If @error Then
Return SetError(@error + 10, @extended, 0)
EndIf
$tRectDest = _WinAPI_CreateRectEx(0, 0, DllStructGetData($tSIZE, 1), DllStructGetData($tSIZE, 2))
EndIf
For $i = 1 To 4
DllStructSetData($tTHUMBNAILPROPERTIES, 2, DllStructGetData($tRectDest, $i), $i)
Next
If IsDllStruct($tRectSrc) Then
$iFlags += 2
For $i = 1 To 4
DllStructSetData($tTHUMBNAILPROPERTIES, 3, DllStructGetData($tRectSrc, $i), $i)
Next
EndIf
DllStructSetData($tTHUMBNAILPROPERTIES, 1, BitOR($iFlags, 0x1D))
DllStructSetData($tTHUMBNAILPROPERTIES, 4, $iOpacity)
DllStructSetData($tTHUMBNAILPROPERTIES, 5, $bVisible)
DllStructSetData($tTHUMBNAILPROPERTIES, 6, $bClientAreaOnly)
Local $aCall = DllCall('dwmapi.dll', 'long', 'DwmUpdateThumbnailProperties', 'handle', $hThumbnail,  'struct*', $tTHUMBNAILPROPERTIES)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_Ellipse($hDC, $tRECT)
Local $aCall = DllCall('gdi32.dll', 'bool', 'Ellipse', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_EndPaint($hWnd, ByRef $tPAINTSTRUCT)
Local $aCall = DllCall('user32.dll', 'bool', 'EndPaint', 'hwnd', $hWnd, 'struct*', $tPAINTSTRUCT)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_EndPath($hDC)
Local $aCall = DllCall('gdi32.dll', 'bool', 'EndPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_EnumDisplayMonitors($hDC = 0, $tRECT = 0)
Local $hEnumProc = DllCallbackRegister('__EnumDisplayMonitorsProc', 'bool', 'handle;handle;ptr;lparam')
Dim $__g_vEnum[101][2] = [[0]]
Local $aCall = DllCall('user32.dll', 'bool', 'EnumDisplayMonitors', 'handle', $hDC, 'struct*', $tRECT,  'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
If @error Or Not $aCall[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumDisplaySettings($sDevice, $iMode)
If Not StringStripWS($sDevice, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sDevice = Null
Local $tDEVMODE = DllStructCreate($tagDEVMODE_DISPLAY)
DllStructSetData($tDEVMODE, 'Size', DllStructGetSize($tDEVMODE))
DllStructSetData($tDEVMODE, 'DriverExtra', 0)
Local $aCall = DllCall('user32.dll', 'bool', 'EnumDisplaySettingsW', 'wstr', $sDevice, 'dword', $iMode,  'struct*', $tDEVMODE)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aRet[5]
$aRet[0] = DllStructGetData($tDEVMODE, 'PelsWidth')
$aRet[1] = DllStructGetData($tDEVMODE, 'PelsHeight')
$aRet[2] = DllStructGetData($tDEVMODE, 'BitsPerPel')
$aRet[3] = DllStructGetData($tDEVMODE, 'DisplayFrequency')
$aRet[4] = DllStructGetData($tDEVMODE, 'DisplayFlags')
Return $aRet
EndFunc
Func _WinAPI_EnumFontFamilies($hDC = 0, $sFaceName = '', $iCharSet = 1, $iFontType = 0x07, $sPattern = '', $bExclude = False)
Local $tLOGFONT = DllStructCreate($tagLOGFONT)
Local $tPattern = DllStructCreate('uint;uint;ptr;wchar[' & (StringLen($sPattern) + 1) & ']')
DllStructSetData($tPattern, 1, $iFontType)
If Not $sPattern Then
DllStructSetData($tPattern, 2, 0)
DllStructSetData($tPattern, 3, 0)
Else
DllStructSetData($tPattern, 2, $bExclude)
DllStructSetData($tPattern, 3, DllStructGetPtr($tPattern, 4))
DllStructSetData($tPattern, 4, $sPattern)
EndIf
DllStructSetData($tLOGFONT, 9, $iCharSet)
DllStructSetData($tLOGFONT, 13, 0)
DllStructSetData($tLOGFONT, 14, StringLeft($sFaceName, 31))
Local $hCDC
If Not $hDC Then
$hCDC = _WinAPI_CreateCompatibleDC(0)
Else
$hCDC = $hDC
EndIf
Dim $__g_vEnum[101][8] = [[0]]
Local $hEnumProc = DllCallbackRegister('__EnumFontFamiliesProc', 'int', 'ptr;ptr;dword;PTR')
Local $aCall = DllCall('gdi32.dll', 'int', 'EnumFontFamiliesExW', 'handle', $hCDC, 'struct*', $tLOGFONT,  'ptr', DllCallbackGetPtr($hEnumProc), 'struct*', $tPattern, 'dword', 0)
If @error Or Not $aCall[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If Not $hDC Then
_WinAPI_DeleteDC($hCDC)
EndIf
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EqualRect($tRECT1, $tRECT2)
Local $aCall = DllCall('user32.dll', 'bool', 'EqualRect', 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_EqualRgn($hRgn1, $hRgn2)
Local $aCall = DllCall('gdi32.dll', 'bool', 'EqualRgn', 'handle', $hRgn1, 'handle', $hRgn2)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ExcludeClipRect($hDC, $tRECT)
Local $aCall = DllCall('gdi32.dll', 'int', 'ExcludeClipRect', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ExtCreatePen($iPenStyle, $iWidth, $iBrushStyle, $iRGB, $iHatch = 0, $aUserStyle = 0, $iStart = 0, $iEnd = -1)
Local $iCount = 0, $tStyle = 0
If BitAND($iPenStyle, 0xFF) = 7 Then
If __CheckErrorArrayBounds($aUserStyle, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$tStyle = DllStructCreate('dword[' & ($iEnd - $iStart + 1) & ']')
For $i = $iStart To $iEnd
DllStructSetData($tStyle, 1, $aUserStyle[$i], $iCount + 1)
$iCount += 1
Next
EndIf
Local $tLOGBRUSH = DllStructCreate($tagLOGBRUSH)
DllStructSetData($tLOGBRUSH, 1, $iBrushStyle)
DllStructSetData($tLOGBRUSH, 2, __RGB($iRGB))
DllStructSetData($tLOGBRUSH, 3, $iHatch)
Local $aCall = DllCall('gdi32.dll', 'handle', 'ExtCreatePen', 'dword', $iPenStyle, 'dword', $iWidth, 'struct*', $tLOGBRUSH,  'dword', $iCount, 'struct*', $tStyle)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ExtCreateRegion($tRGNDATA, $tXFORM = 0)
Local $aCall = DllCall('gdi32.dll', 'handle', 'ExtCreateRegion', 'struct*', $tXFORM, 'dword', DllStructGetSize($tRGNDATA),  'struct*', $tRGNDATA)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ExtFloodFill($hDC, $iX, $iY, $iRGB, $iType = 0)
Local $aCall = DllCall('gdi32.dll', 'bool', 'ExtFloodFill', 'handle', $hDC, 'int', $iX, 'int', $iY, 'dword', __RGB($iRGB),  'uint', $iType)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ExtSelectClipRgn($hDC, $hRgn, $iMode = 5)
Local $aCall = DllCall('gdi32.dll', 'int', 'ExtSelectClipRgn', 'handle', $hDC, 'handle', $hRgn, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_FillPath($hDC)
Local $aCall = DllCall('gdi32.dll', 'bool', 'FillPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_FillRgn($hDC, $hRgn, $hBrush)
Local $aCall = DllCall('gdi32.dll', 'bool', 'FillRgn', 'handle', $hDC, 'handle', $hRgn, 'handle', $hBrush)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_FlattenPath($hDC)
Local $aCall = DllCall('gdi32.dll', 'bool', 'FlattenPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_FrameRgn($hDC, $hRgn, $hBrush, $iWidth, $iHeight)
Local $aCall = DllCall('gdi32.dll', 'bool', 'FrameRgn', 'handle', $hDC, 'handle', $hRgn, 'handle', $hBrush, 'int', $iWidth, 'int', $iHeight)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_GdiComment($hDC, $pBuffer, $iSize)
Local $aCall = DllCall('gdi32.dll', 'bool', 'GdiComment', 'handle', $hDC, 'uint', $iSize, 'struct*', $pBuffer)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_GetArcDirection($hDC)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetArcDirection', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
If ($aCall[0] < 1) Or ($aCall[0] > 2) Then Return SetError(10, $aCall[0], 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetBitmapBits($hBitmap, $iSize, $pBits)
Local $aCall = DllCall('gdi32.dll', 'long', 'GetBitmapBits', 'handle', $hBitmap, 'long', $iSize, 'struct*', $pBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetBitmapDimensionEx($hBitmap)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aCall = DllCall('gdi32.dll', 'bool', 'GetBitmapDimensionEx', 'handle', $hBitmap, 'struct*', $tSIZE)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tSIZE
EndFunc
Func _WinAPI_GetBkColor($hDC)
Local $aCall = DllCall('gdi32.dll', 'dword', 'GetBkColor', 'handle', $hDC)
If @error Or ($aCall[0] = -1) Then Return SetError(@error, @extended, -1)
Return __RGB($aCall[0])
EndFunc
Func _WinAPI_GetBoundsRect($hDC, $iFlags = 0)
Local $tRECT = DllStructCreate($tagRECT)
Local $aCall = DllCall('gdi32.dll', 'uint', 'GetBoundsRect', 'handle', $hDC, 'struct*', $tRECT, 'uint', $iFlags)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended($aCall[0], $tRECT)
EndFunc
Func _WinAPI_GetBrushOrg($hDC)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aCall = DllCall('gdi32.dll', 'bool', 'GetBrushOrgEx', 'handle', $hDC, 'struct*', $tPOINT)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_GetBValue($iRGB)
Return BitShift(BitAND(__RGB($iRGB), 0xFF0000), 16)
EndFunc
Func _WinAPI_GetClipBox($hDC, ByRef $tRECT)
$tRECT = DllStructCreate($tagRECT)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetClipBox', 'handle', $hDC, 'struct*', $tRECT)
If @error Or Not $aCall[0] Then
$tRECT = 0
Return SetError(@error, @extended, 0)
EndIf
Return $aCall[0]
EndFunc
Func _WinAPI_GetClipRgn($hDC)
Local $hRgn = _WinAPI_CreateRectRgn(0, 0, 0, 0)
Local $iError = 0
Local $aCall = DllCall('gdi32.dll', 'int', 'GetClipRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Or ($aCall[0] = -1) Then $iError = @error + 10
If $iError Or Not $aCall[0] Then
_WinAPI_DeleteObject($hRgn)
$hRgn = 0
EndIf
Return SetError($iError, 0, $hRgn)
EndFunc
Func _WinAPI_GetColorAdjustment($hDC)
Local $tAdjustment = DllStructCreate($tagCOLORADJUSTMENT)
Local $aCall = DllCall('gdi32.dll', 'bool', 'GetColorAdjustment', 'handle', $hDC, 'struct*', $tAdjustment)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tAdjustment
EndFunc
Func _WinAPI_GetCurrentPosition($hDC)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetCurrentPositionEx', 'handle', $hDC, 'struct*', $tPOINT)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_GetDeviceGammaRamp($hDC, ByRef $aRamp)
$aRamp = 0
Local $tData = DllStructCreate('word[256];word[256];word[256]')
Local $aCall = DllCall('gdi32.dll', 'bool', 'GetDeviceGammaRamp', 'handle', $hDC, 'struct*', $tData)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Dim $aRamp[256][3]
For $i = 0 To 2
For $j = 0 To 255
$aRamp[$j][$i] = DllStructGetData($tData, $i + 1, $j + 1)
Next
Next
Return 1
EndFunc
Func _WinAPI_GetDIBColorTable($hBitmap)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hBitmap)
Local $tPeak = DllStructCreate('dword[256]')
Local $iError = 0
Local $aCall = DllCall('gdi32.dll', 'uint', 'GetDIBColorTable', 'handle', $hDC, 'uint', 0, 'uint', 256, 'struct*', $tPeak)
If @error Or Not $aCall[0] Then $iError = @error + 10
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
If $iError Then Return SetError($iError, 0, 0)
Local $tData = DllStructCreate('dword[' & $aCall[0] & ']')
If @error Then Return SetError(@error + 20, @extended, 0)
_WinAPI_MoveMemory($tData, $aCall[4], 4 * $aCall[0])
Return SetExtended($aCall[0], $tData)
EndFunc
Func _WinAPI_GetDIBits($hDC, $hBitmap, $iStartScan, $iScanLines, $pBits, $tBI, $iUsage)
Local $aCall = DllCall("gdi32.dll", "int", "GetDIBits", "handle", $hDC, "handle", $hBitmap, "uint", $iStartScan,  "uint", $iScanLines, "struct*", $pBits, "struct*", $tBI, "uint", $iUsage)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_GetEnhMetaFile($sFilePath)
Local $aCall = DllCall('gdi32.dll', 'handle', 'GetEnhMetaFileW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetEnhMetaFileBits($hEmf, ByRef $pBuffer)
Local $aCall = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileBits', 'handle', $hEmf, 'uint', 0, 'ptr', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 50, @extended, 0)
$pBuffer = __HeapReAlloc($pBuffer, $aCall[0], 1)
If @error Then Return SetError(@error, @extended, 0)
$aCall = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileBits', 'handle', $hEmf, 'uint', $aCall[0], 'ptr', $pBuffer)
If Not $aCall[0] Then Return SetError(60, 0, 0)
Return $aCall[2]
EndFunc
Func _WinAPI_GetEnhMetaFileDescription($hEmf)
Local $tData = DllStructCreate('wchar[4096]')
Local $aCall = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileDescriptionW', 'handle', $hEmf, 'uint', 4096, 'struct*', $tData)
If @error Or ($aCall[0] = 4294967295) Then Return SetError(@error + 20, $aCall[0], 0)
If Not $aCall[0] Then Return 0
Local $aData = _WinAPI_StructToArray($tData)
If @error Then Return SetError(@error, @extended, 0)
Local $aRet[2]
For $i = 0 To 1
If $aData[0] > $i Then
$aRet[$i] = $aData[$i + 1]
Else
$aRet[$i] = ''
EndIf
Next
Return $aRet
EndFunc
Func _WinAPI_GetEnhMetaFileDimension($hEmf)
Local $tENHMETAHEADER = _WinAPI_GetEnhMetaFileHeader($hEmf)
If @error Then Return SetError(@error, @extended, 0)
Local $tSIZE = DllStructCreate($tagSIZE)
DllStructSetData($tSIZE, 1, Round((DllStructGetData($tENHMETAHEADER, 'rcFrame', 3) - DllStructGetData($tENHMETAHEADER, 'rcFrame', 1)) * DllStructGetData($tENHMETAHEADER, 'Device', 1) / DllStructGetData($tENHMETAHEADER, 'Millimeters', 1) / 100))
DllStructSetData($tSIZE, 2, Round((DllStructGetData($tENHMETAHEADER, 'rcFrame', 4) - DllStructGetData($tENHMETAHEADER, 'rcFrame', 2)) * DllStructGetData($tENHMETAHEADER, 'Device', 2) / DllStructGetData($tENHMETAHEADER, 'Millimeters', 2) / 100))
Return $tSIZE
EndFunc
Func _WinAPI_GetEnhMetaFileHeader($hEmf)
Local $tENHMETAHEADER = DllStructCreate($tagENHMETAHEADER)
Local $aCall = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileHeader', 'handle', $hEmf,  'uint', DllStructGetSize($tENHMETAHEADER), 'struct*', $tENHMETAHEADER)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended($aCall[0], $tENHMETAHEADER)
EndFunc
Func _WinAPI_GetFontName($sFaceName, $iStyle = 0, $iCharSet = 1)
If Not $sFaceName Then Return SetError(1, 0, '')
Local $iFlags = 0
If BitAND($iStyle, 0x01) Then
$iFlags += 0x00000020
EndIf
If BitAND($iStyle, 0x02) Then
$iFlags += 0x00000001
EndIf
If Not $iFlags Then
$iFlags = 0x00000040
EndIf
Local $tLOGFONT = DllStructCreate($tagLOGFONT)
DllStructSetData($tLOGFONT, 9, $iCharSet)
DllStructSetData($tLOGFONT, 13, 0)
DllStructSetData($tLOGFONT, 14, StringLeft($sFaceName, 31))
Local $tFN = DllStructCreate('dword;wchar[64]')
DllStructSetData($tFN, 1, $iFlags)
DllStructSetData($tFN, 2, '')
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hEnumProc = DllCallbackRegister('__EnumFontStylesProc', 'int', 'ptr;ptr;dword;lparam')
Local $sRet = ''
Local $aCall = DllCall('gdi32.dll', 'int', 'EnumFontFamiliesExW', 'handle', $hDC, 'struct*', $tLOGFONT,  'ptr', DllCallbackGetPtr($hEnumProc), 'struct*', $tFN, 'dword', 0)
If Not @error And Not $aCall[0] Then $sRet = DllStructGetData($tFN, 2)
DllCallbackFree($hEnumProc)
_WinAPI_DeleteDC($hDC)
If Not $sRet Then Return SetError(2, 0, '')
Return $sRet
EndFunc
Func _WinAPI_GetFontResourceInfo($sFont, $bForce = False, $iFlag = Default)
If $iFlag = Default Then
If $bForce Then
If Not _WinAPI_AddFontResourceEx($sFont, $FR_NOT_ENUM) Then Return SetError(@error + 20, @extended, '')
EndIf
Local $iError = 0
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetFontResourceInfoW', 'wstr', $sFont, 'dword*', 4096, 'wstr', '', 'dword', 0x01)
If @error Or Not $aRet[0] Then $iError = @error + 10
If $bForce Then
_WinAPI_RemoveFontResourceEx($sFont, $FR_NOT_ENUM)
EndIf
If $iError Then Return SetError($iError, 0, '')
Return $aRet[3]
Else
If Not FileExists($sFont) Then
$sFont = RegRead("HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Fonts") & "\" & $sFont
If Not FileExists($sFont) Then Return SetError(31, 0, "")
EndIf
Local Const $hFile = _WinAPI_CreateFile($sFont, 2, 2, 2)
If Not $hFile Then Return SetError(32, _WinAPI_GetLastError(), "")
Local Const $iFile = FileGetSize($sFont)
Local Const $tBuffer = DllStructCreate("byte[" & $iFile + 1 & "]")
Local Const $pFile = DllStructGetPtr($tBuffer)
Local $iRead
_WinAPI_ReadFile($hFile, $pFile, $iFile, $iRead)
_WinAPI_CloseHandle($hFile)
Local $sTTFName = _WinAPI_GetFontMemoryResourceInfo($pFile, $iFlag)
If @error Then
If @error = 1 Then
$sTTFName = _WinAPI_GetFontResourceInfo($sFont, True)
Return SetError(@error, @extended, $sTTFName)
EndIf
Return SetError(33, @error, "")
EndIf
Return $sTTFName
EndIf
EndFunc
Func _WinAPI_GetFontMemoryResourceInfo($pMemory, $iFlag = 1)
Local Const $tagTT_OFFSET_TABLE = "USHORT uMajorVersion;USHORT uMinorVersion;USHORT uNumOfTables;USHORT uSearchRange;USHORT uEntrySelector;USHORT uRangeShift"
Local Const $tagTT_TABLE_DIRECTORY = "char szTag[4];ULONG uCheckSum;ULONG uOffset;ULONG uLength"
Local Const $tagTT_NAME_TABLE_HEADER = "USHORT uFSelector;USHORT uNRCount;USHORT uStorageOffset"
Local Const $tagTT_NAME_RECORD = "USHORT uPlatformID;USHORT uEncodingID;USHORT uLanguageID;USHORT uNameID;USHORT uStringLength;USHORT uStringOffset"
Local $tTTOffsetTable = DllStructCreate($tagTT_OFFSET_TABLE, $pMemory)
Local $iNumOfTables = _WinAPI_SwapWord(DllStructGetData($tTTOffsetTable, "uNumOfTables"))
If Not (_WinAPI_SwapWord(DllStructGetData($tTTOffsetTable, "uMajorVersion")) = 1 And  _WinAPI_SwapWord(DllStructGetData($tTTOffsetTable, "uMinorVersion")) = 0) Then Return SetError(1, 0, "")
Local $iTblDirSize = DllStructGetSize(DllStructCreate($tagTT_TABLE_DIRECTORY))
Local $bFound = False, $iOffset, $tTblDir
For $i = 0 To $iNumOfTables - 1
$tTblDir = DllStructCreate($tagTT_TABLE_DIRECTORY, $pMemory + DllStructGetSize($tTTOffsetTable) + $i * $iTblDirSize)
If StringLeft(DllStructGetData($tTblDir, "szTag"), 4) = "name" Then
$bFound = True
$iOffset = _WinAPI_SwapDWord(DllStructGetData($tTblDir, "uOffset"))
ExitLoop
EndIf
Next
If Not $bFound Then Return SetError(2, 0, "")
Local $tNTHeader = DllStructCreate($tagTT_NAME_TABLE_HEADER, $pMemory + $iOffset)
Local $iNTHeaderSize = DllStructGetSize($tNTHeader)
Local $iNRCount = _WinAPI_SwapWord(DllStructGetData($tNTHeader, "uNRCount"))
Local $iStorageOffset = _WinAPI_SwapWord(DllStructGetData($tNTHeader, "uStorageOffset"))
Local $iTTRecordSize = DllStructGetSize(DllStructCreate($tagTT_NAME_RECORD))
Local $tResult, $sResult, $iStringLength = 0, $iStringOffset, $iEncodingID, $tTTRecord
For $i = 0 To $iNRCount - 1
$tTTRecord = DllStructCreate($tagTT_NAME_RECORD, $pMemory + $iOffset + $iNTHeaderSize + $i * $iTTRecordSize)
If @error Then ContinueLoop
If _WinAPI_SwapWord($tTTRecord.uNameID) = $iFlag Then
$iStringLength = _WinAPI_SwapWord(DllStructGetData($tTTRecord, "uStringLength"))
$iStringOffset = _WinAPI_SwapWord(DllStructGetData($tTTRecord, "uStringOffset"))
$iEncodingID = _WinAPI_SwapWord(DllStructGetData($tTTRecord, "uEncodingID"))
Local $sWchar = "char"
If $iEncodingID = 1 Then
$sWchar = "word"
$iStringLength /= 2
EndIf
If Not $iStringLength Then
$sResult = ""
ContinueLoop
EndIf
$tResult = DllStructCreate($sWchar & " szTTFName[" & $iStringLength & "]", $pMemory + $iOffset + $iStringOffset + $iStorageOffset)
If $iEncodingID = 1 Then
$sResult = ""
For $j = 1 To $iStringLength
$sResult &= ChrW(_WinAPI_SwapWord(DllStructGetData($tResult, 1, $j)))
Next
Else
$sResult = $tResult.szTTFName
EndIf
If StringLen($sResult) > 0 Then ExitLoop
EndIf
Next
Return $sResult
EndFunc
Func _WinAPI_GetGlyphOutline($hDC, $sChar, $iFormat, ByRef $pBuffer, $tMAT2 = 0)
Local $tGM = DllStructCreate($tagGLYPHMETRICS)
Local $aCall, $iLength = 0
If Not IsDllStruct($tMAT2) Then
$tMAT2 = DllStructCreate('short[8]')
DllStructSetData($tMAT2, 1, 1, 2)
DllStructSetData($tMAT2, 1, 1, 8)
EndIf
If $iFormat Then
$aCall = DllCall('gdi32.dll', 'dword', 'GetGlyphOutlineW', 'handle', $hDC, 'uint', AscW($sChar), 'uint', $iFormat,  'struct*', $tGM, 'dword', 0, 'ptr', 0, 'struct*', $tMAT2)
If @error Or ($aCall[0] = 4294967295) Then Return SetError(@error + 10, @extended, 0)
$iLength = $aCall[0]
$pBuffer = __HeapReAlloc($pBuffer, $iLength, 1)
If @error Then Return SetError(@error + 20, @extended, 0)
EndIf
$aCall = DllCall('gdi32.dll', 'dword', 'GetGlyphOutlineW', 'handle', $hDC, 'uint', AscW($sChar), 'uint', $iFormat,  'struct*', $tGM, 'dword', $iLength, 'ptr', $pBuffer, 'struct*', $tMAT2)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] = 4294967295 Then Return SetError(10, -1, 0)
Return SetExtended($iLength, $tGM)
EndFunc
Func _WinAPI_GetGraphicsMode($hDC)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetGraphicsMode', 'handle', $hDC)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetGValue($iRGB)
Return BitShift(BitAND(__RGB($iRGB), 0x00FF00), 8)
EndFunc
Func _WinAPI_GetMapMode($hDC)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetMapMode', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetMonitorInfo($hMonitor)
Local $tMIEX = DllStructCreate('dword;long[4];long[4];dword;wchar[32]')
DllStructSetData($tMIEX, 1, DllStructGetSize($tMIEX))
Local $aCall = DllCall('user32.dll', 'bool', 'GetMonitorInfoW', 'handle', $hMonitor, 'struct*', $tMIEX)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aRet[4]
For $i = 0 To 1
$aRet[$i] = DllStructCreate($tagRECT)
_WinAPI_MoveMemory($aRet[$i], DllStructGetPtr($tMIEX, $i + 2), 16)
Next
$aRet[3] = DllStructGetData($tMIEX, 5)
Switch DllStructGetData($tMIEX, 4)
Case 1
$aRet[2] = 1
Case Else
$aRet[2] = 0
EndSwitch
Return $aRet
EndFunc
Func _WinAPI_GetOutlineTextMetrics($hDC)
Local $aCall = DllCall('gdi32.dll', 'uint', 'GetOutlineTextMetricsW', 'handle', $hDC, 'uint', 0, 'ptr', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $tData = DllStructCreate('byte[' & $aCall[0] & ']')
Local $tOLTM = DllStructCreate($tagOUTLINETEXTMETRIC, DllStructGetPtr($tData))
$aCall = DllCall('gdi32.dll', 'uint', 'GetOutlineTextMetricsW', 'handle', $hDC, 'uint', $aCall[0], 'struct*', $tData)
If Not $aCall[0] Then Return SetError(20, 0, 0)
Return $tOLTM
EndFunc
Func _WinAPI_GetPixel($hDC, $iX, $iY)
Local $aCall = DllCall('gdi32.dll', 'dword', 'GetPixel', 'handle', $hDC, 'int', $iX, 'int', $iY)
If @error Or ($aCall[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aCall[0])
EndFunc
Func _WinAPI_GetPolyFillMode($hDC)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetPolyFillMode', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetPosFromRect($tRECT)
Local $aRet[4]
For $i = 0 To 3
$aRet[$i] = DllStructGetData($tRECT, $i + 1)
If @error Then Return SetError(@error, @extended, 0)
Next
For $i = 2 To 3
$aRet[$i] -= $aRet[$i - 2]
Next
Return $aRet
EndFunc
Func _WinAPI_GetRegionData($hRgn, ByRef $tRGNDATA)
Local $aCall = DllCall('gdi32.dll', 'dword', 'GetRegionData', 'handle', $hRgn, 'dword', 0, 'ptr', 0)
If @error Or Not $aCall[0] Then
$tRGNDATA = 0
Return SetError(@error, @extended, False)
EndIf
$tRGNDATA = DllStructCreate($tagRGNDATAHEADER)
Local $iRectSize = $aCall[0] - DllStructGetSize($tRGNDATA)
If $iRectSize > 0 Then $tRGNDATA = DllStructCreate($tagRGNDATAHEADER & ';byte[' & $iRectSize & ']')
$aCall = DllCall('gdi32.dll', 'dword', 'GetRegionData', 'handle', $hRgn, 'dword', $aCall[0], 'struct*', $tRGNDATA)
If Not $aCall[0] Then $tRGNDATA = 0
Return $aCall[0]
EndFunc
Func _WinAPI_GetRgnBox($hRgn, ByRef $tRECT)
$tRECT = DllStructCreate($tagRECT)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetRgnBox', 'handle', $hRgn, 'struct*', $tRECT)
If @error Or Not $aCall[0] Then
$tRECT = 0
Return SetError(@error, @extended, 0)
EndIf
Return $aCall[0]
EndFunc
Func _WinAPI_GetROP2($hDC)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetROP2', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetRValue($iRGB)
Return BitAND(__RGB($iRGB), 0x0000FF)
EndFunc
Func _WinAPI_GetStretchBltMode($hDC)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetStretchBltMode', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetTabbedTextExtent($hDC, $sText, $aTab = 0, $iStart = 0, $iEnd = -1)
Local $iTab, $iCount
If Not IsArray($aTab) Then
If $aTab Then
$iTab = $aTab
Dim $aTab[1] = [$iTab]
$iStart = 0
$iEnd = 0
$iCount = 1
Else
$iCount = 0
EndIf
Else
$iCount = 1
EndIf
Local $tTab = 0
If $iCount Then
If __CheckErrorArrayBounds($aTab, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$iCount = $iEnd - $iStart + 1
$tTab = DllStructCreate('uint[' & $iCount & ']')
$iTab = 1
For $i = $iStart To $iEnd
DllStructSetData($tTab, 1, $aTab[$i], $iTab)
$iTab += 1
Next
EndIf
Local $aCall = DllCall('user32.dll', 'dword', 'GetTabbedTextExtentW', 'handle', $hDC, 'wstr', $sText, 'int', StringLen($sText), 'int', $iCount, 'struct*', $tTab)
If @error Or Not $aCall[0] Then Return SetError(@error + 20, @extended, 0)
Return _WinAPI_CreateSize(_WinAPI_LoWord($aCall[0]), _WinAPI_HiWord($aCall[0]))
EndFunc
Func _WinAPI_GetTextAlign($hDC)
Local $aCall = DllCall('gdi32.dll', 'uint', 'GetTextAlign', 'handle', $hDC)
If @error Or ($aCall[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_GetTextCharacterExtra($hDC)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetTextCharacterExtra', 'handle', $hDC)
If @error Or ($aCall[0] = 0x8000000) Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_GetTextFace($hDC)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetTextFaceW', 'handle', $hDC, 'int', 2048, 'wstr', '')
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
Return $aCall[3]
EndFunc
Func _WinAPI_GetUDFColorMode()
Return Number($__g_iRGBMode)
EndFunc
Func _WinAPI_GetUpdateRect($hWnd, $bErase = True)
Local $tRECT = DllStructCreate($tagRECT)
Local $aCall = DllCall('user32.dll', 'bool', 'GetUpdateRect', 'hwnd', $hWnd, 'struct*', $tRECT, 'bool', $bErase)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetUpdateRgn($hWnd, $hRgn, $bErase = True)
Local $aCall = DllCall('user32.dll', 'int', 'GetUpdateRgn', 'hwnd', $hWnd, 'handle', $hRgn, 'bool', $bErase)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetWindowExt($hDC)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aCall = DllCall('gdi32.dll', 'bool', 'GetWindowExtEx', 'handle', $hDC, 'struct*', $tSIZE)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tSIZE
EndFunc
Func _WinAPI_GetWindowOrg($hDC)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aCall = DllCall('gdi32.dll', 'bool', 'GetWindowOrgEx', 'handle', $hDC, 'struct*', $tPOINT)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_GetWindowRgnBox($hWnd, ByRef $tRECT)
$tRECT = DllStructCreate($tagRECT)
Local $aCall = DllCall('gdi32.dll', 'int', 'GetWindowRgnBox', 'hwnd', $hWnd, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetWorldTransform($hDC)
Local $tXFORM = DllStructCreate($tagXFORM)
Local $aCall = DllCall('gdi32.dll', 'bool', 'GetWorldTransform', 'handle', $hDC, 'struct*', $tXFORM)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tXFORM
EndFunc
Func _WinAPI_GradientFill($hDC, Const ByRef $aVertex, $iStart = 0, $iEnd = -1, $bRotate = False)
If __CheckErrorArrayBounds($aVertex, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aVertex, $UBOUND_COLUMNS) < 3 Then Return SetError(13, 0, 0)
Local $iPoint = $iEnd - $iStart + 1
If $iPoint > 3 Then
$iEnd = $iStart + 2
$iPoint = 3
EndIf
Local $iMode
Switch $iPoint
Case 2
$iMode = Number(Not $bRotate)
Case 3
$iMode = 2
Case Else
Return SetError(15, 0, 0)
EndSwitch
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'ushort[8];'
Next
Local $tVertex = DllStructCreate($tagStruct)
Local $iCount = 1
Local $tGradient = DllStructCreate('ulong[' & $iPoint & ']')
For $i = $iStart To $iEnd
DllStructSetData($tGradient, 1, $iCount - 1, $iCount)
DllStructSetData($tVertex, $iCount, _WinAPI_LoWord($aVertex[$i][0]), 1)
DllStructSetData($tVertex, $iCount, _WinAPI_HiWord($aVertex[$i][0]), 2)
DllStructSetData($tVertex, $iCount, _WinAPI_LoWord($aVertex[$i][1]), 3)
DllStructSetData($tVertex, $iCount, _WinAPI_HiWord($aVertex[$i][1]), 4)
DllStructSetData($tVertex, $iCount, BitShift(_WinAPI_GetRValue($aVertex[$i][2]), -8), 5)
DllStructSetData($tVertex, $iCount, BitShift(_WinAPI_GetGValue($aVertex[$i][2]), -8), 6)
DllStructSetData($tVertex, $iCount, BitShift(_WinAPI_GetBValue($aVertex[$i][2]), -8), 7)
DllStructSetData($tVertex, $iCount, 0, 8)
$iCount += 1
Next
Local $aCall = DllCall('gdi32.dll', 'bool', 'GdiGradientFill', 'handle', $hDC, 'struct*', $tVertex, 'ulong', $iPoint,  'struct*', $tGradient, 'ulong', 1, 'ulong', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_InflateRect(ByRef $tRECT, $iDX, $iDY)
Local $aCall = DllCall('user32.dll', 'bool', 'InflateRect', 'struct*', $tRECT, 'int', $iDX, 'int', $iDY)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_IntersectClipRect($hDC, $tRECT)
Local $aCall = DllCall('gdi32.dll', 'int', 'IntersectClipRect', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3),  'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_IntersectRect($tRECT1, $tRECT2)
Local $tRECT = DllStructCreate($tagRECT)
Local $aCall = DllCall('user32.dll', 'bool', 'IntersectRect', 'struct*', $tRECT, 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_InvalidateRgn($hWnd, $hRgn = 0, $bErase = True)
Local $aCall = DllCall('user32.dll', 'bool', 'InvalidateRgn', 'hwnd', $hWnd, 'handle', $hRgn, 'bool', $bErase)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_InvertANDBitmap($hBitmap, $bDelete = False)
Local $tBITMAP = DllStructCreate($tagBITMAP)
If Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tBITMAP), $tBITMAP) Or (DllStructGetData($tBITMAP, 'bmBitsPixel') <> 1) Then
Return SetError(@error + 10, @extended, 0)
EndIf
Local $hResult = _WinAPI_CreateDIB(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'), 1)
If Not $hResult Then Return SetError(@error, @extended, 0)
Local $hSrcDC = _WinAPI_CreateCompatibleDC(0)
Local $hSrcSv = _WinAPI_SelectObject($hSrcDC, $hBitmap)
Local $hDstDC = _WinAPI_CreateCompatibleDC(0)
Local $hDstSv = _WinAPI_SelectObject($hDstDC, $hResult)
_WinAPI_BitBlt($hDstDC, 0, 0, DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'), $hSrcDC, 0, 0, 0x00330008)
_WinAPI_SelectObject($hSrcDC, $hSrcSv)
_WinAPI_DeleteDC($hSrcDC)
_WinAPI_SelectObject($hDstDC, $hDstSv)
_WinAPI_DeleteDC($hDstDC)
If $bDelete Then
_WinAPI_DeleteObject($hBitmap)
EndIf
Return $hResult
EndFunc
Func _WinAPI_InvertColor($iColor)
If $iColor = -1 Then Return 0
Return 0xFFFFFF - BitAND($iColor, 0xFFFFFF)
EndFunc
Func _WinAPI_InvertRect($hDC, ByRef $tRECT)
Local $aCall = DllCall('user32.dll', 'bool', 'InvertRect', 'handle', $hDC, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_InvertRgn($hDC, $hRgn)
Local $aCall = DllCall('gdi32.dll', 'bool', 'InvertRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_IsRectEmpty(ByRef $tRECT)
Local $aCall = DllCall('user32.dll', 'bool', 'IsRectEmpty', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_LineDDA($iX1, $iY1, $iX2, $iY2, $pLineProc, $pData = 0)
Local $aCall = DllCall('gdi32.dll', 'bool', 'LineDDA', 'int', $iX1, 'int', $iY1, 'int', $iX2, 'int', $iY2, 'ptr', $pLineProc,  'lparam', $pData)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_LineTo($hDC, $iX, $iY)
Local $aCall = DllCall("gdi32.dll", "bool", "LineTo", "handle", $hDC, "int", $iX, "int", $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_LockWindowUpdate($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'LockWindowUpdate', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_LPtoDP($hDC, ByRef $tPOINT, $iCount = 1)
Local $aCall = DllCall('gdi32.dll', 'bool', 'LPtoDP', 'handle', $hDC, 'struct*', $tPOINT, 'int', $iCount)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_MaskBlt($hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $hMask, $iXMask, $iYMask, $iRop)
Local $aCall = DllCall('gdi32.dll', 'bool', 'MaskBlt', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidth, 'int', $iHeight, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc, 'handle', $hMask,  'int', $iXMask, 'int', $iYMask, 'dword', $iRop)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ModifyWorldTransform($hDC, ByRef $tXFORM, $iMode)
Local $aCall = DllCall('gdi32.dll', 'bool', 'ModifyWorldTransform', 'handle', $hDC, 'struct*', $tXFORM, 'dword', $iMode)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_MonitorFromPoint(ByRef $tPOINT, $iFlag = 1)
If DllStructGetSize($tPOINT) <> 8 Then Return SetError(@error + 10, @extended, 0)
Local $aCall = DllCall('user32.dll', 'handle', 'MonitorFromPoint', 'struct', $tPOINT, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_MonitorFromRect(ByRef $tRECT, $iFlag = 1)
Local $aCall = DllCall('user32.dll', 'ptr', 'MonitorFromRect', 'struct*', $tRECT, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_MonitorFromWindow($hWnd, $iFlag = 1)
Local $aCall = DllCall('user32.dll', 'handle', 'MonitorFromWindow', 'hwnd', $hWnd, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_MoveTo($hDC, $iX, $iY)
Local $aCall = DllCall("gdi32.dll", "bool", "MoveToEx", "handle", $hDC, "int", $iX, "int", $iY, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_MoveToEx($hDC, $iX, $iY)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aCall = DllCall('gdi32.dll', 'bool', 'MoveToEx', 'handle', $hDC, 'int', $iX, 'int', $iY, 'struct*', $tPOINT)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_OffsetClipRgn($hDC, $iXOffset, $iYOffset)
Local $aCall = DllCall('gdi32.dll', 'int', 'OffsetClipRgn', 'handle', $hDC, 'int', $iXOffset, 'int', $iYOffset)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_OffsetPoints(ByRef $aPoint, $iXOffset, $iYOffset, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aPoint, $UBOUND_COLUMNS) < 2 Then Return SetError(13, 0, 0)
For $i = $iStart To $iEnd
$aPoint[$i][0] += $iXOffset
$aPoint[$i][1] += $iYOffset
Next
Return 1
EndFunc
Func _WinAPI_OffsetRect(ByRef $tRECT, $iDX, $iDY)
Local $aCall = DllCall('user32.dll', 'bool', 'OffsetRect', 'struct*', $tRECT, 'int', $iDX, 'int', $iDY)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_OffsetRgn($hRgn, $iXOffset, $iYOffset)
Local $aCall = DllCall('gdi32.dll', 'int', 'OffsetRgn', 'handle', $hRgn, 'int', $iXOffset, 'int', $iYOffset)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_OffsetWindowOrg($hDC, $iXOffset, $iYOffset)
$__g_vExt = DllStructCreate($tagPOINT)
Local $aCall = DllCall('gdi32.dll', 'bool', 'OffsetWindowOrgEx', 'handle', $hDC, 'int', $iXOffset, 'int', $iYOffset,  'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PaintDesktop($hDC)
Local $aCall = DllCall('user32.dll', 'bool', 'PaintDesktop', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PaintRgn($hDC, $hRgn)
Local $aCall = DllCall('gdi32.dll', 'bool', 'PaintRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PatBlt($hDC, $iX, $iY, $iWidth, $iHeight, $iRop)
Local $aCall = DllCall('gdi32.dll', 'bool', 'PatBlt', 'handle', $hDC, 'int', $iX, 'int', $iY, 'int', $iWidth, 'int', $iHeight,  'dword', $iRop)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathToRegion($hDC)
Local $aCall = DllCall('gdi32.dll', 'handle', 'PathToRegion', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_PlayEnhMetaFile($hDC, $hEmf, ByRef $tRECT)
Local $aCall = DllCall('gdi32.dll', 'bool', 'PlayEnhMetaFile', 'handle', $hDC, 'handle', $hEmf, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PlgBlt($hDestDC, Const ByRef $aPoint, $hSrcDC, $iXSrc, $iYSrc, $iWidth, $iHeight, $hMask = 0, $iXMask = 0, $iYMask = 0)
If (UBound($aPoint) < 3) Or (UBound($aPoint, $UBOUND_COLUMNS) < 2) Then Return SetError(12, 0, False)
Local $tPoints = DllStructCreate('long[2];long[2];long[2]')
For $i = 0 To 2
For $j = 0 To 1
DllStructSetData($tPoints, $i + 1, $aPoint[$i][$j], $j + 1)
Next
Next
Local $aCall = DllCall('gdi32.dll', 'bool', 'PlgBlt', 'handle', $hDestDC, 'struct*', $tPoints, 'handle', $hSrcDC,  'int', $iXSrc, 'int', $iYSrc, 'int', $iWidth, 'int', $iHeight, 'handle', $hMask,  'int', $iXMask, 'int', $iYMask)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PolyBezier($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, False)
Local $iPoint = 1 + 3 * Floor(($iEnd - $iStart) / 3)
If $iPoint < 1 Then Return SetError(15, 0, False)
$iEnd = $iStart + $iPoint - 1
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'long[2];'
Next
Local $tPOINT = DllStructCreate($tagStruct)
Local $iCount = 0
For $i = $iStart To $iEnd
$iCount += 1
For $j = 0 To 1
DllStructSetData($tPOINT, $iCount, $aPoint[$i][$j], $j + 1)
Next
Next
Local $aCall = DllCall('gdi32.dll', 'bool', 'PolyBezier', 'handle', $hDC, 'struct*', $tPOINT, 'dword', $iPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PolyBezierTo($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, False)
Local $iPoint = 3 * Floor(($iEnd - $iStart + 1) / 3)
If $iPoint < 3 Then Return SetError(15, 0, False)
$iEnd = $iStart + $iPoint - 1
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'long[2];'
Next
Local $tPOINT = DllStructCreate($tagStruct)
Local $iCount = 0
For $i = $iStart To $iEnd
$iCount += 1
For $j = 0 To 1
DllStructSetData($tPOINT, $iCount, $aPoint[$i][$j], $j + 1)
Next
Next
Local $aCall = DllCall('gdi32.dll', 'bool', 'PolyBezierTo', 'handle', $hDC, 'struct*', $tPOINT, 'dword', $iPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PolyDraw($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aPoint, $UBOUND_COLUMNS) < 3 Then Return SetError(13, 0, False)
Local $iPoint = $iEnd - $iStart + 1
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'long[2];'
Next
Local $tPOINT = DllStructCreate($tagStruct)
Local $tTypes = DllStructCreate('byte[' & $iPoint & ']')
Local $iCount = 0
For $i = $iStart To $iEnd
$iCount += 1
For $j = 0 To 1
DllStructSetData($tPOINT, $iCount, $aPoint[$i][$j], $j + 1)
Next
DllStructSetData($tTypes, 1, $aPoint[$i][2], $iCount)
Next
Local $aCall = DllCall('gdi32.dll', 'bool', 'PolyDraw', 'handle', $hDC, 'struct*', $tPOINT, 'struct*', $tTypes, 'dword', $iPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_Polygon($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, False)
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'int[2];'
Next
Local $tData = DllStructCreate($tagStruct)
Local $iCount = 1
For $i = $iStart To $iEnd
For $j = 0 To 1
DllStructSetData($tData, $iCount, $aPoint[$i][$j], $j + 1)
Next
$iCount += 1
Next
Local $aCall = DllCall('gdi32.dll', 'bool', 'Polygon', 'handle', $hDC, 'struct*', $tData, 'int', $iCount - 1)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PtInRectEx($iX, $iY, $iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)
Local $tPOINT = _WinAPI_CreatePoint($iX, $iY)
Local $aCall = DllCall('user32.dll', 'bool', 'PtInRect', 'struct*', $tRECT, 'struct', $tPOINT)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PtInRegion($hRgn, $iX, $iY)
Local $aCall = DllCall('gdi32.dll', 'bool', 'PtInRegion', 'handle', $hRgn, 'int', $iX, 'int', $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PtVisible($hDC, $iX, $iY)
Local $aCall = DllCall('gdi32.dll', 'bool', 'PtVisible', 'handle', $hDC, 'int', $iX, 'int', $iY)
If @error Then Return SetError(@error + 10, @extended, 0)
If $aCall[0] = -1 Then Return SetError(10, $aCall[0], 0)
Return $aCall[0]
EndFunc
Func _WinAPI_RadialGradientFill($hDC, $iX, $iY, $iRadius, $iRGB1, $iRGB2, $fAngleStart = 0, $fAngleEnd = 360, $fStep = 5)
If Abs($fAngleStart) > 360 Then
$fAngleStart = Mod($fAngleStart, 360)
EndIf
If Abs($fAngleEnd) > 360 Then
$fAngleEnd = Mod($fAngleEnd, 360)
EndIf
If ($fAngleStart < 0) Or ($fAngleEnd < 0) Then
$fAngleStart += 360
$fAngleEnd += 360
EndIf
If $fAngleStart > $fAngleEnd Then
Local $fVal = $fAngleStart
$fAngleStart = $fAngleEnd
$fAngleEnd = $fVal
EndIf
If $fStep < 1 Then
$fStep = 1
EndIf
Local $fKi = ATan(1) / 45
Local $iXp = Round($iX + $iRadius * Cos($fKi * $fAngleStart))
Local $iYp = Round($iY + $iRadius * Sin($fKi * $fAngleStart))
Local $iXn, $iYn, $fAn = $fAngleStart
Local $aVertex[3][3]
While $fAn < $fAngleEnd
$fAn += $fStep
If $fAn > $fAngleEnd Then
$fAn = $fAngleEnd
EndIf
$iXn = Round($iX + $iRadius * Cos($fKi * $fAn))
$iYn = Round($iY + $iRadius * Sin($fKi * $fAn))
$aVertex[0][0] = $iX
$aVertex[0][1] = $iY
$aVertex[0][2] = $iRGB1
$aVertex[1][0] = $iXp
$aVertex[1][1] = $iYp
$aVertex[1][2] = $iRGB2
$aVertex[2][0] = $iXn
$aVertex[2][1] = $iYn
$aVertex[2][2] = $iRGB2
If Not _WinAPI_GradientFill($hDC, $aVertex, 0, 2) Then
Return SetError(@error, @extended, 0)
EndIf
$iXp = $iXn
$iYp = $iYn
WEnd
Return 1
EndFunc
Func _WinAPI_Rectangle($hDC, $tRECT)
Local $aCall = DllCall('gdi32.dll', 'bool', 'Rectangle', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_RectInRegion($hRgn, $tRECT)
Local $aCall = DllCall('gdi32.dll', 'bool', 'RectInRegion', 'handle', $hRgn, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_RectIsEmpty(ByRef $tRECT)
Return (DllStructGetData($tRECT, "Left") = 0) And (DllStructGetData($tRECT, "Top") = 0) And  (DllStructGetData($tRECT, "Right") = 0) And (DllStructGetData($tRECT, "Bottom") = 0)
EndFunc
Func _WinAPI_RectVisible($hDC, $tRECT)
Local $aCall = DllCall('gdi32.dll', 'bool', 'RectVisible', 'handle', $hDC, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Switch $aCall[0]
Case 0, 1, 2
Case Else
Return SetError(10, $aCall[0], 0)
EndSwitch
Return $aCall[0]
EndFunc
Func _WinAPI_RemoveFontMemResourceEx($hFont)
Local $aCall = DllCall('gdi32.dll', 'bool', 'RemoveFontMemResourceEx', 'handle', $hFont)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_RemoveFontResourceEx($sFont, $iFlag = 0, $bNotify = False)
Local $aCall = DllCall('gdi32.dll', 'bool', 'RemoveFontResourceExW', 'wstr', $sFont, 'dword', $iFlag, 'ptr', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, False)
If $bNotify Then
Local Const $WM_FONTCHANGE = 0x001D
Local Const $HWND_BROADCAST = 0xFFFF
DllCall('user32.dll', 'none', 'SendMessage', 'hwnd', $HWND_BROADCAST, 'uint', $WM_FONTCHANGE, 'wparam', 0, 'lparam', 0)
EndIf
Return $aCall[0]
EndFunc
Func _WinAPI_RGB($iRed, $iGreen, $iBlue)
Return __RGB(BitOR(BitShift($iBlue, -16), BitShift($iGreen, -8), $iRed))
EndFunc
Func _WinAPI_RotatePoints(ByRef $aPoint, $iXC, $iYC, $fAngle, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aPoint, $UBOUND_COLUMNS) < 2 Then Return SetError(13, 0, 0)
Local $fCos = Cos(ATan(1) / 45 * $fAngle)
Local $fSin = Sin(ATan(1) / 45 * $fAngle)
Local $iXn, $iYn
For $i = $iStart To $iEnd
$iXn = $aPoint[$i][0] - $iXC
$iYn = $aPoint[$i][1] - $iYC
$aPoint[$i][0] = $iXC + Round($iXn * $fCos - $iYn * $fSin)
$aPoint[$i][1] = $iYC + Round($iXn * $fSin + $iYn * $fCos)
Next
Return 1
EndFunc
Func _WinAPI_RoundRect($hDC, $tRECT, $iWidth, $iHeight)
Local $aCall = DllCall('gdi32.dll', 'bool', 'RoundRect', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3),  'int', DllStructGetData($tRECT, 4), 'int', $iWidth, 'int', $iHeight)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SaveHBITMAPToFile($sFilePath, $hBitmap, $iXPelsPerMeter = Default, $iYPelsPerMeter = Default)
Local $tBMP = DllStructCreate('align 1;ushort bfType;dword bfSize;ushort bfReserved1;ushort bfReserved2;dword bfOffset')
Local $tDIB = DllStructCreate($tagDIBSECTION)
Local $hDC, $hSv, $hSource = 0
While $hBitmap
If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), $tDIB)) Or (DllStructGetData($tDIB, 'biCompression')) Then
$hBitmap = 0
Else
Switch DllStructGetData($tDIB, 'bmBitsPixel')
Case 32
If Not _WinAPI_IsAlphaBitmap($hBitmap) Then
If Not $hSource Then
$hSource = _WinAPI_CreateDIB(DllStructGetData($tDIB, 'bmWidth'), DllStructGetData($tDIB, 'bmHeight'), 24)
If Not $hSource Then
$hBitmap = 0
EndIf
$hDC = _WinAPI_CreateCompatibleDC(0)
$hSv = _WinAPI_SelectObject($hDC, $hSource)
If _WinAPI_DrawBitmap($hDC, 0, 0, $hBitmap) Then
$hBitmap = $hSource
Else
$hBitmap = 0
EndIf
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
Else
$hBitmap = 0
EndIf
ContinueLoop
EndIf
Case Else
EndSwitch
If (Not DllStructGetData($tDIB, 'bmBits')) Or (Not DllStructGetData($tDIB, 'biSizeImage')) Then
If Not $hSource Then
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
$hSource = $hBitmap
Else
$hBitmap = 0
EndIf
Else
ExitLoop
EndIf
EndIf
WEnd
Local $hFile = 0, $iError = 0, $iResult = 0
Do
If Not $hBitmap Then
$iError = 1
ExitLoop
EndIf
Local $aData[4][2]
$aData[0][0] = DllStructGetPtr($tBMP)
$aData[0][1] = DllStructGetSize($tBMP)
$aData[1][0] = DllStructGetPtr($tDIB, 'biSize')
$aData[1][1] = 40
$aData[2][1] = DllStructGetData($tDIB, 'biClrUsed') * 4
Local $tTable = 0
If $aData[2][1] Then
$tTable = _WinAPI_GetDIBColorTable($hBitmap)
If @error Or (@extended <> $aData[2][1] / 4) Then
$iError = @error + 10
ExitLoop
EndIf
EndIf
$aData[2][0] = DllStructGetPtr($tTable)
$aData[3][0] = DllStructGetData($tDIB, 'bmBits')
$aData[3][1] = DllStructGetData($tDIB, 'biSizeImage')
DllStructSetData($tBMP, 'bfType', 0x4D42)
DllStructSetData($tBMP, 'bfSize', $aData[0][1] + $aData[1][1] + $aData[2][1] + $aData[3][1])
DllStructSetData($tBMP, 'bfReserved1', 0)
DllStructSetData($tBMP, 'bfReserved2', 0)
DllStructSetData($tBMP, 'bfOffset', $aData[0][1] + $aData[1][1] + $aData[2][1])
$hDC = _WinAPI_GetDC(0)
If $iXPelsPerMeter = Default Then
If Not DllStructGetData($tDIB, 'biXPelsPerMeter') Then
DllStructSetData($tDIB, 'biXPelsPerMeter', _WinAPI_GetDeviceCaps($hDC, 8) / _WinAPI_GetDeviceCaps($hDC, 4) * 1000)
EndIf
Else
DllStructSetData($tDIB, 'biXPelsPerMeter', $iXPelsPerMeter)
EndIf
If $iYPelsPerMeter = Default Then
If Not DllStructGetData($tDIB, 'biYPelsPerMeter') Then
DllStructSetData($tDIB, 'biYPelsPerMeter', _WinAPI_GetDeviceCaps($hDC, 10) / _WinAPI_GetDeviceCaps($hDC, 6) * 1000)
EndIf
Else
DllStructSetData($tDIB, 'biYPelsPerMeter', $iYPelsPerMeter)
EndIf
_WinAPI_ReleaseDC(0, $hDC)
$hFile = _WinAPI_CreateFile($sFilePath, 1, 4)
If @error Then
$iError = @error + 20
ExitLoop
EndIf
Local $iBytes
For $i = 0 To 3
If $aData[$i][1] Then
If Not _WinAPI_WriteFile($hFile, $aData[$i][0], $aData[$i][1], $iBytes) Then
$iError = @error + 30
ExitLoop 2
EndIf
EndIf
Next
$iResult = 1
Until 1
If $hSource Then
_WinAPI_DeleteObject($hSource)
EndIf
_WinAPI_CloseHandle($hFile)
If Not $iResult Then
FileDelete($sFilePath)
EndIf
Return SetError($iError, 0, $iResult)
EndFunc
Func _WinAPI_SaveHICONToFile($sFilePath, Const ByRef $vIcon, $bCompress = 0, $iStart = 0, $iEnd = -1)
Local $aIcon, $aTemp, $iCount = 1
If Not IsArray($vIcon) Then
Dim $aIcon[1] = [$vIcon]
Dim $aTemp[1] = [0]
Else
If __CheckErrorArrayBounds($vIcon, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$iCount = $iEnd - $iStart + 1
If $iCount Then
Dim $aIcon[$iCount]
Dim $aTemp[$iCount]
For $i = 0 To $iCount - 1
$aIcon[$i] = $vIcon[$iStart + $i]
$aTemp[$i] = 0
Next
EndIf
EndIf
Local $hFile = _WinAPI_CreateFile($sFilePath, 1, 4)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $tIco = DllStructCreate('align 1;ushort Reserved;ushort Type;ushort Count;byte Data[' & (16 * $iCount) & ']')
Local $iLength = DllStructGetSize($tIco)
Local $tBI = DllStructCreate($tagBITMAPINFOHEADER)
Local $tII = DllStructCreate($tagICONINFO)
Local $tDIB = DllStructCreate($tagDIBSECTION)
Local $iDIB = DllStructGetSize($tDIB)
Local $pDIB = DllStructGetPtr($tDIB)
Local $iOffset = $iLength
DllStructSetData($tBI, 'biSize', 40)
DllStructSetData($tBI, 'biPlanes', 1)
DllStructSetData($tBI, 'biXPelsPerMeter', 0)
DllStructSetData($tBI, 'biYPelsPerMeter', 0)
DllStructSetData($tBI, 'biClrUsed', 0)
DllStructSetData($tBI, 'biClrImportant', 0)
DllStructSetData($tIco, 'Reserved', 0)
DllStructSetData($tIco, 'Type', 1)
DllStructSetData($tIco, 'Count', $iCount)
Local $iResult = 0, $iError = 0, $iBytes
Local $aInfo[8], $aCall, $pData = 0, $iIndex = 0
Local $aSize[2], $tData = 0
Do
If Not _WinAPI_WriteFile($hFile, $tIco, $iLength, $iBytes) Then
$iError = @error + 30
ExitLoop
EndIf
While $iCount > $iIndex
$aCall = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $aIcon[$iIndex], 'struct*', $tII)
If @error Or Not $aCall[0] Then
$iError = @error + 40
ExitLoop 2
EndIf
For $i = 4 To 5
$aInfo[$i] = _WinAPI_CopyImage(DllStructGetData($tII, $i), 0, 0, 0, 0x2008)
If _WinAPI_GetObject($aInfo[$i], $iDIB, $pDIB) Then
$aInfo[$i - 4] = DllStructGetData($tDIB, 'biSizeImage')
$aInfo[$i - 2] = DllStructGetData($tDIB, 'bmBits')
Else
$iError = @error + 50
EndIf
Next
$aInfo[6] = 40
$aInfo[7] = DllStructGetData($tDIB, 'bmBitsPixel')
Switch $aInfo[7]
Case 16, 24
Case 32
If Not _WinAPI_IsAlphaBitmap($aInfo[5]) Then
If Not $aTemp[$iIndex] Then
$aIcon[$iIndex] = _WinAPI_Create32BitHICON($aIcon[$iIndex])
$aTemp[$iIndex] = $aIcon[$iIndex]
If Not @error Then
ContinueLoop
Else
ContinueCase
EndIf
EndIf
Else
If ($aInfo[1] >= 256 * 256 * 4) And ($bCompress) Then
$iBytes = _WinAPI_CompressBitmapBits($aInfo[5], $pData)
If Not @error Then
$aInfo[0] = 0
$aInfo[1] = $iBytes
$aInfo[2] = 0
$aInfo[3] = $pData
$aInfo[6] = 0
EndIf
EndIf
EndIf
Case Else
$iError = 60
EndSwitch
If Not $iError Then
$tData = DllStructCreate('byte Width;byte Height;byte ColorCount;byte Reserved;ushort Planes;ushort BitCount;long Size;long Offset', DllStructGetPtr($tIco) + 6 + 16 * $iIndex)
DllStructSetData($tData, 'ColorCount', 0)
DllStructSetData($tData, 'Reserved', 0)
DllStructSetData($tData, 'Planes', 1)
DllStructSetData($tData, 'BitCount', $aInfo[7])
DllStructSetData($tData, 'Size', $aInfo[0] + $aInfo[1] + $aInfo[6])
DllStructSetData($tData, 'Offset', $iOffset)
For $i = 0 To 1
$aSize[$i] = DllStructGetData($tDIB, $i + 2)
If $aSize[$i] < 256 Then
DllStructSetData($tData, $i + 1, $aSize[$i])
Else
DllStructSetData($tData, $i + 1, 0)
EndIf
Next
DllStructSetData($tBI, 'biWidth', $aSize[0])
DllStructSetData($tBI, 'biHeight', 2 * $aSize[1])
DllStructSetData($tBI, 'biBitCount', $aInfo[7])
DllStructSetData($tBI, 'biCompression', 0)
DllStructSetData($tBI, 'biSizeImage', $aInfo[0] + $aInfo[1])
$iOffset += $aInfo[0] + $aInfo[1] + $aInfo[6]
Do
If $aInfo[6] Then
If Not _WinAPI_WriteFile($hFile, $tBI, $aInfo[6], $iBytes) Then
$iError = @error + 70
ExitLoop
EndIf
For $i = 1 To 0 Step -1
If Not _WinAPI_WriteFile($hFile, $aInfo[$i + 2], $aInfo[$i], $iBytes) Then
$iError = @error + 80
ExitLoop 2
EndIf
Next
Else
If Not _WinAPI_WriteFile($hFile, $aInfo[3], $aInfo[1], $iBytes) Then
$iError = @error + 90
ExitLoop
EndIf
EndIf
Until 1
EndIf
For $i = 4 To 5
_WinAPI_DeleteObject($aInfo[$i])
Next
If $iError Then
ExitLoop 2
EndIf
$iIndex += 1
WEnd
$aCall = DllCall('kernel32.dll', 'bool', 'SetFilePointerEx', 'handle', $hFile, 'int64', 0, 'int64*', 0, 'dword', 0)
If @error Or Not $aCall[0] Then
$iError = @error + 100
ExitLoop
EndIf
If Not _WinAPI_WriteFile($hFile, $tIco, $iLength, $iBytes) Then
$iError = @error + 110
ExitLoop
EndIf
$iResult = 1
Until 1
For $i = 0 To $iCount - 1
If $aTemp[$i] Then
_WinAPI_DestroyIcon($aTemp[$i])
EndIf
Next
If $pData Then
__HeapFree($pData)
EndIf
_WinAPI_CloseHandle($hFile)
If Not $iResult Then
FileDelete($sFilePath)
EndIf
Return SetError($iError, 0, $iResult)
EndFunc
Func _WinAPI_ScaleWindowExt($hDC, $iXNum, $iXDenom, $iYNum, $iYDenom)
$__g_vExt = DllStructCreate($tagSIZE)
Local $aCall = DllCall('gdi32.dll', 'bool', 'ScaleWindowExtEx', 'handle', $hDC, 'int', $iXNum, 'int', $iXDenom, 'int', $iYNum,  'int', $iYDenom, 'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SelectClipPath($hDC, $iMode = 5)
Local $aCall = DllCall('gdi32.dll', 'bool', 'SelectClipPath', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SelectClipRgn($hDC, $hRgn)
Local $aCall = DllCall('gdi32.dll', 'int', 'SelectClipRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetArcDirection($hDC, $iDirection)
Local $aCall = DllCall('gdi32.dll', 'int', 'SetArcDirection', 'handle', $hDC, 'int', $iDirection)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetBitmapBits($hBitmap, $iSize, $pBits)
Local $aCall = DllCall('gdi32.dll', 'long', 'SetBitmapBits', 'handle', $hBitmap, 'dword', $iSize, 'struct*', $pBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetBitmapDimensionEx($hBitmap, $iWidth, $iHeight)
$__g_vExt = DllStructCreate($tagSIZE)
Local $aCall = DllCall('gdi32.dll', 'bool', 'SetBitmapDimensionEx', 'handle', $hBitmap, 'int', $iWidth, 'int', $iHeight,  'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetBoundsRect($hDC, $iFlags, $tRECT = 0)
Local $aCall = DllCall('gdi32.dll', 'uint', 'SetBoundsRect', 'handle', $hDC, 'struct*', $tRECT, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetBrushOrg($hDC, $iX, $iY)
$__g_vExt = DllStructCreate($tagPOINT)
Local $aCall = DllCall('gdi32.dll', 'bool', 'SetBrushOrgEx', 'handle', $hDC, 'int', $iX, 'int', $iY, 'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetColorAdjustment($hDC, $tAdjustment)
Local $aCall = DllCall('gdi32.dll', 'bool', 'SetColorAdjustment', 'handle', $hDC, 'struct*', $tAdjustment)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetDCBrushColor($hDC, $iRGB)
Local $aCall = DllCall('gdi32.dll', 'dword', 'SetDCBrushColor', 'handle', $hDC, 'dword', __RGB($iRGB))
If @error Or ($aCall[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aCall[0])
EndFunc
Func _WinAPI_SetDCPenColor($hDC, $iRGB)
Local $aCall = DllCall('gdi32.dll', 'dword', 'SetDCPenColor', 'handle', $hDC, 'dword', __RGB($iRGB))
If @error Or ($aCall[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aCall[0])
EndFunc
Func _WinAPI_SetDeviceGammaRamp($hDC, Const ByRef $aRamp)
If (UBound($aRamp, $UBOUND_DIMENSIONS) <> 2) Or (UBound($aRamp, $UBOUND_ROWS) <> 256) Or (UBound($aRamp, $UBOUND_COLUMNS) <> 3) Then
Return SetError(12, 0, 0)
EndIf
Local $tData = DllStructCreate('ushort[256];ushort[256];ushort[256]')
For $i = 0 To 2
For $j = 0 To 255
DllStructSetData($tData, $i + 1, $aRamp[$j][$i], $j + 1)
Next
Next
Local $aCall = DllCall('gdi32.dll', 'bool', 'SetDeviceGammaRamp', 'handle', $hDC, 'struct*', $tData)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetDIBColorTable($hBitmap, $tColorTable, $iColorCount)
If $iColorCount > DllStructGetSize($tColorTable) / 4 Then Return SetError(1, 0, 0)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hBitmap)
Local $iError = 0
Local $aCall = DllCall('gdi32.dll', 'uint', 'SetDIBColorTable', 'handle', $hDC, 'uint', 0, 'uint', $iColorCount, 'struct*', $tColorTable)
If @error Then $iError = @error
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
If $iError Then Return SetError($iError, 0, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetDIBits($hDC, $hBitmap, $iStartScan, $iScanLines, $pBits, $tBMI, $iColorUse = 0)
Local $aCall = DllCall("gdi32.dll", "int", "SetDIBits", "handle", $hDC, "handle", $hBitmap, "uint", $iStartScan,  "uint", $iScanLines, "struct*", $pBits, "struct*", $tBMI, "INT", $iColorUse)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetDIBitsToDevice($hDC, $iXDest, $iYDest, $iWidth, $iHeight, $iXSrc, $iYSrc, $iStartScan, $iScanLines, $tBITMAPINFO, $iUsage, $pBits)
Local $aCall = DllCall('gdi32.dll', 'int', 'SetDIBitsToDevice', 'handle', $hDC, 'int', $iXDest, 'int', $iYDest,  'dword', $iWidth, 'dword', $iHeight, 'int', $iXSrc, 'int', $iYSrc, 'uint', $iStartScan,  'uint', $iScanLines, 'struct*', $pBits, 'struct*', $tBITMAPINFO, 'uint', $iUsage)
If @error Or ($aCall[0] = -1) Then Return SetError(@error + 10, $aCall[0], 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetEnhMetaFileBits($pData, $iLength)
Local $aCall = DllCall('gdi32.dll', 'handle', 'SetEnhMetaFileBits', 'uint', $iLength, 'struct*', $pData)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetGraphicsMode($hDC, $iMode)
Local $aCall = DllCall('gdi32.dll', 'int', 'SetGraphicsMode', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetMapMode($hDC, $iMode)
Local $aCall = DllCall('gdi32.dll', 'int', 'SetMapMode', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetPixel($hDC, $iX, $iY, $iRGB)
Local $aCall = DllCall('gdi32.dll', 'bool', 'SetPixelV', 'handle', $hDC, 'int', $iX, 'int', $iY, 'dword', __RGB($iRGB))
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetPolyFillMode($hDC, $iMode = 1)
Local $aCall = DllCall('gdi32.dll', 'int', 'SetPolyFillMode', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetRectRgn($hRgn, $tRECT)
Local $aCall = DllCall('gdi32.dll', 'bool', 'SetRectRgn', 'handle', $hRgn, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetROP2($hDC, $iMode)
Local $aCall = DllCall('gdi32.dll', 'int', 'SetROP2', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetStretchBltMode($hDC, $iMode)
Local $aCall = DllCall('gdi32.dll', 'int', 'SetStretchBltMode', 'handle', $hDC, 'int', $iMode)
If @error Or Not $aCall[0] Or ($aCall[0] = 87) Then Return SetError(@error + 10, $aCall[0], 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetTextAlign($hDC, $iMode = 0)
Local $aCall = DllCall('gdi32.dll', 'uint', 'SetTextAlign', 'handle', $hDC, 'uint', $iMode)
If @error Or ($aCall[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_SetTextCharacterExtra($hDC, $iCharExtra)
Local $aCall = DllCall('gdi32.dll', 'int', 'SetTextCharacterExtra', 'handle', $hDC, 'int', $iCharExtra)
If @error Or ($aCall[0] = 0x80000000) Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_SetTextJustification($hDC, $iBreakExtra, $iBreakCount)
Local $aCall = DllCall('gdi32.dll', 'bool', 'SetTextJustification', 'handle', $hDC, 'int', $iBreakExtra, 'int', $iBreakCount)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetUDFColorMode($iMode)
$__g_iRGBMode = Not ($iMode = 0)
EndFunc
Func _WinAPI_SetWindowExt($hDC, $iXExtent, $iYExtent)
$__g_vExt = DllStructCreate($tagSIZE)
Local $aCall = DllCall('gdi32.dll', 'bool', 'SetWindowExtEx', 'handle', $hDC, 'int', $iXExtent, 'int', $iYExtent,  'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetWindowOrg($hDC, $iX, $iY)
$__g_vExt = DllStructCreate($tagPOINT)
Local $aCall = DllCall('gdi32.dll', 'bool', 'SetWindowOrgEx', 'handle', $hDC, 'int', $iX, 'int', $iY, 'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetWorldTransform($hDC, ByRef $tXFORM)
Local $aCall = DllCall('gdi32.dll', 'bool', 'SetWorldTransform', 'handle', $hDC, 'struct*', $tXFORM)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_StretchBlt($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRop)
Local $aCall = DllCall('gdi32.dll', 'bool', 'StretchBlt', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest, 'int', $iWidthDest,  'int', $iHeightDest, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', $iRop)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_StretchDIBits($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $tBITMAPINFO, $iUsage, $pBits, $iRop)
Local $aCall = DllCall('gdi32.dll', 'int', 'StretchDIBits', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidthDest, 'int', $iHeightDest, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'struct*', $pBits, 'struct*', $tBITMAPINFO, 'uint', $iUsage,  'dword', $iRop)
If @error Or ($aCall[0] = -1) Then Return SetError(@error + 10, $aCall[0], 0)
Return $aCall[0]
EndFunc
Func _WinAPI_StrokeAndFillPath($hDC)
Local $aCall = DllCall('gdi32.dll', 'bool', 'StrokeAndFillPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_StrokePath($hDC)
Local $aCall = DllCall('gdi32.dll', 'bool', 'StrokePath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SubtractRect(ByRef $tRECT1, ByRef $tRECT2)
Local $tRECT = DllStructCreate($tagRECT)
Local $aCall = DllCall('user32.dll', 'bool', 'SubtractRect', 'struct*', $tRECT, 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_TabbedTextOut($hDC, $iX, $iY, $sText, $aTab = 0, $iStart = 0, $iEnd = -1, $iOrigin = 0)
Local $iTab, $iCount
If Not IsArray($aTab) Then
If $aTab Then
$iTab = $aTab
Dim $aTab[1] = [$iTab]
$iStart = 0
$iEnd = 0
$iCount = 1
Else
$iCount = 0
EndIf
Else
$iCount = 1
EndIf
Local $tTab = 0
If $iCount Then
If __CheckErrorArrayBounds($aTab, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$iCount = $iEnd - $iStart + 1
$tTab = DllStructCreate('uint[' & $iCount & ']')
$iTab = 1
For $i = $iStart To $iEnd
DllStructSetData($tTab, 1, $aTab[$i], $iTab)
$iTab += 1
Next
EndIf
Local $aCall = DllCall('user32.dll', 'long', 'TabbedTextOutW', 'handle', $hDC, 'int', $iX, 'int', $iY, 'wstr', $sText,  'int', StringLen($sText), 'int', $iCount, 'struct*', $tTab, 'int', $iOrigin)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
$__g_vExt = _WinAPI_CreateSize(_WinAPI_LoWord($aCall[0]), _WinAPI_HiWord($aCall[0]))
Return 1
EndFunc
Func _WinAPI_TextOut($hDC, $iX, $iY, $sText)
Local $aCall = DllCall('gdi32.dll', 'bool', 'TextOutW', 'handle', $hDC, 'int', $iX, 'int', $iY, 'wstr', $sText,  'int', StringLen($sText))
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_TransparentBlt($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRGB)
Local $aCall = DllCall('gdi32.dll', 'bool', 'GdiTransparentBlt', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidthDest, 'int', $iHeightDest, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', __RGB($iRGB))
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_UnionRect(ByRef $tRECT1, ByRef $tRECT2)
Local $tRECT = DllStructCreate($tagRECT)
Local $aCall = DllCall('user32.dll', 'bool', 'UnionRect', 'struct*', $tRECT, 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, 0, 0)
Return $tRECT
EndFunc
Func _WinAPI_ValidateRect($hWnd, $tRECT = 0)
Local $aCall = DllCall('user32.dll', 'bool', 'ValidateRect', 'hwnd', $hWnd, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ValidateRgn($hWnd, $hRgn = 0)
Local $aCall = DllCall('user32.dll', 'bool', 'ValidateRgn', 'hwnd', $hWnd, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_WidenPath($hDC)
Local $aCall = DllCall('gdi32.dll', 'bool', 'WidenPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_WindowFromDC($hDC)
Local $aCall = DllCall('user32.dll', 'hwnd', 'WindowFromDC', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func __EnumDisplayMonitorsProc($hMonitor, $hDC, $pRECT, $lParam)
#forceref $hDC, $lParam
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = $hMonitor
If Not $pRECT Then
$__g_vEnum[$__g_vEnum[0][0]][1] = 0
Else
$__g_vEnum[$__g_vEnum[0][0]][1] = DllStructCreate($tagRECT)
If Not _WinAPI_MoveMemory(DllStructGetPtr($__g_vEnum[$__g_vEnum[0][0]][1]), $pRECT, 16) Then Return 0
EndIf
Return 1
EndFunc
Func __EnumFontFamiliesProc($pELFEX, $pNTMEX, $iFontType, $pPattern)
Local $tELFEX = DllStructCreate($tagLOGFONT & ';wchar FullName[64];wchar Style[32];wchar Script[32]', $pELFEX)
Local $tNTMEX = DllStructCreate($tagNEWTEXTMETRICEX, $pNTMEX)
Local $tPattern = DllStructCreate('uint;uint;ptr', $pPattern)
If $iFontType And Not BitAND($iFontType, DllStructGetData($tPattern, 1)) Then
Return 1
EndIf
If DllStructGetData($tPattern, 3) Then
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathMatchSpecW', 'ptr', DllStructGetPtr($tELFEX, 14), 'ptr', DllStructGetData($tPattern, 3))
If Not @error Then
If DllStructGetData($tPattern, 2) Then
If $aCall[0] Then
Return 1
Else
EndIf
Else
If $aCall[0] Then
Else
Return 1
EndIf
EndIf
EndIf
EndIf
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData($tELFEX, 14)
$__g_vEnum[$__g_vEnum[0][0]][1] = DllStructGetData($tELFEX, 16)
$__g_vEnum[$__g_vEnum[0][0]][2] = DllStructGetData($tELFEX, 15)
$__g_vEnum[$__g_vEnum[0][0]][3] = DllStructGetData($tELFEX, 17)
$__g_vEnum[$__g_vEnum[0][0]][4] = $iFontType
$__g_vEnum[$__g_vEnum[0][0]][5] = DllStructGetData($tNTMEX, 19)
$__g_vEnum[$__g_vEnum[0][0]][6] = DllStructGetData($tNTMEX, 20)
$__g_vEnum[$__g_vEnum[0][0]][7] = DllStructGetData($tNTMEX, 21)
Return 1
EndFunc
Func __EnumFontStylesProc($pELFEX, $pNTMEX, $iFontType, $pFN)
#forceref $iFontType
Local $tELFEX = DllStructCreate($tagLOGFONT & ';wchar FullName[64];wchar Style[32];wchar Script[32]', $pELFEX)
Local $tNTMEX = DllStructCreate($tagNEWTEXTMETRICEX, $pNTMEX)
Local $tFN = DllStructCreate('dword;wchar[64]', $pFN)
If BitAND(DllStructGetData($tNTMEX, 'ntmFlags'), 0x0061) = DllStructGetData($tFN, 1) Then
DllStructSetData($tFN, 2, DllStructGetData($tELFEX, 'FullName'))
Return 0
Else
Return 1
EndIf
EndFunc
Global Const $LINGUISTIC_IGNORECASE = 0x00000010
Global Const $LINGUISTIC_IGNOREDIACRITIC = 0x00000020
Global Const $NORM_IGNORECASE = 0x00000001
Global Const $NORM_IGNOREKANATYPE = 0x00010000
Global Const $NORM_IGNORENONSPACE = 0x00000002
Global Const $NORM_IGNORESYMBOLS = 0x00000004
Global Const $NORM_IGNOREWIDTH = 0x00020000
Global Const $NORM_LINGUISTIC_CASING = 0x08000000
Global Const $SORT_DIGITSASNUMBERS = 0x00000008
Global Const $SORT_STRINGSORT = 0x00001000
Global Const $CSTR_LESS_THAN = 1
Global Const $CSTR_EQUAL = 2
Global Const $CSTR_GREATER_THAN = 3
Global Const $MUI_LANGUAGE_ID = 0x0004
Global Const $MUI_LANGUAGE_NAME = 0x0008
Global Const $DATE_AUTOLAYOUT = 0x40
Global Const $DATE_LONGDATE = 0x02
Global Const $DATE_LTRREADING = 0x10
Global Const $DATE_SHORTDATE = 0x01
Global Const $DATE_RTLREADING = 0x20
Global Const $DATE_USE_ALT_CALENDAR = 0x04
Global Const $DATE_YEARMONTH = 0x08
Global Const $GEO_NATION = 1
Global Const $GEO_LATITUDE = 2
Global Const $GEO_LONGITUDE = 3
Global Const $GEO_ISO2 = 4
Global Const $GEO_ISO3 = 5
Global Const $GEO_RFC1766 = 6
Global Const $GEO_LCID = 7
Global Const $GEO_FRIENDLYNAME = 8
Global Const $GEO_OFFICIALNAME = 9
Global Const $GEO_TIMEZONES = 10
Global Const $GEO_OFFICIALLANGUAGES = 11
Global Const $GEO_ISO_UN_NUMBER = 12
Global Const $GEO_PARENT = 13
Global Const $LOCALE_ILANGUAGE = 0x0001
Global Const $LOCALE_SLANGUAGE = 0x0002
Global Const $LOCALE_SENGLANGUAGE = 0x1001
Global Const $LOCALE_SABBREVLANGNAME = 0x0003
Global Const $LOCALE_SNATIVELANGNAME = 0x0004
Global Const $LOCALE_ICOUNTRY = 0x0005
Global Const $LOCALE_SCOUNTRY = 0x0006
Global Const $LOCALE_SENGCOUNTRY = 0x1002
Global Const $LOCALE_SABBREVCTRYNAME = 0x0007
Global Const $LOCALE_SNATIVECTRYNAME = 0x0008
Global Const $LOCALE_IDEFAULTLANGUAGE = 0x0009
Global Const $LOCALE_IDEFAULTCOUNTRY = 0x000A
Global Const $LOCALE_IDEFAULTCODEPAGE = 0x000B
Global Const $LOCALE_IDEFAULTANSICODEPAGE = 0x1004
Global Const $LOCALE_IDEFAULTMACCODEPAGE = 0x1011
Global Const $LOCALE_SLIST = 0x000C
Global Const $LOCALE_IMEASURE = 0x000D
Global Const $LOCALE_SDECIMAL = 0x000E
Global Const $LOCALE_STHOUSAND = 0x000F
Global Const $LOCALE_SGROUPING = 0x0010
Global Const $LOCALE_IDIGITS = 0x0011
Global Const $LOCALE_ILZERO = 0x0012
Global Const $LOCALE_INEGNUMBER = 0x1010
Global Const $LOCALE_SNATIVEDIGITS = 0x0013
Global Const $LOCALE_SCURRENCY = 0x0014
Global Const $LOCALE_SINTLSYMBOL = 0x0015
Global Const $LOCALE_SMONDECIMALSEP = 0x0016
Global Const $LOCALE_SMONTHOUSANDSEP = 0x0017
Global Const $LOCALE_SMONGROUPING = 0x0018
Global Const $LOCALE_ICURRDIGITS = 0x0019
Global Const $LOCALE_IINTLCURRDIGITS = 0x001A
Global Const $LOCALE_ICURRENCY = 0x001B
Global Const $LOCALE_INEGCURR = 0x001C
Global Const $LOCALE_SDATE = 0x001D
Global Const $LOCALE_STIME = 0x001E
Global Const $LOCALE_SSHORTDATE = 0x001F
Global Const $LOCALE_SLONGDATE = 0x0020
Global Const $LOCALE_STIMEFORMAT = 0x1003
Global Const $LOCALE_IDATE = 0x0021
Global Const $LOCALE_ILDATE = 0x0022
Global Const $LOCALE_ITIME = 0x0023
Global Const $LOCALE_ITIMEMARKPOSN = 0x1005
Global Const $LOCALE_ICENTURY = 0x0024
Global Const $LOCALE_ITLZERO = 0x0025
Global Const $LOCALE_IDAYLZERO = 0x0026
Global Const $LOCALE_IMONLZERO = 0x0027
Global Const $LOCALE_S1159 = 0x0028
Global Const $LOCALE_S2359 = 0x0029
Global Const $LOCALE_ICALENDARTYPE = 0x1009
Global Const $LOCALE_IOPTIONALCALENDAR = 0x100B
Global Const $LOCALE_IFIRSTDAYOFWEEK = 0x100C
Global Const $LOCALE_IFIRSTWEEKOFYEAR = 0x100D
Global Const $LOCALE_SDAYNAME1 = 0x002A
Global Const $LOCALE_SDAYNAME2 = 0x002B
Global Const $LOCALE_SDAYNAME3 = 0x002C
Global Const $LOCALE_SDAYNAME4 = 0x002D
Global Const $LOCALE_SDAYNAME5 = 0x002E
Global Const $LOCALE_SDAYNAME6 = 0x002F
Global Const $LOCALE_SDAYNAME7 = 0x0030
Global Const $LOCALE_SABBREVDAYNAME1 = 0x0031
Global Const $LOCALE_SABBREVDAYNAME2 = 0x0032
Global Const $LOCALE_SABBREVDAYNAME3 = 0x0033
Global Const $LOCALE_SABBREVDAYNAME4 = 0x0034
Global Const $LOCALE_SABBREVDAYNAME5 = 0x0035
Global Const $LOCALE_SABBREVDAYNAME6 = 0x0036
Global Const $LOCALE_SABBREVDAYNAME7 = 0x0037
Global Const $LOCALE_SMONTHNAME1 = 0x0038
Global Const $LOCALE_SMONTHNAME2 = 0x0039
Global Const $LOCALE_SMONTHNAME3 = 0x003A
Global Const $LOCALE_SMONTHNAME4 = 0x003B
Global Const $LOCALE_SMONTHNAME5 = 0x003C
Global Const $LOCALE_SMONTHNAME6 = 0x003D
Global Const $LOCALE_SMONTHNAME7 = 0x003E
Global Const $LOCALE_SMONTHNAME8 = 0x003F
Global Const $LOCALE_SMONTHNAME9 = 0x0040
Global Const $LOCALE_SMONTHNAME10 = 0x0041
Global Const $LOCALE_SMONTHNAME11 = 0x0042
Global Const $LOCALE_SMONTHNAME12 = 0x0043
Global Const $LOCALE_SMONTHNAME13 = 0x100E
Global Const $LOCALE_SABBREVMONTHNAME1 = 0x0044
Global Const $LOCALE_SABBREVMONTHNAME2 = 0x0045
Global Const $LOCALE_SABBREVMONTHNAME3 = 0x0046
Global Const $LOCALE_SABBREVMONTHNAME4 = 0x0047
Global Const $LOCALE_SABBREVMONTHNAME5 = 0x0048
Global Const $LOCALE_SABBREVMONTHNAME6 = 0x0049
Global Const $LOCALE_SABBREVMONTHNAME7 = 0x004A
Global Const $LOCALE_SABBREVMONTHNAME8 = 0x004B
Global Const $LOCALE_SABBREVMONTHNAME9 = 0x004C
Global Const $LOCALE_SABBREVMONTHNAME10 = 0x004D
Global Const $LOCALE_SABBREVMONTHNAME11 = 0x004E
Global Const $LOCALE_SABBREVMONTHNAME12 = 0x004F
Global Const $LOCALE_SABBREVMONTHNAME13 = 0x100F
Global Const $LOCALE_SPOSITIVESIGN = 0x0050
Global Const $LOCALE_SNEGATIVESIGN = 0x0051
Global Const $LOCALE_IPOSSIGNPOSN = 0x0052
Global Const $LOCALE_INEGSIGNPOSN = 0x0053
Global Const $LOCALE_IPOSSYMPRECEDES = 0x0054
Global Const $LOCALE_IPOSSEPBYSPACE = 0x0055
Global Const $LOCALE_INEGSYMPRECEDES = 0x0056
Global Const $LOCALE_INEGSEPBYSPACE = 0x0057
Global Const $LOCALE_FONTSIGNATURE = 0x0058
Global Const $LOCALE_SISO639LANGNAME = 0x0059
Global Const $LOCALE_SISO3166CTRYNAME = 0x005A
Global Const $LOCALE_IDEFAULTEBCDICCODEPAGE = 0x1012
Global Const $LOCALE_IPAPERSIZE = 0x100A
Global Const $LOCALE_SENGCURRNAME = 0x1007
Global Const $LOCALE_SNATIVECURRNAME = 0x1008
Global Const $LOCALE_SYEARMONTH = 0x1006
Global Const $LOCALE_SSORTNAME = 0x1013
Global Const $LOCALE_IDIGITSUBSTITUTION = 0x1014
Global Const $LOCALE_CUSTOM_DEFAULT = 0x0C00
Global Const $LOCALE_CUSTOM_UI_DEFAULT = 0x1400
Global Const $LOCALE_CUSTOM_UNSPECIFIED = 0x1000
Global Const $LOCALE_INVARIANT = 0x007F
Global Const $LOCALE_SYSTEM_DEFAULT = 0x0800
Global Const $LOCALE_USER_DEFAULT = 0x0400
Global Const $TIME_FORCE24HOURFORMAT = 0x08
Global Const $TIME_NOMINUTESORSECONDS = 0x01
Global Const $TIME_NOSECONDS = 0x02
Global Const $TIME_NOTIMEMARKER = 0x04
Global Const $LCID_INSTALLED = 1
Global Const $LCID_SUPPORTED = 2
Global Const $RT_ACCELERATOR = 9
Global Const $RT_ANICURSOR = 21
Global Const $RT_ANIICON = 22
Global Const $RT_BITMAP = 2
Global Const $RT_CURSOR = 1
Global Const $RT_DIALOG = 5
Global Const $RT_DLGINCLUDE = 17
Global Const $RT_FONT = 8
Global Const $RT_FONTDIR = 7
Global Const $RT_GROUP_CURSOR = 12
Global Const $RT_GROUP_ICON = 14
Global Const $RT_HTML = 23
Global Const $RT_ICON = 3
Global Const $RT_MANIFEST = 24
Global Const $RT_MENU = 4
Global Const $RT_MESSAGETABLE = 11
Global Const $RT_PLUGPLAY = 19
Global Const $RT_RCDATA = 10
Global Const $RT_STRING = 6
Global Const $RT_VERSION = 16
Global Const $RT_VXD = 20
Global Const $FILE_VER_GET_LOCALISED = 0x01
Global Const $FILE_VER_GET_NEUTRAL = 0x02
Global Const $FILE_VER_GET_PREFETCHED = 0x04
Global Const $OBM_TRTYPE = 32732
Global Const $OBM_LFARROWI = 32734
Global Const $OBM_RGARROWI = 32735
Global Const $OBM_DNARROWI = 32736
Global Const $OBM_UPARROWI = 32737
Global Const $OBM_COMBO = 32738
Global Const $OBM_MNARROW = 32739
Global Const $OBM_LFARROWD = 32740
Global Const $OBM_RGARROWD = 32741
Global Const $OBM_DNARROWD = 32742
Global Const $OBM_UPARROWD = 32743
Global Const $OBM_RESTORED = 32744
Global Const $OBM_ZOOMD = 32745
Global Const $OBM_REDUCED = 32746
Global Const $OBM_RESTORE = 32747
Global Const $OBM_ZOOM = 32748
Global Const $OBM_REDUCE = 32749
Global Const $OBM_LFARROW = 32750
Global Const $OBM_RGARROW = 32751
Global Const $OBM_DNARROW = 32752
Global Const $OBM_UPARROW = 32753
Global Const $OBM_CLOSE = 32754
Global Const $OBM_OLD_RESTORE = 32755
Global Const $OBM_OLD_ZOOM = 32756
Global Const $OBM_OLD_REDUCE = 32757
Global Const $OBM_BTNCORNERS = 32758
Global Const $OBM_CHECKBOXES = 32759
Global Const $OBM_CHECK = 32760
Global Const $OBM_BTSIZE = 32761
Global Const $OBM_OLD_LFARROW = 32762
Global Const $OBM_OLD_RGARROW = 32763
Global Const $OBM_OLD_DNARROW = 32764
Global Const $OBM_OLD_UPARROW = 32765
Global Const $OBM_SIZE = 32766
Global Const $OBM_OLD_CLOSE = 32767
Global Const $OIC_SAMPLE = 32512
Global Const $OIC_HAND = 32513
Global Const $OIC_QUES = 32514
Global Const $OIC_BANG = 32515
Global Const $OIC_NOTE = 32516
Global Const $OIC_WINLOGO = 32517
Global Const $OIC_WARNING = $OIC_BANG
Global Const $OIC_ERROR = $OIC_HAND
Global Const $OIC_INFORMATION = $OIC_NOTE
Global Const $DONT_RESOLVE_DLL_REFERENCES = 0x01
Global Const $LOAD_LIBRARY_AS_DATAFILE = 0x02
Global Const $LOAD_WITH_ALTERED_SEARCH_PATH = 0x08
Global Const $LOAD_IGNORE_CODE_AUTHZ_LEVEL = 0x00000010
Global Const $LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 0x00000040
Global Const $LOAD_LIBRARY_AS_IMAGE_RESOURCE = 0x00000020
Global Const $LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 0x00000200
Global Const $LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 0x00001000
Global Const $LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 0x00000100
Global Const $LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
Global Const $LOAD_LIBRARY_SEARCH_USER_DIRS = 0x00000400
Global Const $OCR_NORMAL = 32512
Global Const $OCR_IBEAM = 32513
Global Const $OCR_WAIT = 32514
Global Const $OCR_CROSS = 32515
Global Const $OCR_UP = 32516
Global Const $OCR_SIZE = 32640
Global Const $OCR_ICON = 32641
Global Const $OCR_SIZENWSE = 32642
Global Const $OCR_SIZENESW = 32643
Global Const $OCR_SIZEWE = 32644
Global Const $OCR_SIZENS = 32645
Global Const $OCR_SIZEALL = 32646
Global Const $OCR_ICOCUR = 32647
Global Const $OCR_NO = 32648
Global Const $OCR_HAND = 32649
Global Const $OCR_APPSTARTING = 32650
Global Const $OCR_HELP = 32651
Global Const $VS_FF_DEBUG = 0x00000001
Global Const $VS_FF_INFOINFERRED = 0x00000010
Global Const $VS_FF_PATCHED = 0x00000004
Global Const $VS_FF_PRERELEASE = 0x00000002
Global Const $VS_FF_PRIVATEBUILD = 0x00000008
Global Const $VS_FF_SPECIALBUILD = 0x00000020
Global Const $VOS_DOS = 0x00010000
Global Const $VOS_NT = 0x00040000
Global Const $VOS__WINDOWS16 = 0x00000001
Global Const $VOS__WINDOWS32 = 0x00000004
Global Const $VOS_OS216 = 0x00020000
Global Const $VOS_OS232 = 0x00030000
Global Const $VOS__PM16 = 0x00000002
Global Const $VOS__PM32 = 0x00000003
Global Const $VOS_UNKNOWN = 0x00000000
Global Const $VOS_DOS_WINDOWS16 = 0x00010001
Global Const $VOS_DOS_WINDOWS32 = 0x00010004
Global Const $VOS_NT_WINDOWS32 = 0x00040004
Global Const $VOS_OS216_PM16 = 0x00020002
Global Const $VOS_OS232_PM32 = 0x00030003
Global Const $VFT_APP = 0x00000001
Global Const $VFT_DLL = 0x00000002
Global Const $VFT_DRV = 0x00000003
Global Const $VFT_FONT = 0x00000004
Global Const $VFT_STATIC_LIB = 0x00000007
Global Const $VFT_UNKNOWN = 0x00000000
Global Const $VFT_VXD = 0x00000005
Global Const $VFT2_DRV_COMM = 0x0000000A
Global Const $VFT2_DRV_DISPLAY = 0x00000004
Global Const $VFT2_DRV_INSTALLABLE = 0x00000008
Global Const $VFT2_DRV_KEYBOARD = 0x00000002
Global Const $VFT2_DRV_LANGUAGE = 0x00000003
Global Const $VFT2_DRV_MOUSE = 0x00000005
Global Const $VFT2_DRV_NETWORK = 0x00000006
Global Const $VFT2_DRV_PRINTER = 0x00000001
Global Const $VFT2_DRV_SOUND = 0x00000009
Global Const $VFT2_DRV_SYSTEM = 0x00000007
Global Const $VFT2_DRV_VERSIONED_PRINTER = 0x0000000C
Global Const $VFT2_UNKNOWN = 0x00000000
Global Const $VFT2_FONT_RASTER = 0x00000001
Global Const $VFT2_FONT_TRUETYPE = 0x00000003
Global Const $VFT2_FONT_VECTOR = 0x00000002
Global $__g_vVal
Global Const $tagVS_FIXEDFILEINFO = 'dword Signature;dword StrucVersion;dword FileVersionMS;dword FileVersionLS;dword ProductVersionMS;dword ProductVersionLS;dword FileFlagsMask;dword FileFlags;dword FileOS;dword FileType;dword FileSubtype;dword FileDateMS;dword FileDateLS'
Func _WinAPI_BeginUpdateResource($sFilePath, $bDelete = False)
Local $aCall = DllCall('kernel32.dll', 'handle', 'BeginUpdateResourceW', 'wstr', $sFilePath, 'bool', $bDelete)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ClipCursor($tRECT)
Local $aCall = DllCall('user32.dll', 'bool', 'ClipCursor', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_CopyCursor($hCursor)
Return _WinAPI_CopyIcon($hCursor)
EndFunc
Func _WinAPI_CreateCaret($hWnd, $hBitmap, $iWidth = 0, $iHeight = 0)
Local $aCall = DllCall('user32.dll', 'bool', 'CreateCaret', 'hwnd', $hWnd, 'handle', $hBitmap, 'int', $iWidth, 'int', $iHeight)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DestroyCaret()
Local $aCall = DllCall('user32.dll', 'bool', 'DestroyCaret')
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_DestroyCursor($hCursor)
Local $aCall = DllCall('user32.dll', 'bool', 'DestroyCursor', 'handle', $hCursor)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_EndUpdateResource($hUpdate, $bDiscard = False)
Local $aCall = DllCall('kernel32.dll', 'bool', 'EndUpdateResourceW', 'handle', $hUpdate, 'bool', $bDiscard)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_EnumResourceLanguages($hModule, $sType, $sName)
Local $iLibrary = 0, $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, BitOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
If Not $hModule Then Return SetError(1, 0, 0)
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Dim $__g_vEnum[101] = [0]
Local $hEnumProc = DllCallbackRegister('__EnumResLanguagesProc', 'bool', 'handle;ptr;ptr;word;long_ptr')
Local $aCall = DllCall('kernel32.dll', 'bool', 'EnumResourceLanguagesW', 'handle', $hModule, $sTypeOfType, $sType,  $sTypeOfName, $sName, 'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
If @error Or Not $aCall[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumResourceNames($hModule, $sType)
Local $aCall, $hEnumProc, $iLibrary = 0, $sTypeOfType = 'int'
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, BitOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
If Not $hModule Then Return SetError(1, 0, 0)
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
Dim $__g_vEnum[101] = [0]
$hEnumProc = DllCallbackRegister('__EnumResNamesProc', 'bool', 'handle;ptr;ptr;long_ptr')
$aCall = DllCall('kernel32.dll', 'bool', 'EnumResourceNamesW', 'handle', $hModule, $sTypeOfType, $sType,  'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
If @error Or Not $aCall[0] Or (Not $__g_vEnum[0]) Then
$__g_vEnum = @error + 10
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumResourceTypes($hModule)
Local $iLibrary = 0
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, BitOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
If Not $hModule Then Return SetError(1, 0, 0)
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
Dim $__g_vEnum[101] = [0]
Local $hEnumProc = DllCallbackRegister('__EnumResTypesProc', 'bool', 'handle;ptr;long_ptr')
Local $aCall = DllCall('kernel32.dll', 'bool', 'EnumResourceTypesW', 'handle', $hModule,  'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
If @error Or Not $aCall[0] Or (Not $__g_vEnum[0]) Then
$__g_vEnum = @error + 10
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_FindResource($hInstance, $sType, $sName)
Local $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aCall = DllCall('kernel32.dll', 'handle', 'FindResourceW', 'handle', $hInstance, $sTypeOfName, $sName, $sTypeOfType, $sType)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_FindResourceEx($hInstance, $sType, $sName, $iLanguage)
Local $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aCall = DllCall('kernel32.dll', 'handle', 'FindResourceExW', 'handle', $hInstance, $sTypeOfType, $sType,  $sTypeOfName, $sName, 'ushort', $iLanguage)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_FreeResource($hData)
Local $aCall = DllCall('kernel32.dll', 'bool', 'FreeResource', 'handle', $hData)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_GetCaretBlinkTime()
Local $aCall = DllCall('user32.dll', 'uint', 'GetCaretBlinkTime')
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetCaretPos()
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aCall = DllCall('user32.dll', 'bool', 'GetCaretPos', 'struct*', $tPOINT)
If @error Then Return SetError(@error, @extended, 0)
If Not $aCall[0] Then Return SetError(10, _WinAPI_GetLastError(), 0)
Local $aRet[2]
For $i = 0 To 1
$aRet[$i] = DllStructGetData($tPOINT, $i + 1)
Next
Return $aRet
EndFunc
Func _WinAPI_GetClipCursor()
Local $tRECT = DllStructCreate($tagRECT)
Local $aCall = DllCall('user32.dll', 'bool', 'GetClipCursor', 'struct*', $tRECT)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetCursor()
Local $aCall = DllCall('user32.dll', 'handle', 'GetCursor')
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetFileVersionInfo($sFilePath, ByRef $pBuffer, $iFlags = 0)
Local $aCall
If _WinAPI_GetVersion() >= 6.0 Then
$aCall = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeExW', 'dword', BitAND($iFlags, 0x03), 'wstr', $sFilePath,  'ptr', 0)
Else
$aCall = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeW', 'wstr', $sFilePath, 'ptr', 0)
EndIf
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
$pBuffer = __HeapReAlloc($pBuffer, $aCall[0], 1)
If @error Then Return SetError(@error + 100, @extended, 0)
Local $iNbByte = $aCall[0]
If _WinAPI_GetVersion() >= 6.0 Then
$aCall = DllCall('version.dll', 'bool', 'GetFileVersionInfoExW', 'dword', BitAND($iFlags, 0x07), 'wstr', $sFilePath,  'dword', 0, 'dword', $iNbByte, 'ptr', $pBuffer)
Else
$aCall = DllCall('version.dll', 'bool', 'GetFileVersionInfoW', 'wstr', $sFilePath,  'dword', 0, 'dword', $iNbByte, 'ptr', $pBuffer)
EndIf
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $iNbByte
EndFunc
Func _WinAPI_HideCaret($hWnd)
Local $aCall = DllCall('user32.dll', 'int', 'HideCaret', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_LoadBitmap($hInstance, $sBitmap)
Local $sBitmapType = "int"
If IsString($sBitmap) Then $sBitmapType = "wstr"
Local $aCall = DllCall("user32.dll", "handle", "LoadBitmapW", "handle", $hInstance, $sBitmapType, $sBitmap)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_LoadCursor($hInstance, $sName)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aCall = DllCall('user32.dll', 'handle', 'LoadCursorW', 'handle', $hInstance, $sTypeOfName, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_LoadCursorFromFile($sFilePath)
Local $aCall = DllCall('user32.dll', 'handle', 'LoadCursorFromFileW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_LoadIndirectString($sStrIn)
Local $aCall = DllCall('shlwapi.dll', 'uint', 'SHLoadIndirectString', 'wstr', $sStrIn, 'wstr', '', 'uint', 4096, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
Return $aCall[2]
EndFunc
Func _WinAPI_LoadString($hInstance, $iStringID)
Local $aCall = DllCall("user32.dll", "int", "LoadStringW", "handle", $hInstance, "uint", $iStringID, "wstr", "", "int", 4096)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, "")
Return SetExtended($aCall[0], $aCall[3])
EndFunc
Func _WinAPI_LoadLibraryEx($sFileName, $iFlags = 0)
Local $aCall = DllCall("kernel32.dll", "handle", "LoadLibraryExW", "wstr", $sFileName, "ptr", 0, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_LoadResource($hInstance, $hResource)
Local $aCall = DllCall('kernel32.dll', 'handle', 'LoadResource', 'handle', $hInstance, 'handle', $hResource)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_LoadStringEx($hModule, $iID, $iLanguage = $LOCALE_USER_DEFAULT)
Local $iLibrary = 0
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, BitOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
If Not $hModule Then Return SetError(@error + 20, @extended, '')
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
Local $sResult = ''
Local $pData = __ResLoad($hModule, 6, Floor($iID / 16) + 1, $iLanguage)
If Not @error Then
Local $iOffset = 0
For $i = 0 To Mod($iID, 16) - 1
$iOffset += 2 * (DllStructGetData(DllStructCreate('ushort', $pData + $iOffset), 1) + 1)
Next
$sResult = DllStructGetData(DllStructCreate('ushort;wchar[' & DllStructGetData(DllStructCreate('ushort', $pData + $iOffset), 1) & ']', $pData + $iOffset), 2)
If @error Then $sResult = ''
Else
Return SetError(10, 0, '')
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
Return SetError(Number(Not $sResult), 0, $sResult)
EndFunc
Func _WinAPI_LockResource($hData)
Local $aCall = DllCall('kernel32.dll', 'ptr', 'LockResource', 'handle', $hData)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetCaretBlinkTime($iDuration)
Local $iPrev = _WinAPI_GetCaretBlinkTime()
If Not $iPrev Then Return SetError(@error + 20, @extended, 0)
Local $aCall = DllCall('user32.dll', 'bool', 'SetCaretBlinkTime', 'uint', $iDuration)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $iPrev
EndFunc
Func _WinAPI_SetCaretPos($iX, $iY)
Local $aCall = DllCall('user32.dll', 'int', 'SetCaretPos', 'int', $iX, 'int', $iY)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetCursor($hCursor)
Local $aCall = DllCall("user32.dll", "handle", "SetCursor", "handle", $hCursor)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetSystemCursor($hCursor, $iID, $bCopy = False)
If $bCopy Then
$hCursor = _WinAPI_CopyCursor($hCursor)
EndIf
Local $aCall = DllCall('user32.dll', 'bool', 'SetSystemCursor', 'handle', $hCursor, 'dword', $iID)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ShowCaret($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'ShowCaret', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ShowCursor($bShow)
Local $aCall = DllCall("user32.dll", "int", "ShowCursor", "bool", $bShow)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SizeOfResource($hInstance, $hResource)
Local $aCall = DllCall('kernel32.dll', 'dword', 'SizeofResource', 'handle', $hInstance, 'handle', $hResource)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_UpdateResource($hUpdate, $sType, $sName, $iLanguage, $pData, $iSize)
Local $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aCall = DllCall('kernel32.dll', 'bool', 'UpdateResourceW', 'handle', $hUpdate, $sTypeOfType, $sType, $sTypeOfName, $sName,  'word', $iLanguage, 'ptr', $pData, 'dword', $iSize)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_VerQueryRoot($pData)
Local $aCall = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\', 'ptr*', 0, 'uint*', 0)
If @error Or Not $aCall[0] Or Not $aCall[4] Then Return SetError(@error + 10, @extended, 0)
Local $tVFFI = DllStructCreate($tagVS_FIXEDFILEINFO)
If Not _WinAPI_MoveMemory($tVFFI, $aCall[3], $aCall[4]) Then Return SetError(@error + 20, @extended, 0)
Return $tVFFI
EndFunc
Func _WinAPI_VerQueryValue($pData, $sValues = '')
$sValues = StringRegExpReplace($sValues, '\A[\s\|]*|[\s\|]*\Z', '')
If Not $sValues Then
$sValues = 'Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild'
EndIf
$sValues = StringSplit($sValues, '|', $STR_NOCOUNT)
Local $aCall = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\VarFileInfo\Translation', 'ptr*', 0,  'uint*', 0)
If @error Or Not $aCall[0] Or Not $aCall[4] Then Return SetError(@error + 10, 0, 0)
Local $iLength = Floor($aCall[4] / 4)
Local $tLang = DllStructCreate('dword[' & $iLength & ']', $aCall[3])
If @error Then Return SetError(@error + 20, 0, 0)
Local $sCP, $aInfo[101][UBound($sValues) + 1] = [[0]]
For $i = 1 To $iLength
__Inc($aInfo)
$aInfo[$aInfo[0][0]][0] = _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))
$sCP = Hex(_WinAPI_MakeLong(_WinAPI_HiWord(DllStructGetData($tLang, 1, $i)), _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))), 8)
For $j = 0 To UBound($sValues) - 1
$aCall = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\StringFileInfo\' & $sCP & '\' & $sValues[$j],  'ptr*', 0, 'uint*', 0)
If Not @error And $aCall[0] And $aCall[4] Then
$aInfo[$aInfo[0][0]][$j + 1] = DllStructGetData(DllStructCreate('wchar[' & $aCall[4] & ']', $aCall[3]), 1)
Else
$aInfo[$aInfo[0][0]][$j + 1] = ''
EndIf
Next
Next
__Inc($aInfo, -1)
Return $aInfo
EndFunc
Func _WinAPI_VerQueryValueEx($hModule, $sValues = '', $iLanguage = 0x0400)
$__g_vVal = StringRegExpReplace($sValues, '\A[\s\|]*|[\s\|]*\Z', '')
If Not $__g_vVal Then
$__g_vVal = 'Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild'
EndIf
$__g_vVal = StringSplit($__g_vVal, '|')
If Not IsArray($__g_vVal) Then Return SetError(1, 0, 0)
Local $iLibrary = 0
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, BitOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
If Not $hModule Then
Return SetError(@error + 10, @extended, 0)
EndIf
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
Dim $__g_vEnum[101][$__g_vVal[0] + 1] = [[0]]
Local $hEnumProc = DllCallbackRegister('__EnumVerValuesProc', 'bool', 'ptr;ptr;ptr;word;long_ptr')
Local $aCall = DllCall('kernel32.dll', 'bool', 'EnumResourceLanguagesW', 'handle', $hModule, 'int', 16, 'int', 1,  'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', $iLanguage)
Do
If @error Then
$__g_vEnum = @error + 20
Else
If Not $aCall[0] Then
Switch _WinAPI_GetLastError()
Case 0, 15106
ExitLoop
Case Else
$__g_vEnum = 20
EndSwitch
Else
ExitLoop
EndIf
EndIf
Until 1
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If Not $__g_vEnum[0][0] Then $__g_vEnum = 230
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func __EnumResLanguagesProc($hModule, $iType, $iName, $iLanguage, $lParam)
#forceref $hModule, $iType, $iName, $lParam
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0]] = $iLanguage
Return 1
EndFunc
Func __EnumResNamesProc($hModule, $iType, $iName, $lParam)
#forceref $hModule, $iType, $lParam
Local $iLength = _WinAPI_StrLen($iName)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' & ($iLength + 1) & ']', $iName), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = Number($iName)
EndIf
Return 1
EndFunc
Func __EnumResTypesProc($hModule, $iType, $lParam)
#forceref $hModule, $lParam
Local $iLength = _WinAPI_StrLen($iType)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' & ($iLength + 1) & ']', $iType), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = Number($iType)
EndIf
Return 1
EndFunc
Func __EnumVerValuesProc($hModule, $iType, $iName, $iLanguage, $iDefault)
Local $aCall, $iEnum = 1, $iError = 0
Switch $iDefault
Case -1
Case 0x0400
$iLanguage = 0x0400
$iEnum = 0
Case Else
If $iLanguage <> $iDefault Then
Return 1
EndIf
$iEnum = 0
EndSwitch
Do
Local $pData = __ResLoad($hModule, $iType, $iName, $iLanguage)
If @error Then
$iError = @error + 10
ExitLoop
EndIf
$aCall = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\VarFileInfo\Translation', 'ptr*', 0, 'uint*', 0)
If @error Or Not $aCall[0] Or Not $aCall[4] Then
$iError = @error + 20
ExitLoop
EndIf
Local $tData = DllStructCreate('ushort;ushort', $aCall[3])
If @error Then
$iError = @error + 30
ExitLoop
EndIf
Until 1
If Not $iError Then
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData($tData, 1)
Local $sCP = Hex(_WinAPI_MakeLong(DllStructGetData($tData, 2), DllStructGetData($tData, 1)), 8)
For $i = 1 To $__g_vVal[0]
$aCall = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\StringFileInfo\' & $sCP & '\' & $__g_vVal[$i],  'ptr*', 0, 'uint*', 0)
If Not @error And $aCall[0] And $aCall[4] Then
$__g_vEnum[$__g_vEnum[0][0]][$i] = DllStructGetData(DllStructCreate('wchar[' & $aCall[4] & ']', $aCall[3]), 1)
Else
$__g_vEnum[$__g_vEnum[0][0]][$i] = ''
EndIf
Next
Else
$__g_vEnum = @error + 40
EndIf
If $__g_vEnum Then Return SetError($iError, 0, 0)
Return $iEnum
EndFunc
Func __ResLoad($hInstance, $sType, $sName, $iLanguage)
Local $hInfo = _WinAPI_FindResourceEx($hInstance, $sType, $sName, $iLanguage)
If Not $hInfo Then Return SetError(@error + 10, @extended, 0)
Local $iSize = _WinAPI_SizeOfResource($hInstance, $hInfo)
If Not $iSize Then Return SetError(@error + 20, @extended, 0)
Local $hData = _WinAPI_LoadResource($hInstance, $hInfo)
If Not $hData Then Return SetError(@error + 30, @extended, 0)
Local $pData = _WinAPI_LockResource($hData)
If Not $pData Then Return SetError(@error + 40, @extended, 0)
Return SetExtended($iSize, $pData)
EndFunc
Global Const $__LISTVIEWCONSTANT_SORTINFOSIZE = 11
Global $__g_aListViewSortInfo[1][$__LISTVIEWCONSTANT_SORTINFOSIZE]
Global $__g_tListViewBuffer, $__g_tListViewBufferANSI
Global $__g_tListViewItem = DllStructCreate($tagLVITEM)
Global Const $__LISTVIEWCONSTANT_ClassName = "SysListView32"
Global Const $__LISTVIEWCONSTANT_WM_SETREDRAW = 0x000B
Global Const $__LISTVIEWCONSTANT_WM_SETFONT = 0x0030
Global Const $__LISTVIEWCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__LISTVIEWCONSTANT_ILD_TRANSPARENT = 0x00000001
Global Const $__LISTVIEWCONSTANT_ILD_BLEND25 = 0x00000002
Global Const $__LISTVIEWCONSTANT_ILD_BLEND50 = 0x00000004
Global Const $__LISTVIEWCONSTANT_ILD_MASK = 0x00000010
Global Const $__LISTVIEWCONSTANT_VK_DOWN = 0x28
Global Const $__LISTVIEWCONSTANT_VK_END = 0x23
Global Const $__LISTVIEWCONSTANT_VK_HOME = 0x24
Global Const $__LISTVIEWCONSTANT_VK_LEFT = 0x25
Global Const $__LISTVIEWCONSTANT_VK_NEXT = 0x22
Global Const $__LISTVIEWCONSTANT_VK_PRIOR = 0x21
Global Const $__LISTVIEWCONSTANT_VK_RIGHT = 0x27
Global Const $__LISTVIEWCONSTANT_VK_UP = 0x26
Global Const $tagLVBKIMAGE = "ulong Flags;hwnd hBmp;ptr Image;uint ImageMax;int XOffPercent;int YOffPercent"
Global Const $tagLVCOLUMN = "uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal"
Global Const $tagLVGROUP = "uint Size;uint Mask;ptr Header;int HeaderMax;ptr Footer;int FooterMax;int GroupID;uint StateMask;uint State;uint Align;" &  "ptr  pszSubtitle;uint cchSubtitle;ptr pszTask;uint cchTask;ptr pszDescriptionTop;uint cchDescriptionTop;ptr pszDescriptionBottom;" &  "uint cchDescriptionBottom;int iTitleImage;int iExtendedImage;int iFirstItem;uint cItems;ptr pszSubsetTitle;uint cchSubsetTitle"
Global Const $tagLVINSERTMARK = "uint Size;dword Flags;int Item;dword Reserved"
Global Const $tagLVSETINFOTIP = "uint Size;dword Flags;ptr Text;int Item;int SubItem"
Func _GUICtrlListView_AddArray($hWnd, ByRef $aItems)
Local $tBuffer, $iMsg, $iMsgSet
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tListViewBuffer
$iMsg = $LVM_INSERTITEMW
$iMsgSet = $LVM_SETITEMW
Else
$tBuffer = $__g_tListViewBufferANSI
$iMsg = $LVM_INSERTITEMA
$iMsgSet = $LVM_SETITEMA
EndIf
Local $tItem = $__g_tListViewItem
DllStructSetData($tItem, "Mask", $LVIF_TEXT)
Local $iLastItem = _GUICtrlListView_GetItemCount($hWnd)
_GUICtrlListView_BeginUpdate($hWnd)
Local $pSendMsg = __GUICtrl_SendMsg_Init($hWnd, $iMsg, 0, $tItem, $tBuffer, False, 6)
For $iI = 0 To UBound($aItems) - 1
DllStructSetData($tItem, "Item", $iI + $iLastItem)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tBuffer, 1, $aItems[$iI][0])
$pSendMsg($hWnd, $iMsg, 0, $tItem, $tBuffer, False, 6)
For $iJ = 1 To UBound($aItems, $UBOUND_COLUMNS) - 1
DllStructSetData($tItem, "SubItem", $iJ)
DllStructSetData($tBuffer, 1, $aItems[$iI][$iJ])
$pSendMsg($hWnd, $iMsgSet, 0, $tItem, $tBuffer, False, 6)
Next
Next
_GUICtrlListView_EndUpdate($hWnd)
EndFunc
Func _GUICtrlListView_AddColumn($hWnd, $sText, $iWidth = 50, $iAlign = -1, $iImage = -1, $bOnRight = False)
Return _GUICtrlListView_InsertColumn($hWnd, _GUICtrlListView_GetColumnCount($hWnd), $sText, $iWidth, $iAlign, $iImage, $bOnRight)
EndFunc
Func _GUICtrlListView_AddItem($hWnd, $sText, $iImage = -1, $iParam = 0)
Return _GUICtrlListView_InsertItem($hWnd, $sText, -1, $iImage, $iParam)
EndFunc
Func _GUICtrlListView_AddSubItem($hWnd, $iIndex, $sText, $iSubItem, $iImage = -1)
Local $tBuffer, $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tListViewBuffer
$iMsg = $LVM_SETITEMW
Else
$tBuffer = $__g_tListViewBufferANSI
$iMsg = $LVM_SETITEMA
EndIf
Local $tItem = $__g_tListViewItem
Local $iMask = $LVIF_TEXT
If $iImage <> -1 Then $iMask = BitOR($iMask, $LVIF_IMAGE)
DllStructSetData($tBuffer, 1, $sText)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "Image", $iImage)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, 0, $tItem, $tBuffer, False, 6, False, -1)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_ApproximateViewHeight($hWnd, $iCount = -1, $iCX = -1, $iCY = -1)
If IsHWnd($hWnd) Then
Return BitShift((_SendMessage($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 16)
Else
Return BitShift((GUICtrlSendMsg($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 16)
EndIf
EndFunc
Func _GUICtrlListView_ApproximateViewRect($hWnd, $iCount = -1, $iCX = -1, $iCY = -1)
Local $iView
If IsHWnd($hWnd) Then
$iView = _SendMessage($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))
Else
$iView = GUICtrlSendMsg($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))
EndIf
Local $aView[2]
$aView[0] = BitAND($iView, 0xFFFF)
$aView[1] = BitShift($iView, 16)
Return $aView
EndFunc
Func _GUICtrlListView_ApproximateViewWidth($hWnd, $iCount = -1, $iCX = -1, $iCY = -1)
If IsHWnd($hWnd) Then
Return BitAND((_SendMessage($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 0xFFFF)
Else
Return BitAND((GUICtrlSendMsg($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 0xFFFF)
EndIf
EndFunc
Func _GUICtrlListView_Arrange($hWnd, $iArrange = 0)
Local $aArrange[4] = [$LVA_DEFAULT, $LVA_ALIGNLEFT, $LVA_ALIGNTOP, $LVA_SNAPTOGRID]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ARRANGE, $aArrange[$iArrange]) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_ARRANGE, $aArrange[$iArrange], 0) <> 0
EndIf
EndFunc
Func __GUICtrlListView_ArrayDelete(ByRef $avArray, $iElement)
If Not IsArray($avArray) Then Return SetError(1, 0, "")
Local $iUpper = UBound($avArray)
If $iUpper = 1 Then
SetError(2)
Return ""
EndIf
Local $avNewArray[$iUpper - 1][$__LISTVIEWCONSTANT_SORTINFOSIZE]
$avNewArray[0][0] = $avArray[0][0]
If $iElement < 0 Then
$iElement = 0
EndIf
If $iElement > ($iUpper - 1) Then
$iElement = ($iUpper - 1)
EndIf
If $iElement > 0 Then
For $iCntr = 0 To $iElement - 1
For $x = 1 To $__LISTVIEWCONSTANT_SORTINFOSIZE - 1
$avNewArray[$iCntr][$x] = $avArray[$iCntr][$x]
Next
Next
EndIf
If $iElement < ($iUpper - 1) Then
For $iCntr = ($iElement + 1) To ($iUpper - 1)
For $x = 1 To $__LISTVIEWCONSTANT_SORTINFOSIZE - 1
$avNewArray[$iCntr - 1][$x] = $avArray[$iCntr][$x]
Next
Next
EndIf
$avArray = $avNewArray
SetError(0)
Return 1
EndFunc
Func _GUICtrlListView_BeginUpdate($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $__LISTVIEWCONSTANT_WM_SETREDRAW, False) = 0
Else
Return GUICtrlSendMsg($hWnd, $__LISTVIEWCONSTANT_WM_SETREDRAW, False, 0) = 0
EndIf
EndFunc
Func _GUICtrlListView_CancelEditLabel($hWnd)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LVM_CANCELEDITLABEL)
Else
GUICtrlSendMsg($hWnd, $LVM_CANCELEDITLABEL, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_ClickItem($hWnd, $iIndex, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 1)
_GUICtrlListView_EnsureVisible($hWnd, $iIndex, False)
Local $tRECT = _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $LVIR_LABEL)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tPoint = _WinAPI_PointFromRect($tRECT, True)
$tPoint = _WinAPI_ClientToScreen($hWnd, $tPoint)
Local $iX, $iY
_WinAPI_GetXYFromPoint($tPoint, $iX, $iY)
Local $iXPlus = DllStructGetData($tRECT, "Left") < 0 ? DllStructGetData($tRECT, "Left") * -1 : 0
Local $iMode = Opt("MouseCoordMode", 1)
If Not $bMove Then
Local $aPos = MouseGetPos()
_WinAPI_ShowCursor(False)
MouseClick($sButton, $iX + $iXPlus, $iY, $iClicks, $iSpeed)
MouseMove($aPos[0], $aPos[1], 0)
_WinAPI_ShowCursor(True)
Else
MouseClick($sButton, $iX + $iXPlus, $iY, $iClicks, $iSpeed)
EndIf
Opt("MouseCoordMode", $iMode)
EndFunc
Func _GUICtrlListView_CopyItems($hWnd_Source, $hWnd_Destination, $bDelFlag = False)
Local $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd_Source) Then
$iMsg = $LVM_GETITEMW
Else
$iMsg = $LVM_GETITEMA
EndIf
Local $tItem = $__g_tListViewItem
Local $a_Indices, $iIndex
Local $iCols = _GUICtrlListView_GetColumnCount($hWnd_Source)
Local $iItems = _GUICtrlListView_GetItemCount($hWnd_Source)
_GUICtrlListView_BeginUpdate($hWnd_Source)
_GUICtrlListView_BeginUpdate($hWnd_Destination)
If BitAND(_GUICtrlListView_GetExtendedListViewStyle($hWnd_Source), $LVS_EX_CHECKBOXES) == $LVS_EX_CHECKBOXES Then
For $i = 0 To $iItems - 1
If (_GUICtrlListView_GetItemChecked($hWnd_Source, $i)) Then
If IsArray($a_Indices) Then
ReDim $a_Indices[UBound($a_Indices) + 1]
Else
Local $a_Indices[2]
EndIf
$a_Indices[0] = $a_Indices[0] + 1
$a_Indices[UBound($a_Indices) - 1] = $i
EndIf
Next
If (IsArray($a_Indices)) Then
For $i = 1 To $a_Indices[0]
DllStructSetData($tItem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "StateMask", -1)
__GUICtrl_SendMsg($hWnd_Source, $iMsg, 0, $tItem, 0, True, -1)
$iIndex = _GUICtrlListView_AddItem($hWnd_Destination, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], 0), DllStructGetData($tItem, "Image"))
_GUICtrlListView_SetItemChecked($hWnd_Destination, $iIndex)
For $x = 1 To $iCols - 1
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", $x)
__GUICtrl_SendMsg($hWnd_Source, $iMsg, 0, $tItem, 0, True, -1)
_GUICtrlListView_AddSubItem($hWnd_Destination, $iIndex, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], $x), $x, DllStructGetData($tItem, "Image"))
Next
Next
If $bDelFlag Then
For $i = $a_Indices[0] To 1 Step -1
_GUICtrlListView_DeleteItem($hWnd_Source, $a_Indices[$i])
Next
EndIf
EndIf
EndIf
If (_GUICtrlListView_GetSelectedCount($hWnd_Source)) Then
$a_Indices = _GUICtrlListView_GetSelectedIndices($hWnd_Source, 1)
For $i = 1 To $a_Indices[0]
DllStructSetData($tItem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "StateMask", -1)
__GUICtrl_SendMsg($hWnd_Source, $iMsg, 0, $tItem, 0, True, -1)
$iIndex = _GUICtrlListView_AddItem($hWnd_Destination, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], 0), DllStructGetData($tItem, "Image"))
For $x = 1 To $iCols - 1
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", $x)
__GUICtrl_SendMsg($hWnd_Source, $iMsg, 0, $tItem, 0, True, -1)
_GUICtrlListView_AddSubItem($hWnd_Destination, $iIndex, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], $x), $x, DllStructGetData($tItem, "Image"))
Next
Next
_GUICtrlListView_SetItemSelected($hWnd_Source, -1, False)
If $bDelFlag Then
For $i = $a_Indices[0] To 1 Step -1
_GUICtrlListView_DeleteItem($hWnd_Source, $a_Indices[$i])
Next
EndIf
EndIf
_GUICtrlListView_EndUpdate($hWnd_Source)
_GUICtrlListView_EndUpdate($hWnd_Destination)
EndFunc
Func _GUICtrlListView_Create($hWnd, $sHeaderText, $iX, $iY, $iWidth = 150, $iHeight = 150, $iStyle = 0x0000000D, $iExStyle = 0x00000000, $bCoInit = False)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sHeaderText) Then Return SetError(2, 0, 0)
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = $LVS_DEFAULT
If $iExStyle = -1 Then $iExStyle = 0x00000000
Local Const $S_OK = 0x0
Local Const $S_FALSE = 0x1
Local Const $RPC_E_CHANGED_MODE = 0x80010106
Local Const $E_INVALIDARG = 0x80070057
Local Const $E_OUTOFMEMORY = 0x8007000E
Local Const $E_UNEXPECTED = 0x8000FFFF
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
Local Const $COINIT_APARTMENTTHREADED = 0x02
Local $iStr_len = StringLen($sHeaderText)
If $iStr_len Then $sHeaderText = StringSplit($sHeaderText, $sSeparatorChar)
$iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $iStyle)
If $bCoInit Then
Local $aCall = DllCall('ole32.dll', 'long', 'CoInitializeEx', 'ptr', 0, 'dword', $COINIT_APARTMENTTHREADED)
If @error Then Return SetError(@error, @extended, 0)
Switch $aCall[0]
Case $S_OK
Case $S_FALSE
Case $RPC_E_CHANGED_MODE
Case $E_INVALIDARG
Case $E_OUTOFMEMORY
Case $E_UNEXPECTED
EndSwitch
EndIf
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hList = _WinAPI_CreateWindowEx($iExStyle, $__LISTVIEWCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_SendMessage($hList, $__LISTVIEWCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($__LISTVIEWCONSTANT_DEFAULT_GUI_FONT), True)
If $iStr_len Then
For $x = 1 To $sHeaderText[0]
_GUICtrlListView_InsertColumn($hList, $x - 1, $sHeaderText[$x], 75)
Next
EndIf
Return $hList
EndFunc
Func _GUICtrlListView_CreateDragImage($hWnd, $iIndex)
Local $aDrag[3]
Local $tPoint = DllStructCreate($tagPOINT)
$aDrag[0] = Ptr(__GUICtrl_SendMsg($hWnd, $LVM_CREATEDRAGIMAGE, $iIndex, $tPoint, 0, True, -1))
$aDrag[1] = DllStructGetData($tPoint, "X")
$aDrag[2] = DllStructGetData($tPoint, "Y")
Return $aDrag
EndFunc
Func _GUICtrlListView_CreateSolidBitMap($hWnd, $iColor, $iWidth, $iHeight)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _WinAPI_CreateSolidBitmap($hWnd, $iColor, $iWidth, $iHeight)
EndFunc
Func _GUICtrlListView_DeleteAllItems($hWnd)
If _GUICtrlListView_GetItemCount($hWnd) = 0 Then Return True
Local $vCID = 0
If IsHWnd($hWnd) Then
$vCID = _WinAPI_GetDlgCtrlID($hWnd)
Else
$vCID = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
If $vCID < $_UDF_STARTID Then
Local $iParam = 0
For $iIndex = _GUICtrlListView_GetItemCount($hWnd) - 1 To 0 Step -1
$iParam = _GUICtrlListView_GetItemParam($hWnd, $iIndex)
If GUICtrlGetState($iParam) > 0 And GUICtrlGetHandle($iParam) = 0 Then
GUICtrlDelete($iParam)
EndIf
Next
If _GUICtrlListView_GetItemCount($hWnd) = 0 Then Return True
EndIf
Return _SendMessage($hWnd, $LVM_DELETEALLITEMS) <> 0
EndFunc
Func _GUICtrlListView_DeleteColumn($hWnd, $iCol)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_DELETECOLUMN, $iCol) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_DELETECOLUMN, $iCol, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_DeleteItem($hWnd, $iIndex)
Local $vCID = 0
If IsHWnd($hWnd) Then
$vCID = _WinAPI_GetDlgCtrlID($hWnd)
Else
$vCID = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
If $vCID < $_UDF_STARTID Then
Local $iParam = _GUICtrlListView_GetItemParam($hWnd, $iIndex)
If GUICtrlGetState($iParam) > 0 And GUICtrlGetHandle($iParam) = 0 Then
If GUICtrlDelete($iParam) Then
Return True
EndIf
EndIf
EndIf
Return _SendMessage($hWnd, $LVM_DELETEITEM, $iIndex) <> 0
EndFunc
Func _GUICtrlListView_DeleteItemsSelected($hWnd)
Local $iItemCount = _GUICtrlListView_GetItemCount($hWnd)
If _GUICtrlListView_GetSelectedCount($hWnd) = $iItemCount Then
Return _GUICtrlListView_DeleteAllItems($hWnd)
Else
Local $aSelected = _GUICtrlListView_GetSelectedIndices($hWnd, True)
If Not IsArray($aSelected) Then Return SetError($LV_ERR, $LV_ERR, 0)
_GUICtrlListView_SetItemSelected($hWnd, -1, False)
Local $vCID = 0, $iNative_Delete, $iUDF_Delete
If IsHWnd($hWnd) Then
$vCID = _WinAPI_GetDlgCtrlID($hWnd)
Else
$vCID = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
For $iIndex = $aSelected[0] To 1 Step -1
If $vCID < $_UDF_STARTID Then
Local $iParam = _GUICtrlListView_GetItemParam($hWnd, $aSelected[$iIndex])
If GUICtrlGetState($iParam) > 0 And GUICtrlGetHandle($iParam) = 0 Then
$iNative_Delete = GUICtrlDelete($iParam)
If $iNative_Delete Then ContinueLoop
EndIf
EndIf
$iUDF_Delete = _SendMessage($hWnd, $LVM_DELETEITEM, $aSelected[$iIndex])
If $iNative_Delete + $iUDF_Delete = 0 Then
ExitLoop
EndIf
Next
Return Not $iIndex
EndIf
EndFunc
Func _GUICtrlListView_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__LISTVIEWCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hGUICtrl_LastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func __GUICtrlListView_Draw($hWnd, $iIndex, $hDC, $iX, $iY, $iStyle = 0)
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_MASK)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_Draw", "handle", $hWnd, "int", $iIndex, "handle", $hDC, "int", $iX, "int", $iY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUICtrlListView_DrawDragImage(ByRef $hWnd, ByRef $aDrag)
Local $hDC = _WinAPI_GetWindowDC($hWnd)
Local $tPoint = _WinAPI_GetMousePos(True, $hWnd)
_WinAPI_InvalidateRect($hWnd)
__GUICtrlListView_Draw($aDrag[0], 0, $hDC, DllStructGetData($tPoint, "X"), DllStructGetData($tPoint, "Y"))
_WinAPI_ReleaseDC($hWnd, $hDC)
EndFunc
Func _GUICtrlListView_EditLabel($hWnd, $iIndex)
Local $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$iMsg = $LVM_EDITLABELW
Else
$iMsg = $LVM_EDITLABEL
EndIf
Local $aCall
If IsHWnd($hWnd) Then
$aCall = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] = 0 Then Return 0
Return _SendMessage($hWnd, $iMsg, $iIndex, 0, 0, "wparam", "lparam", "hwnd")
Else
$aCall = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", GUICtrlGetHandle($hWnd))
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] = 0 Then Return 0
Return Ptr(GUICtrlSendMsg($hWnd, $iMsg, $iIndex, 0))
EndIf
EndFunc
Func _GUICtrlListView_EnableGroupView($hWnd, $bEnable = True)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ENABLEGROUPVIEW, $bEnable)
Else
Return GUICtrlSendMsg($hWnd, $LVM_ENABLEGROUPVIEW, $bEnable, 0)
EndIf
EndFunc
Func _GUICtrlListView_EndUpdate($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $__LISTVIEWCONSTANT_WM_SETREDRAW, True) = 0
Else
Return GUICtrlSendMsg($hWnd, $__LISTVIEWCONSTANT_WM_SETREDRAW, True, 0) = 0
EndIf
EndFunc
Func _GUICtrlListView_EnsureVisible($hWnd, $iIndex, $bPartialOK = False)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ENSUREVISIBLE, $iIndex, $bPartialOK)
Else
Return GUICtrlSendMsg($hWnd, $LVM_ENSUREVISIBLE, $iIndex, $bPartialOK)
EndIf
EndFunc
Func _GUICtrlListView_FindInText($hWnd, $sText, $iStart = -1, $bWrapOK = True, $bReverse = False)
Local $iCount = _GUICtrlListView_GetItemCount($hWnd)
Local $iColumns = _GUICtrlListView_GetColumnCount($hWnd)
If $iColumns = 0 Then $iColumns = 1
If $bReverse And $iStart = -1 Then Return -1
Local $sList
If $bReverse Then
For $iI = $iStart - 1 To 0 Step -1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
Else
For $iI = $iStart + 1 To $iCount - 1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
EndIf
If (($iStart = -1) Or Not $bWrapOK) And Not $bReverse Then Return -1
If $bReverse And $bWrapOK Then
For $iI = $iCount - 1 To $iStart + 1 Step -1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
Else
For $iI = 0 To $iStart - 1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
EndIf
Return -1
EndFunc
Func _GUICtrlListView_FindItem($hWnd, $iStart, ByRef $tFindInfo, $sText = "")
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
DllStructSetData($tBuffer, 1, $sText)
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_FINDITEM, $iStart, $tFindInfo, $tBuffer, False, 2, False, -1)
Return $iRet
EndFunc
Func _GUICtrlListView_FindNearest($hWnd, $iX, $iY, $iDir = 0, $iStart = -1, $bWrapOK = True)
Local $aDir[8] = [$__LISTVIEWCONSTANT_VK_LEFT, $__LISTVIEWCONSTANT_VK_RIGHT, $__LISTVIEWCONSTANT_VK_UP, $__LISTVIEWCONSTANT_VK_DOWN, $__LISTVIEWCONSTANT_VK_HOME, $__LISTVIEWCONSTANT_VK_END, $__LISTVIEWCONSTANT_VK_PRIOR, $__LISTVIEWCONSTANT_VK_NEXT]
Local $tFindInfo = DllStructCreate($tagLVFINDINFO)
Local $iFlags = $LVFI_NEARESTXY
If $bWrapOK Then $iFlags = BitOR($iFlags, $LVFI_WRAP)
DllStructSetData($tFindInfo, "Flags", $iFlags)
DllStructSetData($tFindInfo, "X", $iX)
DllStructSetData($tFindInfo, "Y", $iY)
DllStructSetData($tFindInfo, "Direction", $aDir[$iDir])
Return _GUICtrlListView_FindItem($hWnd, $iStart, $tFindInfo)
EndFunc
Func _GUICtrlListView_FindParam($hWnd, $iParam, $iStart = -1)
Local $tFindInfo = DllStructCreate($tagLVFINDINFO)
DllStructSetData($tFindInfo, "Flags", $LVFI_PARAM)
DllStructSetData($tFindInfo, "Param", $iParam)
Return _GUICtrlListView_FindItem($hWnd, $iStart, $tFindInfo)
EndFunc
Func _GUICtrlListView_FindText($hWnd, $sText, $iStart = -1, $bPartialOK = True, $bWrapOK = True)
Local $tFindInfo = DllStructCreate($tagLVFINDINFO)
Local $iFlags = $LVFI_STRING
If $bPartialOK Then $iFlags = BitOR($iFlags, $LVFI_PARTIAL)
If $bWrapOK Then $iFlags = BitOR($iFlags, $LVFI_WRAP)
DllStructSetData($tFindInfo, "Flags", $iFlags)
Return _GUICtrlListView_FindItem($hWnd, $iStart, $tFindInfo, $sText)
EndFunc
Func _GUICtrlListView_GetBkColor($hWnd)
Local $i_Color
If IsHWnd($hWnd) Then
$i_Color = _SendMessage($hWnd, $LVM_GETBKCOLOR)
Else
$i_Color = GUICtrlSendMsg($hWnd, $LVM_GETBKCOLOR, 0, 0)
EndIf
Return __GUICtrlListView_ReverseColorOrder($i_Color)
EndFunc
Func _GUICtrlListView_GetBkImage($hWnd)
Local $tBuffer, $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tListViewBuffer
$iMsg = $LVM_GETBKIMAGEW
Else
$tBuffer = $__g_tListViewBufferANSI
$iMsg = $LVM_GETBKIMAGEA
EndIf
Local $tImage = DllStructCreate($tagLVBKIMAGE)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, 0, $tImage, $tBuffer, True, 3, True)
Local $aImage[4]
Switch BitAND(DllStructGetData($tImage, "Flags"), $LVBKIF_SOURCE_MASK)
Case $LVBKIF_SOURCE_HBITMAP
$aImage[0] = 1
Case $LVBKIF_SOURCE_URL
$aImage[0] = 2
EndSwitch
$aImage[1] = DllStructGetData($tBuffer, 1)
$aImage[2] = DllStructGetData($tImage, "XOffPercent")
$aImage[3] = DllStructGetData($tImage, "YOffPercent")
Return SetError($iRet <> 0, 0, $aImage)
EndFunc
Func _GUICtrlListView_GetCallbackMask($hWnd)
Local $iFlags = 0
Local $iMask = _SendMessage($hWnd, $LVM_GETCALLBACKMASK)
If BitAND($iMask, $LVIS_CUT) <> 0 Then $iFlags = BitOR($iFlags, 1)
If BitAND($iMask, $LVIS_DROPHILITED) <> 0 Then $iFlags = BitOR($iFlags, 2)
If BitAND($iMask, $LVIS_FOCUSED) <> 0 Then $iFlags = BitOR($iFlags, 4)
If BitAND($iMask, $LVIS_SELECTED) <> 0 Then $iFlags = BitOR($iFlags, 8)
If BitAND($iMask, $LVIS_OVERLAYMASK) <> 0 Then $iFlags = BitOR($iFlags, 16)
If BitAND($iMask, $LVIS_STATEIMAGEMASK) <> 0 Then $iFlags = BitOR($iFlags, 32)
Return $iFlags
EndFunc
Func _GUICtrlListView_GetColumn($hWnd, $iIndex)
Local $tBuffer, $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tListViewBuffer
$iMsg = $LVM_GETCOLUMNW
Else
$tBuffer = $__g_tListViewBufferANSI
$iMsg = $LVM_GETCOLUMNA
EndIf
Local $tColumn = DllStructCreate($tagLVCOLUMN)
DllStructSetData($tColumn, "Mask", $LVCF_ALLDATA)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, $tColumn, $tBuffer, True, 4, True)
Local $aColumn[9]
Switch BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_JUSTIFYMASK)
Case $LVCFMT_RIGHT
$aColumn[0] = 1
Case $LVCFMT_CENTER
$aColumn[0] = 2
Case Else
$aColumn[0] = 0
EndSwitch
$aColumn[1] = BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_IMAGE) <> 0
$aColumn[2] = BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_BITMAP_ON_RIGHT) <> 0
$aColumn[3] = BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_COL_HAS_IMAGES) <> 0
$aColumn[4] = DllStructGetData($tColumn, "CX")
$aColumn[5] = DllStructGetData($tBuffer, 1)
$aColumn[6] = DllStructGetData($tColumn, "SubItem")
$aColumn[7] = DllStructGetData($tColumn, "Image")
$aColumn[8] = DllStructGetData($tColumn, "Order")
Return SetError($iRet = 0, 0, $aColumn)
EndFunc
Func _GUICtrlListView_GetColumnCount($hWnd)
Return _SendMessage(_GUICtrlListView_GetHeader($hWnd), 0x1200)
EndFunc
Func _GUICtrlListView_GetColumnOrder($hWnd)
Local $a_Cols = _GUICtrlListView_GetColumnOrderArray($hWnd), $s_Cols = ""
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
For $i = 1 To $a_Cols[0]
$s_Cols &= $a_Cols[$i] & $sSeparatorChar
Next
$s_Cols = StringTrimRight($s_Cols, 1)
Return $s_Cols
EndFunc
Func _GUICtrlListView_GetColumnOrderArray($hWnd)
Local $iColumns = _GUICtrlListView_GetColumnCount($hWnd)
Local $tColumns = DllStructCreate("int[" & $iColumns & "]")
__GUICtrl_SendMsg($hWnd, $LVM_GETCOLUMNORDERARRAY, $iColumns, $tColumns, 0, True, -1)
Local $aBuffer[$iColumns + 1]
$aBuffer[0] = $iColumns
For $iI = 1 To $iColumns
$aBuffer[$iI] = DllStructGetData($tColumns, 1, $iI)
Next
Return $aBuffer
EndFunc
Func _GUICtrlListView_GetColumnWidth($hWnd, $iCol)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETCOLUMNWIDTH, $iCol)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETCOLUMNWIDTH, $iCol, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetCounterPage($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETCOUNTPERPAGE)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETCOUNTPERPAGE, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetEditControl($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETEDITCONTROL))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETEDITCONTROL, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetEmptyText($hWnd)
Local $tText = DllStructCreate("wchar[4096]")
Local $iText = DllStructGetSize($tText)
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_GETEMPTYTEXT, $iText, $tText, 0, True, -1)
Return $iRet ? DllStructGetData($tText, 1) : ""
EndFunc
Func _GUICtrlListView_GetExtendedListViewStyle($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETEXTENDEDLISTVIEWSTYLE)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetFocusedGroup($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETFOCUSEDGROUP)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETFOCUSEDGROUP, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetGroupCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETGROUPCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETGROUPCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetGroupInfo($hWnd, $iGroupID)
Local $tGroup = __GUICtrlListView_GetGroupInfoEx($hWnd, $iGroupID, BitOR($LVGF_HEADER, $LVGF_ALIGN))
Local $iErr = @error
Local $aGroup[2]
$aGroup[0] = _WinAPI_GetString(DllStructGetData($tGroup, "Header"))
Select
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_CENTER) <> 0
$aGroup[1] = 1
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_RIGHT) <> 0
$aGroup[1] = 2
Case Else
$aGroup[1] = 0
EndSelect
Return SetError($iErr, 0, $aGroup)
EndFunc
Func __GUICtrlListView_GetGroupInfoEx($hWnd, $iGroupID, $iMask)
Local $tGroup = DllStructCreate($tagLVGROUP)
Local $iGroup = DllStructGetSize($tGroup)
DllStructSetData($tGroup, "Size", $iGroup)
DllStructSetData($tGroup, "Mask", $iMask)
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_GETGROUPINFO, $iGroupID, $tGroup, 0, True, -1)
Return SetError($iRet <> $iGroupID, 0, $tGroup)
EndFunc
Func _GUICtrlListView_GetGroupInfoByIndex($hWnd, $iIndex)
Local $tGroup = DllStructCreate($tagLVGROUP)
Local $iGroup = DllStructGetSize($tGroup)
DllStructSetData($tGroup, "Size", $iGroup)
DllStructSetData($tGroup, "Mask", BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_GROUPID))
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_GETGROUPINFOBYINDEX, $iIndex, $tGroup, 0, True, -1)
Local $aGroup[3]
$aGroup[0] = _WinAPI_GetString(DllStructGetData($tGroup, "Header"))
Select
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_CENTER) <> 0
$aGroup[1] = 1
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_RIGHT) <> 0
$aGroup[1] = 2
Case Else
$aGroup[1] = 0
EndSelect
$aGroup[2] = DllStructGetData($tGroup, "GroupID")
Return SetError($iRet = 0, 0, $aGroup)
EndFunc
Func _GUICtrlListView_GetGroupRect($hWnd, $iGroupID, $iGet = $LVGGR_GROUP)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Top", $iGet)
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_GETGROUPRECT, $iGroupID, $tRECT, 0, True, -1)
Local $aRect[4]
For $x = 0 To 3
$aRect[$x] = DllStructGetData($tRECT, $x + 1)
Next
Return SetError($iRet = 0, 0, $aRect)
EndFunc
Func _GUICtrlListView_GetGroupState($hWnd, $iGroupID, $iMask)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETGROUPSTATE, $iGroupID, $iMask)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETGROUPSTATE, $iGroupID, $iMask)
EndIf
EndFunc
Func _GUICtrlListView_GetGroupViewEnabled($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ISGROUPVIEWENABLED) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_ISGROUPVIEWENABLED, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_GetHeader($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETHEADER))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETHEADER, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetHotCursor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETHOTCURSOR, 0, 0, 0, "wparam", "lparam", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_GETHOTCURSOR, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetHotItem($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETHOTITEM)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETHOTITEM, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetHoverTime($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETHOVERTIME)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETHOVERTIME, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetImageList($hWnd, $iImageList)
Local $aImageList[3] = [$LVSIL_NORMAL, $LVSIL_SMALL, $LVSIL_STATE]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETIMAGELIST, $aImageList[$iImageList], 0, 0, "wparam", "lparam", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_GETIMAGELIST, $aImageList[$iImageList], 0))
EndIf
EndFunc
Func _GUICtrlListView_GetInsertMark($hWnd)
Local $tMark = DllStructCreate($tagLVINSERTMARK)
Local $iMark = DllStructGetSize($tMark)
DllStructSetData($tMark, "Size", $iMark)
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_GETINSERTMARK, 0, $tMark, 0, True, -1)
Local $aMark[2]
$aMark[0] = DllStructGetData($tMark, "Flags") = $LVIM_AFTER
$aMark[1] = DllStructGetData($tMark, "Item")
Return SetError($iRet = 0, 0, $aMark)
EndFunc
Func _GUICtrlListView_GetInsertMarkColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETINSERTMARKCOLOR, $LVSIL_STATE)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETINSERTMARKCOLOR, $LVSIL_STATE, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetInsertMarkRect($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRect[5]
$aRect[0] = __GUICtrl_SendMsg($hWnd, $LVM_GETINSERTMARKRECT, 0, $tRECT, 0, True, -1)
$aRect[1] = DllStructGetData($tRECT, "Left")
$aRect[2] = DllStructGetData($tRECT, "Top")
$aRect[3] = DllStructGetData($tRECT, "Right")
$aRect[4] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetISearchString($hWnd)
Local $tBuffer, $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tListViewBuffer
$iMsg = $LVM_GETISEARCHSTRINGW
Else
$tBuffer = $__g_tListViewBufferANSI
$iMsg = $LVM_GETISEARCHSTRINGA
EndIf
Local $iBuffer
If IsHWnd($hWnd) Then
$iBuffer = _SendMessage($hWnd, $iMsg) + 1
Else
$iBuffer = GUICtrlSendMsg($hWnd, $iMsg, 0, 0) + 1
EndIf
If $iBuffer = 1 Then Return ""
__GUICtrl_SendMsg($hWnd, $iMsg, 0, $tBuffer, 0, True, -1)
Return DllStructGetData($tBuffer, 1)
EndFunc
Func _GUICtrlListView_GetItem($hWnd, $iIndex, $iSubItem = 0)
Local $tItem = $__g_tListViewItem
DllStructSetData($tItem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "StateMask", -1)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Local $iState = DllStructGetData($tItem, "State")
Local $aItem[8]
If BitAND($iState, $LVIS_CUT) <> 0 Then $aItem[0] = BitOR($aItem[0], 1)
If BitAND($iState, $LVIS_DROPHILITED) <> 0 Then $aItem[0] = BitOR($aItem[0], 2)
If BitAND($iState, $LVIS_FOCUSED) <> 0 Then $aItem[0] = BitOR($aItem[0], 4)
If BitAND($iState, $LVIS_SELECTED) <> 0 Then $aItem[0] = BitOR($aItem[0], 8)
$aItem[1] = __GUICtrlListView_OverlayImageMaskToIndex($iState)
$aItem[2] = __GUICtrlListView_StateImageMaskToIndex($iState)
$aItem[3] = _GUICtrlListView_GetItemText($hWnd, $iIndex, $iSubItem)
$aItem[4] = DllStructGetData($tItem, "Image")
$aItem[5] = DllStructGetData($tItem, "Param")
$aItem[6] = DllStructGetData($tItem, "Indent")
$aItem[7] = DllStructGetData($tItem, "GroupID")
Return $aItem
EndFunc
Func _GUICtrlListView_GetItemChecked($hWnd, $iIndex)
Local $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$iMsg = $LVM_GETITEMW
Else
$iMsg = $LVM_GETITEMA
EndIf
Local $tItem = $__g_tListViewItem
DllStructSetData($tItem, "Mask", $LVIF_STATE)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "StateMask", 0xffff)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, 0, $tItem, 0, True, -1)
If Not $iRet Then Return SetError($LV_ERR, $LV_ERR, False)
Return BitAND(DllStructGetData($tItem, "State"), 0x2000) <> 0
EndFunc
Func _GUICtrlListView_GetItemCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETITEMCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETITEMCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetItemCut($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_CUT) <> 0
EndFunc
Func _GUICtrlListView_GetItemDropHilited($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_DROPHILITED) <> 0
EndFunc
Func _GUICtrlListView_GetItemEx($hWnd, ByRef $tItem)
Local $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$iMsg = $LVM_GETITEMW
Else
$iMsg = $LVM_GETITEMA
EndIf
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, 0, $tItem, 0, True, -1)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_GetItemFocused($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_FOCUSED) <> 0
EndFunc
Func _GUICtrlListView_GetItemGroupID($hWnd, $iIndex)
Local $tItem = $__g_tListViewItem
DllStructSetData($tItem, "Mask", $LVIF_GROUPID)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", 0)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "GroupID")
EndFunc
Func _GUICtrlListView_GetItemImage($hWnd, $iIndex, $iSubItem = 0)
Local $tItem = $__g_tListViewItem
DllStructSetData($tItem, "Mask", $LVIF_IMAGE)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "Image")
EndFunc
Func _GUICtrlListView_GetItemIndent($hWnd, $iIndex)
Local $tItem = $__g_tListViewItem
DllStructSetData($tItem, "Mask", $LVIF_INDENT)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", 0)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "Indent")
EndFunc
Func __GUICtrlListView_GetItemOverlayImage($hWnd, $iIndex)
Return BitShift(_GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_OVERLAYMASK), 8)
EndFunc
Func _GUICtrlListView_GetItemParam($hWnd, $iIndex)
Local $tItem = $__g_tListViewItem
DllStructSetData($tItem, "Mask", $LVIF_PARAM)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", 0)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "Param")
EndFunc
Func _GUICtrlListView_GetItemPosition($hWnd, $iIndex)
Local $tPoint = DllStructCreate($tagPOINT)
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_GETITEMPOSITION, $iIndex, $tPoint, 0, True, -1)
Local $aPoint[2]
If Not $iRet Then Return $aPoint
$aPoint[0] = DllStructGetData($tPoint, "X")
$aPoint[1] = DllStructGetData($tPoint, "Y")
Return $aPoint
EndFunc
Func _GUICtrlListView_GetItemPositionX($hWnd, $iIndex)
Local $aPoint = _GUICtrlListView_GetItemPosition($hWnd, $iIndex)
Return $aPoint[0]
EndFunc
Func _GUICtrlListView_GetItemPositionY($hWnd, $iIndex)
Local $aPoint = _GUICtrlListView_GetItemPosition($hWnd, $iIndex)
Return $aPoint[1]
EndFunc
Func _GUICtrlListView_GetItemRect($hWnd, $iIndex, $iPart = 3)
Local $tRECT = _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $iPart)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $iPart = 3)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iPart)
__GUICtrl_SendMsg($hWnd, $LVM_GETITEMRECT, $iIndex, $tRECT, 0, True, -1)
Return $tRECT
EndFunc
Func _GUICtrlListView_GetItemSelected($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_SELECTED) <> 0
EndFunc
Func _GUICtrlListView_GetItemSpacing($hWnd, $bSmall = False)
Local $iSpace
If IsHWnd($hWnd) Then
$iSpace = _SendMessage($hWnd, $LVM_GETITEMSPACING, $bSmall)
Else
$iSpace = GUICtrlSendMsg($hWnd, $LVM_GETITEMSPACING, $bSmall, 0)
EndIf
Local $aSpace[2]
$aSpace[0] = BitAND($iSpace, 0xFFFF)
$aSpace[1] = BitShift($iSpace, 16)
Return $aSpace
EndFunc
Func _GUICtrlListView_GetItemSpacingX($hWnd, $bSmall = False)
If IsHWnd($hWnd) Then
Return BitAND(_SendMessage($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 0xFFFF)
Else
Return BitAND(GUICtrlSendMsg($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 0xFFFF)
EndIf
EndFunc
Func _GUICtrlListView_GetItemSpacingY($hWnd, $bSmall = False)
If IsHWnd($hWnd) Then
Return BitShift(_SendMessage($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 16)
Else
Return BitShift(GUICtrlSendMsg($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 16)
EndIf
EndFunc
Func _GUICtrlListView_GetItemState($hWnd, $iIndex, $iMask)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETITEMSTATE, $iIndex, $iMask)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETITEMSTATE, $iIndex, $iMask)
EndIf
EndFunc
Func _GUICtrlListView_GetItemStateImage($hWnd, $iIndex)
Return BitShift(_GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_STATEIMAGEMASK), 12)
EndFunc
Func _GUICtrlListView_GetItemText($hWnd, $iIndex, $iSubItem = 0)
Local $tBuffer, $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tListViewBuffer
$iMsg = $LVM_GETITEMTEXTW
Else
$tBuffer = $__g_tListViewBufferANSI
$iMsg = $LVM_GETITEMTEXTA
EndIf
Local $tItem = $__g_tListViewItem
DllStructSetData($tBuffer, 1, "")
DllStructSetData($tItem, "Mask", $LVIF_TEXT)
DllStructSetData($tItem, "SubItem", $iSubItem)
__GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, $tItem, $tBuffer, False, 6, True)
Return DllStructGetData($tBuffer, 1)
EndFunc
Func _GUICtrlListView_GetItemTextArray($hWnd, $iItem = -1)
Local $sItems = _GUICtrlListView_GetItemTextString($hWnd, $iItem)
If $sItems = "" Then
Local $aItems[1] = [0]
Return SetError($LV_ERR, $LV_ERR, $aItems)
EndIf
Return StringSplit($sItems, Opt('GUIDataSeparatorChar'))
EndFunc
Func _GUICtrlListView_GetItemTextString($hWnd, $iItem = -1)
Local $sRow = "", $sSeparatorChar = Opt('GUIDataSeparatorChar'), $iSelected
If $iItem = -1 Then
$iSelected = _GUICtrlListView_GetNextItem($hWnd)
Else
$iSelected = $iItem
EndIf
If $iSelected < 0 Or $iSelected > _GUICtrlListView_GetItemCount($hWnd) - 1 Then Return SetError(1, 0, 0)
For $x = 0 To _GUICtrlListView_GetColumnCount($hWnd) - 1
$sRow &= _GUICtrlListView_GetItemText($hWnd, $iSelected, $x) & $sSeparatorChar
Next
Return StringTrimRight($sRow, 1)
EndFunc
Func _GUICtrlListView_GetNextItem($hWnd, $iStart = -1, $iSearch = 0, $iState = 8)
Local $aSearch[5] = [$LVNI_ALL, $LVNI_ABOVE, $LVNI_BELOW, $LVNI_TOLEFT, $LVNI_TORIGHT]
Local $iFlags = $aSearch[$iSearch]
If BitAND($iState, 1) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_CUT)
If BitAND($iState, 2) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_DROPHILITED)
If BitAND($iState, 4) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_FOCUSED)
If BitAND($iState, 8) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_SELECTED)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETNEXTITEM, $iStart, $iFlags)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETNEXTITEM, $iStart, $iFlags)
EndIf
EndFunc
Func _GUICtrlListView_GetNumberOfWorkAreas($hWnd)
Local $tData = DllStructCreate("int Data")
__GUICtrl_SendMsg($hWnd, $LVM_GETNUMBEROFWORKAREAS, 0, $tData, 0, True, -1)
Return DllStructGetData($tData, "Data")
EndFunc
Func _GUICtrlListView_GetOrigin($hWnd)
Local $tPoint = DllStructCreate($tagPOINT)
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_GETORIGIN, 0, $tPoint, 0, True, -1)
Local $aOrigin[2]
$aOrigin[0] = DllStructGetData($tPoint, "X")
$aOrigin[1] = DllStructGetData($tPoint, "Y")
Return SetError(@error, $iRet = 1, $aOrigin)
EndFunc
Func _GUICtrlListView_GetOriginX($hWnd)
Local $aOrigin = _GUICtrlListView_GetOrigin($hWnd)
Return $aOrigin[0]
EndFunc
Func _GUICtrlListView_GetOriginY($hWnd)
Local $aOrigin = _GUICtrlListView_GetOrigin($hWnd)
Return $aOrigin[1]
EndFunc
Func _GUICtrlListView_GetOutlineColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETOUTLINECOLOR)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETOUTLINECOLOR, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetSelectedColumn($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETSELECTEDCOLUMN)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETSELECTEDCOLUMN, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetSelectedCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETSELECTEDCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETSELECTEDCOUNT, 0, 0)
EndIf
EndFunc
Func __GUICtrlListView_GetCheckedIndices($hWnd)
Local $iCount = _GUICtrlListView_GetItemCount($hWnd)
Local $aSelected[$iCount + 1] = [0]
For $i = 0 To $iCount - 1
If _GUICtrlListView_GetItemChecked($hWnd, $i) Then
$aSelected[0] += 1
$aSelected[$aSelected[0]] = $i
EndIf
Next
ReDim $aSelected[$aSelected[0] + 1]
Return $aSelected
EndFunc
Func _GUICtrlListView_GetSelectedIndices($hWnd, $bArray = False)
Local $sIndices, $aIndices[1] = [0]
Local $iSelectedCount = _GUICtrlListView_GetSelectedCount($hWnd)
If $iSelectedCount Then
Local $iSelected, $iStart = -1
For $i = 1 To $iSelectedCount
If IsHWnd($hWnd) Then
$iSelected = _SendMessage($hWnd, $LVM_GETNEXTITEM, $iStart, $LVNI_SELECTED)
Else
$iSelected = GUICtrlSendMsg($hWnd, $LVM_GETNEXTITEM, $iStart, $LVNI_SELECTED)
EndIf
If (Not $bArray) Then
If StringLen($sIndices) Then
$sIndices &= "|" & $iSelected
Else
$sIndices = $iSelected
EndIf
Else
ReDim $aIndices[UBound($aIndices) + 1]
$aIndices[0] = UBound($aIndices) - 1
$aIndices[UBound($aIndices) - 1] = $iSelected
EndIf
$iStart = $iSelected
Next
EndIf
If (Not $bArray) Then
Return String($sIndices)
Else
Return $aIndices
EndIf
EndFunc
Func _GUICtrlListView_GetSelectionMark($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETSELECTIONMARK)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETSELECTIONMARK, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetStringWidth($hWnd, $sString)
Local $tBuffer, $iMsg
If _GUICtrlListView_GetUnicodeFormat Then
$tBuffer = $__g_tListViewBuffer
$iMsg = $LVM_GETSTRINGWIDTHW
Else
$tBuffer = $__g_tListViewBufferANSI
$iMsg = $LVM_GETSTRINGWIDTHA
EndIf
DllStructSetData($tBuffer, 1, $sString)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, 0, $tBuffer, 0, True, -1)
Return $iRet
EndFunc
Func _GUICtrlListView_GetSubItemRect($hWnd, $iIndex, $iSubItem, $iPart = 0)
Local $aPart[2] = [$LVIR_BOUNDS, $LVIR_ICON]
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Top", $iSubItem)
DllStructSetData($tRECT, "Left", $aPart[$iPart])
__GUICtrl_SendMsg($hWnd, $LVM_GETSUBITEMRECT, $iIndex, $tRECT, 0, True, -1)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetTextBkColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETTEXTBKCOLOR)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETTEXTBKCOLOR, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetTextColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETTEXTCOLOR)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETTEXTCOLOR, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetToolTips($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETTOOLTIPS))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETTOOLTIPS, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetTopIndex($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETTOPINDEX)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETTOPINDEX, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetUnicodeFormat($hWnd)
If Not IsDllStruct($__g_tListViewBuffer) Then
$__g_tListViewBuffer = DllStructCreate("wchar Text[4096]")
$__g_tListViewBufferANSI = DllStructCreate("char Text[4096]", DllStructGetPtr($__g_tListViewBuffer))
EndIf
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETUNICODEFORMAT) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETUNICODEFORMAT, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_GetView($hWnd)
Local $iView
If IsHWnd($hWnd) Then
$iView = _SendMessage($hWnd, $LVM_GETVIEW)
Else
$iView = GUICtrlSendMsg($hWnd, $LVM_GETVIEW, 0, 0)
EndIf
Switch $iView
Case $LV_VIEW_ICON
Return Int($LV_VIEW_ICON)
Case $LV_VIEW_DETAILS
Return Int($LV_VIEW_DETAILS)
Case $LV_VIEW_LIST
Return Int($LV_VIEW_LIST)
Case $LV_VIEW_SMALLICON
Return Int($LV_VIEW_SMALLICON)
Case $LV_VIEW_TILE
Return Int($LV_VIEW_TILE)
Case Else
Return -1
EndSwitch
EndFunc
Func _GUICtrlListView_GetViewDetails($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_DETAILS
EndFunc
Func _GUICtrlListView_GetViewLarge($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_ICON
EndFunc
Func _GUICtrlListView_GetViewList($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_LIST
EndFunc
Func _GUICtrlListView_GetViewSmall($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_SMALLICON
EndFunc
Func _GUICtrlListView_GetViewTile($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_TILE
EndFunc
Func _GUICtrlListView_GetViewRect($hWnd)
Local $aRect[4] = [0, 0, 0, 0]
Local $iView = _GUICtrlListView_GetView($hWnd)
If ($iView < 0) And ($iView > 4) Then Return $aRect
Local $tRECT = DllStructCreate($tagRECT)
__GUICtrl_SendMsg($hWnd, $LVM_GETVIEWRECT, 0, $tRECT, 0, True, -1)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_HideColumn($hWnd, $iCol)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETCOLUMNWIDTH, $iCol) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNWIDTH, $iCol, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_HitTest($hWnd, $iX = -1, $iY = -1)
Local $iMode = Opt("MouseCoordMode", 1)
Local $aPos = MouseGetPos()
Opt("MouseCoordMode", $iMode)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $aPos[0])
DllStructSetData($tPoint, "Y", $aPos[1])
Local $aCall = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hWnd, "struct*", $tPoint)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] = 0 Then Return 0
If $iX = -1 Then $iX = DllStructGetData($tPoint, "X")
If $iY = -1 Then $iY = DllStructGetData($tPoint, "Y")
Local $tTest = DllStructCreate($tagLVHITTESTINFO)
DllStructSetData($tTest, "X", $iX)
DllStructSetData($tTest, "Y", $iY)
Local $aTest[10]
$aTest[0] = __GUICtrl_SendMsg($hWnd, $LVM_HITTEST, 0, $tTest, 0, True, -1)
Local $iFlags = DllStructGetData($tTest, "Flags")
$aTest[1] = BitAND($iFlags, $LVHT_NOWHERE) <> 0
$aTest[2] = BitAND($iFlags, $LVHT_ONITEMICON) <> 0
$aTest[3] = BitAND($iFlags, $LVHT_ONITEMLABEL) <> 0
$aTest[4] = BitAND($iFlags, $LVHT_ONITEMSTATEICON) <> 0
$aTest[5] = BitAND($iFlags, $LVHT_ONITEM) <> 0
$aTest[6] = BitAND($iFlags, $LVHT_ABOVE) <> 0
$aTest[7] = BitAND($iFlags, $LVHT_BELOW) <> 0
$aTest[8] = BitAND($iFlags, $LVHT_TOLEFT) <> 0
$aTest[9] = BitAND($iFlags, $LVHT_TORIGHT) <> 0
Return $aTest
EndFunc
Func __GUICtrlListView_IndexToOverlayImageMask($iIndex)
Return BitShift($iIndex, -8)
EndFunc
Func __GUICtrlListView_IndexToStateImageMask($iIndex)
Return BitShift($iIndex, -12)
EndFunc
Func _GUICtrlListView_InsertColumn($hWnd, $iIndex, $sText, $iWidth = 50, $iAlign = -1, $iImage = -1, $bOnRight = False)
Local $aAlign[3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
Local $tBuffer, $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tListViewBuffer
$iMsg = $LVM_INSERTCOLUMNW
Else
$tBuffer = $__g_tListViewBufferANSI
$iMsg = $LVM_INSERTCOLUMNA
EndIf
Local $tColumn = DllStructCreate($tagLVCOLUMN)
Local $iMask = BitOR($LVCF_FMT, $LVCF_WIDTH, $LVCF_TEXT)
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $iFmt = $aAlign[$iAlign]
If $iImage <> -1 Then
$iMask = BitOR($iMask, $LVCF_IMAGE)
$iFmt = BitOR($iFmt, $LVCFMT_COL_HAS_IMAGES, $LVCFMT_IMAGE)
EndIf
If $bOnRight Then $iFmt = BitOR($iFmt, $LVCFMT_BITMAP_ON_RIGHT)
DllStructSetData($tBuffer, 1, $sText)
DllStructSetData($tColumn, "Mask", $iMask)
DllStructSetData($tColumn, "Fmt", $iFmt)
DllStructSetData($tColumn, "CX", $iWidth)
DllStructSetData($tColumn, "Image", $iImage)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, $tColumn, $tBuffer, False, 4)
If $iAlign > 0 Then _GUICtrlListView_SetColumn($hWnd, $iRet, $sText, $iWidth, $iAlign, $iImage, $bOnRight)
Return $iRet
EndFunc
Func _GUICtrlListView_InsertGroup($hWnd, $iIndex, $iGroupID, $sHeader, $iAlign = 0)
Local $aAlign[3] = [$LVGA_HEADER_LEFT, $LVGA_HEADER_CENTER, $LVGA_HEADER_RIGHT]
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $tHeader = _WinAPI_MultiByteToWideChar($sHeader)
Local $tGroup = DllStructCreate($tagLVGROUP)
Local $iMask = BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_GROUPID)
DllStructSetData($tGroup, "Size", DllStructGetSize($tGroup))
DllStructSetData($tGroup, "Mask", $iMask)
DllStructSetData($tGroup, "GroupID", $iGroupID)
DllStructSetData($tGroup, "Align", $aAlign[$iAlign])
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_INSERTGROUP, $iIndex, $tGroup, $tHeader, False, 3)
Return $iRet
EndFunc
Func _GUICtrlListView_InsertItem($hWnd, $sText, $iIndex = -1, $iImage = -1, $iParam = 0)
Local $tBuffer, $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tListViewBuffer
$iMsg = $LVM_INSERTITEMW
Else
$tBuffer = $__g_tListViewBufferANSI
$iMsg = $LVM_INSERTITEMA
EndIf
Local $tItem = $__g_tListViewItem
If $iIndex = -1 Then $iIndex = 999999999
DllStructSetData($tBuffer, 1, $sText)
Local $iMask = BitOR($LVIF_TEXT, $LVIF_PARAM)
If $iImage >= 0 Then $iMask = BitOR($iMask, $LVIF_IMAGE)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "Image", $iImage)
DllStructSetData($tItem, "Param", $iParam)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, 0, $tItem, $tBuffer, False, 6)
Return $iRet
EndFunc
Func _GUICtrlListView_InsertMarkHitTest($hWnd, $iX = -1, $iY = -1)
Local $iMode = Opt("MouseCoordMode", 1)
Local $aPos = MouseGetPos()
Opt("MouseCoordMode", $iMode)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $aPos[0])
DllStructSetData($tPoint, "Y", $aPos[1])
Local $aCall = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hWnd, "struct*", $tPoint)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] = 0 Then Return 0
If $iX = -1 Then $iX = DllStructGetData($tPoint, "X")
If $iY = -1 Then $iY = DllStructGetData($tPoint, "Y")
Local $tMark = DllStructCreate($tagLVINSERTMARK)
DllStructSetData($tPoint, "X", $iX)
DllStructSetData($tPoint, "Y", $iY)
DllStructSetData($tMark, "Size", DllStructGetSize($tMark))
__GUICtrl_SendMsg($hWnd, $LVM_INSERTMARKHITTEST, DllStructGetPtr($tPoint), $tMark, $tPoint, True, -1, False, 0)
Local $aTest[2]
$aTest[0] = DllStructGetData($tMark, "Flags") = $LVIM_AFTER
$aTest[1] = DllStructGetData($tMark, "Item")
Return $aTest
EndFunc
Func _GUICtrlListView_IsItemVisible($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ISITEMVISIBLE, $iIndex) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_ISITEMVISIBLE, $iIndex, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_JustifyColumn($hWnd, $iIndex, $iAlign = -1)
Local $aAlign[3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
Local $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$iMsg = $LVM_SETCOLUMNW
Else
$iMsg = $LVM_SETCOLUMNA
EndIf
Local $tColumn = DllStructCreate($tagLVCOLUMN)
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $iMask = $LVCF_FMT
Local $iFmt = $aAlign[$iAlign]
DllStructSetData($tColumn, "Mask", $iMask)
DllStructSetData($tColumn, "Fmt", $iFmt)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, $tColumn, 0, False, -1)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_MapIDToIndex($hWnd, $iID)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_MAPIDTOINDEX, $iID)
Else
Return GUICtrlSendMsg($hWnd, $LVM_MAPIDTOINDEX, $iID, 0)
EndIf
EndFunc
Func _GUICtrlListView_MapIndexToID($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_MAPINDEXTOID, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_MAPINDEXTOID, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlListView_MoveGroup($hWnd, $iGroupID, $iIndex = -1)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_MOVEGROUP, $iGroupID, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_MOVEGROUP, $iGroupID, $iIndex)
EndIf
EndFunc
Func __GUICtrlListView_OverlayImageMaskToIndex($iMask)
Return BitShift(BitAND($LVIS_OVERLAYMASK, $iMask), 8)
EndFunc
Func _GUICtrlListView_RedrawItems($hWnd, $iFirst, $iLast)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_REDRAWITEMS, $iFirst, $iLast) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_REDRAWITEMS, $iFirst, $iLast) <> 0
EndIf
EndFunc
Func _GUICtrlListView_RegisterSortCallBack($hWnd, $vCompareType = 1, $bArrows = True, $sPrivateCallBack = "__GUICtrlListView_Sort")
#Au3Stripper_Ignore_Funcs=$sPrivateCallBack
If IsBool($vCompareType) Then $vCompareType = ($vCompareType) ? 1 : 0
Local $hHeader = _GUICtrlListView_GetHeader($hWnd)
ReDim $__g_aListViewSortInfo[UBound($__g_aListViewSortInfo) + 1][$__LISTVIEWCONSTANT_SORTINFOSIZE]
$__g_aListViewSortInfo[0][0] = UBound($__g_aListViewSortInfo) - 1
Local $iIndex = $__g_aListViewSortInfo[0][0]
$__g_aListViewSortInfo[$iIndex][0] = _GUICtrlListView_GetUnicodeFormat($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
$__g_aListViewSortInfo[$iIndex][1] = $hWnd
$__g_aListViewSortInfo[$iIndex][2] =  DllCallbackRegister($sPrivateCallBack, "int", "int;int;hwnd")
$__g_aListViewSortInfo[$iIndex][3] = -1
$__g_aListViewSortInfo[$iIndex][4] = -1
$__g_aListViewSortInfo[$iIndex][5] = 1
$__g_aListViewSortInfo[$iIndex][6] = -1
$__g_aListViewSortInfo[$iIndex][7] = 0
$__g_aListViewSortInfo[$iIndex][8] = $vCompareType
$__g_aListViewSortInfo[$iIndex][9] = $bArrows
$__g_aListViewSortInfo[$iIndex][10] = $hHeader
Return $__g_aListViewSortInfo[$iIndex][2] <> 0
EndFunc
Func _GUICtrlListView_RemoveAllGroups($hWnd)
_GUICtrlListView_BeginUpdate($hWnd)
Local $iGroupID
For $x = _GUICtrlListView_GetGroupCount($hWnd) - 1 To 0 Step -1
$iGroupID = _GUICtrlListView_GetGroupInfoByIndex($hWnd, $x)[2]
_GUICtrlListView_RemoveGroup($hWnd, $iGroupID)
Next
_GUICtrlListView_EndUpdate($hWnd)
EndFunc
Func _GUICtrlListView_RemoveGroup($hWnd, $iGroupID)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_REMOVEGROUP, $iGroupID)
Else
Return GUICtrlSendMsg($hWnd, $LVM_REMOVEGROUP, $iGroupID, 0)
EndIf
EndFunc
Func __GUICtrlListView_ReverseColorOrder($iColor)
Local $sH = Hex(String($iColor), 6)
Return '0x' & StringMid($sH, 5, 2) & StringMid($sH, 3, 2) & StringMid($sH, 1, 2)
EndFunc
Func _GUICtrlListView_Scroll($hWnd, $iDX, $iDY)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SCROLL, $iDX, $iDY) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SCROLL, $iDX, $iDY) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetBkColor($hWnd, $iColor)
Local $iRet
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETBKCOLOR, 0, $iColor)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETBKCOLOR, 0, $iColor)
EndIf
_WinAPI_InvalidateRect($hWnd)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetBkHBITMAP($hWnd, $hBitmap, $iStyle = 0, $iXOffset = 0, $iYOffset = 0, $bDeleteBitmap = False)
Local $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$iMsg = $LVM_SETBKIMAGEW
Else
$iMsg = $LVM_SETBKIMAGEA
EndIf
Local $iFlags = BitOR($LVBKIF_STYLE_TILE, $LVBKIF_FLAG_TILEOFFSET)
If $iXOffset = Default Then $iXOffset = 0
If $iYOffset = Default Then $iYOffset = 0
If IsPtr($hBitmap) Then
If (Not $iStyle) Or ($iStyle = Default) Then
$iFlags = $LVBKIF_STYLE_NORMAL
Else
$iXOffset *= -1
$iYOffset *= -1
EndIf
$iFlags = BitOR($iFlags, $LVBKIF_SOURCE_HBITMAP)
Else
$iFlags = $LVBKIF_SOURCE_NONE
EndIf
Local $tLVBKImage = DllStructCreate($tagLVBKIMAGE)
Local $pLVBKImage = DllStructGetPtr($tLVBKImage)
DllStructSetData($tLVBKImage, 'Flags', $iFlags)
DllStructSetData($tLVBKImage, 'hBmp', $hBitmap)
DllStructSetData($tLVBKImage, 'XOffPercent', $iXOffset)
DllStructSetData($tLVBKImage, 'YOffPercent', $iYOffset)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, 0, $pLVBKImage)
If $bDeleteBitmap And $iRet Then DllCall('gdi32.dll', 'bool', 'DeleteObject', 'handle', $hBitmap)
If $iFlags = $LVBKIF_SOURCE_NONE Then Return True
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetBkImage($hWnd, $sURL = "", $iStyle = 0, $iXOffset = 0, $iYOffset = 0)
Local $aStyle[2] = [$LVBKIF_STYLE_NORMAL, $LVBKIF_STYLE_TILE]
Local $tBuffer, $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tListViewBuffer
$iMsg = $LVM_SETBKIMAGEW
Else
$tBuffer = $__g_tListViewBufferANSI
$iMsg = $LVM_SETBKIMAGEA
EndIf
Local $tImage = DllStructCreate($tagLVBKIMAGE)
Local $iFlags = 0
If $sURL <> "" Then $iFlags = $LVBKIF_SOURCE_URL
$iFlags = BitOR($iFlags, $aStyle[$iStyle])
DllStructSetData($tBuffer, 1, $sURL)
DllStructSetData($tImage, "Flags", $iFlags)
DllStructSetData($tImage, "XOffPercent", $iXOffset)
DllStructSetData($tImage, "YOffPercent", $iYOffset)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, 0, $tImage, $tBuffer, False, 3, False, -1)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetCallBackMask($hWnd, $iMask)
Local $iFlags = 0
If BitAND($iMask, 1) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_CUT)
If BitAND($iMask, 2) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_DROPHILITED)
If BitAND($iMask, 4) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_FOCUSED)
If BitAND($iMask, 8) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_SELECTED)
If BitAND($iMask, 16) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_OVERLAYMASK)
If BitAND($iMask, 32) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_STATEIMAGEMASK)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETCALLBACKMASK, $iFlags) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETCALLBACKMASK, $iFlags, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetColumn($hWnd, $iIndex, $sText, $iWidth = -1, $iAlign = -1, $iImage = -1, $bOnRight = False)
Local $aAlign[3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
Local $tBuffer, $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tListViewBuffer
$iMsg = $LVM_SETCOLUMNW
Else
$tBuffer = $__g_tListViewBufferANSI
$iMsg = $LVM_SETCOLUMNA
EndIf
Local $tColumn = DllStructCreate($tagLVCOLUMN)
Local $iMask = $LVCF_TEXT
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
$iMask = BitOR($iMask, $LVCF_FMT)
Local $iFmt = $aAlign[$iAlign]
If $iWidth <> -1 Then $iMask = BitOR($iMask, $LVCF_WIDTH)
If $iImage <> -1 Then
$iMask = BitOR($iMask, $LVCF_IMAGE)
$iFmt = BitOR($iFmt, $LVCFMT_COL_HAS_IMAGES, $LVCFMT_IMAGE)
Else
$iImage = 0
EndIf
If $bOnRight Then $iFmt = BitOR($iFmt, $LVCFMT_BITMAP_ON_RIGHT)
DllStructSetData($tBuffer, 1, $sText)
DllStructSetData($tColumn, "Mask", $iMask)
DllStructSetData($tColumn, "Fmt", $iFmt)
DllStructSetData($tColumn, "CX", $iWidth)
DllStructSetData($tColumn, "Image", $iImage)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, $iIndex, $tColumn, $tBuffer, False, 4)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetColumnOrder($hWnd, $sOrder)
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
Return _GUICtrlListView_SetColumnOrderArray($hWnd, StringSplit($sOrder, $sSeparatorChar))
EndFunc
Func _GUICtrlListView_SetColumnOrderArray($hWnd, $aOrder)
Local $tOrders = DllStructCreate("int[" & $aOrder[0] & "]")
For $iI = 1 To $aOrder[0]
DllStructSetData($tOrders, 1, $aOrder[$iI], $iI)
Next
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_SETCOLUMNORDERARRAY, $aOrder[0], $tOrders, False, -1)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetColumnWidth($hWnd, $iCol, $iWidth)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETCOLUMNWIDTH, $iCol, $iWidth)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNWIDTH, $iCol, $iWidth)
EndIf
EndFunc
Func _GUICtrlListView_SetExtendedListViewStyle($hWnd, $iExStyle, $iExMask = 0)
Local $iRet
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETEXTENDEDLISTVIEWSTYLE, $iExMask, $iExStyle)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETEXTENDEDLISTVIEWSTYLE, $iExMask, $iExStyle)
EndIf
_WinAPI_InvalidateRect($hWnd)
Return $iRet
EndFunc
Func _GUICtrlListView_SetGroupInfo($hWnd, $iGroupID, $sHeader, $iAlign = 0, $iState = $LVGS_NORMAL)
Local $tGroup = 0
If BitAND($iState, $LVGS_SELECTED) Then
$tGroup = __GUICtrlListView_GetGroupInfoEx($hWnd, $iGroupID, BitOR($LVGF_GROUPID, $LVGF_ITEMS))
If @error Or DllStructGetData($tGroup, "cItems") = 0 Then Return False
EndIf
Local $aAlign[3] = [$LVGA_HEADER_LEFT, $LVGA_HEADER_CENTER, $LVGA_HEADER_RIGHT]
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $tHeader = _WinAPI_MultiByteToWideChar($sHeader)
$tGroup = DllStructCreate($tagLVGROUP)
Local $iMask = BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_STATE)
DllStructSetData($tGroup, "Size", DllStructGetSize($tGroup))
DllStructSetData($tGroup, "Mask", $iMask)
DllStructSetData($tGroup, "Align", $aAlign[$iAlign])
DllStructSetData($tGroup, "State", $iState)
DllStructSetData($tGroup, "StateMask", $iState)
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_SETGROUPINFO, $iGroupID, $tGroup, $tHeader, False, 3)
DllStructSetData($tGroup, "Mask", $LVGF_GROUPID)
DllStructSetData($tGroup, "GroupID", $iGroupID)
__GUICtrl_SendMsg($hWnd, $LVM_SETGROUPINFO, 0, $tGroup, 0, False, -1)
_WinAPI_InvalidateRect($hWnd)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetHotCursor($hWnd, $hCursor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETHOTCURSOR, 0, $hCursor, 0, "wparam", "handle", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_SETHOTCURSOR, 0, $hCursor))
EndIf
EndFunc
Func _GUICtrlListView_SetHotItem($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETHOTITEM, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETHOTITEM, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlListView_SetHoverTime($hWnd, $iTime)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETHOVERTIME, 0, $iTime)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETHOVERTIME, 0, $iTime)
EndIf
EndFunc
Func _GUICtrlListView_SetIconSpacing($hWnd, $iCX, $iCY)
Local $iRet, $aPadding[2]
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETICONSPACING, 0, _WinAPI_MakeLong($iCX, $iCY))
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETICONSPACING, 0, _WinAPI_MakeLong($iCX, $iCY))
EndIf
_WinAPI_InvalidateRect($hWnd)
$aPadding[0] = BitAND($iRet, 0xFFFF)
$aPadding[1] = BitShift($iRet, 16)
Return $aPadding
EndFunc
Func _GUICtrlListView_SetImageList($hWnd, $hHandle, $iType = 0)
$iType = Int($iType)
If $iType < 0 Or $iType > 2 Then
$iType = 0
EndIf
Local $aType[3] = [$LVSIL_NORMAL, $LVSIL_SMALL, $LVSIL_STATE]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETIMAGELIST, $aType[$iType], $hHandle, 0, "wparam", "handle", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_SETIMAGELIST, $aType[$iType], $hHandle))
EndIf
EndFunc
Func _GUICtrlListView_SetInfoTip($hWnd, $iIndex, $sText, $iSubItem = 0)
Local $tBuffer = _WinAPI_MultiByteToWideChar($sText)
Local $tInfo = DllStructCreate($tagLVSETINFOTIP)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Item", $iIndex)
DllStructSetData($tInfo, "SubItem", $iSubItem)
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_SETINFOTIP, 0, $tInfo, $tBuffer, False, 3, False, -1)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetInsertMark($hWnd, $iIndex, $bAfter = False)
Local $tMark = DllStructCreate($tagLVINSERTMARK)
DllStructSetData($tMark, "Size", DllStructGetSize($tMark))
If $bAfter Then DllStructSetData($tMark, "Flags", $LVIM_AFTER)
DllStructSetData($tMark, "Item", $iIndex)
DllStructSetData($tMark, "Reserved", 0)
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_SETINSERTMARK, 0, $tMark, 0, False, -1)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetInsertMarkColor($hWnd, $iColor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETINSERTMARKCOLOR, 0, $iColor)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETINSERTMARKCOLOR, 0, $iColor)
EndIf
EndFunc
Func _GUICtrlListView_SetItem($hWnd, $sText, $iIndex = 0, $iSubItem = 0, $iImage = -1, $iParam = -1, $iIndent = -1)
Local $pBuffer, $iBuffer
If $sText <> -1 Then
Local $tBuffer
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tListViewBuffer
Else
$tBuffer = $__g_tListViewBufferANSI
EndIf
$pBuffer = DllStructGetPtr($tBuffer)
$iBuffer = DllStructGetSize($tBuffer)
DllStructSetData($tBuffer, "Text", $sText)
Else
$pBuffer = -1
$iBuffer = 0
EndIf
Local $tItem = $__g_tListViewItem
Local $iMask = $LVIF_TEXT
If $iImage <> -1 Then $iMask = BitOR($iMask, $LVIF_IMAGE)
If $iParam <> -1 Then $iMask = BitOR($iMask, $LVIF_PARAM)
If $iIndent <> -1 Then $iMask = BitOR($iMask, $LVIF_INDENT)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "Text", $pBuffer)
DllStructSetData($tItem, "TextMax", $iBuffer)
DllStructSetData($tItem, "Image", $iImage)
DllStructSetData($tItem, "Param", $iParam)
DllStructSetData($tItem, "Indent", $iIndent)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func _GUICtrlListView_SetItemChecked($hWnd, $iIndex, $bCheck = True)
Local $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$iMsg = $LVM_SETITEMW
Else
$iMsg = $LVM_SETITEMA
EndIf
Local $tItem = $__g_tListViewItem
If ($bCheck) Then
DllStructSetData($tItem, "State", 0x2000)
Else
DllStructSetData($tItem, "State", 0x1000)
EndIf
DllStructSetData($tItem, "StateMask", 0xf000)
DllStructSetData($tItem, "Mask", $LVIF_STATE)
DllStructSetData($tItem, "SubItem", 0)
Local $iIndexMax = $iIndex
If $iIndex = -1 Then
$iIndex = 0
$iIndexMax = _GUICtrlListView_GetItemCount($hWnd) - 1
EndIf
Local $iRet
For $x = $iIndex To $iIndexMax
DllStructSetData($tItem, "Item", $x)
$iRet = __GUICtrl_SendMsg($hWnd, $iMsg, 0, $tItem, 0, False, -1)
If $iRet = 0 Then ExitLoop
Next
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetItemCount($hWnd, $iItems)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETITEMCOUNT, $iItems, BitOR($LVSICF_NOINVALIDATEALL, $LVSICF_NOSCROLL)) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETITEMCOUNT, $iItems, BitOR($LVSICF_NOINVALIDATEALL, $LVSICF_NOSCROLL)) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetItemCut($hWnd, $iIndex, $bEnabled = True)
Local $iState = 0
If $bEnabled Then $iState = $LVIS_CUT
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $LVIS_CUT)
EndFunc
Func _GUICtrlListView_SetItemDropHilited($hWnd, $iIndex, $bEnabled = True)
Local $iState = 0
If $bEnabled Then $iState = $LVIS_DROPHILITED
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $LVIS_DROPHILITED)
EndFunc
Func _GUICtrlListView_SetItemEx($hWnd, ByRef $tItem, $iNested = 0)
Local $tBuffer, $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tListViewBuffer
$iMsg = $LVM_SETITEMW
Else
$tBuffer = $__g_tListViewBufferANSI
$iMsg = $LVM_SETITEMA
EndIf
Local $iBuffer = 0
If $iNested Then
$tBuffer = 0
DllStructSetData($tItem, "Text", 0)
Else
If DllStructGetData($tItem, "Text") <> -1 Then
$iBuffer = DllStructGetSize($tBuffer)
Else
EndIf
EndIf
DllStructSetData($tItem, "TextMax", $iBuffer)
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, 0, $tItem, $tBuffer, False, -1)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetItemFocused($hWnd, $iIndex, $bEnabled = True)
Local $iState = 0
If $bEnabled Then $iState = $LVIS_FOCUSED
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $LVIS_FOCUSED)
EndFunc
Func _GUICtrlListView_SetItemGroupID($hWnd, $iIndex, $iGroupID)
Local $tItem = $__g_tListViewItem
DllStructSetData($tItem, "Mask", $LVIF_GROUPID)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "GroupID", $iGroupID)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem, 1)
EndFunc
Func _GUICtrlListView_SetItemImage($hWnd, $iIndex, $iImage, $iSubItem = 0)
Local $tItem = $__g_tListViewItem
DllStructSetData($tItem, "Mask", $LVIF_IMAGE)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "Image", $iImage)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem, 1)
EndFunc
Func _GUICtrlListView_SetItemIndent($hWnd, $iIndex, $iIndent)
Local $tItem = $__g_tListViewItem
DllStructSetData($tItem, "Mask", $LVIF_INDENT)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "Indent", $iIndent)
Local $iRet = _GUICtrlListView_SetItemEx($hWnd, $tItem, 1)
_WinAPI_InvalidateRect($hWnd)
Return $iRet
EndFunc
Func __GUICtrlListView_SetItemOverlayImage($hWnd, $iIndex, $iImage)
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, __GUICtrlListView_IndexToOverlayImageMask($iImage), $LVIS_OVERLAYMASK)
EndFunc
Func _GUICtrlListView_SetItemParam($hWnd, $iIndex, $iParam)
Local $tItem = $__g_tListViewItem
DllStructSetData($tItem, "Mask", $LVIF_PARAM)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "Param", $iParam)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem, 1)
EndFunc
Func _GUICtrlListView_SetItemPosition($hWnd, $iIndex, $iCX, $iCY)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETITEMPOSITION, $iIndex, _WinAPI_MakeLong($iCX, $iCY)) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETITEMPOSITION, $iIndex, _WinAPI_MakeLong($iCX, $iCY)) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetItemPosition32($hWnd, $iIndex, $iCX, $iCY)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $iCX)
DllStructSetData($tPoint, "Y", $iCY)
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_SETITEMPOSITION32, $iIndex, $tPoint, 0, False, -1)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetItemSelected($hWnd, $iIndex, $bSelected = True, $bFocused = False)
Local $tItem = $__g_tListViewItem
Local $iSelected = 0, $iFocused = 0
If ($bSelected = True) Then $iSelected = $LVIS_SELECTED
If ($bFocused = True And $iIndex <> -1) Then $iFocused = $LVIS_FOCUSED
DllStructSetData($tItem, "Mask", $LVIF_STATE)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "State", BitOR($iSelected, $iFocused))
DllStructSetData($tItem, "StateMask", BitOR($LVIS_SELECTED, $iFocused))
Local $iRet = __GUICtrl_SendMsg($hWnd, $LVM_SETITEMSTATE, $iIndex, $tItem, 0, False, -1)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $iStateMask)
Local $tItem = $__g_tListViewItem
DllStructSetData($tItem, "Mask", $LVIF_STATE)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "State", $iState)
DllStructSetData($tItem, "StateMask", $iStateMask)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem, 1) <> 0
EndFunc
Func _GUICtrlListView_SetItemStateImage($hWnd, $iIndex, $iImage)
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, BitShift($iImage, -12), $LVIS_STATEIMAGEMASK)
EndFunc
Func _GUICtrlListView_SetItemText($hWnd, $iIndex, $sText, $iSubItem = 0)
Local $iRet
If $iSubItem = -1 Then
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
Local $i_Cols = _GUICtrlListView_GetColumnCount($hWnd)
Local $a_Text = StringSplit($sText, $sSeparatorChar)
If $i_Cols > $a_Text[0] Then $i_Cols = $a_Text[0]
For $i = 1 To $i_Cols
$iRet = _GUICtrlListView_SetItemText($hWnd, $iIndex, $a_Text[$i], $i - 1)
If Not $iRet Then ExitLoop
Next
Return $iRet
EndIf
Local $tBuffer, $iMsg
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tListViewBuffer
$iMsg = $LVM_SETITEMW
Else
$tBuffer = $__g_tListViewBufferANSI
$iMsg = $LVM_SETITEMA
EndIf
Local $tItem = $__g_tListViewItem
DllStructSetData($tBuffer, 1, $sText)
DllStructSetData($tItem, "Mask", $LVIF_TEXT)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
$iRet = __GUICtrl_SendMsg($hWnd, $iMsg, 0, $tItem, $tBuffer, False, 6, False, -1)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetOutlineColor($hWnd, $iColor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETOUTLINECOLOR, 0, $iColor)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETOUTLINECOLOR, 0, $iColor)
EndIf
EndFunc
Func _GUICtrlListView_SetSelectedColumn($hWnd, $iCol)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LVM_SETSELECTEDCOLUMN, $iCol)
Else
GUICtrlSendMsg($hWnd, $LVM_SETSELECTEDCOLUMN, $iCol, 0)
EndIf
_WinAPI_InvalidateRect($hWnd)
EndFunc
Func _GUICtrlListView_SetSelectionMark($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETSELECTIONMARK, 0, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETSELECTIONMARK, 0, $iIndex)
EndIf
EndFunc
Func _GUICtrlListView_SetTextBkColor($hWnd, $iColor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETTEXTBKCOLOR, 0, $iColor) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETTEXTBKCOLOR, 0, $iColor) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetTextColor($hWnd, $iColor)
Local $iRet
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETTEXTCOLOR, 0, $iColor)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETTEXTCOLOR, 0, $iColor)
EndIf
_WinAPI_InvalidateRect($hWnd)
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetToolTips($hWnd, $hToolTip)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETTOOLTIPS, 0, $hToolTip, 0, "wparam", "hwnd", "hwnd")
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_SETTOOLTIPS, 0, $hToolTip))
EndIf
EndFunc
Func _GUICtrlListView_SetUnicodeFormat($hWnd, $bUnicode)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETUNICODEFORMAT, $bUnicode)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETUNICODEFORMAT, $bUnicode, 0)
EndIf
EndFunc
Func _GUICtrlListView_SetView($hWnd, $iView)
Local $aView[5] = [$LV_VIEW_ICON, $LV_VIEW_DETAILS, $LV_VIEW_LIST, $LV_VIEW_SMALLICON, $LV_VIEW_TILE]
If ($iView < 0) Or ($iView > 4) Then Return False
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETVIEW, $aView[$iView]) <> -1
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETVIEW, $aView[$iView], 0) <> -1
EndIf
EndFunc
Func _GUICtrlListView_SetWorkAreas($hWnd, $iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iRight)
DllStructSetData($tRECT, "Bottom", $iBottom)
__GUICtrl_SendMsg($hWnd, $LVM_SETWORKAREAS, 1, $tRECT, 0, False, -1)
EndFunc
Func _GUICtrlListView_SimpleSort($hWnd, ByRef $vSortSense, $iCol, $bToggleSense = True)
Local $iItemCount = _GUICtrlListView_GetItemCount($hWnd)
If $iItemCount Then
Local $iDescending = 0
If UBound($vSortSense) Then
$iDescending = $vSortSense[$iCol]
Else
$iDescending = $vSortSense
EndIf
Local $vSeparatorChar = Opt('GUIDataSeparatorChar')
Local $iColumnCount = _GUICtrlListView_GetColumnCount($hWnd)
Local Enum $iIndexValue = $iColumnCount, $iItemParam
Local $aListViewItems[$iItemCount][$iColumnCount + 2]
Local $sSelectedItems = _GUICtrlListView_GetSelectedIndices($hWnd)
Local $aSelectedItems[1] = [0]
If Not $sSelectedItems = "" Then $aSelectedItems = StringSplit($sSelectedItems, $vSeparatorChar)
Local $aCheckedItems = __GUICtrlListView_GetCheckedIndices($hWnd)
Local $sItemText, $iFocused = -1
For $i = 0 To $iItemCount - 1
If $iFocused = -1 Then
If _GUICtrlListView_GetItemFocused($hWnd, $i) Then $iFocused = $i
EndIf
_GUICtrlListView_SetItemSelected($hWnd, $i, False)
_GUICtrlListView_SetItemChecked($hWnd, $i, False)
For $j = 0 To $iColumnCount - 1
$sItemText = StringStripWS(_GUICtrlListView_GetItemText($hWnd, $i, $j), $STR_STRIPTRAILING)
If (StringIsFloat($sItemText) Or StringIsInt($sItemText)) Then
$aListViewItems[$i][$j] = Number($sItemText)
Else
$aListViewItems[$i][$j] = $sItemText
EndIf
Next
$aListViewItems[$i][$iIndexValue] = $i
$aListViewItems[$i][$iItemParam] = _GUICtrlListView_GetItemParam($hWnd, $i)
Next
_ArraySort($aListViewItems, $iDescending, 0, 0, $iCol)
For $i = 0 To $iItemCount - 1
For $j = 0 To $iColumnCount - 1
_GUICtrlListView_SetItemText($hWnd, $i, $aListViewItems[$i][$j], $j)
Next
_GUICtrlListView_SetItemParam($hWnd, $i, $aListViewItems[$i][$iItemParam])
For $j = 1 To $aSelectedItems[0]
If $aListViewItems[$i][$iIndexValue] = $aSelectedItems[$j] Then
If $aListViewItems[$i][$iIndexValue] = $iFocused Then
_GUICtrlListView_SetItemSelected($hWnd, $i, True, True)
Else
_GUICtrlListView_SetItemSelected($hWnd, $i, True)
EndIf
ExitLoop
EndIf
Next
For $j = 1 To $aCheckedItems[0]
If $aListViewItems[$i][$iIndexValue] = $aCheckedItems[$j] Then
_GUICtrlListView_SetItemChecked($hWnd, $i, True)
ExitLoop
EndIf
Next
Next
If $bToggleSense Then
If UBound($vSortSense) Then
$vSortSense[$iCol] = Not $iDescending
Else
$vSortSense = Not $iDescending
EndIf
EndIf
EndIf
EndFunc
#Au3Stripper_Ignore_Funcs=__GUICtrlListView_Sort
Func __GUICtrlListView_Sort($nItem1, $nItem2, $hWnd)
Local $iIndex, $sVal1, $sVal2, $nResult
Local $tBuffer, $iMsg
If $__g_aListViewSortInfo[$iIndex][0] Then
$tBuffer = $__g_tListViewBuffer
$iMsg = $LVM_GETITEMTEXTW
Else
$tBuffer = $__g_tListViewBufferANSI
$iMsg = $LVM_GETITEMTEXTA
EndIf
Local $tItem = $__g_tListViewItem
For $x = 1 To $__g_aListViewSortInfo[0][0]
If $hWnd = $__g_aListViewSortInfo[$x][1] Then
$iIndex = $x
ExitLoop
EndIf
Next
If $__g_aListViewSortInfo[$iIndex][3] = $__g_aListViewSortInfo[$iIndex][4] Then
If Not $__g_aListViewSortInfo[$iIndex][7] Then
$__g_aListViewSortInfo[$iIndex][5] *= -1
$__g_aListViewSortInfo[$iIndex][7] = 1
EndIf
Else
$__g_aListViewSortInfo[$iIndex][7] = 1
EndIf
$__g_aListViewSortInfo[$iIndex][6] = $__g_aListViewSortInfo[$iIndex][3]
DllStructSetData($tItem, "Mask", $LVIF_TEXT)
DllStructSetData($tItem, "SubItem", $__g_aListViewSortInfo[$iIndex][3])
__GUICtrl_SendMsg($hWnd, $iMsg, $nItem1, $tItem, $tBuffer, False, 6, True)
$sVal1 = DllStructGetData($tBuffer, 1)
__GUICtrl_SendMsg($hWnd, $iMsg, $nItem2, $tItem, $tBuffer, False, 6, True)
$sVal2 = DllStructGetData($tBuffer, 1)
If $__g_aListViewSortInfo[$iIndex][8] = 1 Then
If (StringIsFloat($sVal1) Or StringIsInt($sVal1)) Then $sVal1 = Number($sVal1)
If (StringIsFloat($sVal2) Or StringIsInt($sVal2)) Then $sVal2 = Number($sVal2)
EndIf
If $__g_aListViewSortInfo[$iIndex][8] < 2 Then
$nResult = 0
If $sVal1 < $sVal2 Then
$nResult = -1
ElseIf $sVal1 > $sVal2 Then
$nResult = 1
EndIf
Else
$nResult = DllCall('shlwapi.dll', 'int', 'StrCmpLogicalW', 'wstr', $sVal1, 'wstr', $sVal2)[0]
EndIf
$nResult = $nResult * $__g_aListViewSortInfo[$iIndex][5]
Return $nResult
EndFunc
Func _GUICtrlListView_SortItems($hWnd, $iCol)
Local $iRet, $iIndex, $pFunction, $hHeader, $iFormat
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
For $x = 1 To $__g_aListViewSortInfo[0][0]
If $hWnd = $__g_aListViewSortInfo[$x][1] Then
$iIndex = $x
ExitLoop
EndIf
Next
$pFunction = DllCallbackGetPtr($__g_aListViewSortInfo[$iIndex][2])
$__g_aListViewSortInfo[$iIndex][3] = $iCol
$__g_aListViewSortInfo[$iIndex][7] = 0
$__g_aListViewSortInfo[$iIndex][4] = $__g_aListViewSortInfo[$iIndex][6]
$iRet = _SendMessage($hWnd, $LVM_SORTITEMSEX, $hWnd, $pFunction, 0, "hwnd", "ptr")
If $iRet <> 0 Then
If $__g_aListViewSortInfo[$iIndex][9] Then
$hHeader = $__g_aListViewSortInfo[$iIndex][10]
For $x = 0 To _GUICtrlHeader_GetItemCount($hHeader) - 1
$iFormat = _GUICtrlHeader_GetItemFormat($hHeader, $x)
If BitAND($iFormat, $HDF_SORTDOWN) Then
_GUICtrlHeader_SetItemFormat($hHeader, $x, BitXOR($iFormat, $HDF_SORTDOWN))
ElseIf BitAND($iFormat, $HDF_SORTUP) Then
_GUICtrlHeader_SetItemFormat($hHeader, $x, BitXOR($iFormat, $HDF_SORTUP))
EndIf
Next
$iFormat = _GUICtrlHeader_GetItemFormat($hHeader, $iCol)
If $__g_aListViewSortInfo[$iIndex][5] = 1 Then
_GUICtrlHeader_SetItemFormat($hHeader, $iCol, BitOR($iFormat, $HDF_SORTUP))
Else
_GUICtrlHeader_SetItemFormat($hHeader, $iCol, BitOR($iFormat, $HDF_SORTDOWN))
EndIf
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func __GUICtrlListView_StateImageMaskToIndex($iMask)
Return BitShift(BitAND($iMask, $LVIS_STATEIMAGEMASK), 12)
EndFunc
Func _GUICtrlListView_SubItemHitTest($hWnd, $iX = -1, $iY = -1)
If $iX = -1 Then $iX = _WinAPI_GetMousePosX(True, $hWnd)
If $iY = -1 Then $iY = _WinAPI_GetMousePosY(True, $hWnd)
Local $tTest = DllStructCreate($tagLVHITTESTINFO)
DllStructSetData($tTest, "X", $iX)
DllStructSetData($tTest, "Y", $iY)
__GUICtrl_SendMsg($hWnd, $LVM_SUBITEMHITTEST, 0, $tTest, 0, True, -1)
Local $iFlags = DllStructGetData($tTest, "Flags")
Local $aTest[11]
$aTest[0] = DllStructGetData($tTest, "Item")
$aTest[1] = DllStructGetData($tTest, "SubItem")
$aTest[2] = BitAND($iFlags, $LVHT_NOWHERE) <> 0
$aTest[3] = BitAND($iFlags, $LVHT_ONITEMICON) <> 0
$aTest[4] = BitAND($iFlags, $LVHT_ONITEMLABEL) <> 0
$aTest[5] = BitAND($iFlags, $LVHT_ONITEMSTATEICON) <> 0
$aTest[6] = BitAND($iFlags, $LVHT_ONITEM) <> 0
$aTest[7] = BitAND($iFlags, $LVHT_ABOVE) <> 0
$aTest[8] = BitAND($iFlags, $LVHT_BELOW) <> 0
$aTest[9] = BitAND($iFlags, $LVHT_TOLEFT) <> 0
$aTest[10] = BitAND($iFlags, $LVHT_TORIGHT) <> 0
Return $aTest
EndFunc
Func _GUICtrlListView_UnRegisterSortCallBack($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
For $x = 1 To $__g_aListViewSortInfo[0][0]
If $hWnd = $__g_aListViewSortInfo[$x][1] Then
DllCallbackFree($__g_aListViewSortInfo[$x][2])
__GUICtrlListView_ArrayDelete($__g_aListViewSortInfo, $x)
$__g_aListViewSortInfo[0][0] -= 1
ExitLoop
EndIf
Next
EndFunc
Global Const $__IPADDRESSCONSTANT_WM_USER = 0X400
Global Const $IPM_CLEARADDRESS = ($__IPADDRESSCONSTANT_WM_USER + 100)
Global Const $IPM_SETADDRESS = ($__IPADDRESSCONSTANT_WM_USER + 101)
Global Const $IPM_GETADDRESS = ($__IPADDRESSCONSTANT_WM_USER + 102)
Global Const $IPM_SETRANGE = ($__IPADDRESSCONSTANT_WM_USER + 103)
Global Const $IPM_SETFOCUS = ($__IPADDRESSCONSTANT_WM_USER + 104)
Global Const $IPM_ISBLANK = ($__IPADDRESSCONSTANT_WM_USER + 105)
Global Const $IPN_FIRST = (-860)
Global Const $IPN_FIELDCHANGED = ($IPN_FIRST - 0)
Global Const $__IPADDRESSCONSTANT_ClassName = "SysIPAddress32"
Global Const $__IPADDRESSCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__IPADDRESSCONSTANT_LOGPIXELSX = 88
Global Const $__IPADDRESSCONSTANT_PROOF_QUALITY = 2
Func _GUICtrlIpAddress_Create($hWnd, $iX, $iY, $iWidth = 125, $iHeight = 25, $iStyles = 0x00000000, $iExstyles = 0x00000000)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If $iStyles = -1 Then $iStyles = 0x00000000
If $iExstyles = -1 Then $iExstyles = 0x00000000
Local $iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $__UDFGUICONSTANT_WS_TABSTOP, $iStyles)
Local Const $ICC_INTERNET_CLASSES = 0x0800
Local $tICCE = DllStructCreate('dword dwSize;dword dwICC')
DllStructSetData($tICCE, "dwSize", DllStructGetSize($tICCE))
DllStructSetData($tICCE, "dwICC", $ICC_INTERNET_CLASSES)
DllCall('comctl32.dll', 'bool', 'InitCommonControlsEx', 'struct*', $tICCE)
If @error Then Return SetError(@error, @extended, 0)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hIPAddress = _WinAPI_CreateWindowEx($iExstyles, $__IPADDRESSCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_WinAPI_SetFont($hIPAddress, _WinAPI_GetStockObject($__IPADDRESSCONSTANT_DEFAULT_GUI_FONT))
Return $hIPAddress
EndFunc
Func _GUICtrlIpAddress_ClearAddress($hWnd)
_SendMessage($hWnd, $IPM_CLEARADDRESS)
EndFunc
Func _GUICtrlIpAddress_Destroy($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__IPADDRESSCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If _WinAPI_InProcess($hWnd, $__g_hGUICtrl_LastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlIpAddress_Get($hWnd)
Local $tIP = _GUICtrlIpAddress_GetEx($hWnd)
If @error Then Return SetError(2, 2, "")
Return StringFormat("%d.%d.%d.%d", DllStructGetData($tIP, "Field1"),  DllStructGetData($tIP, "Field2"),  DllStructGetData($tIP, "Field3"),  DllStructGetData($tIP, "Field4"))
EndFunc
Func _GUICtrlIpAddress_GetArray($hWnd)
Local $tIP = _GUICtrlIpAddress_GetEx($hWnd)
Local $aIP[4]
$aIP[0] = DllStructGetData($tIP, "Field1")
$aIP[1] = DllStructGetData($tIP, "Field2")
$aIP[2] = DllStructGetData($tIP, "Field3")
$aIP[3] = DllStructGetData($tIP, "Field4")
Return $aIP
EndFunc
Func _GUICtrlIpAddress_GetEx($hWnd)
Local $tIP = DllStructCreate($tagGETIPAddress)
__GUICtrl_SendMsg($hWnd, $IPM_GETADDRESS, 0, $tIP, 0, True)
Return $tIP
EndFunc
Func _GUICtrlIpAddress_IsBlank($hWnd)
Return _SendMessage($hWnd, $IPM_ISBLANK) <> 0
EndFunc
Func _GUICtrlIpAddress_Set($hWnd, $sAddress)
Local $aAddress = StringSplit($sAddress, ".")
If $aAddress[0] = 4 Then
Local $tIP = DllStructCreate($tagGETIPAddress)
For $x = 1 To 4
DllStructSetData($tIP, "Field" & $x, $aAddress[$x])
Next
_GUICtrlIpAddress_SetEx($hWnd, $tIP)
EndIf
EndFunc
Func _GUICtrlIpAddress_SetArray($hWnd, $aAddress)
If UBound($aAddress) = 4 Then
Local $tIP = DllStructCreate($tagGETIPAddress)
For $x = 0 To 3
DllStructSetData($tIP, "Field" & $x + 1, $aAddress[$x])
Next
_GUICtrlIpAddress_SetEx($hWnd, $tIP)
EndIf
EndFunc
Func _GUICtrlIpAddress_SetEx($hWnd, $tIP)
_SendMessage($hWnd, $IPM_SETADDRESS, 0,  _WinAPI_MakeLong(BitOR(DllStructGetData($tIP, "Field4"), 0x100 * DllStructGetData($tIP, "Field3")),  BitOR(DllStructGetData($tIP, "Field2"), 0x100 * DllStructGetData($tIP, "Field1"))))
EndFunc
Func _GUICtrlIpAddress_SetFocus($hWnd, $iIndex)
_SendMessage($hWnd, $IPM_SETFOCUS, $iIndex)
EndFunc
Func _GUICtrlIpAddress_SetFont($hWnd, $sFaceName = "Arial", $iFontSize = 12, $iFontWeight = 400, $bFontItalic = False)
Local $hDC = _WinAPI_GetDC(0)
Local $iHeight = Round(($iFontSize * _WinAPI_GetDeviceCaps($hDC, $__IPADDRESSCONSTANT_LOGPIXELSX)) / 72, 0)
_WinAPI_ReleaseDC(0, $hDC)
Local $tFont = DllStructCreate($tagLOGFONT)
DllStructSetData($tFont, "Height", $iHeight)
DllStructSetData($tFont, "Weight", $iFontWeight)
DllStructSetData($tFont, "Italic", $bFontItalic)
DllStructSetData($tFont, "Underline", False)
DllStructSetData($tFont, "Strikeout", False)
DllStructSetData($tFont, "Quality", $__IPADDRESSCONSTANT_PROOF_QUALITY)
DllStructSetData($tFont, "FaceName", $sFaceName)
Local $hFont = _WinAPI_CreateFontIndirect($tFont)
_WinAPI_SetFont($hWnd, $hFont)
EndFunc
Func _GUICtrlIpAddress_SetRange($hWnd, $iIndex, $iLowRange = 0, $iHighRange = 255)
If ($iLowRange < 0 Or $iLowRange > $iHighRange) Or $iHighRange > 255 Or ($iIndex < 0 Or $iIndex > 3) Then Return SetError(-1, -1, False)
Return _SendMessage($hWnd, $IPM_SETRANGE, $iIndex, BitOR($iLowRange, 0x100 * $iHighRange)) <> 0
EndFunc
Func _GUICtrlIpAddress_ShowHide($hWnd, $iState)
If $iState <> @SW_HIDE And $iState <> @SW_SHOW Then Return SetError(1, 1, 0)
Return _WinAPI_ShowWindow($hWnd, $iState) <> 0
EndFunc
Global Const $__MISCCONSTANT_CC_ANYCOLOR = 0x0100
Global Const $__MISCCONSTANT_CC_FULLOPEN = 0x0002
Global Const $__MISCCONSTANT_CC_RGBINIT = 0x0001
Global Const $tagCHOOSECOLOR = "dword Size;hwnd hWndOwnder;handle hInstance;dword rgbResult;ptr CustColors;dword Flags;lparam lCustData;" &  "ptr lpfnHook;ptr lpTemplateName"
Global Const $tagCHOOSEFONT = "dword Size;hwnd hWndOwner;handle hDC;ptr LogFont;int PointSize;dword Flags;dword rgbColors;lparam CustData;" &  "ptr fnHook;ptr TemplateName;handle hInstance;ptr szStyle;word FontType;int SizeMin;int SizeMax"
Func _ChooseColor($vReturnType = 0, $iColorRef = 0, $iRefType = 0, $hWndOwnder = 0)
Local $tagCustcolors = "dword[16]"
Local $tChoose = DllStructCreate($tagCHOOSECOLOR)
Local Static $tCc = DllStructCreate($tagCustcolors)
Local $iReturnType, $vReturn
If $vReturnType = -9 Or $vReturnType = -10 Then
Local $a_tCc = __ChooseColor_StructToArray($tCc)
$a_tCc[0] = -1
If $vReturnType = -10 Then $tCc = DllStructCreate($tagCustcolors)
Return $a_tCc
ElseIf $vReturnType > 9 Then
$tCc = DllStructCreate($tagCustcolors)
$iReturnType = $vReturnType - 10
ElseIf IsArray($vReturnType) Then
If UBound($vReturnType, $UBOUND_ROWS) = 17 And UBound($vReturnType, $UBOUND_DIMENSIONS) = 1 Then
For $n = 1 To 16
DllStructSetData($tCc, 1, $vReturnType[$n], $n)
Next
If $vReturnType[0] = -9 Then
$vReturnType[0] = 0
Return $vReturnType
EndIf
If $vReturnType[0] > 9 Then $vReturnType[0] -= 10
$iReturnType = $vReturnType[0]
Else
Return SetError(-5, 0, -1)
EndIf
Else
$iReturnType = $vReturnType
EndIf
If $iReturnType < 0 Or $iReturnType > 2 Then
If IsArray($vReturnType) Then
$vReturnType[0] = -1
Return SetError(-4, 0, $vReturnType)
EndIf
Return SetError(-4, 0, -1)
EndIf
If $iRefType = 1 Then
$iColorRef = Int($iColorRef)
ElseIf $iRefType = 2 Then
$iColorRef = Hex(String($iColorRef), 6)
$iColorRef = '0x' & StringMid($iColorRef, 5, 2) & StringMid($iColorRef, 3, 2) & StringMid($iColorRef, 1, 2)
EndIf
DllStructSetData($tChoose, "Size", DllStructGetSize($tChoose))
DllStructSetData($tChoose, "hWndOwnder", $hWndOwnder)
DllStructSetData($tChoose, "rgbResult", $iColorRef)
DllStructSetData($tChoose, "CustColors", DllStructGetPtr($tCc))
DllStructSetData($tChoose, "Flags", BitOR($__MISCCONSTANT_CC_ANYCOLOR, $__MISCCONSTANT_CC_FULLOPEN, $__MISCCONSTANT_CC_RGBINIT))
Local $aResult = DllCall("comdlg32.dll", "bool", "ChooseColor", "struct*", $tChoose)
Local $iError = @error
If @error Then
Local $iExtended = @extended
If IsArray($vReturnType) Then
$vReturnType[0] = -1
Return SetError($iError, $iExtended, $vReturnType)
EndIf
Return SetError($iError, $iExtended, -1)
EndIf
If $aResult[0] = 0 Then
If IsArray($vReturnType) Then
$vReturnType[0] = -1
Return SetError(-3, 0, $vReturnType)
EndIf
Return SetError(-3, 0, -1)
EndIf
Local $sColor_picked = DllStructGetData($tChoose, "rgbResult")
If $iReturnType = 1 Then
$vReturn = '0x' & Hex(String($sColor_picked), 6)
ElseIf $iReturnType = 2 Then
$sColor_picked = Hex(String($sColor_picked), 6)
$vReturn = '0x' & StringMid($sColor_picked, 5, 2) & StringMid($sColor_picked, 3, 2) & StringMid($sColor_picked, 1, 2)
Else
$vReturn = $sColor_picked
EndIf
If IsArray($vReturnType) Then
$vReturnType = __ChooseColor_StructToArray($tCc)
$vReturnType[0] = $vReturn
Return $vReturnType
EndIf
Return $vReturn
EndFunc
Func __ChooseColor_StructToArray(ByRef $tStruct)
Local $aArray[17]
For $n = 1 To 16
$aArray[$n] = DllStructGetData($tStruct, 1, $n)
Next
Return $aArray
EndFunc
Func _ChooseFont($sFontName = "Courier New", $iPointSize = 10, $iFontColorRef = 0, $iFontWeight = 0, $bItalic = False, $bUnderline = False, $bStrikethru = False, $hWndOwner = 0)
Local $iItalic = 0, $iUnderline = 0, $iStrikeout = 0
$iFontColorRef = BitOR(BitShift(BitAND($iFontColorRef, 0x000000FF), -16), BitAND($iFontColorRef, 0x0000FF00), BitShift(BitAND($iFontColorRef, 0x00FF0000), 16))
Local $hDC = __MISC_GetDC(0)
Local $iHeight = Round(($iPointSize * __MISC_GetDeviceCaps($hDC, $LOGPIXELSX)) / 72, 0)
__MISC_ReleaseDC(0, $hDC)
Local $tChooseFont = DllStructCreate($tagCHOOSEFONT)
Local $tLogFont = DllStructCreate($tagLOGFONT)
DllStructSetData($tChooseFont, "Size", DllStructGetSize($tChooseFont))
DllStructSetData($tChooseFont, "hWndOwner", $hWndOwner)
DllStructSetData($tChooseFont, "LogFont", DllStructGetPtr($tLogFont))
DllStructSetData($tChooseFont, "PointSize", $iPointSize)
DllStructSetData($tChooseFont, "Flags", BitOR($CF_SCREENFONTS, $CF_PRINTERFONTS, $CF_EFFECTS, $CF_INITTOLOGFONTSTRUCT, $CF_NOSCRIPTSEL))
DllStructSetData($tChooseFont, "rgbColors", $iFontColorRef)
DllStructSetData($tChooseFont, "FontType", 0)
DllStructSetData($tLogFont, "Height", $iHeight)
DllStructSetData($tLogFont, "Weight", $iFontWeight)
DllStructSetData($tLogFont, "Italic", $bItalic)
DllStructSetData($tLogFont, "Underline", $bUnderline)
DllStructSetData($tLogFont, "Strikeout", $bStrikethru)
DllStructSetData($tLogFont, "FaceName", $sFontName)
Local $aCall = DllCall("comdlg32.dll", "bool", "ChooseFontW", "struct*", $tChooseFont)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] = 0 Then Return SetError(-3, -3, -1)
Local $sFaceName = DllStructGetData($tLogFont, "FaceName")
If StringLen($sFaceName) = 0 And StringLen($sFontName) > 0 Then $sFaceName = $sFontName
If DllStructGetData($tLogFont, "Italic") Then $iItalic = 2
If DllStructGetData($tLogFont, "Underline") Then $iUnderline = 4
If DllStructGetData($tLogFont, "Strikeout") Then $iStrikeout = 8
Local $iAttributes = BitOR($iItalic, $iUnderline, $iStrikeout)
Local $iSize = DllStructGetData($tChooseFont, "PointSize") / 10
Local $iColorRef = DllStructGetData($tChooseFont, "rgbColors")
Local $iWeight = DllStructGetData($tLogFont, "Weight")
Local $sColor_picked = Hex(String($iColorRef), 6)
Return StringSplit($iAttributes & "," & $sFaceName & "," & $iSize & "," & $iWeight & "," & $iColorRef & "," & '0x' & $sColor_picked & "," & '0x' & StringMid($sColor_picked, 5, 2) & StringMid($sColor_picked, 3, 2) & StringMid($sColor_picked, 1, 2), ",")
EndFunc
Func _ClipPutFile($sFilePath, $sDelimiter = "|")
Local Const $GMEM_MOVEABLE = 0x0002, $CF_HDROP = 15
$sFilePath &= $sDelimiter & $sDelimiter
Local $nGlobMemSize = 2 * (StringLen($sFilePath) + 20)
Local $aCall = DllCall("user32.dll", "bool", "OpenClipboard", "hwnd", 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, _WinAPI_GetLastError(), False)
Local $iError = 0, $iLastError = 0
$aCall = DllCall("user32.dll", "bool", "EmptyClipboard")
If @error Or Not $aCall[0] Then
$iError = @error + 20
$iLastError = _WinAPI_GetLastError()
Else
$aCall = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $GMEM_MOVEABLE, "ulong_ptr", $nGlobMemSize)
If @error Or Not $aCall[0] Then
$iError = @error + 30
$iLastError = _WinAPI_GetLastError()
Else
Local $hGlobal = $aCall[0]
$aCall = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hGlobal)
If @error Or Not $aCall[0] Then
$iError = @error + 40
$iLastError = _WinAPI_GetLastError()
Else
Local $hLock = $aCall[0]
Local $tDROPFILES = DllStructCreate("dword pFiles;" & $tagPOINT & ";bool fNC;bool fWide;wchar[" & StringLen($sFilePath) + 1 & "]", $hLock)
If @error Then Return SetError(@error + 50, 6, False)
Local $tStruct = DllStructCreate("dword;long;long;bool;bool")
DllStructSetData($tDROPFILES, "pFiles", DllStructGetSize($tStruct))
DllStructSetData($tDROPFILES, "X", 0)
DllStructSetData($tDROPFILES, "Y", 0)
DllStructSetData($tDROPFILES, "fNC", 0)
DllStructSetData($tDROPFILES, "fWide", 1)
DllStructSetData($tDROPFILES, 6, $sFilePath)
For $i = 1 To StringLen($sFilePath)
If DllStructGetData($tDROPFILES, 6, $i) = $sDelimiter Then DllStructSetData($tDROPFILES, 6, Chr(0), $i)
Next
$aCall = DllCall("user32.dll", "handle", "SetClipboardData", "uint", $CF_HDROP, "handle", $hGlobal)
If @error Or Not $aCall[0] Then
$iError = @error + 60
$iLastError = _WinAPI_GetLastError()
EndIf
$aCall = DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hGlobal)
If (@error Or Not $aCall[0]) And Not $iError And _WinAPI_GetLastError() Then
$iError = @error + 80
$iLastError = _WinAPI_GetLastError()
EndIf
EndIf
$aCall = DllCall("kernel32.dll", "ptr", "GlobalFree", "handle", $hGlobal)
If (@error Or $aCall[0]) And Not $iError Then
$iError = @error + 90
$iLastError = _WinAPI_GetLastError()
EndIf
EndIf
EndIf
$aCall = DllCall("user32.dll", "bool", "CloseClipboard")
If (@error Or Not $aCall[0]) And Not $iError Then Return SetError(@error + 70, _WinAPI_GetLastError(), False)
If $iError Then Return SetError($iError, $iLastError, False)
Return True
EndFunc
Func _MouseTrap($iLeft = 0, $iTop = 0, $iRight = 0, $iBottom = 0)
Local $aCall
If $iLeft = Default Then $iLeft = 0
If $iTop = Default Then $iTop = 0
If $iRight = Default Then $iRight = 0
If $iBottom = Default Then $iBottom = 0
If @NumParams = 0 Then
$aCall = DllCall("user32.dll", "bool", "ClipCursor", "ptr", 0)
If @error Or Not $aCall[0] Then Return SetError(1, _WinAPI_GetLastError(), False)
Else
If @NumParams = 2 Then
$iRight = $iLeft + 1
$iBottom = $iTop + 1
EndIf
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iRight)
DllStructSetData($tRECT, "Bottom", $iBottom)
$aCall = DllCall("user32.dll", "bool", "ClipCursor", "struct*", $tRECT)
If @error Or Not $aCall[0] Then Return SetError(2, _WinAPI_GetLastError(), False)
EndIf
Return True
EndFunc
Func _Singleton($sOccurrenceName, $iFlag = 0)
Local Const $ERROR_ALREADY_EXISTS = 183
Local Const $SECURITY_DESCRIPTOR_REVISION = 1
Local $tSecurityAttributes = 0
If BitAND($iFlag, 2) Then
Local $tSecurityDescriptor = DllStructCreate("byte;byte;word;ptr[4]")
Local $aCall = DllCall("advapi32.dll", "bool", "InitializeSecurityDescriptor",  "struct*", $tSecurityDescriptor, "dword", $SECURITY_DESCRIPTOR_REVISION)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then
$aCall = DllCall("advapi32.dll", "bool", "SetSecurityDescriptorDacl",  "struct*", $tSecurityDescriptor, "bool", 1, "ptr", 0, "bool", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then
$tSecurityAttributes = DllStructCreate($tagSECURITY_ATTRIBUTES)
DllStructSetData($tSecurityAttributes, 1, DllStructGetSize($tSecurityAttributes))
DllStructSetData($tSecurityAttributes, 2, DllStructGetPtr($tSecurityDescriptor))
DllStructSetData($tSecurityAttributes, 3, 0)
EndIf
EndIf
EndIf
Local $aHandle = DllCall("kernel32.dll", "handle", "CreateMutexW", "struct*", $tSecurityAttributes, "bool", 1, "wstr", $sOccurrenceName)
If @error Then Return SetError(@error, @extended, 0)
Local $aLastError = DllCall("kernel32.dll", "dword", "GetLastError")
If @error Then Return SetError(@error, @extended, 0)
If $aLastError[0] = $ERROR_ALREADY_EXISTS Then
If BitAND($iFlag, 1) Then
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $aHandle[0])
If @error Then Return SetError(@error, @extended, 0)
Return SetError($aLastError[0], $aLastError[0], 0)
Else
Exit -1
EndIf
EndIf
Return $aHandle[0]
EndFunc
Func _IsPressed($sHexKey, $vDLL = "user32.dll")
Local $aCall = DllCall($vDLL, "short", "GetAsyncKeyState", "int", "0x" & $sHexKey)
If @error Then Return SetError(@error, @extended, False)
Return BitAND($aCall[0], 0x8000) <> 0
EndFunc
Func _VersionCompare($sVersion1, $sVersion2)
If $sVersion1 = $sVersion2 Then Return 0
Local $sSubVersion1 = "", $sSubVersion2 = ""
If StringIsAlpha(StringRight($sVersion1, 1)) Then
$sSubVersion1 = StringRight($sVersion1, 1)
$sVersion1 = StringTrimRight($sVersion1, 1)
EndIf
If StringIsAlpha(StringRight($sVersion2, 1)) Then
$sSubVersion2 = StringRight($sVersion2, 1)
$sVersion2 = StringTrimRight($sVersion2, 1)
EndIf
Local $aVersion1 = StringSplit($sVersion1, ".,"),  $aVersion2 = StringSplit($sVersion2, ".,")
Local $iPartDifference = ($aVersion1[0] - $aVersion2[0])
If $iPartDifference < 0 Then
ReDim $aVersion1[UBound($aVersion2)]
$aVersion1[0] = UBound($aVersion1) - 1
For $i = (UBound($aVersion1) - Abs($iPartDifference)) To $aVersion1[0]
$aVersion1[$i] = "0"
Next
ElseIf $iPartDifference > 0 Then
ReDim $aVersion2[UBound($aVersion1)]
$aVersion2[0] = UBound($aVersion2) - 1
For $i = (UBound($aVersion2) - Abs($iPartDifference)) To $aVersion2[0]
$aVersion2[$i] = "0"
Next
EndIf
For $i = 1 To $aVersion1[0]
If StringIsDigit($aVersion1[$i]) And StringIsDigit($aVersion2[$i]) Then
If Number($aVersion1[$i]) > Number($aVersion2[$i]) Then
Return SetExtended(2, 1)
ElseIf Number($aVersion1[$i]) < Number($aVersion2[$i]) Then
Return SetExtended(2, -1)
ElseIf $i = $aVersion1[0] Then
If $sSubVersion1 > $sSubVersion2 Then
Return SetExtended(3, 1)
ElseIf $sSubVersion1 < $sSubVersion2 Then
Return SetExtended(3, -1)
EndIf
EndIf
Else
If $aVersion1[$i] > $aVersion2[$i] Then
Return SetExtended(1, 1)
ElseIf $aVersion1[$i] < $aVersion2[$i] Then
Return SetExtended(1, -1)
EndIf
EndIf
Next
Return SetExtended(Abs($iPartDifference), 0)
EndFunc
Func __MISC_GetDC($hWnd)
Local $aCall = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Or Not $aCall[0] Then Return SetError(1, _WinAPI_GetLastError(), 0)
Return $aCall[0]
EndFunc
Func __MISC_GetDeviceCaps($hDC, $iIndex)
Local $aCall = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func __MISC_ReleaseDC($hWnd, $hDC)
Local $aCall = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Global Const $GDIP_DASHCAPFLAT = 0
Global Const $GDIP_DASHCAPROUND = 2
Global Const $GDIP_DASHCAPTRIANGLE = 3
Global Const $GDIP_DASHSTYLESOLID = 0
Global Const $GDIP_DASHSTYLEDASH = 1
Global Const $GDIP_DASHSTYLEDOT = 2
Global Const $GDIP_DASHSTYLEDASHDOT = 3
Global Const $GDIP_DASHSTYLEDASHDOTDOT = 4
Global Const $GDIP_DASHSTYLECUSTOM = 5
Global Const $GDIP_EPGCHROMINANCETABLE = '{F2E455DC-09B3-4316-8260-676ADA32481C}'
Global Const $GDIP_EPGCOLORDEPTH = '{66087055-AD66-4C7C-9A18-38A2310B8337}'
Global Const $GDIP_EPGCOMPRESSION = '{E09D739D-CCD4-44EE-8EBA-3FBF8BE4FC58}'
Global Const $GDIP_EPGLUMINANCETABLE = '{EDB33BCE-0266-4A77-B904-27216099E717}'
Global Const $GDIP_EPGQUALITY = '{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}'
Global Const $GDIP_EPGRENDERMETHOD = '{6D42C53A-229A-4825-8BB7-5C99E2B9A8B8}'
Global Const $GDIP_EPGSAVEFLAG = '{292266FC-AC40-47BF-8CFC-A85B89A655DE}'
Global Const $GDIP_EPGSCANMETHOD = '{3A4E2661-3109-4E56-8536-42C156E7DCFA}'
Global Const $GDIP_EPGTRANSFORMATION = '{8D0EB2D1-A58E-4EA8-AA14-108074B7B6F9}'
Global Const $GDIP_EPGVERSION = '{24D18C76-814A-41A4-BF53-1C219CCCF797}'
Global Const $GDIP_EPTBYTE = 1
Global Const $GDIP_EPTASCII = 2
Global Const $GDIP_EPTSHORT = 3
Global Const $GDIP_EPTLONG = 4
Global Const $GDIP_EPTRATIONAL = 5
Global Const $GDIP_EPTLONGRANGE = 6
Global Const $GDIP_EPTUNDEFINED = 7
Global Const $GDIP_EPTRATIONALRANGE = 8
Global Const $GDIP_ERROK = 0
Global Const $GDIP_ERRGENERICERROR = 1
Global Const $GDIP_ERRINVALIDPARAMETER = 2
Global Const $GDIP_ERROUTOFMEMORY = 3
Global Const $GDIP_ERROBJECTBUSY = 4
Global Const $GDIP_ERRINSUFFICIENTBUFFER = 5
Global Const $GDIP_ERRNOTIMPLEMENTED = 6
Global Const $GDIP_ERRWIN32ERROR = 7
Global Const $GDIP_ERRWRONGSTATE = 8
Global Const $GDIP_ERRABORTED = 9
Global Const $GDIP_ERRFILENOTFOUND = 10
Global Const $GDIP_ERRVALUEOVERFLOW = 11
Global Const $GDIP_ERRACCESSDENIED = 12
Global Const $GDIP_ERRUNKNOWNIMAGEFORMAT = 13
Global Const $GDIP_ERRFONTFAMILYNOTFOUND = 14
Global Const $GDIP_ERRFONTSTYLENOTFOUND = 15
Global Const $GDIP_ERRNOTTRUETYPEFONT = 16
Global Const $GDIP_ERRUNSUPPORTEDGDIVERSION = 17
Global Const $GDIP_ERRGDIPLUSNOTINITIALIZED = 18
Global Const $GDIP_ERRPROPERTYNOTFOUND = 19
Global Const $GDIP_ERRPROPERTYNOTSUPPORTED = 20
Global Const $GDIP_EVTCOMPRESSIONLZW = 2
Global Const $GDIP_EVTCOMPRESSIONCCITT3 = 3
Global Const $GDIP_EVTCOMPRESSIONCCITT4 = 4
Global Const $GDIP_EVTCOMPRESSIONRLE = 5
Global Const $GDIP_EVTCOMPRESSIONNONE = 6
Global Const $GDIP_EVTTRANSFORMROTATE90 = 13
Global Const $GDIP_EVTTRANSFORMROTATE180 = 14
Global Const $GDIP_EVTTRANSFORMROTATE270 = 15
Global Const $GDIP_EVTTRANSFORMFLIPHORIZONTAL = 16
Global Const $GDIP_EVTTRANSFORMFLIPVERTICAL = 17
Global Const $GDIP_EVTMULTIFRAME = 18
Global Const $GDIP_EVTLASTFRAME = 19
Global Const $GDIP_EVTFLUSH = 20
Global Const $GDIP_EVTFRAMEDIMENSIONPAGE = 23
Global Const $GDIP_ICFENCODER = 0x00000001
Global Const $GDIP_ICFDECODER = 0x00000002
Global Const $GDIP_ICFSUPPORTBITMAP = 0x00000004
Global Const $GDIP_ICFSUPPORTVECTOR = 0x00000008
Global Const $GDIP_ICFSEEKABLEENCODE = 0x00000010
Global Const $GDIP_ICFBLOCKINGDECODE = 0x00000020
Global Const $GDIP_ICFBUILTIN = 0x00010000
Global Const $GDIP_ICFSYSTEM = 0x00020000
Global Const $GDIP_ICFUSER = 0x00040000
Global Const $GDIP_ILMREAD = 0x0001
Global Const $GDIP_ILMWRITE = 0x0002
Global Const $GDIP_ILMUSERINPUTBUF = 0x0004
Global Const $GDIP_LINECAPFLAT = 0x00
Global Const $GDIP_LINECAPSQUARE = 0x01
Global Const $GDIP_LINECAPROUND = 0x02
Global Const $GDIP_LINECAPTRIANGLE = 0x03
Global Const $GDIP_LINECAPNOANCHOR = 0x10
Global Const $GDIP_LINECAPSQUAREANCHOR = 0x11
Global Const $GDIP_LINECAPROUNDANCHOR = 0x12
Global Const $GDIP_LINECAPDIAMONDANCHOR = 0x13
Global Const $GDIP_LINECAPARROWANCHOR = 0x14
Global Const $GDIP_LINECAPCUSTOM = 0xFF
Global Const $GDIP_PXF01INDEXED = 0x00030101
Global Const $GDIP_PXF04INDEXED = 0x00030402
Global Const $GDIP_PXF08INDEXED = 0x00030803
Global Const $GDIP_PXF16GRAYSCALE = 0x00101004
Global Const $GDIP_PXF16RGB555 = 0x00021005
Global Const $GDIP_PXF16RGB565 = 0x00021006
Global Const $GDIP_PXF16ARGB1555 = 0x00061007
Global Const $GDIP_PXF24RGB = 0x00021808
Global Const $GDIP_PXF32RGB = 0x00022009
Global Const $GDIP_PXF32ARGB = 0x0026200A
Global Const $GDIP_PXF32PARGB = 0x000E200B
Global Const $GDIP_PXF48RGB = 0x0010300C
Global Const $GDIP_PXF64ARGB = 0x0034400D
Global Const $GDIP_PXF64PARGB = 0x001A400E
Global Const $GDIP_IMAGEFORMAT_UNDEFINED = "{B96B3CA9-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_MEMORYBMP = "{B96B3CAA-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_BMP = "{B96B3CAB-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_EMF = "{B96B3CAC-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_WMF = "{B96B3CAD-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_JPEG = "{B96B3CAE-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_PNG = "{B96B3CAF-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_GIF = "{B96B3CB0-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_TIFF = "{B96B3CB1-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_EXIF = "{B96B3CB2-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_ICON = "{B96B3CB5-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGETYPE_UNKNOWN = 0
Global Const $GDIP_IMAGETYPE_BITMAP = 1
Global Const $GDIP_IMAGETYPE_METAFILE = 2
Global Const $GDIP_IMAGEFLAGS_NONE = 0x0
Global Const $GDIP_IMAGEFLAGS_SCALABLE = 0x0001
Global Const $GDIP_IMAGEFLAGS_HASALPHA = 0x0002
Global Const $GDIP_IMAGEFLAGS_HASTRANSLUCENT = 0x0004
Global Const $GDIP_IMAGEFLAGS_PARTIALLYSCALABLE = 0x0008
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_RGB = 0x0010
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_CMYK = 0x0020
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_GRAY = 0x0040
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_YCBCR = 0x0080
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_YCCK = 0x0100
Global Const $GDIP_IMAGEFLAGS_HASREALDPI = 0x1000
Global Const $GDIP_IMAGEFLAGS_HASREALPIXELSIZE = 0x2000
Global Const $GDIP_IMAGEFLAGS_READONLY = 0x00010000
Global Const $GDIP_IMAGEFLAGS_CACHING = 0x00020000
Global Const $GDIP_SMOOTHINGMODE_INVALID = -1
Global Const $GDIP_SMOOTHINGMODE_DEFAULT = 0
Global Const $GDIP_SMOOTHINGMODE_HIGHSPEED = 1
Global Const $GDIP_SMOOTHINGMODE_HIGHQUALITY = 2
Global Const $GDIP_SMOOTHINGMODE_NONE = 3
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS8X4 = 4
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS = $GDIP_SMOOTHINGMODE_ANTIALIAS8X4
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 = 5
Global Const $GDIP_RLUM = 0.3086
Global Const $GDIP_GLUM = 0.6094
Global Const $GDIP_BLUM = 0.0820
Global Const $GDIP_INTERPOLATIONMODE_INVALID = -1
Global Const $GDIP_INTERPOLATIONMODE_DEFAULT = 0
Global Const $GDIP_INTERPOLATIONMODE_LOWQUALITY = 1
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITY = 2
Global Const $GDIP_INTERPOLATIONMODE_BILINEAR = 3
Global Const $GDIP_INTERPOLATIONMODE_BICUBIC = 4
Global Const $GDIP_INTERPOLATIONMODE_NEARESTNEIGHBOR = 5
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITYBILINEAR = 6
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC = 7
Global Const $GDIP_PIXELOFFSETMODE_INVALID = -1
Global Const $GDIP_PIXELOFFSETMODE_DEFAULT = 0
Global Const $GDIP_PIXELOFFSETMODE_HIGHSPEED = 1
Global Const $GDIP_PIXELOFFSETMODE_HIGHQUALITY = 2
Global Const $GDIP_PIXELOFFSETMODE_NONE = 3
Global Const $GDIP_PIXELOFFSETMODE_HALF = 4
Global Const $GDIP_PENSETLINEJOIN_MITER = 0
Global Const $GDIP_PENSETLINEJOIN_BEVEL = 1
Global Const $GDIP_PENSETLINEJOIN_ROUND = 2
Global Const $GDIP_PENSETLINEJOIN_MITERCLIPPED = 3
Global Const $GDIP_FillModeAlternate = 0
Global Const $GDIP_FillModeWinding = 1
Global Const $GDIP_QUALITYMODEINVALID = -1
Global Const $GDIP_QUALITYMODEDEFAULT = 0
Global Const $GDIP_QUALITYMODELOW = 1
Global Const $GDIP_QUALITYMODEHIGH = 2
Global Const $GDIP_COMPOSITINGMODESOURCEOVER = 0
Global Const $GDIP_COMPOSITINGMODESOURCECOPY = 1
Global Const $GDIP_COMPOSITINGQUALITY_DEFAULT = 0
Global Const $GDIP_COMPOSITINGQUALITY_HIGHSPEED = 1
Global Const $GDIP_COMPOSITINGQUALITY_HIGHQUALITY = 2
Global Const $GDIP_COMPOSITINGQUALITY_GAMMACORRECTED = 3
Global Const $GDIP_COMPOSITINGQUALITY_ASSUMELINEAR = 4
Global Const $GDIP_HATCHSTYLE_HORIZONTAL = 0
Global Const $GDIP_HATCHSTYLE_VERTICAL = 1
Global Const $GDIP_HATCHSTYLE_FORWARDDIAGONAL = 2
Global Const $GDIP_HATCHSTYLE_BACKWARDDIAGONAL = 3
Global Const $GDIP_HATCHSTYLE_CROSS = 4
Global Const $GDIP_HATCHSTYLE_DIAGONALCROSS = 5
Global Const $GDIP_HATCHSTYLE_05PERCENT = 6
Global Const $GDIP_HATCHSTYLE_10PERCENT = 7
Global Const $GDIP_HATCHSTYLE_20PERCENT = 8
Global Const $GDIP_HATCHSTYLE_25PERCENT = 9
Global Const $GDIP_HATCHSTYLE_30PERCENT = 10
Global Const $GDIP_HATCHSTYLE_40PERCENT = 11
Global Const $GDIP_HATCHSTYLE_50PERCENT = 12
Global Const $GDIP_HATCHSTYLE_60PERCENT = 13
Global Const $GDIP_HATCHSTYLE_70PERCENT = 14
Global Const $GDIP_HATCHSTYLE_75PERCENT = 15
Global Const $GDIP_HATCHSTYLE_80PERCENT = 16
Global Const $GDIP_HATCHSTYLE_90PERCENT = 17
Global Const $GDIP_HATCHSTYLE_LIGHTDOWNWARDDIAGONAL = 18
Global Const $GDIP_HATCHSTYLE_LIGHTUPWARDDIAGONAL = 19
Global Const $GDIP_HATCHSTYLE_DARKDOWNWARDDIAGONAL = 20
Global Const $GDIP_HATCHSTYLE_DARKUPWARDDIAGONAL = 21
Global Const $GDIP_HATCHSTYLE_WIDEDOWNWARDDIAGONAL = 22
Global Const $GDIP_HATCHSTYLE_WIDEUPWARDDIAGONAL = 23
Global Const $GDIP_HATCHSTYLE_LIGHTVERTICAL = 24
Global Const $GDIP_HATCHSTYLE_LIGHTHORIZONTAL = 25
Global Const $GDIP_HATCHSTYLE_NARROWVERTICAL = 26
Global Const $GDIP_HATCHSTYLE_NARROWHORIZONTAL = 27
Global Const $GDIP_HATCHSTYLE_DARKVERTICAL = 28
Global Const $GDIP_HATCHSTYLE_DARKHORIZONTAL = 29
Global Const $GDIP_HATCHSTYLE_DASHEDDOWNWARDDIAGONAL = 30
Global Const $GDIP_HATCHSTYLE_DASHEDUPWARDDIAGONAL = 31
Global Const $GDIP_HATCHSTYLE_DASHEDHORIZONTAL = 32
Global Const $GDIP_HATCHSTYLE_DASHEDVERTICAL = 33
Global Const $GDIP_HATCHSTYLE_SMALLCONFETTI = 34
Global Const $GDIP_HATCHSTYLE_LARGECONFETTI = 35
Global Const $GDIP_HATCHSTYLE_ZIGZAG = 36
Global Const $GDIP_HATCHSTYLE_WAVE = 37
Global Const $GDIP_HATCHSTYLE_DIAGONALBRICK = 38
Global Const $GDIP_HATCHSTYLE_HORIZONTALBRICK = 39
Global Const $GDIP_HATCHSTYLE_WEAVE = 40
Global Const $GDIP_HATCHSTYLE_PLAID = 41
Global Const $GDIP_HATCHSTYLE_DIVOT = 42
Global Const $GDIP_HATCHSTYLE_DOTTEDGRID = 43
Global Const $GDIP_HATCHSTYLE_DOTTEDDIAMOND = 44
Global Const $GDIP_HATCHSTYLE_SHINGLE = 45
Global Const $GDIP_HATCHSTYLE_TRELLIS = 46
Global Const $GDIP_HATCHSTYLE_SPHERE = 47
Global Const $GDIP_HATCHSTYLE_SMALLGRID = 48
Global Const $GDIP_HATCHSTYLE_SMALLCHECKERBOARD = 49
Global Const $GDIP_HATCHSTYLE_LARGECHECKERBOARD = 50
Global Const $GDIP_HATCHSTYLE_OUTLINEDDIAMOND = 51
Global Const $GDIP_HATCHSTYLE_SOLIDDIAMOND = 52
Global Const $GDIP_HATCHSTYLE_TOTAL = 53
Global Const $GDIP_HATCHSTYLE_LARGEGRID = $GDIP_HATCHSTYLE_CROSS
Global Const $GDIP_HATCHSTYLE_MIN = $GDIP_HATCHSTYLE_HORIZONTAL
Global Const $GDIP_HATCHSTYLE_MAX = $GDIP_HATCHSTYLE_TOTAL - 1
Global Const $GDIP_BlurEffectGuid = '{633C80A4-1843-482b-9EF2-BE2834C5FDD4}'
Global Const $GDIP_SharpenEffectGuid = '{63CBF3EE-C526-402c-8F71-62C540BF5142}'
Global Const $GDIP_ColorMatrixEffectGuid = '{718F2615-7933-40e3-A511-5F68FE14DD74}'
Global Const $GDIP_ColorLUTEffectGuid = '{A7CE72A9-0F7F-40d7-B3CC-D0C02D5C3212}'
Global Const $GDIP_BrightnessContrastEffectGuid = '{D3A1DBE1-8EC4-4c17-9F4C-EA97AD1C343D}'
Global Const $GDIP_HueSaturationLightnessEffectGuid = '{8B2DD6C3-EB07-4d87-A5F0-7108E26A9C5F}'
Global Const $GDIP_LevelsEffectGuid = '{99C354EC-2A31-4f3a-8C34-17A803B33A25}'
Global Const $GDIP_TintEffectGuid = '{1077AF00-2848-4441-9489-44AD4C2D7A2C}'
Global Const $GDIP_ColorBalanceEffectGuid = '{537E597D-251E-48da-9664-29CA496B70F8}'
Global Const $GDIP_RedEyeCorrectionEffectGuid = '{74D29D05-69A4-4266-9549-3CC52836B632}'
Global Const $GDIP_ColorCurveEffectGuid = '{DD6A0022-58E4-4a67-9D9B-D48EB881A53D}'
Global Const $GDIP_AdjustExposure = 0
Global Const $GDIP_AdjustDensity = 1
Global Const $GDIP_AdjustContrast = 2
Global Const $GDIP_AdjustHighlight = 3
Global Const $GDIP_AdjustShadow = 4
Global Const $GDIP_AdjustMidtone = 5
Global Const $GDIP_AdjustWhiteSaturation = 6
Global Const $GDIP_AdjustBlackSaturation = 7
Global Const $GDIP_CurveChannelAll = 0
Global Const $GDIP_CurveChannelRed = 1
Global Const $GDIP_CurveChannelGreen = 2
Global Const $GDIP_CurveChannelBlue = 3
Global Const $GDIP_PaletteTypeCustom = 0
Global Const $GDIP_PaletteTypeOptimal = 1
Global Const $GDIP_PaletteTypeFixedBW = 2
Global Const $GDIP_PaletteTypeFixedHalftone8 = 3
Global Const $GDIP_PaletteTypeFixedHalftone27 = 4
Global Const $GDIP_PaletteTypeFixedHalftone64 = 5
Global Const $GDIP_PaletteTypeFixedHalftone125 = 6
Global Const $GDIP_PaletteTypeFixedHalftone216 = 7
Global Const $GDIP_PaletteTypeFixedHalftone252 = 8
Global Const $GDIP_PaletteTypeFixedHalftone256 = 9
Global Const $GDIP_PaletteFlagsHasAlpha = 0x0001
Global Const $GDIP_PaletteFlagsGrayScale = 0x0002
Global Const $GDIP_PaletteFlagsHalftone = 0x0004
Global Const $GDIP_DitherTypeNone = 0
Global Const $GDIP_DitherTypeSolid = 1
Global Const $GDIP_DitherTypeOrdered4x4 = 2
Global Const $GDIP_DitherTypeOrdered8x8 = 3
Global Const $GDIP_DitherTypeOrdered16x16 = 4
Global Const $GDIP_DitherTypeOrdered91x91 = 5
Global Const $GDIP_DitherTypeSpiral4x4 = 6
Global Const $GDIP_DitherTypeSpiral8x8 = 7
Global Const $GDIP_DitherTypeDualSpiral4x4 = 8
Global Const $GDIP_DitherTypeDualSpiral8x8 = 9
Global Const $GDIP_DitherTypeErrorDiffusion = 10
Global Const $GDIP_DitherTypeMax = 10
Global Const $GDIP_HistogramFormatARGB = 0
Global Const $GDIP_HistogramFormatPARGB = 1
Global Const $GDIP_HistogramFormatRGB = 2
Global Const $GDIP_HistogramFormatGray = 3
Global Const $GDIP_HistogramFormatB = 4
Global Const $GDIP_HistogramFormatG = 5
Global Const $GDIP_HistogramFormatR = 6
Global Const $GDIP_HistogramFormatA = 7
Global Const $GDIP_TEXTRENDERINGHINTSYSTEMDEFAULT = 0
Global Const $GDIP_TEXTRENDERINGHINTSINGLEBITPERPIXELGRIDFIT = 1
Global Const $GDIP_TEXTRENDERINGHINTSINGLEBITPERPIXEL = 2
Global Const $GDIP_TEXTRENDERINGHINTANTIALIASGRIDFIT = 3
Global Const $GDIP_TEXTRENDERINGHINTANTIALIAS = 4
Global Const $GDIP_TEXTRENDERINGHINTCLEARTYPEGRIDFIT = 5
Global Const $GDIP_RotateNoneFlipNone = 0
Global Const $GDIP_Rotate90FlipNone = 1
Global Const $GDIP_Rotate180FlipNone = 2
Global Const $GDIP_Rotate270FlipNone = 3
Global Const $GDIP_RotateNoneFlipX = 4
Global Const $GDIP_Rotate90FlipX = 5
Global Const $GDIP_Rotate180FlipX = 6
Global Const $GDIP_Rotate270FlipX = 7
Global Const $GDIP_RotateNoneFlipY = $GDIP_Rotate180FlipX
Global Const $GDIP_Rotate90FlipY = $GDIP_Rotate270FlipX
Global Const $GDIP_Rotate180FlipY = $GDIP_RotateNoneFlipX
Global Const $GDIP_Rotate270FlipY = $GDIP_Rotate90FlipX
Global Const $GDIP_RotateNoneFlipXY = $GDIP_Rotate180FlipNone
Global Const $GDIP_Rotate90FlipXY = $GDIP_Rotate270FlipNone
Global Const $GDIP_Rotate270FlipXY = $GDIP_Rotate90FlipNone
Global Const $GDIP_FRAMEDIMENSION_TIME = "{6AEDBD6D-3FB5-418A-83A6-7F45229DC872}"
Global Const $GDIP_FRAMEDIMENSION_RESOLUTION = "{84236F7B-3BD3-428F-8DAB-4EA1439CA315}"
Global Const $GDIP_FRAMEDIMENSION_PAGE = "{7462DC86-6180-4C7E-8E3F-EE7333A7A483}"
Global Const $GDIP_COLORADJUSTTYPE_DEFAULT = 0
Global Const $GDIP_COLORADJUSTTYPE_BITMAP = 1
Global Const $GDIP_COLORADJUSTTYPE_BRUSH = 2
Global Const $GDIP_COLORADJUSTTYPE_PEN = 3
Global Const $GDIP_COLORADJUSTTYPE_TEXT = 4
Global Const $GDIP_COLORADJUSTTYPE_COUNT = 5
Global Const $GDIP_COLORADJUSTTYPE_ANY = 6
Global Enum $GDIP_WrapModeTile, $GDIP_WrapModeTileFlipX, $GDIP_WrapModeTileFlipY, $GDIP_WrapModeTileFlipXY, $GDIP_WrapModeClamp
Global $__g_hGDIPBrush = 0
Global $__g_hGDIPDll = 0
Global $__g_hGDIPPen = 0
Global $__g_iGDIPRef = 0
Global $__g_iGDIPToken = 0
Global $__g_bGDIP_V1_0 = True
Func _GDIPlus_ArrowCapCreate($fHeight, $fWidth, $bFilled = True)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateAdjustableArrowCap", "float", $fHeight, "float", $fWidth, "bool", $bFilled, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[4]
EndFunc
Func _GDIPlus_ArrowCapDispose($hCap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDeleteCustomLineCap", "handle", $hCap)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapGetFillState($hArrowCap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetAdjustableArrowCapFillState", "handle", $hArrowCap, "bool*", 0)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapGetHeight($hArrowCap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetAdjustableArrowCapHeight", "handle", $hArrowCap, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_ArrowCapGetMiddleInset($hArrowCap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetAdjustableArrowCapMiddleInset", "handle", $hArrowCap, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_ArrowCapGetWidth($hArrowCap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetAdjustableArrowCapWidth", "handle", $hArrowCap, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_ArrowCapSetFillState($hArrowCap, $bFilled = True)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetAdjustableArrowCapFillState", "handle", $hArrowCap, "bool", $bFilled)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapSetHeight($hArrowCap, $fHeight)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetAdjustableArrowCapHeight", "handle", $hArrowCap, "float", $fHeight)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapSetMiddleInset($hArrowCap, $fInset)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetAdjustableArrowCapMiddleInset", "handle", $hArrowCap, "float", $fInset)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapSetWidth($hArrowCap, $fWidth)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetAdjustableArrowCapWidth", "handle", $hArrowCap, "float", $fWidth)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapCloneArea($hBitmap, $nLeft, $nTop, $nWidth, $nHeight, $iFormat = 0x00021808)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCloneBitmapArea", "float", $nLeft, "float", $nTop, "float", $nWidth, "float", $nHeight,  "int", $iFormat, "handle", $hBitmap, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[7]
EndFunc
Func _GDIPlus_BitmapCreateDIBFromBitmap($hBitmap)
Local $aCall = DllCall($__g_hGDIPDll, "uint", "GdipGetImageDimension", "handle", $hBitmap, "float*", 0, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Local $tData = _GDIPlus_BitmapLockBits($hBitmap, 0, 0, $aCall[2], $aCall[3], $GDIP_ILMREAD, $GDIP_PXF32ARGB)
Local $pBits = DllStructGetData($tData, "Scan0")
If Not $pBits Then Return 0
Local $tBIHDR = DllStructCreate($tagBITMAPV5HEADER)
DllStructSetData($tBIHDR, "bV5Size", DllStructGetSize($tBIHDR))
DllStructSetData($tBIHDR, "bV5Width", $aCall[2])
DllStructSetData($tBIHDR, "bV5Height", $aCall[3])
DllStructSetData($tBIHDR, "bV5Planes", 1)
DllStructSetData($tBIHDR, "bV5BitCount", 32)
DllStructSetData($tBIHDR, "bV5Compression", 0)
DllStructSetData($tBIHDR, "bV5SizeImage", $aCall[3] * DllStructGetData($tData, "Stride"))
DllStructSetData($tBIHDR, "bV5AlphaMask", 0xFF000000)
DllStructSetData($tBIHDR, "bV5RedMask", 0x00FF0000)
DllStructSetData($tBIHDR, "bV5GreenMask", 0x0000FF00)
DllStructSetData($tBIHDR, "bV5BlueMask", 0x000000FF)
DllStructSetData($tBIHDR, "bV5CSType", 2)
DllStructSetData($tBIHDR, "bV5Intent", 4)
Local $hHBitmapv5 = DllCall("gdi32.dll", "ptr", "CreateDIBSection", "hwnd", 0, "struct*", $tBIHDR, "uint", 0, "ptr*", 0, "ptr", 0, "dword", 0)
If Not @error And $hHBitmapv5[0] Then
DllCall("gdi32.dll", "dword", "SetBitmapBits", "ptr", $hHBitmapv5[0], "dword", $aCall[2] * $aCall[3] * 4, "ptr", DllStructGetData($tData, "Scan0"))
$hHBitmapv5 = $hHBitmapv5[0]
Else
$hHBitmapv5 = 0
EndIf
_GDIPlus_BitmapUnlockBits($hBitmap, $tData)
$tData = 0
$tBIHDR = 0
Return $hHBitmapv5
EndFunc
Func _GDIPlus_BitmapCreateFromFile($sFileName)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromFile", "wstr", $sFileName, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_BitmapCreateFromGraphics($iWidth, $iHeight, $hGraphics)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromGraphics", "int", $iWidth, "int", $iHeight, "handle", $hGraphics,  "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[4]
EndFunc
Func _GDIPlus_BitmapCreateFromHBITMAP($hBitmap, $hPal = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromHBITMAP", "handle", $hBitmap, "handle", $hPal, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _GDIPlus_BitmapCreateFromMemory($dImage, $bHBITMAP = False)
If Not IsBinary($dImage) Then Return SetError(1, 0, 0)
Local Const $dMemBitmap = Binary($dImage)
Local Const $iLen = BinaryLen($dMemBitmap)
Local Const $GMEM_MOVEABLE = 0x0002
Local $aCall = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $GMEM_MOVEABLE, "ulong_ptr", $iLen)
If @error Then Return SetError(4, 0, 0)
Local Const $hData = $aCall[0]
$aCall = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hData)
If @error Then Return SetError(5, 0, 0)
Local $tMem = DllStructCreate("byte[" & $iLen & "]", $aCall[0])
DllStructSetData($tMem, 1, $dMemBitmap)
DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hData)
If @error Then Return SetError(6, 0, 0)
Local Const $hStream = _WinAPI_CreateStreamOnHGlobal($hData)
If @error Then Return SetError(2, 0, 0)
Local Const $hBitmap = _GDIPlus_BitmapCreateFromStream($hStream)
If @error Then Return SetError(3, 0, 0)
DllCall("oleaut32.dll", "long", "DispCallFunc", "ptr", $hStream, "ulong_ptr", 8 * (1 + @AutoItX64), "uint", 4, "ushort", 23, "uint", 0, "ptr", 0, "ptr", 0, "str", "")
If $bHBITMAP Then
Local Const $hHBmp = _GDIPlus_BitmapCreateDIBFromBitmap($hBitmap)
_GDIPlus_BitmapDispose($hBitmap)
Return $hHBmp
EndIf
Return $hBitmap
EndFunc
Func _GDIPlus_BitmapCreateFromResource($hInst, $vResourceName)
Local $sType = "int"
If IsString($vResourceName) Then $sType = "wstr"
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromResource", "handle", $hInst, $sType, $vResourceName, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight, $iPixelFormat = $GDIP_PXF32ARGB, $iStride = 0, $pScan0 = 0)
Local $aCall = DllCall($__g_hGDIPDll, "uint", "GdipCreateBitmapFromScan0", "int", $iWidth, "int", $iHeight, "int", $iStride, "int", $iPixelFormat, "struct*", $pScan0, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[6]
EndFunc
Func _GDIPlus_BitmapCreateFromStream($pStream)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromStream", "ptr", $pStream, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_BitmapCreateHBITMAPFromBitmap($hBitmap, $iARGB = 0xFF000000)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateHBITMAPFromBitmap", "handle", $hBitmap, "handle*", 0, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_BitmapDispose($hBitmap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDisposeImage", "handle", $hBitmap)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapCreateFromHICON($hIcon)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromHICON", "handle", $hIcon, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_BitmapCreateFromHICON32($hIcon)
Local $tSIZE = _WinAPI_GetIconDimension($hIcon)
Local $iWidth = DllStructGetData($tSIZE, 'X')
Local $iHeight = DllStructGetData($tSIZE, 'Y')
If $iWidth <= 0 Or $iHeight <= 0 Then Return SetError(10, -1, 0)
Local $tBITMAPINFO = DllStructCreate("dword Size;long Width;long Height;word Planes;word BitCount;dword Compression;dword SizeImage;long XPelsPerMeter;long YPelsPerMeter;dword ClrUsed;dword ClrImportant;dword RGBQuad")
DllStructSetData($tBITMAPINFO, 'Size', DllStructGetSize($tBITMAPINFO) - 4)
DllStructSetData($tBITMAPINFO, 'Width', $iWidth)
DllStructSetData($tBITMAPINFO, 'Height', -$iHeight)
DllStructSetData($tBITMAPINFO, 'Planes', 1)
DllStructSetData($tBITMAPINFO, 'BitCount', 32)
DllStructSetData($tBITMAPINFO, 'Compression', 0)
DllStructSetData($tBITMAPINFO, 'SizeImage', 0)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $pBits
Local $hBmp = _WinAPI_CreateDIBSection(0, $tBITMAPINFO, 0, $pBits)
Local $hOrig = _WinAPI_SelectObject($hDC, $hBmp)
_WinAPI_DrawIconEx($hDC, 0, 0, $hIcon, $iWidth, $iHeight)
Local $hBitmapIcon = _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight, $GDIP_PXF32ARGB, $iWidth * 4, $pBits)
Local $hBitmap = _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight)
Local $hContext = _GDIPlus_ImageGetGraphicsContext($hBitmap)
_GDIPlus_GraphicsDrawImage($hContext, $hBitmapIcon, 0, 0)
_GDIPlus_GraphicsDispose($hContext)
_GDIPlus_BitmapDispose($hBitmapIcon)
_WinAPI_SelectObject($hDC, $hOrig)
_WinAPI_DeleteDC($hDC)
_WinAPI_DeleteObject($hBmp)
Return $hBitmap
EndFunc
Func _GDIPlus_BitmapGetPixel($hBitmap, $iX, $iY)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipBitmapGetPixel", "handle", $hBitmap, "int", $iX, "int", $iY, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[4]
EndFunc
Func _GDIPlus_BitmapLockBits($hBitmap, $iLeft, $iTop, $iWidth, $iHeight, $iFlags = $GDIP_ILMREAD, $iFormat = $GDIP_PXF32RGB)
Local $tData = DllStructCreate($tagGDIPBITMAPDATA)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iWidth)
DllStructSetData($tRECT, "Bottom", $iHeight)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipBitmapLockBits", "handle", $hBitmap, "struct*", $tRECT, "uint", $iFlags, "int", $iFormat, "struct*", $tData)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $tData
EndFunc
Func _GDIPlus_BitmapSetPixel($hBitmap, $iX, $iY, $iARGB)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipBitmapSetPixel", "handle", $hBitmap, "int", $iX, "int", $iY, "uint", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapSetResolution($hBitmap, $fDpiX, $fDpiY)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipBitmapSetResolution", "handle", $hBitmap, "float", $fDpiX, "float", $fDpiY)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapUnlockBits($hBitmap, $tBitmapData)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipBitmapUnlockBits", "handle", $hBitmap, "struct*", $tBitmapData)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_BrushClone($hBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCloneBrush", "handle", $hBrush, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_BrushCreateSolid($iARGB = 0xFF000000)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateSolidFill", "int", $iARGB, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_BrushDispose($hBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDeleteBrush", "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_BrushGetSolidColor($hBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetSolidFillColor", "handle", $hBrush, "dword*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_BrushGetType($hBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetBrushType", "handle", $hBrush, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_BrushSetSolidColor($hBrush, $iARGB = 0xFF000000)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetSolidFillColor", "handle", $hBrush, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ColorMatrixCreate()
Return _GDIPlus_ColorMatrixCreateScale(1, 1, 1, 1)
EndFunc
Func _GDIPlus_ColorMatrixCreateGrayScale()
Local $iI, $iJ, $tCM, $aLums[4] = [$GDIP_RLUM, $GDIP_GLUM, $GDIP_BLUM, 0]
$tCM = DllStructCreate($tagGDIPCOLORMATRIX)
For $iI = 0 To 3
For $iJ = 1 To 3
DllStructSetData($tCM, "m", $aLums[$iI], $iI * 5 + $iJ)
Next
Next
DllStructSetData($tCM, "m", 1, 19)
DllStructSetData($tCM, "m", 1, 25)
Return $tCM
EndFunc
Func _GDIPlus_ColorMatrixCreateNegative()
Local $iI, $tCM
$tCM = _GDIPlus_ColorMatrixCreateScale(-1, -1, -1, 1)
For $iI = 1 To 4
DllStructSetData($tCM, "m", 1, 20 + $iI)
Next
Return $tCM
EndFunc
Func _GDIPlus_ColorMatrixCreateSaturation($fSat)
Local $fSatComp, $tCM
$tCM = DllStructCreate($tagGDIPCOLORMATRIX)
$fSatComp = (1 - $fSat)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_RLUM + $fSat, 1)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_RLUM, 2)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_RLUM, 3)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_GLUM, 6)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_GLUM + $fSat, 7)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_GLUM, 8)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_BLUM, 11)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_BLUM, 12)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_BLUM + $fSat, 13)
DllStructSetData($tCM, "m", 1, 19)
DllStructSetData($tCM, "m", 1, 25)
Return $tCM
EndFunc
Func _GDIPlus_ColorMatrixCreateScale($fRed, $fGreen, $fBlue, $fAlpha = 1)
Local $tCM
$tCM = DllStructCreate($tagGDIPCOLORMATRIX)
DllStructSetData($tCM, "m", $fRed, 1)
DllStructSetData($tCM, "m", $fGreen, 7)
DllStructSetData($tCM, "m", $fBlue, 13)
DllStructSetData($tCM, "m", $fAlpha, 19)
DllStructSetData($tCM, "m", 1, 25)
Return $tCM
EndFunc
Func _GDIPlus_ColorMatrixCreateTranslate($fRed, $fGreen, $fBlue, $fAlpha = 0)
Local $iI, $tCM, $aFactors[4] = [$fRed, $fGreen, $fBlue, $fAlpha]
$tCM = _GDIPlus_ColorMatrixCreate()
For $iI = 0 To 3
DllStructSetData($tCM, "m", $aFactors[$iI], 21 + $iI)
Next
Return $tCM
EndFunc
Func _GDIPlus_CustomLineCapClone($hCustomLineCap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCloneCustomLineCap", "handle", $hCustomLineCap, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_CustomLineCapCreate($hPathFill, $hPathStroke, $iLineCap = 0, $nBaseInset = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateCustomLineCap", "handle", $hPathFill, "handle", $hPathStroke, "int", $iLineCap, "float", $nBaseInset, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[5]
EndFunc
Func _GDIPlus_CustomLineCapDispose($hCap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDeleteCustomLineCap", "handle", $hCap)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_CustomLineCapGetStrokeCaps($hCustomLineCap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetCustomLineCapStrokeCaps", "hwnd", $hCustomLineCap, "ptr*", 0, "ptr*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then SetError(10, $aCall[0], 0)
Local $aCaps[2]
$aCaps[0] = $aCall[2]
$aCaps[1] = $aCall[3]
Return $aCaps
EndFunc
Func _GDIPlus_CustomLineCapSetStrokeCaps($hCustomLineCap, $iStartCap, $iEndCap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetCustomLineCapStrokeCaps", "handle", $hCustomLineCap, "int", $iStartCap, "int", $iEndCap)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_Decoders()
Local $iCount = _GDIPlus_DecodersGetCount()
Local $iSize = _GDIPlus_DecodersGetSize()
Local $tBuffer = DllStructCreate("byte[" & $iSize & "]")
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageDecoders", "uint", $iCount, "uint", $iSize, "struct*", $tBuffer)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tCodec, $aInfo[$iCount + 1][14]
$aInfo[0][0] = $iCount
For $iI = 1 To $iCount
$tCodec = DllStructCreate($tagGDIPIMAGECODECINFO, $pBuffer)
$aInfo[$iI][1] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "CLSID"))
$aInfo[$iI][2] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "FormatID"))
$aInfo[$iI][3] = _WinAPI_GetString(DllStructGetData($tCodec, "CodecName"))
$aInfo[$iI][4] = _WinAPI_GetString(DllStructGetData($tCodec, "DllName"))
$aInfo[$iI][5] = _WinAPI_GetString(DllStructGetData($tCodec, "FormatDesc"))
$aInfo[$iI][6] = _WinAPI_GetString(DllStructGetData($tCodec, "FileExt"))
$aInfo[$iI][7] = _WinAPI_GetString(DllStructGetData($tCodec, "MimeType"))
$aInfo[$iI][8] = DllStructGetData($tCodec, "Flags")
$aInfo[$iI][9] = DllStructGetData($tCodec, "Version")
$aInfo[$iI][10] = DllStructGetData($tCodec, "SigCount")
$aInfo[$iI][11] = DllStructGetData($tCodec, "SigSize")
$aInfo[$iI][12] = DllStructGetData($tCodec, "SigPattern")
$aInfo[$iI][13] = DllStructGetData($tCodec, "SigMask")
$pBuffer += DllStructGetSize($tCodec)
Next
Return $aInfo
EndFunc
Func _GDIPlus_DecodersGetCount()
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageDecodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[1]
EndFunc
Func _GDIPlus_DecodersGetSize()
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageDecodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_DrawImagePoints($hGraphic, $hImage, $nULX, $nULY, $nURX, $nURY, $nLLX, $nLLY, $iCount = 3)
Local $tPoint = DllStructCreate("float X;float Y;float X2;float Y2;float X3;float Y3")
DllStructSetData($tPoint, "X", $nULX)
DllStructSetData($tPoint, "Y", $nULY)
DllStructSetData($tPoint, "X2", $nURX)
DllStructSetData($tPoint, "Y2", $nURY)
DllStructSetData($tPoint, "X3", $nLLX)
DllStructSetData($tPoint, "Y3", $nLLY)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawImagePoints", "handle", $hGraphic, "handle", $hImage, "struct*", $tPoint, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_Encoders()
Local $iCount = _GDIPlus_EncodersGetCount()
Local $iSize = _GDIPlus_EncodersGetSize()
Local $tBuffer = DllStructCreate("byte[" & $iSize & "]")
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncoders", "uint", $iCount, "uint", $iSize, "struct*", $tBuffer)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tCodec, $aInfo[$iCount + 1][14]
$aInfo[0][0] = $iCount
For $iI = 1 To $iCount
$tCodec = DllStructCreate($tagGDIPIMAGECODECINFO, $pBuffer)
$aInfo[$iI][1] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "CLSID"))
$aInfo[$iI][2] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "FormatID"))
$aInfo[$iI][3] = _WinAPI_GetString(DllStructGetData($tCodec, "CodecName"))
$aInfo[$iI][4] = _WinAPI_GetString(DllStructGetData($tCodec, "DllName"))
$aInfo[$iI][5] = _WinAPI_GetString(DllStructGetData($tCodec, "FormatDesc"))
$aInfo[$iI][6] = _WinAPI_GetString(DllStructGetData($tCodec, "FileExt"))
$aInfo[$iI][7] = _WinAPI_GetString(DllStructGetData($tCodec, "MimeType"))
$aInfo[$iI][8] = DllStructGetData($tCodec, "Flags")
$aInfo[$iI][9] = DllStructGetData($tCodec, "Version")
$aInfo[$iI][10] = DllStructGetData($tCodec, "SigCount")
$aInfo[$iI][11] = DllStructGetData($tCodec, "SigSize")
$aInfo[$iI][12] = DllStructGetData($tCodec, "SigPattern")
$aInfo[$iI][13] = DllStructGetData($tCodec, "SigMask")
$pBuffer += DllStructGetSize($tCodec)
Next
Return $aInfo
EndFunc
Func _GDIPlus_EncodersGetCLSID($sFileExtension)
Local $aEncoders = _GDIPlus_Encoders()
If @error Then Return SetError(@error, 0, "")
For $iI = 1 To $aEncoders[0][0]
If StringInStr($aEncoders[$iI][6], "*." & $sFileExtension) > 0 Then Return $aEncoders[$iI][1]
Next
Return SetError(-1, -1, "")
EndFunc
Func _GDIPlus_EncodersGetCount()
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[1]
EndFunc
Func _GDIPlus_EncodersGetParamList($hImage, $sEncoder)
Local $iSize = _GDIPlus_EncodersGetParamListSize($hImage, $sEncoder)
If @error Then Return SetError(@error + 10, @extended, 0)
Local $tGUID = _WinAPI_GUIDFromString($sEncoder)
Local $iRemainingSize = $iSize - 4 - _GDIPlus_ParamSize()
Local $tBuffer
If $iRemainingSize Then
$tBuffer = DllStructCreate("dword Count;" & $tagGDIPENCODERPARAM & ";byte [" & $iRemainingSize & "]")
Else
$tBuffer = DllStructCreate("dword Count;" & $tagGDIPENCODERPARAM)
EndIf
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetEncoderParameterList", "handle", $hImage, "struct*", $tGUID, "uint", $iSize, "struct*", $tBuffer)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $tBuffer
EndFunc
Func _GDIPlus_EncodersGetParamListSize($hImage, $sEncoder)
Local $tGUID = _WinAPI_GUIDFromString($sEncoder)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetEncoderParameterListSize", "handle", $hImage, "struct*", $tGUID, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _GDIPlus_EncodersGetSize()
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_FontCreate($hFamily, $fSize, $iStyle = 0, $iUnit = 3)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateFont", "handle", $hFamily, "float", $fSize, "int", $iStyle, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[5]
EndFunc
Func _GDIPlus_FontDispose($hFont)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDeleteFont", "handle", $hFont)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_FontFamilyCreate($sFamily, $pCollection = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateFontFamilyFromName", "wstr", $sFamily, "ptr", $pCollection, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _GDIPlus_FontFamilyCreateFromCollection($sFontName, $hFontCollection)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateFontFamilyFromName", "wstr", $sFontName, "ptr", $hFontCollection, "ptr*", 0)
If @error Then Return SetError(@error, @extended, "")
If $aCall[0] Then Return SetError(10, $aCall[0], "")
Return $aCall[3]
EndFunc
Func _GDIPlus_FontFamilyDispose($hFamily)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDeleteFontFamily", "handle", $hFamily)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_FontFamilyGetCellAscent($hFontFamily, $iStyle = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetCellAscent", "handle", $hFontFamily, "int", $iStyle, "ushort*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _GDIPlus_FontFamilyGetCellDescent($hFontFamily, $iStyle = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetCellDescent", "handle", $hFontFamily, "int", $iStyle, "ushort*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _GDIPlus_FontFamilyGetEmHeight($hFontFamily, $iStyle = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetEmHeight", "handle", $hFontFamily, "int", $iStyle, "ushort*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _GDIPlus_FontFamilyGetLineSpacing($hFontFamily, $iStyle = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetLineSpacing", "handle", $hFontFamily, "int", $iStyle, "ushort*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _GDIPlus_FontGetHeight($hFont, $hGraphics)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetFontHeight", "handle", $hFont, "handle", $hGraphics, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _GDIPlus_FontPrivateAddFont($hFontCollection, $sFontFile)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipPrivateAddFontFile", "ptr", $hFontCollection, "wstr", $sFontFile)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_FontPrivateAddMemoryFont($hFontCollection, $tFont)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipPrivateAddMemoryFont", "handle", $hFontCollection, "struct*", $tFont, "int", DllStructGetSize($tFont))
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_FontPrivateCollectionDispose($hFontCollection)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDeletePrivateFontCollection", "handle*", $hFontCollection)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_FontPrivateCreateCollection()
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipNewPrivateFontCollection", "ptr*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[1]
EndFunc
Func _GDIPlus_GraphicsClear($hGraphics, $iARGB = 0xFF000000)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGraphicsClear", "handle", $hGraphics, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsCreateFromHDC($hDC)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateFromHDC", "handle", $hDC, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_GraphicsCreateFromHWND($hWnd)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateFromHWND", "hwnd", $hWnd, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_GraphicsDispose($hGraphics)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDeleteGraphics", "handle", $hGraphics)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawArc($hGraphics, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawArc", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawBezier($hGraphics, $nX1, $nY1, $nX2, $nY2, $nX3, $nY3, $nX4, $nY4, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawBezier", "handle", $hGraphics, "handle", $hPen, "float", $nX1, "float", $nY1,  "float", $nX2, "float", $nY2, "float", $nX3, "float", $nY3, "float", $nX4, "float", $nY4)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawClosedCurve($hGraphics, $aPoints, $hPen = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_PenDefCreate($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawClosedCurve", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawClosedCurve2($hGraphics, $aPoints, $nTension, $hPen = 0)
Local $iI, $iCount, $tPoints, $aCall
__GDIPlus_PenDefCreate($hPen)
$iCount = $aPoints[0][0]
$tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
$aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawClosedCurve2", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount, "float", $nTension)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawCurve($hGraphics, $aPoints, $hPen = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_PenDefCreate($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawCurve", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawCurve2($hGraphics, $aPoints, $nTension, $hPen = 0)
Local $iI, $iCount, $tPoints, $aCall
__GDIPlus_PenDefCreate($hPen)
$iCount = $aPoints[0][0]
$tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
$aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawCurve2", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount, "float", $nTension)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawEllipse($hGraphics, $nX, $nY, $nWidth, $nHeight, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawEllipse", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImage($hGraphics, $hImage, $nX, $nY)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawImage", "handle", $hGraphics, "handle", $hImage, "float", $nX, "float", $nY)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImagePointsRect($hGraphics, $hImage, $nULX, $nULY, $nURX, $nURY, $nLLX, $nLLY, $nSrcX, $nSrcY, $nSrcWidth, $nSrcHeight, $hImageAttributes = 0, $iUnit = 2)
Local $tPoints = DllStructCreate("float X; float Y; float X2; float Y2; float X3; float Y3;")
DllStructSetData($tPoints, "X", $nULX)
DllStructSetData($tPoints, "Y", $nULY)
DllStructSetData($tPoints, "X2", $nURX)
DllStructSetData($tPoints, "Y2", $nURY)
DllStructSetData($tPoints, "X3", $nLLX)
DllStructSetData($tPoints, "Y3", $nLLY)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawImagePointsRect", "handle", $hGraphics, "handle", $hImage, "struct*", $tPoints, "int", 3, "float", $nSrcX, "float", $nSrcY, "float", $nSrcWidth, "float", $nSrcHeight, "int", $iUnit, "handle", $hImageAttributes, "ptr", 0, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImageRect($hGraphics, $hImage, $nX, $nY, $nW, $nH)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawImageRect", "handle", $hGraphics, "handle", $hImage, "float", $nX, "float", $nY,  "float", $nW, "float", $nH)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImageRectRect($hGraphics, $hImage, $nSrcX, $nSrcY, $nSrcWidth, $nSrcHeight, $nDstX, $nDstY, $nDstWidth, $nDstHeight, $pAttributes = 0, $iUnit = 2)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawImageRectRect", "handle", $hGraphics, "handle", $hImage,  "float", $nDstX, "float", $nDstY, "float", $nDstWidth, "float", $nDstHeight,  "float", $nSrcX, "float", $nSrcY, "float", $nSrcWidth, "float", $nSrcHeight,  "int", $iUnit, "handle", $pAttributes, "ptr", 0, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawLine($hGraphics, $nX1, $nY1, $nX2, $nY2, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawLine", "handle", $hGraphics, "handle", $hPen, "float", $nX1, "float", $nY1,  "float", $nX2, "float", $nY2)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawPath($hGraphics, $hPath, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawPath", "handle", $hGraphics, "handle", $hPen, "handle", $hPath)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawPie($hGraphics, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawPie", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawPolygon($hGraphics, $aPoints, $hPen = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_PenDefCreate($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawPolygon", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawRectangle", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawString($hGraphics, $sString, $nX, $nY, $sFont = Default, $fSize = Default, $iFormat = Default, $iARGB = Default)
If $sFont = Default Then $sFont = "Arial"
If $fSize = Default Then $fSize = 10
If $iFormat = Default Then $iFormat = 0
If $iARGB = Default Then $iARGB = 0xFF000000
If BitAND($iARGB, 0xFF000000) = 0 Then $iARGB = BitOR($iARGB, 0xFF000000)
Local $hBrush = _GDIPlus_BrushCreateSolid($iARGB)
Local $hFormat = _GDIPlus_StringFormatCreate($iFormat)
Local $hFamily = _GDIPlus_FontFamilyCreate($sFont)
Local $hFont = _GDIPlus_FontCreate($hFamily, $fSize)
Local $tLayout = _GDIPlus_RectFCreate($nX, $nY, 0.0, 0.0)
Local $aInfo = _GDIPlus_GraphicsMeasureString($hGraphics, $sString, $hFont, $tLayout, $hFormat)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult = _GDIPlus_GraphicsDrawStringEx($hGraphics, $sString, $hFont, $aInfo[0], $hFormat, $hBrush)
Local $iError = @error, $iExtended = @extended
_GDIPlus_FontDispose($hFont)
_GDIPlus_FontFamilyDispose($hFamily)
_GDIPlus_StringFormatDispose($hFormat)
_GDIPlus_BrushDispose($hBrush)
Return SetError($iError, $iExtended, $aResult)
EndFunc
Func _GDIPlus_GraphicsDrawStringEx($hGraphics, $sString, $hFont, $tLayout, $hFormat, $hBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawString", "handle", $hGraphics, "wstr", $sString, "int", -1, "handle", $hFont,  "struct*", $tLayout, "handle", $hFormat, "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillClosedCurve($hGraphics, $aPoints, $hBrush = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_BrushDefCreate($hBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipFillClosedCurve", "handle", $hGraphics, "handle", $hBrush, "struct*", $tPoints, "int", $iCount)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillClosedCurve2($hGraphics, $aPoints, $nTension, $hBrush = 0, $iFillMode = 0)
Local $iI, $iCount, $tPoints, $aCall
__GDIPlus_BrushDefCreate($hBrush)
$iCount = $aPoints[0][0]
$tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
$aCall = DllCall($__g_hGDIPDll, "int", "GdipFillClosedCurve2", "handle", $hGraphics, "handle", $hBrush, "struct*", $tPoints, "int", $iCount, "float", $nTension, "int", $iFillMode)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillEllipse($hGraphics, $nX, $nY, $nWidth, $nHeight, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipFillEllipse", "handle", $hGraphics, "handle", $hBrush, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillPath($hGraphics, $hPath, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipFillPath", "handle", $hGraphics, "handle", $hBrush, "handle", $hPath)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillPie($hGraphics, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipFillPie", "handle", $hGraphics, "handle", $hBrush, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillPolygon($hGraphics, $aPoints, $hBrush = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_BrushDefCreate($hBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipFillPolygon", "handle", $hGraphics, "handle", $hBrush,  "struct*", $tPoints, "int", $iCount, "int", "FillModeAlternate")
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipFillRectangle", "handle", $hGraphics, "handle", $hBrush, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillRegion($hGraphics, $hRegion, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipFillRegion", "handle", $hGraphics, "handle", $hBrush, "handle", $hRegion)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsGetCompositingMode($hGraphics)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetCompositingMode", "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2] - 1
EndFunc
Func _GDIPlus_GraphicsGetCompositingQuality($hGraphics)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetCompositingQuality", "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2] - 1
EndFunc
Func _GDIPlus_GraphicsGetDC($hGraphics)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetDC", "handle", $hGraphics, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_GraphicsGetInterpolationMode($hGraphics)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetInterpolationMode", "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2] - 1
EndFunc
Func _GDIPlus_GraphicsGetSmoothingMode($hGraphics)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetSmoothingMode", "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Switch $aCall[2]
Case $GDIP_SMOOTHINGMODE_NONE
Return 0
Case $GDIP_SMOOTHINGMODE_HIGHQUALITY, $GDIP_SMOOTHINGMODE_ANTIALIAS8X4
Return 1
Case $GDIP_SMOOTHINGMODE_ANTIALIAS8X8
Return 2
Case Else
Return 0
EndSwitch
EndFunc
Func _GDIPlus_GraphicsGetTransform($hGraphics, $hMatrix)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetWorldTransform", "handle", $hGraphics, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsMeasureCharacterRanges($hGraphics, $sString, $hFont, $tLayout, $hStringFormat)
Local $iCount = _GDIPlus_StringFormatGetMeasurableCharacterRangeCount($hStringFormat)
If @error Then Return SetError(@error, @extended, 0)
Local $tRegions = DllStructCreate("handle[" & $iCount & "]")
Local $aRegions[$iCount + 1] = [$iCount]
For $iI = 1 To $iCount
$aRegions[$iI] = _GDIPlus_RegionCreate()
DllStructSetData($tRegions, 1, $aRegions[$iI], $iI)
Next
DllCall($__g_hGDIPDll, "int", "GdipMeasureCharacterRanges", "handle", $hGraphics, "wstr", $sString, "int", -1, "hwnd", $hFont, "struct*", $tLayout, "handle", $hStringFormat, "int", $iCount, "struct*", $tRegions)
Local $iError = @error, $iExtended = @extended
If $iError Then
For $iI = 1 To $iCount
_GDIPlus_RegionDispose($aRegions[$iI])
Next
Return SetError($iError + 10, $iExtended, 0)
EndIf
Return $aRegions
EndFunc
Func _GDIPlus_GraphicsMeasureString($hGraphics, $sString, $hFont, $tLayout, $hFormat)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipMeasureString", "handle", $hGraphics, "wstr", $sString, "int", -1, "handle", $hFont,  "struct*", $tLayout, "handle", $hFormat, "struct*", $tRECTF, "int*", 0, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Local $aInfo[3]
$aInfo[0] = $tRECTF
$aInfo[1] = $aCall[8]
$aInfo[2] = $aCall[9]
Return $aInfo
EndFunc
Func _GDIPlus_GraphicsReleaseDC($hGraphics, $hDC)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipReleaseDC", "handle", $hGraphics, "handle", $hDC)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_GraphicsResetClip($hGraphics)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipResetClip", "handle", $hGraphics)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsResetTransform($hGraphics)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipResetWorldTransform", "handle", $hGraphics)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsRestore($hGraphics, $iState)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipRestoreGraphics", "handle", $hGraphics, "uint", $iState)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsRotateTransform($hGraphics, $fAngle, $iOrder = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipRotateWorldTransform", "handle", $hGraphics, "float", $fAngle, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSave($hGraphics)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSaveGraphics", "handle", $hGraphics, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_GraphicsScaleTransform($hGraphics, $fScaleX, $fScaleY, $iOrder = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipScaleWorldTransform", "handle", $hGraphics, "float", $fScaleX, "float", $fScaleY, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetClipPath($hGraphics, $hPath, $iCombineMode = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetClipPath", "handle", $hGraphics, "handle", $hPath, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetClipRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $iCombineMode = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetClipRect", "handle", $hGraphics, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetClipRegion($hGraphics, $hRegion, $iCombineMode = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetClipRegion", "handle", $hGraphics, "handle", $hRegion, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetCompositingMode($hGraphics, $iCompositionMode)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetCompositingMode", "handle", $hGraphics, "int", $iCompositionMode + 1)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetCompositingQuality($hGraphics, $iCompositionQuality)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetCompositingQuality", "handle", $hGraphics, "int", $iCompositionQuality + 1)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetInterpolationMode($hGraphics, $iInterpolationMode)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetInterpolationMode", "handle", $hGraphics, "int", $iInterpolationMode + 1)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetPixelOffsetMode($hGraphics, $iPixelOffsetMode)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPixelOffsetMode", "handle", $hGraphics, "int", $iPixelOffsetMode + 1)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetSmoothingMode($hGraphics, $iSmooth)
If $iSmooth < $GDIP_SMOOTHINGMODE_DEFAULT Or $iSmooth > $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 Then $iSmooth = $GDIP_SMOOTHINGMODE_DEFAULT
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetSmoothingMode", "handle", $hGraphics, "int", $iSmooth)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetTextRenderingHint($hGraphics, $iTextRenderingHint)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetTextRenderingHint", "handle", $hGraphics, "int", $iTextRenderingHint)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetTransform($hGraphics, $hMatrix)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetWorldTransform", "handle", $hGraphics, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsTransformPoints($hGraphics, ByRef $aPoints, $iCoordSpaceTo = 0, $iCoordSpaceFrom = 1)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], ($iI - 1) * 2 + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], ($iI - 1) * 2 + 2)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipTransformPoints", "handle", $hGraphics, "int", $iCoordSpaceTo, "int", $iCoordSpaceFrom, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
For $iI = 1 To $iCount
$aPoints[$iI][0] = DllStructGetData($tPoints, 1, ($iI - 1) * 2 + 1)
$aPoints[$iI][1] = DllStructGetData($tPoints, 1, ($iI - 1) * 2 + 2)
Next
Return True
EndFunc
Func _GDIPlus_GraphicsTranslateTransform($hGraphics, $nDX, $nDY, $iOrder = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipTranslateWorldTransform", "handle", $hGraphics, "float", $nDX, "float", $nDY, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_HatchBrushCreate($iHatchStyle = 0, $iARGBForeground = 0xFFFFFFFF, $iARGBBackground = 0xFFFFFFFF)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateHatchBrush", "int", $iHatchStyle, "uint", $iARGBForeground, "uint", $iARGBBackground, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[4]
EndFunc
Func _GDIPlus_HICONCreateFromBitmap($hBitmap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateHICONFromBitmap", "handle", $hBitmap, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_ImageAttributesCreate()
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateImageAttributes", "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[1]
EndFunc
Func _GDIPlus_ImageAttributesDispose($hImageAttributes)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDisposeImageAttributes", "handle", $hImageAttributes)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ImageAttributesSetColorKeys($hImageAttributes, $iColorAdjustType = 0, $bEnable = False, $iARGBLow = 0, $iARGBHigh = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetImageAttributesColorKeys", "handle", $hImageAttributes, "int", $iColorAdjustType, "int", $bEnable, "uint", $iARGBLow, "uint", $iARGBHigh)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ImageAttributesSetColorMatrix($hImageAttributes, $iColorAdjustType = 0, $bEnable = False, $tClrMatrix = 0, $tGrayMatrix = 0, $iColorMatrixFlags = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetImageAttributesColorMatrix", "handle", $hImageAttributes, "int", $iColorAdjustType, "int", $bEnable, "struct*", $tClrMatrix, "struct*", $tGrayMatrix, "int", $iColorMatrixFlags)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ImageAttributesSetRemapTable($hImageAttributes, $aColorMap = 0, $iColorAdjustType = 0, $bEnable = True)
Local $aCall
If IsArray($aColorMap) Then
Local $iCount = $aColorMap[0][0]
Local $tColorMap = DllStructCreate("uint[" & $iCount * 2 & "]")
For $i = 1 To $iCount
DllStructSetData($tColorMap, 1, $aColorMap[$i][0], ($i - 1) * 2 + 1)
DllStructSetData($tColorMap, 1, $aColorMap[$i][1], ($i - 1) * 2 + 2)
Next
$aCall = DllCall($__g_hGDIPDll, "int", "GdipSetImageAttributesRemapTable", "handle", $hImageAttributes, "int", $iColorAdjustType, "int", $bEnable, "int", $iCount, "struct*", $tColorMap)
Else
$aCall = DllCall($__g_hGDIPDll, "int", "GdipSetImageAttributesRemapTable", "handle", $hImageAttributes, "int", $iColorAdjustType, "int", $bEnable, "int", 0, "struct*", 0)
EndIf
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ImageAttributesSetThreshold($hImageAttributes, $fThreshold, $iColorAdjustType = $GDIP_COLORADJUSTTYPE_DEFAULT, $bEnable = True)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetImageAttributesThreshold", "handle", $hImageAttributes, "int", $iColorAdjustType, "bool", $bEnable, "float", $fThreshold)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ImageClone($hImage)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCloneImage", "handle", $hImage, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_ImageDispose($hImage)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDisposeImage", "handle", $hImage)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ImageGetDimension($hImage)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageDimension", "handle", $hImage, "float*", 0, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Local $aImgDim[2] = [$aCall[2], $aCall[3]]
Return $aImgDim
EndFunc
Func _GDIPlus_ImageGetFlags($hImage)
Local $aFlag[2] = [0, ""]
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, $aFlag)
Local $aImageFlags[13][2] =  [["Pixel data Cacheable", $GDIP_IMAGEFLAGS_CACHING],  ["Pixel data read-only", $GDIP_IMAGEFLAGS_READONLY],  ["Pixel size in image", $GDIP_IMAGEFLAGS_HASREALPIXELSIZE],  ["DPI info in image", $GDIP_IMAGEFLAGS_HASREALDPI],  ["YCCK color space", $GDIP_IMAGEFLAGS_COLORSPACE_YCCK],  ["YCBCR color space", $GDIP_IMAGEFLAGS_COLORSPACE_YCBCR],  ["Grayscale image", $GDIP_IMAGEFLAGS_COLORSPACE_GRAY],  ["CMYK color space", $GDIP_IMAGEFLAGS_COLORSPACE_CMYK],  ["RGB color space", $GDIP_IMAGEFLAGS_COLORSPACE_RGB],  ["Partially scalable", $GDIP_IMAGEFLAGS_PARTIALLYSCALABLE],  ["Alpha values other than 0 (transparent) and 255 (opaque)", $GDIP_IMAGEFLAGS_HASTRANSLUCENT],  ["Alpha values", $GDIP_IMAGEFLAGS_HASALPHA],  ["Scalable", $GDIP_IMAGEFLAGS_SCALABLE]]
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageFlags", "handle", $hImage, "long*", 0)
If @error Then Return SetError(@error, @extended, $aFlag)
If $aCall[0] Then Return SetError(10, $aCall[0], $aFlag)
If $aCall[2] = $GDIP_IMAGEFLAGS_NONE Then
$aFlag[1] = "No pixel data"
Return SetError(12, $aCall[2], $aFlag)
EndIf
$aFlag[0] = $aCall[2]
For $i = 0 To 12
If BitAND($aCall[2], $aImageFlags[$i][1]) = $aImageFlags[$i][1] Then
If StringLen($aFlag[1]) Then $aFlag[1] &= "|"
$aCall[2] -= $aImageFlags[$i][1]
$aFlag[1] &= $aImageFlags[$i][0]
EndIf
Next
Return $aFlag
EndFunc
Func _GDIPlus_ImageGetFrameCount($hImage, $sDimensionID)
Local $tGUID = _WinAPI_GUIDFromString($sDimensionID)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipImageGetFrameCount", "handle", $hImage, "struct*", $tGUID, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[3]
EndFunc
Func _GDIPlus_ImageGetGraphicsContext($hImage)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageGraphicsContext", "handle", $hImage, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_ImageGetHeight($hImage)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageHeight", "handle", $hImage, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_ImageGetHorizontalResolution($hImage)
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageHorizontalResolution", "handle", $hImage, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return Round($aCall[2])
EndFunc
Func _GDIPlus_ImageGetPixelFormat($hImage)
Local $aFormat[2] = [0, ""]
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, $aFormat)
Local $aPixelFormat[14][2] =  [["1 Bpp Indexed", $GDIP_PXF01INDEXED],  ["4 Bpp Indexed", $GDIP_PXF04INDEXED],  ["8 Bpp Indexed", $GDIP_PXF08INDEXED],  ["16 Bpp Grayscale", $GDIP_PXF16GRAYSCALE],  ["16 Bpp RGB 555", $GDIP_PXF16RGB555],  ["16 Bpp RGB 565", $GDIP_PXF16RGB565],  ["16 Bpp ARGB 1555", $GDIP_PXF16ARGB1555],  ["24 Bpp RGB", $GDIP_PXF24RGB],  ["32 Bpp RGB", $GDIP_PXF32RGB],  ["32 Bpp ARGB", $GDIP_PXF32ARGB],  ["32 Bpp PARGB", $GDIP_PXF32PARGB],  ["48 Bpp RGB", $GDIP_PXF48RGB],  ["64 Bpp ARGB", $GDIP_PXF64ARGB],  ["64 Bpp PARGB", $GDIP_PXF64PARGB]]
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImagePixelFormat", "handle", $hImage, "int*", 0)
If @error Then Return SetError(@error, @extended, $aFormat)
If $aCall[0] Then Return SetError(10, $aCall[0], $aFormat)
For $i = 0 To 13
If $aPixelFormat[$i][1] = $aCall[2] Then
$aFormat[0] = $aPixelFormat[$i][1]
$aFormat[1] = $aPixelFormat[$i][0]
Return $aFormat
EndIf
Next
Return SetError(12, 0, $aFormat)
EndFunc
Func __GDIPlus_ImageGetPropertyCount($hImage)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPropertyCount", "handle", $hImage, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_ImageGetPropertyIdList($hImage)
Local $iCount = __GDIPlus_ImageGetPropertyCount($hImage)
If @error Then Return SetError(@error, @extended, False)
Local $tProperties = DllStructCreate("uint[" & $iCount & "]")
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPropertyIdList", "handle", $hImage, "int", $iCount, "struct*", $tProperties)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Local $sPropertyTagInfo = "0x0000=GpsVer;0x0001=GpsLatitudeRef;0x0002=GpsLatitude;0x0003=GpsLongitudeRef;0x0004=GpsLongitude;0x0005=GpsAltitudeRef;0x0006=GpsAltitude;0x0007=GpsGpsTime;0x0008=GpsGpsSatellites;0x0009=GpsGpsStatus;0x000A=GpsGpsMeasureMode;0x000B=GpsGpsDop;0x000C=GpsSpeedRef;0x000D=GpsSpeed;0x000E=GpsTrackRef;0x000F=GpsTrack;0x0010=GpsImgDirRef;0x0011=GpsImgDir;0x0012=GpsMapDatum;0x0013=GpsDestLatRef;0x0014=GpsDestLat;0x0015=GpsDestLongRef;0x0016=GpsDestLong;0x0017=GpsDestBearRef;0x0018=GpsDestBear;0x0019=GpsDestDistRef;0x001A=GpsDestDist;0x00FE=NewSubfileType;0x00FF=SubfileType;0x0100=ImageWidth;0x0101=ImageHeight;0x0102=BitsPerSample;0x0103=Compression;0x0106=PhotometricInterp;0x0107=ThreshHolding;0x0108=CellWidth;0x0109=CellHeight;0x010A=FillOrder;0x010D=DocumentName;0x010E=ImageDescription;0x010F=EquipMake;0x0110=EquipModel;0x0111=StripOffsets;0x0112=Orientation;0x0115=SamplesPerPixel;0x0116=RowsPerStrip;0x0117=StripBytesCount;0x0118=MinSampleValue;0x0119=MaxSampleValue;0x011A=XResolution;0x011B=YResolution;0x011C=PlanarConfig;0x011D=PageName;0x011E=XPosition;0x011F=YPosition;0x0120=FreeOffset;0x0121=FreeByteCounts;0x0122=GrayResponseUnit;0x0123=GrayResponseCurve;0x0124=T4Option;0x0125=T6Option;0x0128=ResolutionUnit;0x0129=PageNumber;0x012D=TransferFunction;0x0131=SoftwareUsed;0x0132=DateTime;0x013B=Artist;0x013C=HostComputer;0x013D=Predictor;0x013E=WhitePoint;0x013F=PrimaryChromaticities;0x0140=ColorMap;0x0141=HalftoneHints;0x0142=TileWidth;0x0143=TileLength;0x0144=TileOffset;0x0145=TileByteCounts;0x014C=InkSet;0x014D=InkNames;0x014E=NumberOfInks;0x0150=DotRange;0x0151=TargetPrinter;0x0152=ExtraSamples;0x0153=SampleFormat;0x0154=SMinSampleValue;0x0155=SMaxSampleValue;0x0156=TransferRange;0x0200=JPEGProc;0x0201=JPEGInterFormat;0x0202=JPEGInterLength;0x0203=JPEGRestartInterval;0x0205=JPEGLosslessPredictors;0x0206=JPEGPointTransforms;0x0207=JPEGQTables;0x0208=JPEGDCTables;0x0209=JPEGACTables;0x0211=YCbCrCoefficients;0x0212=YCbCrSubsampling;0x0213=YCbCrPositioning;0x0214=REFBlackWhite;0x0301=Gamma;0x0302=ICCProfileDescriptor;0x0303=SRGBRenderingIntent;0x0320=ImageTitle;0x5001=ResolutionXUnit;0x5002=ResolutionYUnit;0x5003=ResolutionXLengthUnit;0x5004=ResolutionYLengthUnit;0x5005=PrintFlags;0x5006=PrintFlagsVersion;0x5007=PrintFlagsCrop;0x5008=PrintFlagsBleedWidth;0x5009=PrintFlagsBleedWidthScale;0x500A=HalftoneLPI;0x500B=HalftoneLPIUnit;0x500C=HalftoneDegree;" & _
"0x500D=HalftoneShape;0x500E=HalftoneMisc;0x500F=HalftoneScreen;0x5010=JPEGQuality;0x5011=GridSize;0x5012=ThumbnailFormat;0x5013=ThumbnailWidth;0x5014=ThumbnailHeight;0x5015=ThumbnailColorDepth;0x5016=ThumbnailPlanes;0x5017=ThumbnailRawBytes;0x5018=ThumbnailSize;0x5019=ThumbnailCompressedSize;0x501A=ColorTransferFunction;0x501B=ThumbnailData;0x5020=ThumbnailImageWidth;0x5021=ThumbnailImageHeight;0x5022=ThumbnailBitsPerSample;0x5023=ThumbnailCompression;0x5024=ThumbnailPhotometricInterp;0x5025=ThumbnailImageDescription;0x5026=ThumbnailEquipMake;0x5027=ThumbnailEquipModel;0x5028=ThumbnailStripOffsets;0x5029=ThumbnailOrientation;0x502A=ThumbnailSamplesPerPixel;0x502B=ThumbnailRowsPerStrip;0x502C=ThumbnailStripBytesCount;0x502D=ThumbnailResolutionX;0x502E=ThumbnailResolutionY;0x502F=ThumbnailPlanarConfig;0x5030=ThumbnailResolutionUnit;0x5031=ThumbnailTransferFunction;0x5032=ThumbnailSoftwareUsed;0x5033=ThumbnailDateTime;0x5034=ThumbnailArtist;0x5035=ThumbnailWhitePoint;0x5036=ThumbnailPrimaryChromaticities;0x5037=ThumbnailYCbCrCoefficients;0x5038=ThumbnailYCbCrSubsampling;0x5039=ThumbnailYCbCrPositioning;0x503A=ThumbnailRefBlackWhite;0x503B=ThumbnailCopyRight;0x5090=LuminanceTable;0x5091=ChrominanceTable;0x5100=FrameDelay;0x5101=LoopCount;0x5102=GlobalPalette;0x5103=IndexBackground;0x5104=IndexTransparent;0x5110=PixelUnit;0x5111=PixelPerUnitX;0x5112=PixelPerUnitY;0x5113=PaletteHistogram;0x8298=Copyright;0x829A=ExifExposureTime;0x829D=ExifFNumber;0x8769=ExifIFD;0x8773=ICCProfile;0x8822=ExifExposureProg;0x8824=ExifSpectralSense;0x8825=GpsIFD;0x8827=ExifISOSpeed;0x8828=ExifOECF;0x9000=ExifVer;0x9003=ExifDTOrig;0x9004=ExifDTDigitized;0x9101=ExifCompConfig;0x9102=ExifCompBPP;0x9201=ExifShutterSpeed;0x9202=ExifAperture;0x9203=ExifBrightness;0x9204=ExifExposureBias;0x9205=ExifMaxAperture;0x9206=ExifSubjectDist;0x9207=ExifMeteringMode;0x9208=ExifLightSource;0x9209=ExifFlash;0x920A=ExifFocalLength;0x927C=ExifMakerNote;0x9286=ExifUserComment;0x9290=ExifDTSubsec;0x9291=ExifDTOrigSS;0x9292=ExifDTDigSS;0xA000=ExifFPXVer;0xA001=ExifColorSpace;0xA002=ExifPixXDim;0xA003=ExifPixYDim;0xA004=ExifRelatedWav;0xA005=ExifInterop;0xA20B=ExifFlashEnergy;0xA20C=ExifSpatialFR;0xA20E=ExifFocalXRes;0xA20F=ExifFocalYRes;0xA210=ExifFocalResUnit;0xA214=ExifSubjectLoc;0xA215=ExifExposureIndex;0xA217=ExifSensingMethod;0xA300=ExifFileSource;0xA301=ExifSceneType;0xA302=ExifCfaPattern"
Local $aProperties[$iCount + 1][2] = [[$iCount]]
Local $aRegExp
For $i = 1 To $iCount
$aProperties[$i][0] = DllStructGetData($tProperties, 1, $i)
$aRegExp = StringRegExp($sPropertyTagInfo, "(?i)" & Hex(DllStructGetData($tProperties, 1, $i), 4) & "=(\w+)", $STR_REGEXPARRAYGLOBALMATCH)
Switch IsArray($aRegExp)
Case True
$aProperties[$i][1] = $aRegExp[0]
Case Else
$aProperties[$i][1] = "PropertyTagUnKnown"
EndSwitch
Next
Return $aProperties
EndFunc
Func __GDIPlus_ImageGetPropertyItemSize($hImage, $iPropID)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPropertyItemSize", "handle", $hImage, "uint", $iPropID, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[3]
EndFunc
Func _GDIPlus_ImageGetPropertyItem($hImage, $iPropID)
Local $iSize = __GDIPlus_ImageGetPropertyItemSize($hImage, $iPropID)
If @error Then Return SetError(@error, @extended, False)
Local $tBuffer = DllStructCreate("byte[" & $iSize & "];")
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPropertyItem", "handle", $hImage, "uint", $iPropID, "uint", $iSize, "struct*", $tBuffer)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Local $tPropertyItem = DllStructCreate("int id; int length; short type; ptr value;", $pBuffer)
Local $iBytes = DllStructGetData($tPropertyItem, "length")
Local $pValue = DllStructGetData($tPropertyItem, "value")
Local $tValues, $iValues
Switch DllStructGetData($tPropertyItem, "type")
Case 2
$iValues = 1
$tValues = DllStructCreate("char[" & $iBytes & "];", $pValue)
Case 3
$iValues = Int($iBytes / 2)
$tValues = DllStructCreate("ushort[" & $iValues & "];", $pValue)
Case 4, 5
$iValues = Int($iBytes / 4)
$tValues = DllStructCreate("uint[" & $iValues & "];", $pValue)
Case 9, 10
$iValues = Int($iBytes / 4)
$tValues = DllStructCreate("int[" & $iValues & "];", $pValue)
Case Else
$iValues = 1
$tValues = DllStructCreate("byte[" & $iBytes & "];", $pValue)
EndSwitch
Local $aValues[$iValues + 1] = [$iValues]
Switch DllStructGetData($tPropertyItem, "type")
Case 5, 10
$iValues = Int($iValues / 2)
ReDim $aValues[$iValues + 1]
$aValues[0] = $iValues
For $j = 1 To $iValues
$aValues[$j] = DllStructGetData($tValues, 1, ($j - 1) * 2 + 1) / DllStructGetData($tValues, 1, ($j - 1) * 2 + 2)
Next
Case 3, 4, 9
For $j = 1 To $iValues
$aValues[$j] = DllStructGetData($tValues, 1, $j)
Next
Case Else
$aValues[1] = DllStructGetData($tValues, 1)
EndSwitch
Return $aValues
EndFunc
Func _GDIPlus_ImageGetRawFormat($hImage)
Local $aGuid[2]
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, $aGuid)
Local $aImageType[11][2] =  [["UNDEFINED", $GDIP_IMAGEFORMAT_UNDEFINED],  ["MEMORYBMP", $GDIP_IMAGEFORMAT_MEMORYBMP],  ["BMP", $GDIP_IMAGEFORMAT_BMP],  ["EMF", $GDIP_IMAGEFORMAT_EMF],  ["WMF", $GDIP_IMAGEFORMAT_WMF],  ["JPEG", $GDIP_IMAGEFORMAT_JPEG],  ["PNG", $GDIP_IMAGEFORMAT_PNG],  ["GIF", $GDIP_IMAGEFORMAT_GIF],  ["TIFF", $GDIP_IMAGEFORMAT_TIFF],  ["EXIF", $GDIP_IMAGEFORMAT_EXIF],  ["ICON", $GDIP_IMAGEFORMAT_ICON]]
Local $tStruct = DllStructCreate("byte[16]")
Local $aCall1 = DllCall($__g_hGDIPDll, "int", "GdipGetImageRawFormat", "handle", $hImage, "struct*", $tStruct)
If @error Then Return SetError(@error, @extended, $aGuid)
If $aCall1[0] Then Return SetError(10, $aCall1[0], $aGuid)
Local $sResult2 = _WinAPI_StringFromGUID($aCall1[2])
If @error Then Return SetError(@error + 20, @extended, $aGuid)
If $sResult2 = "" Then Return SetError(12, 0, $aGuid)
For $i = 0 To 10
If $aImageType[$i][1] == $sResult2 Then
$aGuid[0] = $aImageType[$i][1]
$aGuid[1] = $aImageType[$i][0]
Return $aGuid
EndIf
Next
Return SetError(13, 0, $aGuid)
EndFunc
Func _GDIPlus_ImageGetThumbnail($hImage, $iWidth = 0, $iHeight = 0, $bKeepRatio = True, $hCallback = Null, $hCallbackData = Null)
If $bKeepRatio Then
Local $aImgDim = _GDIPlus_ImageGetDimension($hImage)
If @error Then Return SetError(@error + 20, @extended, False)
Local $f
If $iWidth < 1 Or $iHeight < 1 Then
$iWidth = 0
$iHeight = 0
Else
If ($aImgDim[0] / $aImgDim[1]) > 1 Then
$f = $aImgDim[0] / $iWidth
Else
$f = $aImgDim[1] / $iHeight
EndIf
$iWidth = Int($aImgDim[0] / $f)
$iHeight = Int($aImgDim[1] / $f)
EndIf
EndIf
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageThumbnail", "handle", $hImage, "uint", $iWidth, "uint", $iHeight, "ptr*", 0, "ptr", $hCallback, "ptr", $hCallbackData)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return $aCall[4]
EndFunc
Func _GDIPlus_ImageGetType($hImage)
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, -1)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageType", "handle", $hImage, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_ImageGetVerticalResolution($hImage)
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageVerticalResolution", "handle", $hImage, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return Round($aCall[2])
EndFunc
Func _GDIPlus_ImageGetWidth($hImage)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetImageWidth", "handle", $hImage, "uint*", -1)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_ImageLoadFromFile($sFileName)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipLoadImageFromFile", "wstr", $sFileName, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_ImageLoadFromStream($pStream)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipLoadImageFromStream", "ptr", $pStream, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_ImageRotateFlip($hImage, $iRotateFlipType)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipImageRotateFlip", "handle", $hImage, "int", $iRotateFlipType)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ImageSaveAdd($hImage, $tParams)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSaveAdd", "handle", $hImage, "struct*", $tParams)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ImageSaveAddImage($hImage, $hImageNew, $tParams)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSaveAddImage", "handle", $hImage, "handle", $hImageNew, "struct*", $tParams)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ImageSaveToFile($hImage, $sFileName)
Local $sExt = __GDIPlus_ExtractFileExt($sFileName)
Local $sCLSID = _GDIPlus_EncodersGetCLSID($sExt)
If $sCLSID = "" Then Return SetError(-1, 0, False)
Local $bRet = _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sCLSID, 0)
Return SetError(@error, @extended, $bRet)
EndFunc
Func _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sEncoder, $tParams = 0)
Local $tGUID = _WinAPI_GUIDFromString($sEncoder)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSaveImageToFile", "handle", $hImage, "wstr", $sFileName, "struct*", $tGUID, "struct*", $tParams)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ImageSaveToStream($hImage, $pStream, $tEncoder, $tParams = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSaveImageToStream", "handle", $hImage, "ptr", $pStream, "struct*", $tEncoder, "struct*", $tParams)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ImageScale($hImage, $iScaleW, $iScaleH, $iInterpolationMode = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
Local $iWidth = _GDIPlus_ImageGetWidth($hImage)
If @error Then Return SetError(1, 0, 0)
Local $iHeight = _GDIPlus_ImageGetHeight($hImage)
If @error Then Return SetError(2, 0, 0)
Local $iNewWidth = $iWidth * $iScaleW
Local $iNewHeight = $iHeight * $iScaleH
Local $hBitmap = _GDIPlus_BitmapCreateFromScan0($iNewWidth, $iNewHeight)
If @error Then Return SetError(3, 0, 0)
Local $hBmpCtxt = _GDIPlus_ImageGetGraphicsContext($hBitmap)
_GDIPlus_GraphicsSetInterpolationMode($hBmpCtxt, $iInterpolationMode)
_GDIPlus_GraphicsSetPixelOffsetMode($hBmpCtxt, $GDIP_PIXELOFFSETMODE_HIGHQUALITY)
Local $hIA = _GDIPlus_ImageAttributesCreate()
__GDIPlus_ImageAttributesSetImageWrapMode($hIA)
If @error Then
_GDIPlus_ImageAttributesDispose($hIA)
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(4, 0, 0)
EndIf
_GDIPlus_GraphicsDrawImageRectRect($hBmpCtxt, $hImage, 0, 0, $iWidth, $iHeight, 0, 0, $iNewWidth, $iNewHeight, $hIA)
_GDIPlus_ImageAttributesDispose($hIA)
_GDIPlus_GraphicsDispose($hBmpCtxt)
Return $hBitmap
EndFunc
Func __GDIPlus_ImageAttributesSetImageWrapMode($hImageAttributes, $iWrapMode = $GDIP_WrapModeTileFlipXY, $iColor = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetImageAttributesWrapMode", "handle", $hImageAttributes,  "long", $iWrapMode, "uint", $iColor, "bool", False)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageSelectActiveFrame($hImage, $sDimensionID, $iFrameIndex)
Local $tGUID = _WinAPI_GUIDFromString($sDimensionID)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipImageSelectActiveFrame", "handle", $hImage, "struct*", $tGUID, "uint", $iFrameIndex)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ImageResize($hImage, $iNewWidth, $iNewHeight, $iInterpolationMode = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
Local $iWidth = _GDIPlus_ImageGetWidth($hImage)
If @error Then Return SetError(1, 0, 0)
Local $iHeight = _GDIPlus_ImageGetHeight($hImage)
If @error Then Return SetError(2, 0, 0)
Local $hBitmap = _GDIPlus_BitmapCreateFromScan0($iNewWidth, $iNewHeight)
If @error Then Return SetError(3, 0, 0)
Local $hBmpCtxt = _GDIPlus_ImageGetGraphicsContext($hBitmap)
_GDIPlus_GraphicsSetInterpolationMode($hBmpCtxt, $iInterpolationMode)
_GDIPlus_GraphicsSetPixelOffsetMode($hBmpCtxt, $GDIP_PIXELOFFSETMODE_HIGHQUALITY)
Local $hIA = _GDIPlus_ImageAttributesCreate()
__GDIPlus_ImageAttributesSetImageWrapMode($hIA)
If @error Then
_GDIPlus_ImageAttributesDispose($hIA)
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(4, 0, 0)
EndIf
_GDIPlus_GraphicsDrawImageRectRect($hBmpCtxt, $hImage, 0, 0, $iWidth, $iHeight, 0, 0, $iNewWidth, $iNewHeight, $hIA)
_GDIPlus_GraphicsDispose($hBmpCtxt)
Return $hBitmap
EndFunc
Func _GDIPlus_LineBrushCreate($nX1, $nY1, $nX2, $nY2, $iARGBClr1, $iARGBClr2, $iWrapMode = 0)
Local $tPointF1, $tPointF2, $aCall
$tPointF1 = DllStructCreate("float;float")
$tPointF2 = DllStructCreate("float;float")
DllStructSetData($tPointF1, 1, $nX1)
DllStructSetData($tPointF1, 2, $nY1)
DllStructSetData($tPointF2, 1, $nX2)
DllStructSetData($tPointF2, 2, $nY2)
$aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateLineBrush", "struct*", $tPointF1, "struct*", $tPointF2, "uint", $iARGBClr1, "uint", $iARGBClr2, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[6]
EndFunc
Func _GDIPlus_LineBrushCreateFromRect($tRECTF, $iARGBClr1, $iARGBClr2, $iGradientMode = 0, $iWrapMode = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateLineBrushFromRect", "struct*", $tRECTF, "uint", $iARGBClr1, "uint", $iARGBClr2, "int", $iGradientMode, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[6]
EndFunc
Func _GDIPlus_LineBrushCreateFromRectWithAngle($tRECTF, $iARGBClr1, $iARGBClr2, $fAngle, $bIsAngleScalable = True, $iWrapMode = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateLineBrushFromRectWithAngle", "struct*", $tRECTF, "uint", $iARGBClr1, "uint", $iARGBClr2, "float", $fAngle, "int", $bIsAngleScalable, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[7]
EndFunc
Func _GDIPlus_LineBrushGetColors($hLineGradientBrush)
Local $tARGBs, $aARGBs[2], $aCall
$tARGBs = DllStructCreate("uint;uint")
$aCall = DllCall($__g_hGDIPDll, "uint", "GdipGetLineColors", "handle", $hLineGradientBrush, "struct*", $tARGBs)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
$aARGBs[0] = DllStructGetData($tARGBs, 1)
$aARGBs[1] = DllStructGetData($tARGBs, 2)
Return $aARGBs
EndFunc
Func _GDIPlus_LineBrushGetRect($hLineGradientBrush)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetLineRect", "handle", $hLineGradientBrush, "struct*", $tRECTF)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Local $aRectF[4]
For $iI = 1 To 4
$aRectF[$iI - 1] = DllStructGetData($tRECTF, $iI)
Next
Return $aRectF
EndFunc
Func _GDIPlus_LineBrushMultiplyTransform($hLineGradientBrush, $hMatrix, $iOrder = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipMultiplyLineTransform", "handle", $hLineGradientBrush, "handle", $hMatrix, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushResetTransform($hLineGradientBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipResetLineTransform", "handle", $hLineGradientBrush)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetBlend($hLineGradientBrush, $aBlends)
Local $iI, $iCount, $tFactors, $tPositions, $aCall
$iCount = $aBlends[0][0]
$tFactors = DllStructCreate("float[" & $iCount & "]")
$tPositions = DllStructCreate("float[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tFactors, 1, $aBlends[$iI][0], $iI)
DllStructSetData($tPositions, 1, $aBlends[$iI][1], $iI)
Next
$aCall = DllCall($__g_hGDIPDll, "int", "GdipSetLineBlend", "handle", $hLineGradientBrush, "struct*", $tFactors, "struct*", $tPositions, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetColors($hLineGradientBrush, $iARGBStart, $iARGBEnd)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetLineColors", "handle", $hLineGradientBrush, "uint", $iARGBStart, "uint", $iARGBEnd)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetGammaCorrection($hLineGradientBrush, $bUseGammaCorrection = True)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetLineGammaCorrection", "handle", $hLineGradientBrush, "int", $bUseGammaCorrection)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetLinearBlend($hLineGradientBrush, $fFocus, $fScale = 1)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetLineLinearBlend", "handle", $hLineGradientBrush, "float", $fFocus, "float", $fScale)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetPresetBlend($hLineGradientBrush, $aInterpolations)
Local $iI, $iCount, $tColors, $tPositions, $aCall
$iCount = $aInterpolations[0][0]
$tColors = DllStructCreate("uint[" & $iCount & "]")
$tPositions = DllStructCreate("float[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tColors, 1, $aInterpolations[$iI][0], $iI)
DllStructSetData($tPositions, 1, $aInterpolations[$iI][1], $iI)
Next
$aCall = DllCall($__g_hGDIPDll, "int", "GdipSetLinePresetBlend", "handle", $hLineGradientBrush, "struct*", $tColors, "struct*", $tPositions, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetSigmaBlend($hLineGradientBrush, $fFocus, $fScale = 1)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetLineSigmaBlend", "handle", $hLineGradientBrush, "float", $fFocus, "float", $fScale)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetTransform($hLineGradientBrush, $hMatrix)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetLineTransform", "handle", $hLineGradientBrush, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixCreate()
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateMatrix", "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[1]
EndFunc
Func _GDIPlus_MatrixCreate2($nM11 = 1, $nM12 = 1, $nM21 = 1, $nM22 = 1, $nDX = 0, $nDY = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateMatrix2", "float", $nM11, "float", $nM12, "float", $nM21, "float", $nM22, "float", $nDX, "float", $nDY, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[7]
EndFunc
Func _GDIPlus_MatrixClone($hMatrix)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCloneMatrix", "handle", $hMatrix, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_MatrixDispose($hMatrix)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDeleteMatrix", "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixGetElements($hMatrix)
Local $tElements = DllStructCreate("float[6]")
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetMatrixElements", "handle", $hMatrix, "struct*", $tElements)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Local $aElements[6]
For $iI = 1 To 6
$aElements[$iI - 1] = DllStructGetData($tElements, 1, $iI)
Next
Return $aElements
EndFunc
Func _GDIPlus_MatrixInvert($hMatrix)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipInvertMatrix", "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixMultiply($hMatrix1, $hMatrix2, $iOrder = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipMultiplyMatrix", "handle", $hMatrix1, "handle", $hMatrix2, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixRotate($hMatrix, $fAngle, $bAppend = False)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipRotateMatrix", "handle", $hMatrix, "float", $fAngle, "int", $bAppend)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixScale($hMatrix, $fScaleX, $fScaleY, $bOrder = False)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipScaleMatrix", "handle", $hMatrix, "float", $fScaleX, "float", $fScaleY, "int", $bOrder)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixSetElements($hMatrix, $nM11 = 1, $nM12 = 0, $nM21 = 0, $nM22 = 1, $nDX = 0, $nDY = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetMatrixElements", "handle", $hMatrix, "float", $nM11, "float", $nM12,  "float", $nM21, "float", $nM22, "float", $nDX, "float", $nDY)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixShear($hMatrix, $fShearX, $fShearY, $iOrder = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipShearMatrix", "handle", $hMatrix, "float", $fShearX, "float", $fShearY, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixTransformPoints($hMatrix, ByRef $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], ($iI - 1) * 2 + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], ($iI - 1) * 2 + 2)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipTransformMatrixPoints", "handle", $hMatrix, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
For $iI = 1 To $iCount
$aPoints[$iI][0] = DllStructGetData($tPoints, 1, ($iI - 1) * 2 + 1)
$aPoints[$iI][1] = DllStructGetData($tPoints, 1, ($iI - 1) * 2 + 2)
Next
Return True
EndFunc
Func _GDIPlus_MatrixTranslate($hMatrix, $fOffsetX, $fOffsetY, $bAppend = False)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipTranslateMatrix", "handle", $hMatrix, "float", $fOffsetX, "float", $fOffsetY, "int", $bAppend)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_ParamAdd(ByRef $tParams, $sGUID, $iNbOfValues, $iType, $pValues)
Local $iCount = DllStructGetData($tParams, "Count")
Local $pGUID = DllStructGetPtr($tParams, "GUID") + ($iCount * _GDIPlus_ParamSize())
Local $tParam = DllStructCreate($tagGDIPENCODERPARAM, $pGUID)
_WinAPI_GUIDFromStringEx($sGUID, $pGUID)
DllStructSetData($tParam, "Type", $iType)
DllStructSetData($tParam, "NumberOfValues", $iNbOfValues)
DllStructSetData($tParam, "Values", $pValues)
DllStructSetData($tParams, "Count", $iCount + 1)
EndFunc
Func _GDIPlus_ParamInit($iCount)
Local $sStruct = $tagGDIPENCODERPARAMS
For $i = 2 To $iCount
$sStruct &= ";struct;byte[16];ulong;ulong;ptr;endstruct"
Next
Return DllStructCreate($sStruct)
EndFunc
Func _GDIPlus_ParamSize()
Local $tParam = DllStructCreate($tagGDIPENCODERPARAM)
Return DllStructGetSize($tParam)
EndFunc
Func _GDIPlus_PathAddArc($hPath, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathArc", "handle", $hPath, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddBezier($hPath, $nX1, $nY1, $nX2, $nY2, $nX3, $nY3, $nX4, $nY4)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathBezier", "handle", $hPath, "float", $nX1, "float", $nY1, "float", $nX2, "float", $nY2, "float", $nX3, "float", $nY3, "float", $nX4, "float", $nY4)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddClosedCurve($hPath, $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathClosedCurve", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddClosedCurve2($hPath, $aPoints, $nTension = 0.5)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathClosedCurve2", "handle", $hPath, "struct*", $tPoints, "int", $iCount, "float", $nTension)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddCurve($hPath, $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathCurve", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddCurve2($hPath, $aPoints, $nTension = 0.5)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathCurve2", "handle", $hPath, "struct*", $tPoints, "int", $iCount, "float", $nTension)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddCurve3($hPath, $aPoints, $iOffset, $iNumOfSegments, $nTension = 0.5)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathCurve3", "handle", $hPath, "struct*", $tPoints, "int", $iCount, "int", $iOffset, "int", $iNumOfSegments, "float", $nTension)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddEllipse($hPath, $nX, $nY, $nWidth, $nHeight)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathEllipse", "handle", $hPath, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddLine($hPath, $nX1, $nY1, $nX2, $nY2)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathLine", "handle", $hPath, "float", $nX1, "float", $nY1, "float", $nX2, "float", $nY2)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddLine2($hPath, $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathLine2", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddPath($hPath1, $hPath2, $bConnect = True)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathPath", "handle", $hPath1, "handle", $hPath2, "int", $bConnect)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddPie($hPath, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathPie", "handle", $hPath, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddPolygon($hPath, $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathPolygon", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddRectangle($hPath, $nX, $nY, $nWidth, $nHeight)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathRectangle", "handle", $hPath, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddString($hPath, $sString, $tLayout, $hFamily, $iStyle = 0, $fSize = 8.5, $hFormat = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipAddPathString", "handle", $hPath, "wstr", $sString, "int", -1,  "handle", $hFamily, "int", $iStyle, "float", $fSize, "struct*", $tLayout, "handle", $hFormat)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushCreate($aPoints, $iWrapMode = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreatePathGradient", "struct*", $tPoints, "int", $iCount, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[4]
EndFunc
Func _GDIPlus_PathBrushCreateFromPath($hPath)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreatePathGradientFromPath", "handle", $hPath, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_PathBrushGetCenterPoint($hPathGradientBrush)
Local $tPointF = DllStructCreate("float;float")
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientCenterPoint", "handle", $hPathGradientBrush, "struct*", $tPointF)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Local $aPointF[2]
$aPointF[0] = DllStructGetData($tPointF, 1)
$aPointF[1] = DllStructGetData($tPointF, 2)
Return $aPointF
EndFunc
Func _GDIPlus_PathBrushGetFocusScales($hPathGradientBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientFocusScales", "handle", $hPathGradientBrush, "float*", 0, "float*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Local $aScales[2]
$aScales[0] = $aCall[2]
$aScales[1] = $aCall[3]
Return $aScales
EndFunc
Func _GDIPlus_PathBrushGetPointCount($hPathGradientBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientPointCount", "handle", $hPathGradientBrush, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_PathBrushGetRect($hPathGradientBrush)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientRect", "handle", $hPathGradientBrush, "struct*", $tRECTF)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Local $aRectF[4]
For $iI = 1 To 4
$aRectF[$iI - 1] = DllStructGetData($tRECTF, $iI)
Next
Return $aRectF
EndFunc
Func _GDIPlus_PathBrushGetWrapMode($hPathGradientBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientWrapMode", "handle", $hPathGradientBrush, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_PathBrushMultiplyTransform($hPathGradientBrush, $hMatrix, $iOrder = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipMultiplyPathGradientTransform", "handle", $hPathGradientBrush, "handle", $hMatrix, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushResetTransform($hPathGradientBrush)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipResetPathGradientTransform", "handle", $hPathGradientBrush)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetBlend($hPathGradientBrush, $aBlends)
Local $iCount = $aBlends[0][0]
Local $tFactors = DllStructCreate("float[" & $iCount & "]")
Local $tPositions = DllStructCreate("float[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tFactors, 1, $aBlends[$iI][0], $iI)
DllStructSetData($tPositions, 1, $aBlends[$iI][1], $iI)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientBlend", "handle", $hPathGradientBrush, "struct*", $tFactors, "struct*", $tPositions, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetCenterColor($hPathGradientBrush, $iARGB)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientCenterColor", "handle", $hPathGradientBrush, "uint", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetCenterPoint($hPathGradientBrush, $nX, $nY)
Local $tPointF = DllStructCreate("float;float")
DllStructSetData($tPointF, 1, $nX)
DllStructSetData($tPointF, 2, $nY)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientCenterPoint", "handle", $hPathGradientBrush, "struct*", $tPointF)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetFocusScales($hPathGradientBrush, $fScaleX, $fScaleY)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientFocusScales", "handle", $hPathGradientBrush, "float", $fScaleX, "float", $fScaleY)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetGammaCorrection($hPathGradientBrush, $bUseGammaCorrection)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientGammaCorrection", "handle", $hPathGradientBrush, "int", $bUseGammaCorrection)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetLinearBlend($hPathGradientBrush, $fFocus, $fScale = 1)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientLinearBlend", "handle", $hPathGradientBrush, "float", $fFocus, "float", $fScale)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetPresetBlend($hPathGradientBrush, $aInterpolations)
Local $iCount = $aInterpolations[0][0]
Local $tColors = DllStructCreate("uint[" & $iCount & "]")
Local $tPositions = DllStructCreate("float[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tColors, 1, $aInterpolations[$iI][0], $iI)
DllStructSetData($tPositions, 1, $aInterpolations[$iI][1], $iI)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientPresetBlend", "handle", $hPathGradientBrush, "struct*", $tColors, "struct*", $tPositions, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetSigmaBlend($hPathGradientBrush, $fFocus, $fScale = 1)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientSigmaBlend", "handle", $hPathGradientBrush, "float", $fFocus, "float", $fScale)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetSurroundColor($hPathGradientBrush, $iARGB)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientSurroundColorsWithCount", "handle", $hPathGradientBrush, "uint*", $iARGB, "int*", 1)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetSurroundColorsWithCount($hPathGradientBrush, $aColors)
Local $iCount = $aColors[0]
Local $iColors = _GDIPlus_PathBrushGetPointCount($hPathGradientBrush)
If $iColors < $iCount Then $iCount = $iColors
Local $tColors = DllStructCreate("uint[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tColors, 1, $aColors[$iI], $iI)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientSurroundColorsWithCount", "handle", $hPathGradientBrush, "struct*", $tColors, "int*", $iCount)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _GDIPlus_PathBrushSetTransform($hPathGradientBrush, $hMatrix)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientTransform", "handle", $hPathGradientBrush, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetWrapMode($hPathGradientBrush, $iWrapMode)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientWrapMode", "handle", $hPathGradientBrush, "int", $iWrapMode)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathClone($hPath)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipClonePath", "handle", $hPath, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_PathCloseFigure($hPath)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipClosePathFigure", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathCreate($iFillMode = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreatePath", "int", $iFillMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_PathCreate2($aPathData, $iFillMode = 0)
Local $iCount = $aPathData[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
Local $tTypes = DllStructCreate("byte[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPathData[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPathData[$iI][1], (($iI - 1) * 2) + 2)
DllStructSetData($tTypes, 1, $aPathData[$iI][2], $iI)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreatePath2", "struct*", $tPoints, "struct*", $tTypes, "int", $iCount, "int", $iFillMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[5]
EndFunc
Func _GDIPlus_PathDispose($hPath)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDeletePath", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathFlatten($hPath, $fFlatness = 0.25, $hMatrix = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipFlattenPath", "handle", $hPath, "handle", $hMatrix, "float", $fFlatness)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathGetData($hPath)
Local $iCount = _GDIPlus_PathGetPointCount($hPath)
Local $tPathData = DllStructCreate("int Count; ptr Points; ptr Types;")
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
Local $tTypes = DllStructCreate("byte[" & $iCount & "]")
DllStructSetData($tPathData, "Count", $iCount)
DllStructSetData($tPathData, "Points", DllStructGetPtr($tPoints))
DllStructSetData($tPathData, "Types", DllStructGetPtr($tTypes))
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPathData", "handle", $hPath, "struct*", $tPathData)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError($aCall[0], $aCall[0], -1)
Local $aData[$iCount + 1][3]
$aData[0][0] = $iCount
For $iI = 1 To $iCount
$aData[$iI][0] = DllStructGetData($tPoints, 1, (($iI - 1) * 2) + 1)
$aData[$iI][1] = DllStructGetData($tPoints, 1, (($iI - 1) * 2) + 2)
$aData[$iI][2] = DllStructGetData($tTypes, 1, $iI)
Next
Return $aData
EndFunc
Func _GDIPlus_PathGetFillMode($hPath)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPathFillMode", "handle", $hPath, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_PathGetLastPoint($hPath)
Local $tPointF = DllStructCreate("float;float")
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPathLastPoint", "handle", $hPath, "struct*", $tPointF)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Local $aPointF[2]
$aPointF[0] = DllStructGetData($tPointF, 1)
$aPointF[1] = DllStructGetData($tPointF, 2)
Return $aPointF
EndFunc
Func _GDIPlus_PathGetPointCount($hPath)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPointCount", "handle", $hPath, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_PathGetPoints($hPath)
Local $iI, $iCount, $tPoints, $aPoints[1][1], $aCall
$iCount = _GDIPlus_PathGetPointCount($hPath)
If @error Then Return SetError(@error + 10, @extended, -1)
$tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
$aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPathPoints", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Local $aPoints[$iCount + 1][2]
$aPoints[0][0] = $iCount
For $iI = 1 To $iCount
$aPoints[$iI][0] = DllStructGetData($tPoints, 1, (($iI - 1) * 2) + 1)
$aPoints[$iI][1] = DllStructGetData($tPoints, 1, (($iI - 1) * 2) + 2)
Next
Return $aPoints
EndFunc
Func _GDIPlus_PathGetWorldBounds($hPath, $hMatrix = 0, $hPen = 0)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPathWorldBounds", "handle", $hPath, "struct*", $tRECTF, "handle", $hMatrix, "handle", $hPen)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Local $aRectF[4]
For $iI = 1 To 4
$aRectF[$iI - 1] = DllStructGetData($tRECTF, $iI)
Next
Return $aRectF
EndFunc
Func _GDIPlus_PathIsOutlineVisiblePoint($hPath, $nX, $nY, $hPen = 0, $hGraphics = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipIsOutlineVisiblePathPoint", "handle", $hPath, "float", $nX, "float", $nY, "handle", $hPen, "handle", $hGraphics, "int*", 0)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return $aCall[6] <> 0
EndFunc
Func _GDIPlus_PathIsVisiblePoint($hPath, $nX, $nY, $hGraphics = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipIsVisiblePathPoint", "handle", $hPath, "float", $nX, "float", $nY, "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return $aCall[5] <> 0
EndFunc
Func _GDIPlus_PathIterCreate($hPath)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreatePathIter", "handle*", 0, "handle", $hPath)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[1]
EndFunc
Func _GDIPlus_PathIterDispose($hPathIter)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDeletePathIter", "handle", $hPathIter)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathIterGetSubpathCount($hPathIter)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipPathIterGetSubpathCount", "handle", $hPathIter, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_PathIterNextMarkerPath($hPathIter, $hPath)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipPathIterNextMarkerPath", "handle", $hPathIter, "int*", 0, "handle", $hPath)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_PathIterNextSubpathPath($hPathIter, $hPath)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipPathIterNextSubpathPath", "handle", $hPathIter, "int*", 0, "handle", $hPath, "bool*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Local $aRet[2]
$aRet[0] = $aCall[2]
$aRet[1] = $aCall[4]
Return $aRet
EndFunc
Func _GDIPlus_PathIterRewind($hPathIter)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipPathIterRewind", "handle", $hPathIter)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathReset($hPath)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipResetPath", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathReverse($hPath)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipReversePath", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathSetFillMode($hPath, $iFillMode)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPathFillMode", "handle", $hPath, "int", $iFillMode)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathSetMarker($hPath)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPathMarker", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathStartFigure($hPath)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipStartPathFigure", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathTransform($hPath, $hMatrix)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipTransformPath", "handle", $hPath, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathWarp($hPath, $hMatrix, $aPoints, $nX, $nY, $nWidth, $nHeight, $iWarpMode = 0, $fFlatness = 0.25)
Local $iCount = $aPoints[0][0]
If $iCount <> 3 And $iCount <> 4 Then Return SetError(11, 0, False)
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], ($iI - 1) * 2 + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], ($iI - 1) * 2 + 2)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipWarpPath", "handle", $hPath, "handle", $hMatrix, "struct*", $tPoints, "int", $iCount,  "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight, "int", $iWarpMode, "float", $fFlatness)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathWiden($hPath, $hPen, $hMatrix = 0, $fFlatness = 0.25)
__GDIPlus_PenDefCreate($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipWidenPath", "handle", $hPath, "handle", $hPen, "handle", $hMatrix, "float", $fFlatness)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PathWindingModeOutline($hPath, $hMatrix = 0, $fFlatness = 0.25)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipWindingModeOutline", "handle", $hPath, "handle", $hMatrix, "float", $fFlatness)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenCreate($iARGB = 0xFF000000, $nWidth = 1, $iUnit = 2)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreatePen1", "dword", $iARGB, "float", $nWidth, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[4]
EndFunc
Func _GDIPlus_PenCreate2($hBrush, $nWidth = 1, $iUnit = 2)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreatePen2", "handle", $hBrush, "float", $nWidth, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[4]
EndFunc
Func _GDIPlus_PenDispose($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDeletePen", "handle", $hPen)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenGetAlignment($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPenMode", "handle", $hPen, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_PenGetColor($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPenColor", "handle", $hPen, "dword*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_PenGetCustomEndCap($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPenCustomEndCap", "handle", $hPen, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_PenGetDashCap($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPenDashCap197819", "handle", $hPen, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_PenGetDashStyle($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPenDashStyle", "handle", $hPen, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_PenGetEndCap($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPenEndCap", "handle", $hPen, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_PenGetMiterLimit($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPenMiterLimit", "handle", $hPen, "float*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_PenGetWidth($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetPenWidth", "handle", $hPen, "float*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_PenResetTransform($hPen)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipResetPenTransform", "handle", $hPen)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenRotateTransform($hPen, $fAngle, $iOrder = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipRotatePenTransform", "handle", $hPen, "float", $fAngle, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenScaleTransform($hPen, $fScaleX, $fScaleY, $iOrder = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipScalePenTransform", "handle", $hPen, "float", $fScaleX, "float", $fScaleY, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetAlignment($hPen, $iAlignment = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPenMode", "handle", $hPen, "int", $iAlignment)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetColor($hPen, $iARGB)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPenColor", "handle", $hPen, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetCompound($hPen, $aCompounds)
Local $iCount = $aCompounds[0]
Local $tCompounds = DllStructCreate("float[" & $iCount & "];")
For $i = 1 To $iCount
DllStructSetData($tCompounds, 1, $aCompounds[$i], $i)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPenCompoundArray", "handle", $hPen, "struct*", $tCompounds, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetCustomEndCap($hPen, $hEndCap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPenCustomEndCap", "handle", $hPen, "handle", $hEndCap)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetDashCap($hPen, $iDash = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPenDashCap197819", "handle", $hPen, "int", $iDash)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetDashStyle($hPen, $iStyle = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPenDashStyle", "handle", $hPen, "int", $iStyle)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetEndCap($hPen, $iEndCap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPenEndCap", "handle", $hPen, "int", $iEndCap)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetLineCap($hPen, $iStartCap, $iEndCap, $iDashCap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPenLineCap197819", "handle", $hPen, "int", $iStartCap, "int", $iEndCap, "int", $iDashCap)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetLineJoin($hPen, $iLineJoin)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPenLineJoin", "handle", $hPen, "int", $iLineJoin)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetMiterLimit($hPen, $fMiterLimit)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPenMiterLimit", "handle", $hPen, "float", $fMiterLimit)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetStartCap($hPen, $iLineCap)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPenStartCap", "handle", $hPen, "int", $iLineCap)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetTransform($hPen, $hMatrix)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPenTransform", "handle", $hPen, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetWidth($hPen, $fWidth)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetPenWidth", "handle", $hPen, "float", $fWidth)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_RectFCreate($nX = 0, $nY = 0, $nWidth = 0, $nHeight = 0)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
DllStructSetData($tRECTF, "X", $nX)
DllStructSetData($tRECTF, "Y", $nY)
DllStructSetData($tRECTF, "Width", $nWidth)
DllStructSetData($tRECTF, "Height", $nHeight)
Return $tRECTF
EndFunc
Func _GDIPlus_RegionClone($hRegion)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCloneRegion", "handle", $hRegion, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_RegionCombinePath($hRegion, $hPath, $iCombineMode = 2)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCombineRegionPath", "handle", $hRegion, "handle", $hPath, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_RegionCombineRect($hRegion, $nX, $nY, $nWidth, $nHeight, $iCombineMode = 2)
Local $tRECTF = _GDIPlus_RectFCreate($nX, $nY, $nWidth, $nHeight)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCombineRegionRect", "handle", $hRegion, "struct*", $tRECTF, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_RegionCombineRegion($hRegionDst, $hRegionSrc, $iCombineMode = 2)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCombineRegionRegion", "handle", $hRegionDst, "handle", $hRegionSrc, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_RegionCreate()
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateRegion", "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[1]
EndFunc
Func _GDIPlus_RegionCreateFromPath($hPath)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateRegionPath", "handle", $hPath, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_RegionCreateFromRect($nX, $nY, $nWidth, $nHeight)
Local $tRECTF = _GDIPlus_RectFCreate($nX, $nY, $nWidth, $nHeight)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateRegionRect", "struct*", $tRECTF, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_RegionDispose($hRegion)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDeleteRegion", "handle", $hRegion)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_RegionGetBounds($hRegion, $hGraphics)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetRegionBounds", "handle", $hRegion, "handle", $hGraphics, "struct*", $tRECTF)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Local $aBounds[4]
For $iI = 1 To 4
$aBounds[$iI - 1] = DllStructGetData($tRECTF, $iI)
Next
Return $aBounds
EndFunc
Func _GDIPlus_RegionGetHRgn($hRegion, $hGraphics = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetRegionHRgn", "handle", $hRegion, "handle", $hGraphics, "handle*", 0)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return $aCall[3]
EndFunc
Func _GDIPlus_RegionSetEmpty($hRegion)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetEmpty", "handle", $hRegion)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_RegionSetInfinite($hRegion)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetInfinite", "handle", $hRegion)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_RegionTransform($hRegion, $hMatrix)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipTransformRegion", "handle", $hRegion, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_RegionTranslate($hRegion, $nDX, $nDY)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipTranslateRegion", "handle", $hRegion, "float", $nDX, "float", $nDY)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_Shutdown()
If $__g_hGDIPDll = 0 Then Return SetError(-1, -1, False)
$__g_iGDIPRef -= 1
If $__g_iGDIPRef = 0 Then
DllCall($__g_hGDIPDll, "none", "GdiplusShutdown", "ulong_ptr", $__g_iGDIPToken)
DllClose($__g_hGDIPDll)
$__g_hGDIPDll = 0
EndIf
Return True
EndFunc
Func _GDIPlus_Startup($sGDIPDLL = Default, $bRetDllHandle = False)
$__g_iGDIPRef += 1
If $__g_iGDIPRef > 1 Then Return True
If $sGDIPDLL = Default Then $sGDIPDLL = "gdiplus.dll"
$__g_hGDIPDll = DllOpen($sGDIPDLL)
If $__g_hGDIPDll = -1 Then
$__g_iGDIPRef = 0
Return SetError(1, 2, False)
EndIf
Local $sVer = FileGetVersion($sGDIPDLL)
$sVer = StringSplit($sVer, ".")
If $sVer[1] > 5 Then $__g_bGDIP_V1_0 = False
Local $tInput = DllStructCreate($tagGDIPSTARTUPINPUT)
Local $tToken = DllStructCreate("ulong_ptr Data")
DllStructSetData($tInput, "Version", 1)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdiplusStartup", "struct*", $tToken, "struct*", $tInput, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
$__g_iGDIPToken = DllStructGetData($tToken, "Data")
If $bRetDllHandle Then Return $__g_hGDIPDll
Return SetExtended($sVer[1], True)
EndFunc
Func _GDIPlus_StringFormatCreate($iFormat = 0, $iLangID = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateStringFormat", "int", $iFormat, "word", $iLangID, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _GDIPlus_StringFormatDispose($hFormat)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDeleteStringFormat", "handle", $hFormat)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_StringFormatGetMeasurableCharacterRangeCount($hStringFormat)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetStringFormatMeasurableCharacterRangeCount", "handle", $hStringFormat, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_StringFormatSetAlign($hStringFormat, $iFlag)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetStringFormatAlign", "handle", $hStringFormat, "int", $iFlag)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_StringFormatSetLineAlign($hStringFormat, $iStringAlign)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetStringFormatLineAlign", "handle", $hStringFormat, "int", $iStringAlign)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_StringFormatSetMeasurableCharacterRanges($hStringFormat, $aRanges)
Local $iCount = $aRanges[0][0]
Local $tCharacterRanges = DllStructCreate("int[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tCharacterRanges, 1, $aRanges[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tCharacterRanges, 1, $aRanges[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetStringFormatMeasurableCharacterRanges", "handle", $hStringFormat, "int", $iCount, "struct*", $tCharacterRanges)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_TextureCreate($hImage, $iWrapMode = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateTexture", "handle", $hImage, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _GDIPlus_TextureCreate2($hImage, $nX, $nY, $nWidth, $nHeight, $iWrapMode = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateTexture2", "handle", $hImage, "int", $iWrapMode, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[7]
EndFunc
Func _GDIPlus_TextureCreateIA($hImage, $nX, $nY, $nWidth, $nHeight, $pImageAttributes = 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateTextureIA", "handle", $hImage, "handle", $pImageAttributes, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight, "ptr*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[7]
EndFunc
Func __GDIPlus_BrushDefCreate(ByRef $hBrush)
If $hBrush = 0 Then
$__g_hGDIPBrush = _GDIPlus_BrushCreateSolid()
$hBrush = $__g_hGDIPBrush
EndIf
EndFunc
Func __GDIPlus_BrushDefDispose($iCurError = @error, $iCurExtended = @extended)
If $__g_hGDIPBrush <> 0 Then
_GDIPlus_BrushDispose($__g_hGDIPBrush)
$__g_hGDIPBrush = 0
EndIf
Return SetError($iCurError, $iCurExtended)
EndFunc
Func __GDIPlus_ExtractFileExt($sFileName, $bNoDot = True)
Local $iIndex = __GDIPlus_LastDelimiter(".\:", $sFileName)
If ($iIndex > 0) And (StringMid($sFileName, $iIndex, 1) = '.') Then
If $bNoDot Then
Return StringMid($sFileName, $iIndex + 1)
Else
Return StringMid($sFileName, $iIndex)
EndIf
Else
Return ""
EndIf
EndFunc
Func __GDIPlus_LastDelimiter($sDelimiters, $sString)
Local $sDelimiter, $iN
For $iI = 1 To StringLen($sDelimiters)
$sDelimiter = StringMid($sDelimiters, $iI, 1)
$iN = StringInStr($sString, $sDelimiter, $STR_NOCASESENSEBASIC, -1)
If $iN > 0 Then Return $iN
Next
EndFunc
Func __GDIPlus_PenDefCreate(ByRef $hPen)
If $hPen = 0 Then
$__g_hGDIPPen = _GDIPlus_PenCreate()
$hPen = $__g_hGDIPPen
EndIf
EndFunc
Func __GDIPlus_PenDefDispose($iCurError = @error, $iCurExtended = @extended)
If $__g_hGDIPPen <> 0 Then
_GDIPlus_PenDispose($__g_hGDIPPen)
$__g_hGDIPPen = 0
EndIf
Return SetError($iCurError, $iCurExtended)
EndFunc
Func _GDIPlus_BitmapApplyEffect($hBitmap, $hEffect, $tRECT = Null)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
If Not IsPtr($hEffect) Then Return SetError(10, 0, False)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipBitmapApplyEffect", "handle", $hBitmap, "handle", $hEffect, "struct*", $tRECT, "int", 0, "ptr*", 0, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapApplyEffectEx($hBitmap, $hEffect, $iX = 0, $iY = 0, $iW = 0, $iH = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $tRECT = 0
If BitOR($iX, $iY, $iW, $iH) Then
$tRECT = DllStructCreate("int Left; int Top; int Right; int Bottom;")
DllStructSetData($tRECT, "Right", $iW + DllStructSetData($tRECT, "Left", $iX))
DllStructSetData($tRECT, "Bottom", $iH + DllStructSetData($tRECT, "Top", $iY))
EndIf
Local $iStatus = _GDIPlus_BitmapApplyEffect($hBitmap, $hEffect, $tRECT)
If Not $iStatus Then Return SetError(@error, @extended, False)
Return True
EndFunc
Func _GDIPlus_BitmapConvertFormat($hBitmap, $iPixelFormat, $iDitherType, $iPaletteType, $tPalette, $fAlphaThresholdPercent = 0.0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipBitmapConvertFormat", "handle", $hBitmap, "uint", $iPixelFormat, "uint", $iDitherType, "uint", $iPaletteType, "struct*", $tPalette, "float", $fAlphaThresholdPercent)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapCreateApplyEffect($hBitmap, $hEffect, $tRECT = Null, $tOutRECT = Null)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipBitmapCreateApplyEffect", "handle*", $hBitmap, "int", 1, "handle", $hEffect, "struct*", $tRECT, "struct*", $tOutRECT, "handle*", 0, "int", 0, "ptr*", 0, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[6]
EndFunc
Func _GDIPlus_BitmapCreateApplyEffectEx($hBitmap, $hEffect, $iX = 0, $iY = 0, $iW = 0, $iH = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tRECT = 0
If BitOR($iX, $iY, $iW, $iH) Then
$tRECT = DllStructCreate("int Left; int Top; int Right; int Bottom;")
DllStructSetData($tRECT, "Right", $iW + DllStructSetData($tRECT, "Left", $iX))
DllStructSetData($tRECT, "Bottom", $iH + DllStructSetData($tRECT, "Top", $iY))
EndIf
Local $hBitmap_FX = _GDIPlus_BitmapCreateApplyEffect($hBitmap, $hEffect, $tRECT, Null)
Return SetError(@error, @extended, $hBitmap_FX)
EndFunc
Func _GDIPlus_BitmapGetHistogram($hBitmap, $iHistogramFormat, $iHistogramSize, $tChannel_0, $tChannel_1 = 0, $tChannel_2 = 0, $tChannel_3 = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipBitmapGetHistogram", "handle", $hBitmap, "uint", $iHistogramFormat, "uint", $iHistogramSize, "struct*", $tChannel_0, "struct*", $tChannel_1, "struct*", $tChannel_2, "struct*", $tChannel_3)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapGetHistogramEx($hBitmap)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $iSize = _GDIPlus_BitmapGetHistogramSize($GDIP_HistogramFormatARGB)
Local $tHistogram = DllStructCreate("int Size; uint Red[" & $iSize & "]; uint MaxRed; uint Green[" & $iSize & "]; uint MaxGreen; uint Blue[" & $iSize & "]; uint MaxBlue; uint Alpha[" & $iSize & "]; uint MaxAlpha; uint Grey[" & $iSize & "]; uint MaxGrey;")
DllStructSetData($tHistogram, "Size", $iSize)
Local $iStatus = _GDIPlus_BitmapGetHistogram($hBitmap, $GDIP_HistogramFormatARGB, $iSize, DllStructGetPtr($tHistogram, "Alpha"), DllStructGetPtr($tHistogram, "Red"), DllStructGetPtr($tHistogram, "Green"), DllStructGetPtr($tHistogram, "Blue"))
If Not $iStatus Then Return SetError(@error, @extended, 0)
$iStatus = _GDIPlus_BitmapGetHistogram($hBitmap, $GDIP_HistogramFormatGray, $iSize, DllStructGetPtr($tHistogram, "Grey"))
If Not $iStatus Then Return SetError(@error + 10, @extended, 0)
Local $iMaxRed = 0, $iMaxGreen = 0, $iMaxBlue = 0, $iMaxAlpha = 0, $iMaxGrey = 0
For $i = 1 To $iSize
If DllStructGetData($tHistogram, "Red", $i) > $iMaxRed Then $iMaxRed = DllStructGetData($tHistogram, "Red", $i)
If DllStructGetData($tHistogram, "Green", $i) > $iMaxGreen Then $iMaxGreen = DllStructGetData($tHistogram, "Green", $i)
If DllStructGetData($tHistogram, "Blue", $i) > $iMaxBlue Then $iMaxBlue = DllStructGetData($tHistogram, "Blue", $i)
If DllStructGetData($tHistogram, "Alpha", $i) > $iMaxAlpha Then $iMaxAlpha = DllStructGetData($tHistogram, "Alpha", $i)
If DllStructGetData($tHistogram, "Grey", $i) > $iMaxGrey Then $iMaxGrey = DllStructGetData($tHistogram, "Grey", $i)
Next
DllStructSetData($tHistogram, "MaxRed", $iMaxRed)
DllStructSetData($tHistogram, "MaxGreen", $iMaxGreen)
DllStructSetData($tHistogram, "MaxBlue", $iMaxBlue)
DllStructSetData($tHistogram, "MaxAlpha", $iMaxAlpha)
DllStructSetData($tHistogram, "MaxGrey", $iMaxGrey)
Return $tHistogram
EndFunc
Func _GDIPlus_BitmapGetHistogramSize($iFormat)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipBitmapGetHistogramSize", "uint", $iFormat, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _GDIPlus_DrawImageFX($hGraphics, $hImage, $hEffect, $tRECTF = 0, $hMatrix = 0, $hImgAttributes = 0, $iUnit = 2)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDrawImageFX", "handle", $hGraphics, "handle", $hImage, "struct*", $tRECTF, "handle", $hMatrix, "handle", $hEffect, "handle", $hImgAttributes, "uint", $iUnit)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_DrawImageFXEx($hGraphics, $hImage, $hEffect, $nX = 0, $nY = 0, $nW = 0, $nH = 0, $hMatrix = 0, $hImgAttributes = 0, $iUnit = 2)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $tRECTF = 0
If BitOR($nX, $nY, $nW, $nH) Then $tRECTF = _GDIPlus_RectFCreate($nX, $nY, $nW, $nH)
Local $iStatus = _GDIPlus_DrawImageFX($hGraphics, $hImage, $hEffect, $tRECTF, $hMatrix, $hImgAttributes, $iUnit)
Return SetError(@error, @extended, $iStatus)
EndFunc
Func _GDIPlus_EffectCreate($sEffectGUID)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tGUID = _WinAPI_GUIDFromString($sEffectGUID)
Local $aCall
If @AutoItX64 Then
$aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateEffect", "struct*", $tGUID, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndIf
Local $tElem = DllStructCreate("uint64[2];", DllStructGetPtr($tGUID))
$aCall = DllCall($__g_hGDIPDll, "int", "GdipCreateEffect", "uint64", DllStructGetData($tElem, 1, 1), "uint64", DllStructGetData($tElem, 1, 2), "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _GDIPlus_EffectCreateBlur($fRadius = 10.0, $bExpandEdge = False)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_Blur)
DllStructSetData($tEffectParameters, "Radius", $fRadius)
DllStructSetData($tEffectParameters, "ExpandEdge", $bExpandEdge)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_BlurEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateBrightnessContrast($iBrightnessLevel = 0, $iContrastLevel = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_BrightnessContrast)
DllStructSetData($tEffectParameters, "BrightnessLevel", $iBrightnessLevel)
DllStructSetData($tEffectParameters, "ContrastLevel", $iContrastLevel)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_BrightnessContrastEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateColorBalance($iCyanRed = 0, $iMagentaGreen = 0, $iYellowBlue = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_ColorBalance)
DllStructSetData($tEffectParameters, "CyanRed", $iCyanRed)
DllStructSetData($tEffectParameters, "MagentaGreen", $iMagentaGreen)
DllStructSetData($tEffectParameters, "YellowBlue", $iYellowBlue)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_ColorBalanceEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateColorCurve($iAdjustment, $iChannel, $iAdjustValue)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_ColorCurve)
DllStructSetData($tEffectParameters, "Adjustment", $iAdjustment)
DllStructSetData($tEffectParameters, "Channel", $iChannel)
DllStructSetData($tEffectParameters, "AdjustValue", $iAdjustValue)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_ColorCurveEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateColorLUT($aColorLUT)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_ColorLUT)
For $iI = 0 To 255
DllStructSetData($tEffectParameters, "LutA", $aColorLUT[$iI][0], $iI + 1)
DllStructSetData($tEffectParameters, "LutR", $aColorLUT[$iI][1], $iI + 1)
DllStructSetData($tEffectParameters, "LutG", $aColorLUT[$iI][2], $iI + 1)
DllStructSetData($tEffectParameters, "LutB", $aColorLUT[$iI][3], $iI + 1)
Next
Local $hEffect = _GDIPlus_EffectCreate($GDIP_ColorLUTEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateColorMatrix($tColorMatrix)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_ColorMatrixEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tColorMatrix)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateHueSaturationLightness($iHueLevel = 0, $iSaturationLevel = 0, $iLightnessLevel = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_HueSaturationLightness)
DllStructSetData($tEffectParameters, "HueLevel", $iHueLevel)
DllStructSetData($tEffectParameters, "SaturationLevel", $iSaturationLevel)
DllStructSetData($tEffectParameters, "LightnessLevel", $iLightnessLevel)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_HueSaturationLightnessEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateLevels($iHighlight = 100, $iMidtone = 0, $iShadow = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_Levels)
DllStructSetData($tEffectParameters, "Highlight", $iHighlight)
DllStructSetData($tEffectParameters, "Midtone", $iMidtone)
DllStructSetData($tEffectParameters, "Shadow", $iShadow)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_LevelsEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateRedEyeCorrection($aAreas)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $iCount = $aAreas[0][0]
Local $tAreas = DllStructCreate("long[" & $iCount * 4 & "]")
For $iI = 1 To $iCount
DllStructSetData($tAreas, 1, DllStructSetData($tAreas, 1, $aAreas[$iI][0], (($iI - 1) * 4) + 1) + $aAreas[$iI][2], (($iI - 1) * 4) + 3)
DllStructSetData($tAreas, 1, DllStructSetData($tAreas, 1, $aAreas[$iI][1], (($iI - 1) * 4) + 2) + $aAreas[$iI][3], (($iI - 1) * 4) + 4)
Next
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_RedEyeCorrection)
DllStructSetData($tEffectParameters, "NumberOfAreas", $iCount)
DllStructSetData($tEffectParameters, "Areas", DllStructGetPtr($tAreas))
Local $hEffect = _GDIPlus_EffectCreate($GDIP_RedEyeCorrectionEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters, (DllStructGetSize($tAreas) + DllStructGetSize($tEffectParameters)) / DllStructGetSize($tEffectParameters))
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateSharpen($fRadius = 10.0, $fAmount = 50.0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_Sharpen)
DllStructSetData($tEffectParameters, "Radius", $fRadius)
DllStructSetData($tEffectParameters, "Amount", $fAmount)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_SharpenEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateTint($iHue = 0, $iAmount = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_Tint)
DllStructSetData($tEffectParameters, "Hue", $iHue)
DllStructSetData($tEffectParameters, "Amount", $iAmount)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_TintEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectDispose($hEffect)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipDeleteEffect", "handle", $hEffect)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_EffectGetParameters($hEffect, $tEffectParameters)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
If DllStructGetSize($tEffectParameters) < __GDIPlus_EffectGetParameterSize($hEffect) Then Return SetError(2, 5, False)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetEffectParameters", "handle", $hEffect, "uint*", DllStructGetSize($tEffectParameters), "struct*", $tEffectParameters)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func __GDIPlus_EffectGetParameterSize($hEffect)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, -1)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipGetEffectParameterSize", "handle", $hEffect, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aCall[0] Then Return SetError(10, $aCall[0], -1)
Return $aCall[2]
EndFunc
Func _GDIPlus_EffectSetParameters($hEffect, $tEffectParameters, $iSizeAdjust = 1)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $iSize = __GDIPlus_EffectGetParameterSize($hEffect)
If @error Then Return SetError(@error, @extended, False)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipSetEffectParameters", "handle", $hEffect, "struct*", $tEffectParameters, "uint", $iSize * $iSizeAdjust)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] Then Return SetError(10, $aCall[0], False)
Return True
EndFunc
Func _GDIPlus_PaletteInitialize($iEntries, $iPaletteType = $GDIP_PaletteTypeOptimal, $iOptimalColors = 0, $bUseTransparentColor = True, $hBitmap = Null)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
If $iOptimalColors > 0 Then $iPaletteType = $GDIP_PaletteTypeOptimal
Local $tPalette = DllStructCreate("uint Flags; uint Count; uint ARGB[" & $iEntries & "];")
DllStructSetData($tPalette, "Flags", $iPaletteType)
DllStructSetData($tPalette, "Count", $iEntries)
Local $aCall = DllCall($__g_hGDIPDll, "int", "GdipInitializePalette", "struct*", $tPalette, "uint", $iPaletteType, "uint", $iOptimalColors, "bool", $bUseTransparentColor, "handle", $hBitmap)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $tPalette
EndFunc
Global Const $SS_LEFT = 0x0
Global Const $SS_CENTER = 0x1
Global Const $SS_RIGHT = 0x2
Global Const $SS_ICON = 0x3
Global Const $SS_BLACKRECT = 0x4
Global Const $SS_GRAYRECT = 0x5
Global Const $SS_WHITERECT = 0x6
Global Const $SS_BLACKFRAME = 0x7
Global Const $SS_GRAYFRAME = 0x8
Global Const $SS_WHITEFRAME = 0x9
Global Const $SS_SIMPLE = 0xB
Global Const $SS_LEFTNOWORDWRAP = 0xC
Global Const $SS_BITMAP = 0xE
Global Const $SS_ENHMETAFILE = 0xF
Global Const $SS_ETCHEDHORZ = 0x10
Global Const $SS_ETCHEDVERT = 0x11
Global Const $SS_ETCHEDFRAME = 0x12
Global Const $SS_REALSIZECONTROL = 0x40
Global Const $SS_NOPREFIX = 0x0080
Global Const $SS_NOTIFY = 0x0100
Global Const $SS_CENTERIMAGE = 0x0200
Global Const $SS_RIGHTJUST = 0x0400
Global Const $SS_SUNKEN = 0x1000
Global Const $GUI_SS_DEFAULT_LABEL = 0
Global Const $GUI_SS_DEFAULT_GRAPHIC = 0
Global Const $GUI_SS_DEFAULT_ICON = $SS_NOTIFY
Global Const $GUI_SS_DEFAULT_PIC = $SS_NOTIFY
Global Const $STM_SETICON = 0x0170
Global Const $STM_GETICON = 0x0171
Global Const $STM_SETIMAGE = 0x0172
Global Const $STM_GETIMAGE = 0x0173
Global Const $TVS_HASBUTTONS = 0x00000001
Global Const $TVS_HASLINES = 0x00000002
Global Const $TVS_LINESATROOT = 0x00000004
Global Const $TVS_EDITLABELS = 0x00000008
Global Const $TVS_DISABLEDRAGDROP = 0x00000010
Global Const $TVS_SHOWSELALWAYS = 0x00000020
Global Const $TVS_RTLREADING = 0x00000040
Global Const $TVS_NOTOOLTIPS = 0x00000080
Global Const $TVS_CHECKBOXES = 0x00000100
Global Const $TVS_TRACKSELECT = 0x00000200
Global Const $TVS_SINGLEEXPAND = 0x00000400
Global Const $TVS_INFOTIP = 0x00000800
Global Const $TVS_FULLROWSELECT = 0x00001000
Global Const $TVS_NOSCROLL = 0x00002000
Global Const $TVS_NONEVENHEIGHT = 0x00004000
Global Const $TVS_NOHSCROLL = 0x00008000
Global Const $TVS_DEFAULT = 0x00000037
Global Const $GUI_SS_DEFAULT_TREEVIEW = BitOR($TVS_HASBUTTONS, $TVS_HASLINES, $TVS_LINESATROOT, $TVS_DISABLEDRAGDROP, $TVS_SHOWSELALWAYS)
Global Const $TVE_COLLAPSE = 0x0001
Global Const $TVE_EXPAND = 0x0002
Global Const $TVE_TOGGLE = 0x0003
Global Const $TVE_EXPANDPARTIAL = 0x4000
Global Const $TVE_COLLAPSERESET = 0x8000
Global Const $TVGN_ROOT = 0x00000000
Global Const $TVGN_NEXT = 0x00000001
Global Const $TVGN_PREVIOUS = 0x00000002
Global Const $TVGN_PARENT = 0x00000003
Global Const $TVGN_CHILD = 0x00000004
Global Const $TVGN_FIRSTVISIBLE = 0x00000005
Global Const $TVGN_NEXTVISIBLE = 0x00000006
Global Const $TVGN_PREVIOUSVISIBLE = 0x00000007
Global Const $TVGN_DROPHILITE = 0x00000008
Global Const $TVGN_CARET = 0x00000009
Global Const $TVGN_LASTVISIBLE = 0x0000000A
Global Const $TVHT_NOWHERE = 0x00000001
Global Const $TVHT_ONITEMICON = 0x00000002
Global Const $TVHT_ONITEMLABEL = 0x00000004
Global Const $TVHT_ONITEMINDENT = 0x00000008
Global Const $TVHT_ONITEMBUTTON = 0x00000010
Global Const $TVHT_ONITEMRIGHT = 0x00000020
Global Const $TVHT_ONITEMSTATEICON = 0x00000040
Global Const $TVHT_ONITEM = 0x00000046
Global Const $TVHT_ABOVE = 0x00000100
Global Const $TVHT_BELOW = 0x00000200
Global Const $TVHT_TORIGHT = 0x00000400
Global Const $TVHT_TOLEFT = 0x00000800
Global Const $TVI_ROOT = 0xFFFF0000
Global Const $TVI_FIRST = 0xFFFF0001
Global Const $TVI_LAST = 0xFFFF0002
Global Const $TVI_SORT = 0xFFFF0003
Global Const $TVIF_TEXT = 0x00000001
Global Const $TVIF_IMAGE = 0x00000002
Global Const $TVIF_PARAM = 0x00000004
Global Const $TVIF_STATE = 0x00000008
Global Const $TVIF_HANDLE = 0x00000010
Global Const $TVIF_SELECTEDIMAGE = 0x00000020
Global Const $TVIF_CHILDREN = 0x00000040
Global Const $TVIF_INTEGRAL = 0x00000080
Global Const $TVIF_EXPANDEDIMAGE = 0x00000100
Global Const $TVIF_STATEEX = 0x00000200
Global Const $TVIF_DI_SETITEM = 0x00001000
Global Const $TVSIL_NORMAL = 0
Global Const $TVSIL_STATE = 2
Global Const $TVC_BYKEYBOARD = 0x2
Global Const $TVC_BYMOUSE = 0x1
Global Const $TVC_UNKNOWN = 0x0
Global Const $TVIS_FOCUSED = 0x00000001
Global Const $TVIS_SELECTED = 0x00000002
Global Const $TVIS_CUT = 0x00000004
Global Const $TVIS_DROPHILITED = 0x00000008
Global Const $TVIS_BOLD = 0x00000010
Global Const $TVIS_EXPANDED = 0x00000020
Global Const $TVIS_EXPANDEDONCE = 0x00000040
Global Const $TVIS_EXPANDPARTIAL = 0x00000080
Global Const $TVIS_OVERLAYMASK = 0x00000F00
Global Const $TVIS_STATEIMAGEMASK = 0x0000F000
Global Const $TVIS_USERMASK = 0x0000F000
Global Const $TVIS_UNCHECKED = 4096
Global Const $TVIS_CHECKED = 8192
Global Const $TVNA_ADD = 1
Global Const $TVNA_ADDFIRST = 2
Global Const $TVNA_ADDCHILD = 3
Global Const $TVNA_ADDCHILDFIRST = 4
Global Const $TVNA_INSERT = 5
Global Const $TVTA_ADDFIRST = 1
Global Const $TVTA_ADD = 2
Global Const $TVTA_INSERT = 3
Global Const $TV_FIRST = 0x1100
Global Const $TVM_INSERTITEMA = $TV_FIRST + 0
Global Const $TVM_DELETEITEM = $TV_FIRST + 1
Global Const $TVM_EXPAND = $TV_FIRST + 2
Global Const $TVM_GETITEMRECT = $TV_FIRST + 4
Global Const $TVM_GETCOUNT = $TV_FIRST + 5
Global Const $TVM_GETINDENT = $TV_FIRST + 6
Global Const $TVM_SETINDENT = $TV_FIRST + 7
Global Const $TVM_GETIMAGELIST = $TV_FIRST + 8
Global Const $TVM_SETIMAGELIST = $TV_FIRST + 9
Global Const $TVM_GETNEXTITEM = $TV_FIRST + 10
Global Const $TVM_SELECTITEM = $TV_FIRST + 11
Global Const $TVM_GETITEMA = $TV_FIRST + 12
Global Const $TVM_SETITEMA = $TV_FIRST + 13
Global Const $TVM_EDITLABELA = $TV_FIRST + 14
Global Const $TVM_GETEDITCONTROL = $TV_FIRST + 15
Global Const $TVM_GETVISIBLECOUNT = $TV_FIRST + 16
Global Const $TVM_HITTEST = $TV_FIRST + 17
Global Const $TVM_CREATEDRAGIMAGE = $TV_FIRST + 18
Global Const $TVM_SORTCHILDREN = $TV_FIRST + 19
Global Const $TVM_ENSUREVISIBLE = $TV_FIRST + 20
Global Const $TVM_SORTCHILDRENCB = $TV_FIRST + 21
Global Const $TVM_ENDEDITLABELNOW = $TV_FIRST + 22
Global Const $TVM_GETISEARCHSTRINGA = $TV_FIRST + 23
Global Const $TVM_SETTOOLTIPS = $TV_FIRST + 24
Global Const $TVM_GETTOOLTIPS = $TV_FIRST + 25
Global Const $TVM_SETINSERTMARK = $TV_FIRST + 26
Global Const $TVM_SETITEMHEIGHT = $TV_FIRST + 27
Global Const $TVM_GETITEMHEIGHT = $TV_FIRST + 28
Global Const $TVM_SETBKCOLOR = $TV_FIRST + 29
Global Const $TVM_SETTEXTCOLOR = $TV_FIRST + 30
Global Const $TVM_GETBKCOLOR = $TV_FIRST + 31
Global Const $TVM_GETTEXTCOLOR = $TV_FIRST + 32
Global Const $TVM_SETSCROLLTIME = $TV_FIRST + 33
Global Const $TVM_GETSCROLLTIME = $TV_FIRST + 34
Global Const $TVM_SETINSERTMARKCOLOR = $TV_FIRST + 37
Global Const $TVM_GETINSERTMARKCOLOR = $TV_FIRST + 38
Global Const $TVM_GETITEMSTATE = $TV_FIRST + 39
Global Const $TVM_SETLINECOLOR = $TV_FIRST + 40
Global Const $TVM_GETLINECOLOR = $TV_FIRST + 41
Global Const $TVM_MAPACCIDTOHTREEITEM = $TV_FIRST + 42
Global Const $TVM_MAPHTREEITEMTOACCID = $TV_FIRST + 43
Global Const $TVM_INSERTITEMW = $TV_FIRST + 50
Global Const $TVM_GETITEMW = $TV_FIRST + 62
Global Const $TVM_SETITEMW = $TV_FIRST + 63
Global Const $TVM_GETISEARCHSTRINGW = $TV_FIRST + 64
Global Const $TVM_EDITLABELW = $TV_FIRST + 65
Global Const $TVM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $TVM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $TVN_FIRST = -400
Global Const $TVN_SELCHANGINGA = $TVN_FIRST - 1
Global Const $TVN_SELCHANGEDA = $TVN_FIRST - 2
Global Const $TVN_GETDISPINFOA = $TVN_FIRST - 3
Global Const $TVN_SETDISPINFOA = $TVN_FIRST - 4
Global Const $TVN_ITEMEXPANDINGA = $TVN_FIRST - 5
Global Const $TVN_ITEMEXPANDEDA = $TVN_FIRST - 6
Global Const $TVN_BEGINDRAGA = $TVN_FIRST - 7
Global Const $TVN_BEGINRDRAGA = $TVN_FIRST - 8
Global Const $TVN_DELETEITEMA = $TVN_FIRST - 9
Global Const $TVN_BEGINLABELEDITA = $TVN_FIRST - 10
Global Const $TVN_ENDLABELEDITA = $TVN_FIRST - 11
Global Const $TVN_KEYDOWN = $TVN_FIRST - 12
Global Const $TVN_GETINFOTIPA = $TVN_FIRST - 13
Global Const $TVN_GETINFOTIPW = $TVN_FIRST - 14
Global Const $TVN_SINGLEEXPAND = $TVN_FIRST - 15
Global Const $TVN_ITEMCHANGINGA = $TVN_FIRST - 16
Global Const $TVN_ITEMCHANGINGW = $TVN_FIRST - 17
Global Const $TVN_ITEMCHANGEDA = $TVN_FIRST - 18
Global Const $TVN_ITEMCHANGEDW = $TVN_FIRST - 19
Global Const $TVN_SELCHANGINGW = $TVN_FIRST - 50
Global Const $TVN_SELCHANGEDW = $TVN_FIRST - 51
Global Const $TVN_GETDISPINFOW = $TVN_FIRST - 52
Global Const $TVN_SETDISPINFOW = $TVN_FIRST - 53
Global Const $TVN_ITEMEXPANDINGW = $TVN_FIRST - 54
Global Const $TVN_ITEMEXPANDEDW = $TVN_FIRST - 55
Global Const $TVN_BEGINDRAGW = $TVN_FIRST - 56
Global Const $TVN_BEGINRDRAGW = $TVN_FIRST - 57
Global Const $TVN_DELETEITEMW = $TVN_FIRST - 58
Global Const $TVN_BEGINLABELEDITW = $TVN_FIRST - 59
Global Const $TVN_ENDLABELEDITW = $TVN_FIRST - 60
Global Const $UDS_WRAP = 0x0001
Global Const $UDS_SETBUDDYINT = 0x0002
Global Const $UDS_ALIGNRIGHT = 0x0004
Global Const $UDS_ALIGNLEFT = 0x0008
Global Const $UDS_ARROWKEYS = 0x0020
Global Const $UDS_HORZ = 0x0040
Global Const $UDS_NOTHOUSANDS = 0x0080
Global Const $GUI_SS_DEFAULT_UPDOWN = $UDS_ALIGNLEFT
Func _FileCountLines($sFilePath)
FileReadToArray($sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return @extended
EndFunc
Func _FileCreate($sFilePath)
Local $hFileOpen = FileOpen($sFilePath, BitOR($FO_OVERWRITE, $FO_CREATEPATH))
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $iFileWrite = FileWrite($hFileOpen, "")
FileClose($hFileOpen)
If Not $iFileWrite Then Return SetError(2, 0, 0)
Return 1
EndFunc
Func _FileListToArray($sFilePath, $sFilter = "*", $iFlag = $FLTA_FILESFOLDERS, $bReturnPath = False)
Local $sDelimiter = "|", $sFileList = "", $sFileName = "", $sFullPath = ""
$sFilePath = StringRegExpReplace($sFilePath, "[\\/]+$", "") & "\"
If $iFlag = Default Then $iFlag = $FLTA_FILESFOLDERS
If $bReturnPath Then $sFullPath = $sFilePath
If $sFilter = Default Then $sFilter = "*"
If Not FileExists($sFilePath) Then Return SetError(1, 0, 0)
If StringRegExp($sFilter, "[\\/:><\|]|(?s)^\s*$") Then Return SetError(2, 0, 0)
If Not ($iFlag = 0 Or $iFlag = 1 Or $iFlag = 2) Then Return SetError(3, 0, 0)
Local $hSearch = FileFindFirstFile($sFilePath & $sFilter)
If @error Then Return SetError(4, 0, 0)
While 1
$sFileName = FileFindNextFile($hSearch)
If @error Then ExitLoop
If ($iFlag + @extended = 2) Then ContinueLoop
$sFileList &= $sDelimiter & $sFullPath & $sFileName
WEnd
FileClose($hSearch)
If $sFileList = "" Then Return SetError(4, 0, 0)
Return StringSplit(StringTrimLeft($sFileList, 1), $sDelimiter)
EndFunc
Func _FileListToArrayRec($sFilePath, $sMask = "*", $iReturn = $FLTAR_FILESFOLDERS, $iRecur = $FLTAR_NORECUR, $iSort = $FLTAR_NOSORT, $iReturnPath = $FLTAR_RELPATH)
If Not FileExists($sFilePath) Then Return SetError(1, 1, "")
If $sMask = Default Then $sMask = "*"
If $iReturn = Default Then $iReturn = $FLTAR_FILESFOLDERS
If $iRecur = Default Then $iRecur = $FLTAR_NORECUR
If $iSort = Default Then $iSort = $FLTAR_NOSORT
If $iReturnPath = Default Then $iReturnPath = $FLTAR_RELPATH
If $iRecur > 1 Or Not IsInt($iRecur) Then Return SetError(1, 6, "")
Local $bLongPath = False
If StringLeft($sFilePath, 4) == "\\?\" Then
$bLongPath = True
EndIf
Local $sFolderSlash = ""
If StringRight($sFilePath, 1) = "\" Then
$sFolderSlash = "\"
Else
$sFilePath = $sFilePath & "\"
EndIf
Local $asFolderSearchList[100] = [1]
$asFolderSearchList[1] = $sFilePath
Local $iHide_HS = 0,  $sHide_HS = ""
If BitAND($iReturn, $FLTAR_NOHIDDEN) Then
$iHide_HS += 2
$sHide_HS &= "H"
$iReturn -= $FLTAR_NOHIDDEN
EndIf
If BitAND($iReturn, $FLTAR_NOSYSTEM) Then
$iHide_HS += 4
$sHide_HS &= "S"
$iReturn -= $FLTAR_NOSYSTEM
EndIf
Local $iHide_Link = 0
If BitAND($iReturn, $FLTAR_NOLINK) Then
$iHide_Link = 0x400
$iReturn -= $FLTAR_NOLINK
EndIf
Local $iMaxLevel = 0
If $iRecur < 0 Then
StringReplace($sFilePath, "\", "", 0, $STR_NOCASESENSEBASIC)
$iMaxLevel = @extended - $iRecur
EndIf
Local $sExclude_List = "", $sExclude_List_Folder = "", $sInclude_List = "*"
Local $aMaskSplit = StringSplit($sMask, "|")
Switch $aMaskSplit[0]
Case 3
$sExclude_List_Folder = $aMaskSplit[3]
ContinueCase
Case 2
$sExclude_List = $aMaskSplit[2]
ContinueCase
Case 1
$sInclude_List = $aMaskSplit[1]
EndSwitch
Local $sInclude_File_Mask = ".+"
If $sInclude_List <> "*" Then
If Not __FLTAR_ListToMask($sInclude_File_Mask, $sInclude_List) Then Return SetError(1, 2, "")
EndIf
Local $sInclude_Folder_Mask = ".+"
Switch $iReturn
Case 0
Switch $iRecur
Case 0
$sInclude_Folder_Mask = $sInclude_File_Mask
EndSwitch
Case 2
$sInclude_Folder_Mask = $sInclude_File_Mask
EndSwitch
Local $sExclude_File_Mask = ":"
If $sExclude_List <> "" Then
If Not __FLTAR_ListToMask($sExclude_File_Mask, $sExclude_List) Then Return SetError(1, 3, "")
EndIf
Local $sExclude_Folder_Mask = ":"
If $iRecur Then
If $sExclude_List_Folder Then
If Not __FLTAR_ListToMask($sExclude_Folder_Mask, $sExclude_List_Folder) Then Return SetError(1, 4, "")
EndIf
If $iReturn = 2 Then
$sExclude_Folder_Mask = $sExclude_File_Mask
EndIf
Else
$sExclude_Folder_Mask = $sExclude_File_Mask
EndIf
If Not ($iReturn = 0 Or $iReturn = 1 Or $iReturn = 2) Then Return SetError(1, 5, "")
If Not ($iSort = 0 Or $iSort = 1 Or $iSort = 2) Then Return SetError(1, 7, "")
If Not ($iReturnPath = 0 Or $iReturnPath = 1 Or $iReturnPath = 2) Then Return SetError(1, 8, "")
If $iHide_Link Then
Local $tFile_Data = DllStructCreate("struct;align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;" &  "dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];endstruct")
Local $hDLL = DllOpen('kernel32.dll'), $aDLL_Ret
EndIf
Local $asReturnList[100] = [0]
Local $asFileMatchList = $asReturnList, $asRootFileMatchList = $asReturnList, $asFolderMatchList = $asReturnList
Local $bFolder = False,  $hSearch = 0,  $sCurrentPath = "", $sName = "", $sRetPath = ""
Local $iAttribs = 0,  $sAttribs = ''
Local $asFolderFileSectionList[100][2] = [[0, 0]]
While $asFolderSearchList[0] > 0
$sCurrentPath = $asFolderSearchList[$asFolderSearchList[0]]
$asFolderSearchList[0] -= 1
Switch $iReturnPath
Case 1
$sRetPath = StringReplace($sCurrentPath, $sFilePath, "")
Case 2
If $bLongPath Then
$sRetPath = StringTrimLeft($sCurrentPath, 4)
Else
$sRetPath = $sCurrentPath
EndIf
EndSwitch
If $iHide_Link Then
$aDLL_Ret = DllCall($hDLL, 'handle', 'FindFirstFileW', 'wstr', $sCurrentPath & "*", 'struct*', $tFile_Data)
If @error Or Not $aDLL_Ret[0] Then
ContinueLoop
EndIf
$hSearch = $aDLL_Ret[0]
Else
$hSearch = FileFindFirstFile($sCurrentPath & "*")
If $hSearch = -1 Then
ContinueLoop
EndIf
EndIf
If $iReturn = 0 And $iSort And $iReturnPath Then
__FLTAR_AddToList($asFolderFileSectionList, $sRetPath, $asFileMatchList[0] + 1)
EndIf
$sAttribs = ''
While 1
If $iHide_Link Then
$aDLL_Ret = DllCall($hDLL, 'int', 'FindNextFileW', 'handle', $hSearch, 'struct*', $tFile_Data)
If @error Or Not $aDLL_Ret[0] Then
ExitLoop
EndIf
$sName = DllStructGetData($tFile_Data, "FileName")
If $sName = ".." Or $sName = "." Then
ContinueLoop
EndIf
$iAttribs = DllStructGetData($tFile_Data, "FileAttributes")
If $iHide_HS And BitAND($iAttribs, $iHide_HS) Then
ContinueLoop
EndIf
If BitAND($iAttribs, $iHide_Link) Then
ContinueLoop
EndIf
$bFolder = False
If BitAND($iAttribs, 16) Then
$bFolder = True
EndIf
Else
$bFolder = False
$sName = FileFindNextFile($hSearch, 1)
If @error Then
ExitLoop
EndIf
If $sName = ".." Or $sName = "." Then
ContinueLoop
EndIf
$sAttribs = @extended
If StringInStr($sAttribs, "D") Then
$bFolder = True
EndIf
If StringRegExp($sAttribs, "[" & $sHide_HS & "]") Then
ContinueLoop
EndIf
EndIf
If $bFolder Then
Select
Case $iRecur < 0
StringReplace($sCurrentPath, "\", "", 0, $STR_NOCASESENSEBASIC)
If @extended < $iMaxLevel Then
ContinueCase
EndIf
Case $iRecur = 1
If Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asFolderSearchList, $sCurrentPath & $sName & "\")
EndIf
EndSelect
EndIf
If $iSort Then
If $bFolder Then
If StringRegExp($sName, $sInclude_Folder_Mask) And Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asFolderMatchList, $sRetPath & $sName & $sFolderSlash)
EndIf
Else
If StringRegExp($sName, $sInclude_File_Mask) And Not StringRegExp($sName, $sExclude_File_Mask) Then
If $sCurrentPath = $sFilePath Then
__FLTAR_AddToList($asRootFileMatchList, $sRetPath & $sName)
Else
__FLTAR_AddToList($asFileMatchList, $sRetPath & $sName)
EndIf
EndIf
EndIf
Else
If $bFolder Then
If $iReturn <> 1 And StringRegExp($sName, $sInclude_Folder_Mask) And Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asReturnList, $sRetPath & $sName & $sFolderSlash)
EndIf
Else
If $iReturn <> 2 And StringRegExp($sName, $sInclude_File_Mask) And Not StringRegExp($sName, $sExclude_File_Mask) Then
__FLTAR_AddToList($asReturnList, $sRetPath & $sName)
EndIf
EndIf
EndIf
WEnd
If $iHide_Link Then
DllCall($hDLL, 'int', 'FindClose', 'ptr', $hSearch)
Else
FileClose($hSearch)
EndIf
WEnd
If $iHide_Link Then
DllClose($hDLL)
EndIf
If $iSort Then
Switch $iReturn
Case 2
If $asFolderMatchList[0] = 0 Then Return SetError(1, 9, "")
ReDim $asFolderMatchList[$asFolderMatchList[0] + 1]
$asReturnList = $asFolderMatchList
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Case 1
If $asRootFileMatchList[0] = 0 And $asFileMatchList[0] = 0 Then Return SetError(1, 9, "")
If $iReturnPath = 0 Then
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList)
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Else
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList, 1)
EndIf
Case 0
If $asRootFileMatchList[0] = 0 And $asFolderMatchList[0] = 0 Then Return SetError(1, 9, "")
If $iReturnPath = 0 Then
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList)
$asReturnList[0] += $asFolderMatchList[0]
ReDim $asFolderMatchList[$asFolderMatchList[0] + 1]
_ArrayConcatenate($asReturnList, $asFolderMatchList, 1)
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Else
Local $asReturnList[$asFileMatchList[0] + $asRootFileMatchList[0] + $asFolderMatchList[0] + 1]
$asReturnList[0] = $asFileMatchList[0] + $asRootFileMatchList[0] + $asFolderMatchList[0]
__ArrayDualPivotSort($asRootFileMatchList, 1, $asRootFileMatchList[0])
For $i = 1 To $asRootFileMatchList[0]
$asReturnList[$i] = $asRootFileMatchList[$i]
Next
Local $iNextInsertionIndex = $asRootFileMatchList[0] + 1
__ArrayDualPivotSort($asFolderMatchList, 1, $asFolderMatchList[0])
Local $sFolderToFind = ""
For $i = 1 To $asFolderMatchList[0]
$asReturnList[$iNextInsertionIndex] = $asFolderMatchList[$i]
$iNextInsertionIndex += 1
If $sFolderSlash Then
$sFolderToFind = $asFolderMatchList[$i]
Else
$sFolderToFind = $asFolderMatchList[$i] & "\"
EndIf
Local $iFileSectionEndIndex = 0, $iFileSectionStartIndex = 0
For $j = 1 To $asFolderFileSectionList[0][0]
If $sFolderToFind = $asFolderFileSectionList[$j][0] Then
$iFileSectionStartIndex = $asFolderFileSectionList[$j][1]
If $j = $asFolderFileSectionList[0][0] Then
$iFileSectionEndIndex = $asFileMatchList[0]
Else
$iFileSectionEndIndex = $asFolderFileSectionList[$j + 1][1] - 1
EndIf
If $iSort = 1 Then
__ArrayDualPivotSort($asFileMatchList, $iFileSectionStartIndex, $iFileSectionEndIndex)
EndIf
For $k = $iFileSectionStartIndex To $iFileSectionEndIndex
$asReturnList[$iNextInsertionIndex] = $asFileMatchList[$k]
$iNextInsertionIndex += 1
Next
ExitLoop
EndIf
Next
Next
EndIf
EndSwitch
Else
If $asReturnList[0] = 0 Then Return SetError(1, 9, "")
ReDim $asReturnList[$asReturnList[0] + 1]
EndIf
Return $asReturnList
EndFunc
Func __FLTAR_AddFileLists(ByRef $asTarget, $asSource_1, $asSource_2, $iSort = 0)
ReDim $asSource_1[$asSource_1[0] + 1]
If $iSort = 1 Then __ArrayDualPivotSort($asSource_1, 1, $asSource_1[0])
$asTarget = $asSource_1
$asTarget[0] += $asSource_2[0]
ReDim $asSource_2[$asSource_2[0] + 1]
If $iSort = 1 Then __ArrayDualPivotSort($asSource_2, 1, $asSource_2[0])
_ArrayConcatenate($asTarget, $asSource_2, 1)
EndFunc
Func __FLTAR_AddToList(ByRef $aList, $vValue_0, $vValue_1 = -1)
If $vValue_1 = -1 Then
$aList[0] += 1
If UBound($aList) <= $aList[0] Then ReDim $aList[UBound($aList) * 2]
$aList[$aList[0]] = $vValue_0
Else
$aList[0][0] += 1
If UBound($aList) <= $aList[0][0] Then ReDim $aList[UBound($aList) * 2][2]
$aList[$aList[0][0]][0] = $vValue_0
$aList[$aList[0][0]][1] = $vValue_1
EndIf
EndFunc
Func __FLTAR_ListToMask(ByRef $sMask, $sList)
If StringRegExp($sList, "\\|/|:|\<|\>|\|") Then Return 0
$sList = StringReplace(StringStripWS(StringRegExpReplace($sList, "\s*;\s*", ";"), BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)), ";", "|")
$sList = StringReplace(StringReplace(StringRegExpReplace($sList, "[][$^.{}()+\-]", "\\$0"), "?", "."), "*", ".*?")
$sMask = "(?i)^(" & $sList & ")\z"
Return 1
EndFunc
Func _FilePrint($sFilePath, $iShow = @SW_HIDE)
Return ShellExecute($sFilePath, "", @WorkingDir, "print", $iShow = Default ? @SW_HIDE : $iShow)
EndFunc
Func _FileReadToArray($sFilePath, ByRef $vReturn, $iFlags = $FRTA_COUNT, $sDelimiter = "")
$vReturn = 0
If $iFlags = Default Then $iFlags = $FRTA_COUNT
If $sDelimiter = Default Then $sDelimiter = ""
Local $bExpand = True
If BitAND($iFlags, $FRTA_INTARRAYS) Then
$bExpand = False
$iFlags -= $FRTA_INTARRAYS
EndIf
Local $iEntire = $STR_CHRSPLIT
If BitAND($iFlags, $FRTA_ENTIRESPLIT) Then
$iEntire = $STR_ENTIRESPLIT
$iFlags -= $FRTA_ENTIRESPLIT
EndIf
Local $iNoCount = 0
If $iFlags <> $FRTA_COUNT Then
$iFlags = $FRTA_NOCOUNT
$iNoCount = $STR_NOCOUNT
EndIf
If $sDelimiter Then
Local $aLines = FileReadToArray($sFilePath)
If @error Then Return SetError(@error, 0, 0)
Local $iDim_1 = UBound($aLines) + $iFlags
If $bExpand Then
Local $iDim_2 = UBound(StringSplit($aLines[0], $sDelimiter, $iEntire + $STR_NOCOUNT))
Local $aTemp_Array[$iDim_1][$iDim_2]
Local $iFields,  $aSplit
For $i = 0 To $iDim_1 - $iFlags - 1
$aSplit = StringSplit($aLines[$i], $sDelimiter, $iEntire + $STR_NOCOUNT)
$iFields = UBound($aSplit)
If $iFields <> $iDim_2 Then
Return SetError(3, 0, 0)
EndIf
For $j = 0 To $iFields - 1
$aTemp_Array[$i + $iFlags][$j] = $aSplit[$j]
Next
Next
If $iDim_2 < 2 Then Return SetError(4, 0, 0)
If $iFlags Then
$aTemp_Array[0][0] = $iDim_1 - $iFlags
$aTemp_Array[0][1] = $iDim_2
EndIf
Else
Local $aTemp_Array[$iDim_1]
For $i = 0 To $iDim_1 - $iFlags - 1
$aTemp_Array[$i + $iFlags] = StringSplit($aLines[$i], $sDelimiter, $iEntire + $iNoCount)
Next
If $iFlags Then
$aTemp_Array[0] = $iDim_1 - $iFlags
EndIf
EndIf
$vReturn = $aTemp_Array
Else
If $iFlags Then
Local $hFileOpen = FileOpen($sFilePath, $FO_READ)
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $sFileRead = FileRead($hFileOpen)
FileClose($hFileOpen)
If StringLen($sFileRead) Then
$vReturn = StringRegExp(@LF & $sFileRead, "(?|(\N+)\z|(\N*)(?:\R))", $STR_REGEXPARRAYGLOBALMATCH)
$vReturn[0] = UBound($vReturn) - 1
Else
Return SetError(2, 0, 0)
EndIf
Else
$vReturn = FileReadToArray($sFilePath)
If @error Then
$vReturn = 0
Return SetError(@error, 0, 0)
EndIf
EndIf
EndIf
Return 1
EndFunc
Func _FileWriteFromArray($sFilePath, Const ByRef $aArray, $iBase = Default, $iUBound = Default, $sDelimiter = "|")
Local $iReturn = 0
If Not IsArray($aArray) Then Return SetError(2, 0, $iReturn)
Local $iDims = UBound($aArray, $UBOUND_DIMENSIONS)
If $iDims > 2 Then Return SetError(4, 0, 0)
Local $iLast = UBound($aArray) - 1
If $iUBound = Default Or $iUBound > $iLast Then $iUBound = $iLast
If $iBase < 0 Or $iBase = Default Then $iBase = 0
If $iBase > $iUBound Then Return SetError(5, 0, $iReturn)
If $sDelimiter = Default Then $sDelimiter = "|"
Local $hFileOpen = $sFilePath
If IsString($sFilePath) Then
$hFileOpen = FileOpen($sFilePath, $FO_OVERWRITE)
If $hFileOpen = -1 Then Return SetError(1, 0, $iReturn)
EndIf
Local $iError = 0
$iReturn = 1
Switch $iDims
Case 1
For $i = $iBase To $iUBound
If Not FileWrite($hFileOpen, $aArray[$i] & @CRLF) Then
$iError = 3
$iReturn = 0
ExitLoop
EndIf
Next
Case 2
Local $sTemp = ""
For $i = $iBase To $iUBound
$sTemp = $aArray[$i][0]
For $j = 1 To UBound($aArray, $UBOUND_COLUMNS) - 1
$sTemp &= $sDelimiter & $aArray[$i][$j]
Next
If Not FileWrite($hFileOpen, $sTemp & @CRLF) Then
$iError = 3
$iReturn = 0
ExitLoop
EndIf
Next
EndSwitch
If IsString($sFilePath) Then FileClose($hFileOpen)
Return SetError($iError, 0, $iReturn)
EndFunc
Func _FileWriteLog($sLogPath, $sLogMsg, $iFlag = -1)
Local $iOpenMode = $FO_APPEND
Local $sMsg = @YEAR & "-" & @MON & "-" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC & " : " & $sLogMsg
If $iFlag = Default Then $iFlag = -1
If $iFlag <> -1 Then
$iOpenMode = $FO_OVERWRITE
$sMsg &= @CRLF & FileRead($sLogPath)
EndIf
Local $hFileOpen = $sLogPath
If IsString($sLogPath) Then $hFileOpen = FileOpen($sLogPath, $iOpenMode)
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $iReturn = FileWriteLine($hFileOpen, $sMsg)
If IsString($sLogPath) Then $iReturn = FileClose($hFileOpen)
If $iFlag <> -1 And Not IsString($sLogPath) Then SetExtended(1)
If $iReturn = 0 Then Return SetError(2, 0, 0)
Return $iReturn
EndFunc
Func _FileWriteToLine($sFilePath, $iLine, $sText, $bOverWrite = False, $bFill = False)
If $bOverWrite = Default Then $bOverWrite = False
If $bFill = Default Then $bFill = False
If Not FileExists($sFilePath) Then Return SetError(2, 0, 0)
If $iLine <= 0 Then Return SetError(4, 0, 0)
If Not (IsBool($bOverWrite) Or $bOverWrite = 0 Or $bOverWrite = 1) Then Return SetError(5, 0, 0)
If Not IsString($sText) Then
$sText = String($sText)
If $sText = "" Then Return SetError(6, 0, 0)
EndIf
If Not IsBool($bFill) Then Return SetError(7, 0, 0)
Local $aArray = FileReadToArray($sFilePath)
If @error Then Local $aArray[0]
Local $iUBound = UBound($aArray) - 1
If $bFill Then
If $iUBound < $iLine Then
ReDim $aArray[$iLine]
$iUBound = $iLine - 1
EndIf
Else
If ($iUBound + 1) < $iLine Then Return SetError(1, 0, 0)
EndIf
$aArray[$iLine - 1] = ($bOverWrite ? $sText : $sText & @CRLF & $aArray[$iLine - 1])
Local $sData = ""
For $i = 0 To $iUBound
$sData &= $aArray[$i] & @CRLF
Next
$sData = StringTrimRight($sData, StringLen(@CRLF))
Local $hFileOpen = FileOpen($sFilePath, FileGetEncoding($sFilePath) + $FO_OVERWRITE)
If $hFileOpen = -1 Then Return SetError(3, 0, 0)
FileWrite($hFileOpen, $sData)
FileClose($hFileOpen)
Return 1
EndFunc
Func _PathFull($sRelativePath, $sBasePath = @WorkingDir)
If Not $sRelativePath Or $sRelativePath = "." Then Return $sBasePath
Local $sFullPath = StringReplace($sRelativePath, "/", "\")
Local Const $sFullPathConst = $sFullPath
Local $sPath
Local $bRootOnly = StringLeft($sFullPath, 1) = "\" And StringMid($sFullPath, 2, 1) <> "\"
If $sBasePath = Default Then $sBasePath = @WorkingDir
For $i = 1 To 2
$sPath = StringLeft($sFullPath, 2)
If $sPath = "\\" Then
$sFullPath = StringTrimLeft($sFullPath, 2)
Local $nServerLen = StringInStr($sFullPath, "\") - 1
$sPath = "\\" & StringLeft($sFullPath, $nServerLen)
$sFullPath = StringTrimLeft($sFullPath, $nServerLen)
ExitLoop
ElseIf StringRight($sPath, 1) = ":" Then
$sFullPath = StringTrimLeft($sFullPath, 2)
ExitLoop
Else
$sFullPath = $sBasePath & "\" & $sFullPath
EndIf
Next
If StringLeft($sFullPath, 1) <> "\" Then
If StringLeft($sFullPathConst, 2) = StringLeft($sBasePath, 2) Then
$sFullPath = $sBasePath & "\" & $sFullPath
Else
$sFullPath = "\" & $sFullPath
EndIf
EndIf
Local $aTemp = StringSplit($sFullPath, "\")
Local $aPathParts[$aTemp[0]], $j = 0
For $i = 2 To $aTemp[0]
If $aTemp[$i] = ".." Then
If $j Then $j -= 1
ElseIf Not ($aTemp[$i] = "" And $i <> $aTemp[0]) And $aTemp[$i] <> "." Then
$aPathParts[$j] = $aTemp[$i]
$j += 1
EndIf
Next
$sFullPath = $sPath
If Not $bRootOnly Then
For $i = 0 To $j - 1
$sFullPath &= "\" & $aPathParts[$i]
Next
Else
$sFullPath &= $sFullPathConst
If StringInStr($sFullPath, "..") Then $sFullPath = _PathFull($sFullPath)
EndIf
Do
$sFullPath = StringReplace($sFullPath, ".\", "\")
Until @extended = 0
Return $sFullPath
EndFunc
Func _PathGetRelative($sFrom, $sTo)
If StringRight($sFrom, 1) <> "\" Then $sFrom &= "\"
If StringRight($sTo, 1) <> "\" Then $sTo &= "\"
If $sFrom = $sTo Then Return SetError(1, 0, StringTrimRight($sTo, 1))
Local $asFrom = StringSplit($sFrom, "\")
Local $asTo = StringSplit($sTo, "\")
If $asFrom[1] <> $asTo[1] Then Return SetError(2, 0, StringTrimRight($sTo, 1))
Local $i = 2
Local $iDiff = 1
While 1
If $asFrom[$i] <> $asTo[$i] Then
$iDiff = $i
ExitLoop
EndIf
$i += 1
WEnd
$i = 1
Local $sRelPath = ""
For $j = 1 To $asTo[0]
If $i >= $iDiff Then
$sRelPath &= "\" & $asTo[$i]
EndIf
$i += 1
Next
$sRelPath = StringTrimLeft($sRelPath, 1)
$i = 1
For $j = 1 To $asFrom[0]
If $i > $iDiff Then
$sRelPath = "..\" & $sRelPath
EndIf
$i += 1
Next
If StringRight($sRelPath, 1) == "\" Then $sRelPath = StringTrimRight($sRelPath, 1)
Return $sRelPath
EndFunc
Func _PathMake($sDrive, $sDir, $sFileName, $sExtension)
If StringLen($sDrive) Then
If Not (StringLeft($sDrive, 2) = "\\") Then $sDrive = StringLeft($sDrive, 1) & ":"
EndIf
If StringLen($sDir) Then
If Not (StringRight($sDir, 1) = "\") And Not (StringRight($sDir, 1) = "/") Then $sDir = $sDir & "\"
Else
$sDir = "\"
EndIf
If StringLen($sDir) Then
If Not (StringLeft($sDir, 1) = "\") And Not (StringLeft($sDir, 1) = "/") Then $sDir = "\" & $sDir
EndIf
If StringLen($sExtension) Then
If Not (StringLeft($sExtension, 1) = ".") Then $sExtension = "." & $sExtension
EndIf
Return $sDrive & $sDir & $sFileName & $sExtension
EndFunc
Func _PathSplit($sFilePath, ByRef $sDrive, ByRef $sDir, ByRef $sFileName, ByRef $sExtension)
Local $aArray = StringRegExp($sFilePath, "^\h*((?:\\\\\?\\)*(\\\\[^\?\/\\]+|[A-Za-z]:)?(.*[\/\\]\h*)?((?:[^\.\/\\]|(?(?=\.[^\/\\]*\.)\.))*)?([^\/\\]*))$", $STR_REGEXPARRAYMATCH)
If @error Then
ReDim $aArray[5]
$aArray[$PATH_ORIGINAL] = $sFilePath
EndIf
$sDrive = $aArray[$PATH_DRIVE]
If StringLeft($aArray[$PATH_DIRECTORY], 1) == "/" Then
$sDir = StringRegExpReplace($aArray[$PATH_DIRECTORY], "\h*[\/\\]+\h*", "\/")
Else
$sDir = StringRegExpReplace($aArray[$PATH_DIRECTORY], "\h*[\/\\]+\h*", "\\")
EndIf
$aArray[$PATH_DIRECTORY] = $sDir
$sFileName = $aArray[$PATH_FILENAME]
$sExtension = $aArray[$PATH_EXTENSION]
Return $aArray
EndFunc
Func _ReplaceStringInFile($sFilePath, $sSearchString, $sReplaceString, $iCaseSensitive = 0, $iOccurance = 1)
If StringInStr(FileGetAttrib($sFilePath), "R") Then Return SetError(1, 0, -1)
Local $hFileOpen = FileOpen($sFilePath, $FO_READ)
If $hFileOpen = -1 Then Return SetError(2, 0, -1)
Local $sFileRead = FileRead($hFileOpen)
FileClose($hFileOpen)
If $iCaseSensitive = Default Then $iCaseSensitive = 0
If $iOccurance = Default Then $iOccurance = 1
$sFileRead = StringReplace($sFileRead, $sSearchString, $sReplaceString, 1 - $iOccurance, $iCaseSensitive)
Local $iReturn = @extended
If $iReturn Then
Local $iFileEncoding = FileGetEncoding($sFilePath)
$hFileOpen = FileOpen($sFilePath, $iFileEncoding + $FO_OVERWRITE)
If $hFileOpen = -1 Then Return SetError(3, 0, -1)
FileWrite($hFileOpen, $sFileRead)
FileClose($hFileOpen)
EndIf
Return $iReturn
EndFunc
Func _TempFile($sDirectoryName = @TempDir, $sFilePrefix = "~", $sFileExtension = ".tmp", $iRandomLength = 7)
If $iRandomLength = Default Or $iRandomLength <= 0 Then $iRandomLength = 7
If $sDirectoryName = Default Or (Not FileExists($sDirectoryName)) Then $sDirectoryName = @TempDir
If $sFileExtension = Default Then $sFileExtension = ".tmp"
If $sFilePrefix = Default Then $sFilePrefix = "~"
If Not FileExists($sDirectoryName) Then $sDirectoryName = @ScriptDir
$sDirectoryName = StringRegExpReplace($sDirectoryName, "[\\/]+$", "")
$sFileExtension = StringRegExpReplace($sFileExtension, "^\.+", "")
$sFilePrefix = StringRegExpReplace($sFilePrefix, '[\\/:*?"<>|]', "")
Local $sTempName = ""
Do
$sTempName = ""
While StringLen($sTempName) < $iRandomLength
$sTempName &= Chr(Random(97, 122, 1))
WEnd
$sTempName = $sDirectoryName & "\" & $sFilePrefix & $sTempName & "." & $sFileExtension
Until Not FileExists($sTempName)
Return $sTempName
EndFunc
Global Const $HGDI_ERROR = Ptr(-1)
Global Const $INVALID_HANDLE_VALUE = Ptr(-1)
Global Const $CLR_INVALID = -1
Global Const $MB_PRECOMPOSED = 0x01
Global Const $MB_COMPOSITE = 0x02
Global Const $MB_USEGLYPHCHARS = 0x04
Global Const $ULW_ALPHA = 0x02
Global Const $ULW_COLORKEY = 0x01
Global Const $ULW_OPAQUE = 0x04
Global Const $ULW_EX_NORESIZE = 0x08
Global Const $WH_CALLWNDPROC = 4
Global Const $WH_CALLWNDPROCRET = 12
Global Const $WH_CBT = 5
Global Const $WH_DEBUG = 9
Global Const $WH_FOREGROUNDIDLE = 11
Global Const $WH_GETMESSAGE = 3
Global Const $WH_JOURNALPLAYBACK = 1
Global Const $WH_JOURNALRECORD = 0
Global Const $WH_KEYBOARD = 2
Global Const $WH_KEYBOARD_LL = 13
Global Const $WH_MOUSE = 7
Global Const $WH_MOUSE_LL = 14
Global Const $WH_MSGFILTER = -1
Global Const $WH_SHELL = 10
Global Const $WH_SYSMSGFILTER = 6
Global Const $WPF_ASYNCWINDOWPLACEMENT = 0x04
Global Const $WPF_RESTORETOMAXIMIZED = 0x02
Global Const $WPF_SETMINPOSITION = 0x01
Global Const $KF_EXTENDED = 0x0100
Global Const $KF_ALTDOWN = 0x2000
Global Const $KF_UP = 0x8000
Global Const $LLKHF_EXTENDED = BitShift($KF_EXTENDED, 8)
Global Const $LLKHF_LOWER_IL_INJECTED = 0x02
Global Const $LLKHF_INJECTED = 0x10
Global Const $LLKHF_ALTDOWN = BitShift($KF_ALTDOWN, 8)
Global Const $LLKHF_UP = BitShift($KF_UP, 8)
Global Const $LVKF_ALT = 0x0001
Global Const $LVKF_CONTROL = 0x0002
Global Const $LVKF_SHIFT = 0x0004
Global Const $OFN_ALLOWMULTISELECT = 0x00000200
Global Const $OFN_CREATEPROMPT = 0x00002000
Global Const $OFN_DONTADDTORECENT = 0x02000000
Global Const $OFN_ENABLEHOOK = 0x00000020
Global Const $OFN_ENABLEINCLUDENOTIFY = 0x00400000
Global Const $OFN_ENABLESIZING = 0x00800000
Global Const $OFN_ENABLETEMPLATE = 0x00000040
Global Const $OFN_ENABLETEMPLATEHANDLE = 0x00000080
Global Const $OFN_EXPLORER = 0x00080000
Global Const $OFN_EXTENSIONDIFFERENT = 0x00000400
Global Const $OFN_FILEMUSTEXIST = 0x00001000
Global Const $OFN_FORCESHOWHIDDEN = 0x10000000
Global Const $OFN_HIDEREADONLY = 0x00000004
Global Const $OFN_LONGNAMES = 0x00200000
Global Const $OFN_NOCHANGEDIR = 0x00000008
Global Const $OFN_NODEREFERENCELINKS = 0x00100000
Global Const $OFN_NOLONGNAMES = 0x00040000
Global Const $OFN_NONETWORKBUTTON = 0x00020000
Global Const $OFN_NOREADONLYRETURN = 0x00008000
Global Const $OFN_NOTESTFILECREATE = 0x00010000
Global Const $OFN_NOVALIDATE = 0x00000100
Global Const $OFN_OVERWRITEPROMPT = 0x00000002
Global Const $OFN_PATHMUSTEXIST = 0x00000800
Global Const $OFN_READONLY = 0x00000001
Global Const $OFN_SHAREAWARE = 0x00004000
Global Const $OFN_SHOWHELP = 0x00000010
Global Const $OFN_EX_NOPLACESBAR = 0x00000001
Global Const $STD_CUT = 0
Global Const $STD_COPY = 1
Global Const $STD_PASTE = 2
Global Const $STD_UNDO = 3
Global Const $STD_REDOW = 4
Global Const $STD_DELETE = 5
Global Const $STD_FILENEW = 6
Global Const $STD_FILEOPEN = 7
Global Const $STD_FILESAVE = 8
Global Const $STD_PRINTPRE = 9
Global Const $STD_PROPERTIES = 10
Global Const $STD_HELP = 11
Global Const $STD_FIND = 12
Global Const $STD_REPLACE = 13
Global Const $STD_PRINT = 14
Global Const $KB_SENDSPECIAL = 0
Global Const $KB_SENDRAW = 1
Global Const $KB_CAPSOFF = 0
Global Const $KB_CAPSON = 1
Global Const $S_OK = 0x00000000
Global Const $E_ABORT = 0x80004004
Global Const $E_ACCESSDENIED = 0x80070005
Global Const $E_FAIL = 0x80004005
Global Const $E_HANDLE = 0x80070006
Global Const $E_INVALIDARG = 0x80070057
Global Const $E_NOINTERFACE = 0x80004002
Global Const $E_NOTIMPL = 0x80004001
Global Const $E_OUTOFMEMORY = 0x8007000E
Global Const $E_POINTER = 0x80004003
Global Const $E_UNEXPECTED = 0x8000FFFF
Global Const $__DLG_WM_USER = 0x400
Global Const $BIF_BROWSEFILEJUNCTIONS = 0x00010000
Global Const $BIF_BROWSEFORCOMPUTER = 0x00001000
Global Const $BIF_BROWSEFORPRINTER = 0x00002000
Global Const $BIF_BROWSEINCLUDEFILES = 0x00004000
Global Const $BIF_BROWSEINCLUDEURLS = 0x00000080
Global Const $BIF_DONTGOBELOWDOMAIN = 0x00000002
Global Const $BIF_EDITBOX = 0x00000010
Global Const $BIF_NEWDIALOGSTYLE = 0x00000040
Global Const $BIF_NONEWFOLDERBUTTON = 0x00000200
Global Const $BIF_NOTRANSLATETARGETS = 0x00000400
Global Const $BIF_RETURNFSANCESTORS = 0x00000008
Global Const $BIF_RETURNONLYFSDIRS = 0x00000001
Global Const $BIF_SHAREABLE = 0x00008000
Global Const $BIF_STATUSTEXT = 0x00000004
Global Const $BIF_USENEWUI = BitOR($BIF_EDITBOX, $BIF_NEWDIALOGSTYLE)
Global Const $BIF_UAHINT = 0x00000100
Global Const $BIF_VALIDATE = 0x00000020
Global Const $BFFM_INITIALIZED = 1
Global Const $BFFM_IUNKNOWN = 5
Global Const $BFFM_SELCHANGED = 2
Global Const $BFFM_VALIDATEFAILED = 4
Global Const $BFFM_SETSTATUSTEXTA = $__DLG_WM_USER + 100
Global Const $BFFM_ENABLEOK = $__DLG_WM_USER + 101
Global Const $BFFM_SETSELECTIONA = $__DLG_WM_USER + 102
Global Const $BFFM_SETSELECTIONW = $__DLG_WM_USER + 103
Global Const $BFFM_SETSTATUSTEXTW = $__DLG_WM_USER + 104
Global Const $BFFM_SETOKTEXT = $__DLG_WM_USER + 105
Global Const $BFFM_SETEXPANDED = $__DLG_WM_USER + 106
Global Const $CDERR_DIALOGFAILURE = 0xFFFF
Global Const $CDERR_FINDRESFAILURE = 0x0006
Global Const $CDERR_INITIALIZATION = 0x0002
Global Const $CDERR_LOADRESFAILURE = 0x0007
Global Const $CDERR_LOADSTRFAILURE = 0x0005
Global Const $CDERR_LOCKRESFAILURE = 0x0008
Global Const $CDERR_MEMALLOCFAILURE = 0x0009
Global Const $CDERR_MEMLOCKFAILURE = 0x000A
Global Const $CDERR_NOHINSTANCE = 0x0004
Global Const $CDERR_NOHOOK = 0x000B
Global Const $CDERR_NOTEMPLATE = 0x0003
Global Const $CDERR_REGISTERMSGFAIL = 0x000C
Global Const $CDERR_STRUCTSIZE = 0x0001
Global Const $PDERR_CREATEICFAILURE = 0x100A
Global Const $PDERR_DEFAULTDIFFERENT = 0x100C
Global Const $PDERR_DNDMMISMATCH = 0x1009
Global Const $PDERR_GETDEVMODEFAIL = 0x1005
Global Const $PDERR_INITFAILURE = 0x1006
Global Const $PDERR_LOADDRVFAILURE = 0x1004
Global Const $PDERR_NODEFAULTPRN = 0x1008
Global Const $PDERR_NODEVICES = 0x1007
Global Const $PDERR_PARSEFAILURE = 0x1002
Global Const $PDERR_PRINTERNOTFOUND = 0x100B
Global Const $PDERR_RETDEFFAILURE = 0x1003
Global Const $PDERR_SETUPFAILURE = 0x1001
Global Const $CFERR_MAXLESSTHANMIN = 0x2002
Global Const $CFERR_NOFONTS = 0x2001
Global Const $FNERR_BUFFERTOOSMALL = 0x3003
Global Const $FNERR_INVALIDFILENAME = 0x3002
Global Const $FNERR_SUBCLASSFAILURE = 0x3001
Global Const $FRERR_BUFFERLENGTHZERO = 0x4001
Global Const $FR_DIALOGTERM = 0x00000040
Global Const $FR_DOWN = 0x00000001
Global Const $FR_ENABLEHOOK = 0x00000100
Global Const $FR_ENABLETEMPLATE = 0x00000200
Global Const $FR_ENABLETEMPLATEHANDLE = 0x00002000
Global Const $FR_FINDNEXT = 0x00000008
Global Const $FR_HIDEUPDOWN = 0x00004000
Global Const $FR_HIDEMATCHCASE = 0x00008000
Global Const $FR_HIDEWHOLEWORD = 0x00010000
Global Const $FR_MATCHCASE = 0x00000004
Global Const $FR_NOMATCHCASE = 0x00000800
Global Const $FR_NOUPDOWN = 0x00000400
Global Const $FR_NOWHOLEWORD = 0x00001000
Global Const $FR_REPLACE = 0x00000010
Global Const $FR_REPLACEALL = 0x00000020
Global Const $FR_SHOWHELP = 0x00000080
Global Const $FR_WHOLEWORD = 0x00000002
Global Const $SHFMT_ID_DEFAULT = 0xFFFF
Global Const $SHFMT_OPT_FULL = 0x00
Global Const $SHFMT_OPT_QUICKFORMAT = 0x01
Global Const $SHFMT_OPT_SYSONLY = 0x02
Global Const $SHFMT_ERROR = -1
Global Const $SHFMT_CANCEL = -2
Global Const $SHFMT_NOFORMAT = -3
Global Const $CDM_FIRST = $__DLG_WM_USER + 100
Global Const $CDM_GETSPEC = $CDM_FIRST
Global Const $CDM_GETFILEPATH = $CDM_FIRST + 1
Global Const $CDM_GETFOLDERPATH = $CDM_FIRST + 2
Global Const $CDM_GETFOLDERIDLIST = $CDM_FIRST + 3
Global Const $CDM_SETCONTROLTEXT = $CDM_FIRST + 4
Global Const $CDM_HIDECONTROL = $CDM_FIRST + 5
Global Const $CDM_SETDEFEXT = $CDM_FIRST + 6
Global Const $CDM_LAST = $__DLG_WM_USER + 200
Global Const $CDN_FIRST = -601
Global Const $CDN_INITDONE = $CDN_FIRST
Global Const $CDN_SELCHANGE = $CDN_FIRST - 1
Global Const $CDN_FOLDERCHANGE = $CDN_FIRST - 2
Global Const $CDN_SHAREVIOLATION = $CDN_FIRST - 3
Global Const $CDN_HELP = $CDN_FIRST - 4
Global Const $CDN_FILEOK = $CDN_FIRST - 5
Global Const $CDN_TYPECHANGE = $CDN_FIRST - 6
Global Const $CDN_INCLUDEITEM = $CDN_FIRST - 7
Global Const $CDN_LAST = -699
Global Const $PSD_DEFAULTMINMARGINS = 0x00000000
Global Const $PSD_DISABLEMARGINS = 0x00000010
Global Const $PSD_DISABLEORIENTATION = 0x00000100
Global Const $PSD_DISABLEPAGEPAINTING = 0x00080000
Global Const $PSD_DISABLEPAPER = 0x00000200
Global Const $PSD_DISABLEPRINTER = 0x00000020
Global Const $PSD_ENABLEPAGEPAINTHOOK = 0x00040000
Global Const $PSD_ENABLEPAGESETUPHOOK = 0x00002000
Global Const $PSD_ENABLEPAGESETUPTEMPLATE = 0x00008000
Global Const $PSD_ENABLEPAGESETUPTEMPLATEHANDLE = 0x00020000
Global Const $PSD_INHUNDREDTHSOFMILLIMETERS = 0x00000008
Global Const $PSD_INTHOUSANDTHSOFINCHES = 0x00000004
Global Const $PSD_MARGINS = 0x00000002
Global Const $PSD_MINMARGINS = 0x00000001
Global Const $PSD_NONETWORKBUTTON = 0x00200000
Global Const $PSD_NOWARNING = 0x00000080
Global Const $PSD_RETURNDEFAULT = 0x00000400
Global Const $PSD_SHOWHELP = 0x00000800
Global Const $WM_PSD_PAGESETUPDLG = $__DLG_WM_USER
Global Const $WM_PSD_FULLPAGERECT = $__DLG_WM_USER + 1
Global Const $WM_PSD_MINMARGINRECT = $__DLG_WM_USER + 2
Global Const $WM_PSD_MARGINRECT = $__DLG_WM_USER + 3
Global Const $WM_PSD_GREEKTEXTRECT = $__DLG_WM_USER + 4
Global Const $WM_PSD_ENVSTAMPRECT = $__DLG_WM_USER + 5
Global Const $WM_PSD_YAFULLPAGERECT = $__DLG_WM_USER + 6
Global Const $PD_ALLPAGES = 0x00000000
Global Const $PD_COLLATE = 0x00000010
Global Const $PD_CURRENTPAGE = 0x00400000
Global Const $PD_DISABLEPRINTTOFILE = 0x00080000
Global Const $PD_ENABLEPRINTHOOK = 0x00001000
Global Const $PD_ENABLEPRINTTEMPLATE = 0x00004000
Global Const $PD_ENABLEPRINTTEMPLATEHANDLE = 0x00010000
Global Const $PD_ENABLESETUPHOOK = 0x00002000
Global Const $PD_ENABLESETUPTEMPLATE = 0x00008000
Global Const $PD_ENABLESETUPTEMPLATEHANDLE = 0x00020000
Global Const $PD_EXCLUSIONFLAGS = 0x01000000
Global Const $PD_HIDEPRINTTOFILE = 0x00100000
Global Const $PD_NOCURRENTPAGE = 0x00800000
Global Const $PD_NONETWORKBUTTON = 0x00200000
Global Const $PD_NOPAGENUMS = 0x00000008
Global Const $PD_NOSELECTION = 0x00000004
Global Const $PD_NOWARNING = 0x00000080
Global Const $PD_PAGENUMS = 0x00000002
Global Const $PD_PRINTSETUP = 0x00000040
Global Const $PD_PRINTTOFILE = 0x00000020
Global Const $PD_RETURNDC = 0x00000100
Global Const $PD_RETURNDEFAULT = 0x00000400
Global Const $PD_RETURNIC = 0x00000200
Global Const $PD_SELECTION = 0x00000001
Global Const $PD_SHOWHELP = 0x00000800
Global Const $PD_USEDEVMODECOPIES = 0x00040000
Global Const $PD_USEDEVMODECOPIESANDCOLLATE = $PD_USEDEVMODECOPIES
Global Const $PD_USELARGETEMPLATE = 0x10000000
Global Const $PD_RESULT_APPLY = 2
Global Const $PD_RESULT_CANCEL = 0
Global Const $PD_RESULT_PRINT = 1
Global Const $EWX_LOGOFF = 0
Global Const $EWX_POWEROFF = 8
Global Const $EWX_REBOOT = 2
Global Const $EWX_SHUTDOWN = 1
Global Const $EWX_FORCE = 4
Global Const $EWX_FORCEIFHUNG = 16
Global Const $OAIF_ALLOW_REGISTRATION = 0x00000001
Global Const $OAIF_REGISTER_EXT = 0x00000002
Global Const $OAIF_EXEC = 0x00000004
Global Const $OAIF_FORCE_REGISTRATION = 0x00000008
Global Const $OAIF_HIDE_REGISTRATION = 0x00000020
Global Const $OAIF_URL_PROTOCOL = 0x00000040
Global Const $CREDUI_FLAGS_ALWAYS_SHOW_UI = 0x00000080
Global Const $CREDUI_FLAGS_COMPLETE_USERNAME = 0x00000800
Global Const $CREDUI_FLAGS_DO_NOT_PERSIST = 0x00000002
Global Const $CREDUI_FLAGS_EXCLUDE_CERTIFICATES = 0x00000008
Global Const $CREDUI_FLAGS_EXPECT_CONFIRMATION = 0x00020000
Global Const $CREDUI_FLAGS_GENERIC_CREDENTIALS = 0x00040000
Global Const $CREDUI_FLAGS_INCORRECT_PASSWORD = 0x00000001
Global Const $CREDUI_FLAGS_KEEP_USERNAME = 0x00100000
Global Const $CREDUI_FLAGS_PASSWORD_ONLY_OK = 0x00000200
Global Const $CREDUI_FLAGS_PERSIST = 0x00001000
Global Const $CREDUI_FLAGS_REQUEST_ADMINISTRATOR = 0x00000004
Global Const $CREDUI_FLAGS_REQUIRE_CERTIFICATE = 0x00000010
Global Const $CREDUI_FLAGS_REQUIRE_SMARTCARD = 0x00000100
Global Const $CREDUI_FLAGS_SERVER_CREDENTIAL = 0x00004000
Global Const $CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX = 0x00000040
Global Const $CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS = 0x00080000
Global Const $CREDUI_FLAGS_VALIDATE_USERNAME = 0x00000400
Global Const $CREDUIWIN_AUTHPACKAGE_ONLY = 0x00000010
Global Const $CREDUIWIN_CHECKBOX = 0x00000002
Global Const $CREDUIWIN_ENUMERATE_ADMINS = 0x00000100
Global Const $CREDUIWIN_ENUMERATE_CURRENT_USER = 0x00000200
Global Const $CREDUIWIN_GENERIC = 0x00000001
Global Const $CREDUIWIN_IN_CRED_ONLY = 0x00000020
Global Const $CREDUIWIN_SECURE_PROMPT = 0x00001000
Global Const $CREDUIWIN_PACK_32_WOW = 0x10000000
Global Const $CREDUIWIN_PREPROMPTING = 0x00002000
Global Const $DLLVER_PLATFORM_WINDOWS = 0x01
Global Const $DLLVER_PLATFORM_NT = 0x02
Global Const $SHCNE_ALLEVENTS = 0x7FFFFFFF
Global Const $SHCNE_ASSOCCHANGED = 0x8000000
Global Const $SHCNE_ATTRIBUTES = 0x00000800
Global Const $SHCNE_CREATE = 0x00000002
Global Const $SHCNE_DELETE = 0x00000004
Global Const $SHCNE_DRIVEADD = 0x00000100
Global Const $SHCNE_DRIVEADDGUI = 0x00010000
Global Const $SHCNE_DRIVEREMOVED = 0x00000080
Global Const $SHCNE_EXTENDED_EVENT = 0x04000000
Global Const $SHCNE_FREESPACE = 0x00040000
Global Const $SHCNE_MEDIAINSERTED = 0x00000020
Global Const $SHCNE_MEDIAREMOVED = 0x00000040
Global Const $SHCNE_MKDIR = 0x00000008
Global Const $SHCNE_NETSHARE = 0x00000200
Global Const $SHCNE_NETUNSHARE = 0x00000400
Global Const $SHCNE_RENAMEFOLDER = 0x00020000
Global Const $SHCNE_RENAMEITEM = 0x00000001
Global Const $SHCNE_RMDIR = 0x00000010
Global Const $SHCNE_SERVERDISCONNECT = 0x00004000
Global Const $SHCNE_UPDATEDIR = 0x00001000
Global Const $SHCNE_UPDATEIMAGE = 0x00008000
Global Const $SHCNE_UPDATEITEM = 0x00002000
Global Const $SHCNE_DISKEVENTS = 0x0002381F
Global Const $SHCNE_GLOBALEVENTS = 0x0C0581E0
Global Const $SHCNE_INTERRUPT = 0x80000000
Global Const $SHCNF_DWORD = 0x00000003
Global Const $SHCNF_IDLIST = 0x00000000
Global Const $SHCNF_PATH = 0x00000001
Global Const $SHCNF_PRINTER = 0x00000002
Global Const $SHCNF_FLUSH = 0x00001000
Global Const $SHCNF_FLUSHNOWAIT = 0x00002000
Global Const $SHCNF_NOTIFYRECURSIVE = 0x00010000
Global Const $SHCNRF_INTERRUPTLEVEL = 0x0001
Global Const $SHCNRF_SHELLLEVEL = 0x0002
Global Const $SHCNRF_RECURSIVEINTERRUPT = 0x1000
Global Const $SHCNRF_NEWDELIVERY = 0x8000
Global Const $SHERB_NOCONFIRMATION = 0x01
Global Const $SHERB_NOPROGRESSUI = 0x02
Global Const $SHERB_NOSOUND = 0x04
Global Const $SHERB_NO_UI = BitOR($SHERB_NOCONFIRMATION, $SHERB_NOPROGRESSUI, $SHERB_NOSOUND)
Global Const $SEE_MASK_DEFAULT = 0x00000000
Global Const $SEE_MASK_CLASSNAME = 0x00000001
Global Const $SEE_MASK_CLASSKEY = 0x00000003
Global Const $SEE_MASK_IDLIST = 0x00000004
Global Const $SEE_MASK_INVOKEIDLIST = 0x0000000C
Global Const $SEE_MASK_ICON = 0x00000010
Global Const $SEE_MASK_HOTKEY = 0x00000020
Global Const $SEE_MASK_NOCLOSEPROCESS = 0x00000040
Global Const $SEE_MASK_CONNECTNETDRV = 0x00000080
Global Const $SEE_MASK_NOASYNC = 0x00000100
Global Const $SEE_MASK_FLAG_DDEWAIT = $SEE_MASK_NOASYNC
Global Const $SEE_MASK_DOENVSUBST = 0x00000200
Global Const $SEE_MASK_FLAG_NO_UI = 0x00000400
Global Const $SEE_MASK_UNICODE = 0x00004000
Global Const $SEE_MASK_NO_CONSOLE = 0x00008000
Global Const $SEE_MASK_ASYNCOK = 0x00100000
Global Const $SEE_MASK_NOQUERYCLASSSTORE = 0x01000000
Global Const $SEE_MASK_HMONITOR = 0x00200000
Global Const $SEE_MASK_NOZONECHECKS = 0x00800000
Global Const $SEE_MASK_WAITFORINPUTIDLE = 0x02000000
Global Const $SEE_MASK_FLAG_LOG_USAGE = 0x04000000
Global Const $SE_ERR_ACCESSDENIED = 5
Global Const $SE_ERR_ASSOCINCOMPLETE = 27
Global Const $SE_ERR_DDEBUSY = 30
Global Const $SE_ERR_DDEFAIL = 29
Global Const $SE_ERR_DDETIMEOUT = 28
Global Const $SE_ERR_DLLNOTFOUND = 32
Global Const $SE_ERR_FNF = 2
Global Const $SE_ERR_NOASSOC = 31
Global Const $SE_ERR_OOM = 8
Global Const $SE_ERR_PNF = 3
Global Const $SE_ERR_SHARE = 26
Global Const $FO_COPY = 2
Global Const $FO_DELETE = 3
Global Const $FO_MOVE = 1
Global Const $FO_RENAME = 4
Global Const $FOF_ALLOWUNDO = 0x0040
Global Const $FOF_CONFIRMMOUSE = 0x0002
Global Const $FOF_FILESONLY = 0x0080
Global Const $FOF_MULTIDESTFILES = 0x0001
Global Const $FOF_NOCONFIRMATION = 0x0010
Global Const $FOF_NOCONFIRMMKDIR = 0x0200
Global Const $FOF_NO_CONNECTED_ELEMENTS = 0x2000
Global Const $FOF_NOCOPYSECURITYATTRIBS = 0x0800
Global Const $FOF_NOERRORUI = 0x0400
Global Const $FOF_NORECURSEREPARSE = 0x8000
Global Const $FOF_NORECURSION = 0x1000
Global Const $FOF_RENAMEONCOLLISION = 0x0008
Global Const $FOF_SILENT = 0x0004
Global Const $FOF_SIMPLEPROGRESS = 0x0100
Global Const $FOF_WANTMAPPINGHANDLE = 0x0020
Global Const $FOF_WANTNUKEWARNING = 0x4000
Global Const $FOF_NO_UI = BitOR($FOF_NOCONFIRMATION, $FOF_NOCONFIRMMKDIR, $FOF_NOERRORUI, $FOF_SILENT)
Global Const $SHGFI_ADDOVERLAYS = 0x00000020
Global Const $SHGFI_ATTR_SPECIFIED = 0x00020000
Global Const $SHGFI_ATTRIBUTES = 0x00000800
Global Const $SHGFI_DISPLAYNAME = 0x00000200
Global Const $SHGFI_EXETYPE = 0x00002000
Global Const $SHGFI_ICON = 0x00000100
Global Const $SHGFI_ICONLOCATION = 0x00001000
Global Const $SHGFI_LARGEICON = 0x00000000
Global Const $SHGFI_LINKOVERLAY = 0x00008000
Global Const $SHGFI_OPENICON = 0x00000002
Global Const $SHGFI_OVERLAYINDEX = 0x00000040
Global Const $SHGFI_PIDL = 0x00000008
Global Const $SHGFI_SELECTED = 0x00010000
Global Const $SHGFI_SHELLICONSIZE = 0x00000004
Global Const $SHGFI_SMALLICON = 0x00000001
Global Const $SHGFI_SYSICONINDEX = 0x00004000
Global Const $SHGFI_TYPENAME = 0x00000400
Global Const $SHGFI_USEFILEATTRIBUTES = 0x00000010
Global Const $SFGAO_CANCOPY = 0x00000001
Global Const $SFGAO_CANMOVE = 0x00000002
Global Const $SFGAO_CANLINK = 0x00000004
Global Const $SFGAO_STORAGE = 0x00000008
Global Const $SFGAO_CANRENAME = 0x00000010
Global Const $SFGAO_CANDELETE = 0x00000020
Global Const $SFGAO_HASPROPSHEET = 0x00000040
Global Const $SFGAO_DROPTARGET = 0x00000100
Global Const $SFGAO_CAPABILITYMASK = BitOR($SFGAO_CANCOPY, $SFGAO_CANMOVE, $SFGAO_CANLINK, $SFGAO_CANRENAME, $SFGAO_CANDELETE, $SFGAO_HASPROPSHEET, $SFGAO_DROPTARGET)
Global Const $SFGAO_SYSTEM = 0x00001000
Global Const $SFGAO_ENCRYPTED = 0x00002000
Global Const $SFGAO_ISSLOW = 0x00004000
Global Const $SFGAO_GHOSTED = 0x00008000
Global Const $SFGAO_LINK = 0x00010000
Global Const $SFGAO_SHARE = 0x00020000
Global Const $SFGAO_READONLY = 0x00040000
Global Const $SFGAO_HIDDEN = 0x00080000
Global Const $SFGAO_DISPLAYATTRMASK = BitOR($SFGAO_ISSLOW, $SFGAO_GHOSTED, $SFGAO_LINK, $SFGAO_SHARE, $SFGAO_READONLY, $SFGAO_HIDDEN)
Global Const $SFGAO_NONENUMERATED = 0x00100000
Global Const $SFGAO_NEWCONTENT = 0x00200000
Global Const $SFGAO_STREAM = 0x00400000
Global Const $SFGAO_STORAGEANCESTOR = 0x00800000
Global Const $SFGAO_VALIDATE = 0x01000000
Global Const $SFGAO_REMOVABLE = 0x02000000
Global Const $SFGAO_COMPRESSED = 0x04000000
Global Const $SFGAO_BROWSABLE = 0x08000000
Global Const $SFGAO_FILESYSANCESTOR = 0x10000000
Global Const $SFGAO_FOLDER = 0x20000000
Global Const $SFGAO_FILESYSTEM = 0x40000000
Global Const $SFGAO_STORAGECAPMASK = BitOR($SFGAO_STORAGE, $SFGAO_LINK, $SFGAO_READONLY, $SFGAO_STREAM, $SFGAO_STORAGEANCESTOR, $SFGAO_FILESYSANCESTOR, $SFGAO_FOLDER, $SFGAO_FILESYSTEM)
Global Const $SFGAO_HASSUBFOLDER = 0x80000000
Global Const $SFGAO_CONTENTSMASK = $SFGAO_HASSUBFOLDER
Global Const $SFGAO_PKEYSFGAOMASK = BitOR($SFGAO_ISSLOW, $SFGAO_READONLY, $SFGAO_HASSUBFOLDER, $SFGAO_VALIDATE)
Global Const $IDO_SHGIOI_DEFAULT = 0x0FFFFFFC
Global Const $IDO_SHGIOI_LINK = 0x0FFFFFFE
Global Const $IDO_SHGIOI_SHARE = 0x0FFFFFFF
Global Const $IDO_SHGIOI_SLOWFILE = 0x0FFFFFFD
Global Const $FCSM_VIEWID = 0x0001
Global Const $FCSM_WEBVIEWTEMPLATE = 0x0002
Global Const $FCSM_INFOTIP = 0x0004
Global Const $FCSM_CLSID = 0x0008
Global Const $FCSM_ICONFILE = 0x0010
Global Const $FCSM_LOGO = 0x0020
Global Const $FCSM_FLAGS = 0x0040
Global Const $FCS_READ = 0x0001
Global Const $FCS_FORCEWRITE = 0x0002
Global Const $FCS_WRITE = BitOR($FCS_READ, $FCS_FORCEWRITE)
Global Const $SSF_AUTOCHECKSELECT = 0x00800000
Global Const $SSF_DESKTOPHTML = 0x00000200
Global Const $SSF_DONTPRETTYPATH = 0x00000800
Global Const $SSF_DOUBLECLICKINWEBVIEW = 0x00000080
Global Const $SSF_HIDEICONS = 0x00004000
Global Const $SSF_ICONSONLY = 0x01000000
Global Const $SSF_MAPNETDRVBUTTON = 0x00001000
Global Const $SSF_NOCONFIRMRECYCLE = 0x00008000
Global Const $SSF_NONETCRAWLING = 0x00100000
Global Const $SSF_SEPPROCESS = 0x00080000
Global Const $SSF_SHOWALLOBJECTS = 0x00000001
Global Const $SSF_SHOWCOMPCOLOR = 0x00000008
Global Const $SSF_SHOWEXTENSIONS = 0x00000002
Global Const $SSF_SHOWINFOTIP = 0x00002000
Global Const $SSF_SHOWSUPERHIDDEN = 0x00040000
Global Const $SSF_SHOWSYSFILES = 0x00000020
Global Const $SSF_SHOWTYPEOVERLAY = 0x02000000
Global Const $SSF_STARTPANELON = 0x00200000
Global Const $SSF_WIN95CLASSIC = 0x00000400
Global Const $SSF_WEBVIEW = 0x00020000
Global Const $CSIDL_ADMINTOOLS = 0x0030
Global Const $CSIDL_ALTSTARTUP = 0x001D
Global Const $CSIDL_APPDATA = 0x001A
Global Const $CSIDL_BITBUCKET = 0x000A
Global Const $CSIDL_CDBURN_AREA = 0x003B
Global Const $CSIDL_COMMON_ADMINTOOLS = 0x002F
Global Const $CSIDL_COMMON_ALTSTARTUP = 0x001E
Global Const $CSIDL_COMMON_APPDATA = 0x0023
Global Const $CSIDL_COMMON_DESKTOPDIRECTORY = 0x0019
Global Const $CSIDL_COMMON_DOCUMENTS = 0x002E
Global Const $CSIDL_COMMON_FAVORITES = 0x001F
Global Const $CSIDL_COMMON_MUSIC = 0x0035
Global Const $CSIDL_COMMON_PICTURES = 0x0036
Global Const $CSIDL_COMMON_PROGRAMS = 0x0017
Global Const $CSIDL_COMMON_STARTMENU = 0x0016
Global Const $CSIDL_COMMON_STARTUP = 0x0018
Global Const $CSIDL_COMMON_TEMPLATES = 0x002D
Global Const $CSIDL_COMMON_VIDEO = 0x0037
Global Const $CSIDL_COMPUTERSNEARME = 0x003D
Global Const $CSIDL_CONNECTIONS = 0x0031
Global Const $CSIDL_CONTROLS = 0x0003
Global Const $CSIDL_COOKIES = 0x0021
Global Const $CSIDL_DESKTOP = 0x0000
Global Const $CSIDL_DESKTOPDIRECTORY = 0x0010
Global Const $CSIDL_DRIVES = 0x0011
Global Const $CSIDL_FAVORITES = 0x0006
Global Const $CSIDL_FONTS = 0x0014
Global Const $CSIDL_INTERNET_CACHE = 0x0020
Global Const $CSIDL_HISTORY = 0x0022
Global Const $CSIDL_LOCAL_APPDATA = 0x001C
Global Const $CSIDL_MYMUSIC = 0x000D
Global Const $CSIDL_MYPICTURES = 0x0027
Global Const $CSIDL_MYVIDEO = 0x000E
Global Const $CSIDL_NETHOOD = 0x0013
Global Const $CSIDL_PERSONAL = 0x0005
Global Const $CSIDL_PRINTERS = 0x0004
Global Const $CSIDL_PRINTHOOD = 0x001B
Global Const $CSIDL_PROFILE = 0x0028
Global Const $CSIDL_PROGRAM_FILES = 0x0026
Global Const $CSIDL_PROGRAM_FILES_COMMON = 0x002B
Global Const $CSIDL_PROGRAM_FILES_COMMONX86 = 0x002C
Global Const $CSIDL_PROGRAM_FILESX86 = 0x002A
Global Const $CSIDL_PROGRAMS = 0x0002
Global Const $CSIDL_RECENT = 0x0008
Global Const $CSIDL_SENDTO = 0x0009
Global Const $CSIDL_STARTMENU = 0x000B
Global Const $CSIDL_STARTUP = 0x0007
Global Const $CSIDL_SYSTEM = 0x0025
Global Const $CSIDL_SYSTEMX86 = 0x0029
Global Const $CSIDL_TEMPLATES = 0x0015
Global Const $CSIDL_WINDOWS = 0x0024
Global Const $SIID_DOCNOASSOC = 0
Global Const $SIID_DOCASSOC = 1
Global Const $SIID_APPLICATION = 2
Global Const $SIID_FOLDER = 3
Global Const $SIID_FOLDEROPEN = 4
Global Const $SIID_DRIVE525 = 5
Global Const $SIID_DRIVE35 = 6
Global Const $SIID_DRIVEREMOVE = 7
Global Const $SIID_DRIVEFIXED = 8
Global Const $SIID_DRIVENET = 9
Global Const $SIID_DRIVENETDISABLED = 10
Global Const $SIID_DRIVECD = 11
Global Const $SIID_DRIVERAM = 12
Global Const $SIID_WORLD = 13
Global Const $SIID_SERVER = 15
Global Const $SIID_PRINTER = 16
Global Const $SIID_MYNETWORK = 17
Global Const $SIID_FIND = 22
Global Const $SIID_HELP = 23
Global Const $SIID_SHARE = 28
Global Const $SIID_LINK = 29
Global Const $SIID_SLOWFILE = 30
Global Const $SIID_RECYCLER = 31
Global Const $SIID_RECYCLERFULL = 32
Global Const $SIID_MEDIACDAUDIO = 40
Global Const $SIID_LOCK = 47
Global Const $SIID_AUTOLIST = 49
Global Const $SIID_PRINTERNET = 50
Global Const $SIID_SERVERSHARE = 51
Global Const $SIID_PRINTERFAX = 52
Global Const $SIID_PRINTERFAXNET = 53
Global Const $SIID_PRINTERFILE = 54
Global Const $SIID_STACK = 55
Global Const $SIID_MEDIASVCD = 56
Global Const $SIID_STUFFEDFOLDER = 57
Global Const $SIID_DRIVEUNKNOWN = 58
Global Const $SIID_DRIVEDVD = 59
Global Const $SIID_MEDIADVD = 60
Global Const $SIID_MEDIADVDRAM = 61
Global Const $SIID_MEDIADVDRW = 62
Global Const $SIID_MEDIADVDR = 63
Global Const $SIID_MEDIADVDROM = 64
Global Const $SIID_MEDIACDAUDIOPLUS = 65
Global Const $SIID_MEDIACDRW = 66
Global Const $SIID_MEDIACDR = 67
Global Const $SIID_MEDIACDBURN = 68
Global Const $SIID_MEDIABLANKCD = 69
Global Const $SIID_MEDIACDROM = 70
Global Const $SIID_AUDIOFILES = 71
Global Const $SIID_IMAGEFILES = 72
Global Const $SIID_VIDEOFILES = 73
Global Const $SIID_MIXEDFILES = 74
Global Const $SIID_FOLDERBACK = 75
Global Const $SIID_FOLDERFRONT = 76
Global Const $SIID_SHIELD = 77
Global Const $SIID_WARNING = 78
Global Const $SIID_INFO = 79
Global Const $SIID_ERROR = 80
Global Const $SIID_KEY = 81
Global Const $SIID_SOFTWARE = 82
Global Const $SIID_RENAME = 83
Global Const $SIID_DELETE = 84
Global Const $SIID_MEDIAAUDIODVD = 85
Global Const $SIID_MEDIAMOVIEDVD = 86
Global Const $SIID_MEDIAENHANCEDCD = 87
Global Const $SIID_MEDIAENHANCEDDVD = 88
Global Const $SIID_MEDIAHDDVD = 89
Global Const $SIID_MEDIABLURAY = 90
Global Const $SIID_MEDIAVCD = 91
Global Const $SIID_MEDIADVDPLUSR = 92
Global Const $SIID_MEDIADVDPLUSRW = 93
Global Const $SIID_DESKTOPPC = 94
Global Const $SIID_MOBILEPC = 95
Global Const $SIID_USERS = 96
Global Const $SIID_MEDIASMARTMEDIA = 97
Global Const $SIID_MEDIACOMPACTFLASH = 98
Global Const $SIID_DEVICECELLPHONE = 99
Global Const $SIID_DEVICECAMERA = 100
Global Const $SIID_DEVICEVIDEOCAMERA = 101
Global Const $SIID_DEVICEAUDIOPLAYER = 102
Global Const $SIID_NETWORKCONNECT = 103
Global Const $SIID_INTERNET = 104
Global Const $SIID_ZIPFILE = 105
Global Const $SIID_SETTINGS = 106
Global Const $SIID_DRIVEHDDVD = 132
Global Const $SIID_DRIVEBD = 133
Global Const $SIID_MEDIAHDDVDROM = 134
Global Const $SIID_MEDIAHDDVDR = 135
Global Const $SIID_MEDIAHDDVDRAM = 136
Global Const $SIID_MEDIABDROM = 137
Global Const $SIID_MEDIABDR = 138
Global Const $SIID_MEDIABDRE = 139
Global Const $SIID_CLUSTEREDDRIVE = 140
Global Const $SIID_MAX_ICONS = 174
Global Const $SHGSI_ICONLOCATION = 0
Global Const $SHGSI_ICON = $SHGFI_ICON
Global Const $SHGSI_SYSICONINDEX = $SHGFI_SYSICONINDEX
Global Const $SHGSI_LINKOVERLAY = $SHGFI_LINKOVERLAY
Global Const $SHGSI_SELECTED = $SHGFI_SELECTED
Global Const $SHGSI_LARGEICON = $SHGFI_LARGEICON
Global Const $SHGSI_SMALLICON = $SHGFI_SMALLICON
Global Const $SHGSI_SHELLICONSIZE = $SHGFI_SHELLICONSIZE
Global Const $NIM_ADD = 0x00
Global Const $NIM_MODIFY = 0x01
Global Const $NIM_DELETE = 0x02
Global Const $NIM_SETFOCUS = 0x03
Global Const $NIM_SETVERSION = 0x04
Global Const $NIF_MESSAGE = 0x01
Global Const $NIF_ICON = 0x02
Global Const $NIF_TIP = 0x04
Global Const $NIF_STATE = 0x08
Global Const $NIF_INFO = 0x10
Global Const $NIF_GUID = 0x20
Global Const $NIF_REALTIME = 0x40
Global Const $NIF_SHOWTIP = 0x80
Global Const $NIS_HIDDEN = 0x01
Global Const $NIS_SHAREDICON = 0x02
Global Const $NIIF_NONE = 0x00
Global Const $NIIF_INFO = 0x01
Global Const $NIIF_WARNING = 0x02
Global Const $NIIF_ERROR = 0x03
Global Const $NIIF_USER = 0x04
Global Const $NIIF_NOSOUND = 0x10
Global Const $NIIF_LARGE_ICON = 0x10
Global Const $NIIF_RESPECT_QUIET_TIME = 0x80
Global Const $NIIF_ICON_MASK = 0x0F
Global Const $SHOP_PRINTERNAME = 1
Global Const $SHOP_FILEPATH = 2
Global Const $SHOP_VOLUMEGUID = 4
Global Const $OFASI_EDIT = 0x01
Global Const $OFASI_OPENDESKTOP = 0x02
Global Const $QUNS_NOT_PRESENT = 1
Global Const $QUNS_BUSY = 2
Global Const $QUNS_RUNNING_D3D_FULL_SCREEN = 3
Global Const $QUNS_PRESENTATION_MODE = 4
Global Const $QUNS_ACCEPTS_NOTIFICATIONS = 5
Global Const $QUNS_QUIET_TIME = 6
Global Const $REST_NORUN = 1
Global Const $REST_NOCLOSE = 2
Global Const $REST_NOSAVESET = 3
Global Const $REST_NOFILEMENU = 4
Global Const $REST_NOSETFOLDERS = 5
Global Const $REST_NOSETTASKBAR = 6
Global Const $REST_NODESKTOP = 7
Global Const $REST_NOFIND = 8
Global Const $REST_NODRIVES = 9
Global Const $REST_NODRIVEAUTORUN = 10
Global Const $REST_NODRIVETYPEAUTORUN = 11
Global Const $REST_NONETHOOD = 12
Global Const $REST_STARTBANNER = 13
Global Const $REST_RESTRICTRUN = 14
Global Const $REST_NOPRINTERTABS = 15
Global Const $REST_NOPRINTERDELETE = 16
Global Const $REST_NOPRINTERADD = 17
Global Const $REST_NOSTARTMENUSUBFOLDERS = 18
Global Const $REST_MYDOCSONNET = 19
Global Const $REST_NOEXITTODOS = 20
Global Const $REST_ENFORCESHELLEXTSECURITY = 21
Global Const $REST_LINKRESOLVEIGNORELINKINFO = 22
Global Const $REST_NOCOMMONGROUPS = 23
Global Const $REST_SEPARATEDESKTOPPROCESS = 24
Global Const $REST_NOWEB = 25
Global Const $REST_NOTRAYCONTEXTMENU = 26
Global Const $REST_NOVIEWCONTEXTMENU = 27
Global Const $REST_NONETCONNECTDISCONNECT = 28
Global Const $REST_STARTMENULOGOFF = 29
Global Const $REST_NOSETTINGSASSIST = 30
Global Const $REST_NOINTERNETICON = 31
Global Const $REST_NORECENTDOCSHISTORY = 32
Global Const $REST_NORECENTDOCSMENU = 33
Global Const $REST_NOACTIVEDESKTOP = 34
Global Const $REST_NOACTIVEDESKTOPCHANGES = 35
Global Const $REST_NOFAVORITESMENU = 36
Global Const $REST_CLEARRECENTDOCSONEXIT = 37
Global Const $REST_CLASSICSHELL = 38
Global Const $REST_NOCUSTOMIZEWEBVIEW = 39
Global Const $REST_NOHTMLWALLPAPER = 40
Global Const $REST_NOCHANGINGWALLPAPER = 41
Global Const $REST_NODESKCOMP = 42
Global Const $REST_NOADDDESKCOMP = 43
Global Const $REST_NODELDESKCOMP = 44
Global Const $REST_NOCLOSEDESKCOMP = 45
Global Const $REST_NOCLOSE_DRAGDROPBAND = 46
Global Const $REST_NOMOVINGBAND = 47
Global Const $REST_NOEDITDESKCOMP = 48
Global Const $REST_NORESOLVESEARCH = 49
Global Const $REST_NORESOLVETRACK = 50
Global Const $REST_FORCECOPYACLWITHFILE = 51
Global Const $REST_NOLOGO3CHANNELNOTIFY = 52
Global Const $REST_NOFORGETSOFTWAREUPDATE = 53
Global Const $REST_NOSETACTIVEDESKTOP = 54
Global Const $REST_NOUPDATEWINDOWS = 55
Global Const $REST_NOCHANGESTARMENU = 56
Global Const $REST_NOFOLDEROPTIONS = 57
Global Const $REST_HASFINDCOMPUTERS = 58
Global Const $REST_INTELLIMENUS = 59
Global Const $REST_RUNDLGMEMCHECKBOX = 60
Global Const $REST_ARP_ShowPostSetup = 61
Global Const $REST_NOCSC = 62
Global Const $REST_NOCONTROLPANEL = 63
Global Const $REST_ENUMWORKGROUP = 64
Global Const $REST_ARP_NOARP = 65
Global Const $REST_ARP_NOREMOVEPAGE = 66
Global Const $REST_ARP_NOADDPAGE = 67
Global Const $REST_ARP_NOWINSETUPPAGE = 68
Global Const $REST_GREYMSIADS = 69
Global Const $REST_NOCHANGEMAPPEDDRIVELABEL = 70
Global Const $REST_NOCHANGEMAPPEDDRIVECOMMENT = 71
Global Const $REST_MAXRECENTDOCS = 72
Global Const $REST_NONETWORKCONNECTIONS = 73
Global Const $REST_FORCESTARTMENULOGOFF = 74
Global Const $REST_NOWEBVIEW = 75
Global Const $REST_NOCUSTOMIZETHISFOLDER = 76
Global Const $REST_NOENCRYPTION = 77
Global Const $REST_DONTSHOWSUPERHIDDEN = 78
Global Const $REST_NOSHELLSEARCHBUTTON = 79
Global Const $REST_NOHARDWARETAB = 80
Global Const $REST_NORUNASINSTALLPROMPT = 81
Global Const $REST_PROMPTRUNASINSTALLNETPATH = 82
Global Const $REST_NOMANAGEMYCOMPUTERVERB = 83
Global Const $REST_NORECENTDOCSNETHOOD = 84
Global Const $REST_DISALLOWRUN = 85
Global Const $REST_NOWELCOMESCREEN = 86
Global Const $REST_RESTRICTCPL = 87
Global Const $REST_DISALLOWCPL = 88
Global Const $REST_NOSMBALLOONTIP = 89
Global Const $REST_NOSMHELP = 90
Global Const $REST_NOWINKEYS = 91
Global Const $REST_NOENCRYPTONMOVE = 92
Global Const $REST_NOLOCALMACHINERUN = 93
Global Const $REST_NOCURRENTUSERRUN = 94
Global Const $REST_NOLOCALMACHINERUNONCE = 95
Global Const $REST_NOCURRENTUSERRUNONCE = 96
Global Const $REST_FORCEACTIVEDESKTOPON = 97
Global Const $REST_NOCOMPUTERSNEARME = 98
Global Const $REST_NOVIEWONDRIVE = 99
Global Const $REST_NONETCRAWL = 100
Global Const $REST_NOSHAREDDOCUMENTS = 101
Global Const $REST_NOSMMYDOCS = 102
Global Const $REST_NOSMMYPICS = 103
Global Const $REST_ALLOWBITBUCKDRIVES = 104
Global Const $REST_NONLEGACYSHELLMODE = 105
Global Const $REST_NOCONTROLPANELBARRICADE = 106
Global Const $REST_NOSTARTPAGE = 107
Global Const $REST_NOAUTOTRAYNOTIFY = 108
Global Const $REST_NOTASKGROUPING = 109
Global Const $REST_NOCDBURNING = 110
Global Const $REST_MYCOMPNOPROP = 111
Global Const $REST_MYDOCSNOPROP = 112
Global Const $REST_NOSTARTPANEL = 113
Global Const $REST_NODISPLAYAPPEARANCEPAGE = 114
Global Const $REST_NOTHEMESTAB = 115
Global Const $REST_NOVISUALSTYLECHOICE = 116
Global Const $REST_NOSIZECHOICE = 117
Global Const $REST_NOCOLORCHOICE = 118
Global Const $REST_SETVISUALSTYLE = 119
Global Const $REST_STARTRUNNOHOMEPATH = 120
Global Const $REST_NOUSERNAMEINSTARTPANEL = 121
Global Const $REST_NOMYCOMPUTERICON = 122
Global Const $REST_NOSMNETWORKPLACES = 123
Global Const $REST_NOSMPINNEDLIST = 124
Global Const $REST_NOSMMYMUSIC = 125
Global Const $REST_NOSMEJECTPC = 126
Global Const $REST_NOSMMOREPROGRAMS = 127
Global Const $REST_NOSMMFUPROGRAMS = 128
Global Const $REST_NOTRAYITEMSDISPLAY = 129
Global Const $REST_NOTOOLBARSONTASKBAR = 130
Global Const $REST_NOSMCONFIGUREPROGRAMS = 131
Global Const $REST_HIDECLOCK = 132
Global Const $REST_NOLOWDISKSPACECHECKS = 133
Global Const $REST_NOENTIRENETWORK = 134
Global Const $REST_NODESKTOPCLEANUP = 135
Global Const $REST_BITBUCKNUKEONDELETE = 136
Global Const $REST_BITBUCKCONFIRMDELETE = 137
Global Const $REST_BITBUCKNOPROP = 138
Global Const $REST_NODISPBACKGROUND = 139
Global Const $REST_NODISPSCREENSAVEPG = 140
Global Const $REST_NODISPSETTINGSPG = 141
Global Const $REST_NODISPSCREENSAVEPREVIEW = 142
Global Const $REST_NODISPLAYCPL = 143
Global Const $REST_HIDERUNASVERB = 144
Global Const $REST_NOTHUMBNAILCACHE = 145
Global Const $REST_NOSTRCMPLOGICAL = 146
Global Const $REST_NOPUBLISHWIZARD = 147
Global Const $REST_NOONLINEPRINTSWIZARD = 148
Global Const $REST_NOWEBSERVICES = 149
Global Const $REST_ALLOWUNHASHEDWEBVIEW = 150
Global Const $REST_ALLOWLEGACYWEBVIEW = 151
Global Const $REST_REVERTWEBVIEWSECURITY = 152
Global Const $REST_INHERITCONSOLEHANDLES = 153
Global Const $REST_SORTMAXITEMCOUNT = 154
Global Const $REST_NOREMOTERECURSIVEEVENTS = 155
Global Const $REST_NOREMOTECHANGENOTIFY = 156
Global Const $REST_NOSIMPLENETIDLIST = 157
Global Const $REST_NOENUMENTIRENETWORK = 158
Global Const $REST_NODETAILSTHUMBNAILONNETWORK = 159
Global Const $REST_NOINTERNETOPENWITH = 160
Global Const $REST_ALLOWLEGACYLMZBEHAVIOR = 161
Global Const $REST_DONTRETRYBADNETNAME = 162
Global Const $REST_ALLOWFILECLSIDJUNCTIONS = 163
Global Const $REST_NOUPNPINSTALL = 164
Global Const $REST_ARP_DONTGROUPPATCHES = 165
Global Const $REST_ARP_NOCHOOSEPROGRAMSPAGE = 166
Global Const $REST_NODISCONNECT = 167
Global Const $REST_NOSECURITY = 168
Global Const $REST_NOFILEASSOCIATE = 169
Global Const $REST_ALLOWCOMMENTTOGGLE = 170
Global Const $REST_USEDESKTOPINICACHE = 171
Global Const $GIL_DONTCACHE = 0x0010
Global Const $GIL_NOTFILENAME = 0x0008
Global Const $GIL_PERCLASS = 0x0004
Global Const $GIL_PERINSTANCE = 0x0002
Global Const $GIL_SIMULATEDOC = 0x0001
Global Const $GIL_SHIELD = 0x0200
Global Const $GIL_FORCENOSHIELD = 0x0400
Global Const $FOLDERID_AddNewPrograms = '{DE61D971-5EBC-4F02-A3A9-6C82895E5C04}'
Global Const $FOLDERID_AdminTools = '{724EF170-A42D-4FEF-9F26-B60E846FBA4F}'
Global Const $FOLDERID_AppUpdates = '{A305CE99-F527-492B-8B1A-7E76FA98D6E4}'
Global Const $FOLDERID_CDBurning = '{9E52AB10-F80D-49DF-ACB8-4330F5687855}'
Global Const $FOLDERID_ChangeRemovePrograms = '{DF7266AC-9274-4867-8D55-3BD661DE872D}'
Global Const $FOLDERID_CommonAdminTools = '{D0384E7D-BAC3-4797-8F14-CBA229B392B5}'
Global Const $FOLDERID_CommonOEMLinks = '{C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D}'
Global Const $FOLDERID_CommonPrograms = '{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}'
Global Const $FOLDERID_CommonStartMenu = '{A4115719-D62E-491D-AA7C-E74B8BE3B067}'
Global Const $FOLDERID_CommonStartup = '{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}'
Global Const $FOLDERID_CommonTemplates = '{B94237E7-57AC-4347-9151-B08C6C32D1F7}'
Global Const $FOLDERID_ComputerFolder = '{0AC0837C-BBF8-452A-850D-79D08E667CA7}'
Global Const $FOLDERID_ConflictFolder = '{4BFEFB45-347D-4006-A5BE-AC0CB0567192}'
Global Const $FOLDERID_ConnectionsFolder = '{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}'
Global Const $FOLDERID_Contacts = '{56784854-C6CB-462B-8169-88E350ACB882}'
Global Const $FOLDERID_ControlPanelFolder = '{82A74AEB-AEB4-465C-A014-D097EE346D63}'
Global Const $FOLDERID_Cookies = '{2B0F765D-C0E9-4171-908E-08A611B84FF6}'
Global Const $FOLDERID_Desktop = '{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}'
Global Const $FOLDERID_DeviceMetadataStore = '{5CE4A5E9-E4EB-479D-B89F-130C02886155}'
Global Const $FOLDERID_DocumentsLibrary = '{7B0DB17D-9CD2-4A93-9733-46CC89022E7C}'
Global Const $FOLDERID_Downloads = '{374DE290-123F-4565-9164-39C4925E467B}'
Global Const $FOLDERID_Favorites = '{1777F761-68AD-4D8A-87BD-30B759FA33DD}'
Global Const $FOLDERID_Fonts = '{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}'
Global Const $FOLDERID_Games = '{CAC52C1A-B53D-4EDC-92D7-6B2E8AC19434}'
Global Const $FOLDERID_GameTasks = '{054FAE61-4DD8-4787-80B6-090220C4B700}'
Global Const $FOLDERID_History = '{D9DC8A3B-B784-432E-A781-5A1130A75963}'
Global Const $FOLDERID_HomeGroup = '{52528A6B-B9E3-4ADD-B60D-588C2DBA842D}'
Global Const $FOLDERID_ImplicitAppShortcuts = '{BCB5256F-79F6-4CEE-B725-DC34E402FD46}'
Global Const $FOLDERID_InternetCache = '{352481E8-33BE-4251-BA85-6007CAEDCF9D}'
Global Const $FOLDERID_InternetFolder = '{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}'
Global Const $FOLDERID_Libraries = '{1B3EA5DC-B587-4786-B4EF-BD1DC332AEAE}'
Global Const $FOLDERID_Links = '{BFB9D5E0-C6A9-404C-B2B2-AE6DB6AF4968}'
Global Const $FOLDERID_LocalAppData = '{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}'
Global Const $FOLDERID_LocalAppDataLow = '{A520A1A4-1780-4FF6-BD18-167343C5AF16}'
Global Const $FOLDERID_LocalizedResourcesDir = '{2A00375E-224C-49DE-B8D1-440DF7EF3DDC}'
Global Const $FOLDERID_Music = '{4BD8D571-6D19-48D3-BE97-422220080E43}'
Global Const $FOLDERID_MusicLibrary = '{2112AB0A-C86A-4FFE-A368-0DE96E47012E}'
Global Const $FOLDERID_NetHood = '{C5ABBF53-E17F-4121-8900-86626FC2C973}'
Global Const $FOLDERID_NetworkFolder = '{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}'
Global Const $FOLDERID_OriginalImages = '{2C36C0AA-5812-4B87-BFD0-4CD0DFB19B39}'
Global Const $FOLDERID_PhotoAlbums = '{69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C}'
Global Const $FOLDERID_PicturesLibrary = '{A990AE9F-A03B-4E80-94BC-9912D7504104}'
Global Const $FOLDERID_Pictures = '{33E28130-4E1E-4676-835A-98395C3BC3BB}'
Global Const $FOLDERID_Playlists = '{DE92C1C7-837F-4F69-A3BB-86E631204A23}'
Global Const $FOLDERID_PrintersFolder = '{76FC4E2D-D6AD-4519-A663-37BD56068185}'
Global Const $FOLDERID_PrintHood = '{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}'
Global Const $FOLDERID_Profile = '{5E6C858F-0E22-4760-9AFE-EA3317B67173}'
Global Const $FOLDERID_ProgramData = '{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}'
Global Const $FOLDERID_ProgramFiles = '{905E63B6-C1BF-494E-B29C-65B732D3D21A}'
Global Const $FOLDERID_ProgramFilesX64 = '{6D809377-6AF0-444B-8957-A3773F02200E}'
Global Const $FOLDERID_ProgramFilesX86 = '{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}'
Global Const $FOLDERID_ProgramFilesCommon = '{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}'
Global Const $FOLDERID_ProgramFilesCommonX64 = '{6365D5A7-0F0D-45E5-87F6-0DA56B6A4F7D}'
Global Const $FOLDERID_ProgramFilesCommonX86 = '{DE974D24-D9C6-4D3E-BF91-F4455120B917}'
Global Const $FOLDERID_Programs = '{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}'
Global Const $FOLDERID_Public = '{DFDF76A2-C82A-4D63-906A-5644AC457385}'
Global Const $FOLDERID_PublicDesktop = '{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}'
Global Const $FOLDERID_PublicDocuments = '{ED4824AF-DCE4-45A8-81E2-FC7965083634}'
Global Const $FOLDERID_PublicDownloads = '{3D644C9B-1FB8-4F30-9B45-F670235F79C0}'
Global Const $FOLDERID_PublicGameTasks = '{DEBF2536-E1A8-4C59-B6A2-414586476AEA}'
Global Const $FOLDERID_PublicLibraries = '{48DAF80B-E6CF-4F4E-B800-0E69D84EE384}'
Global Const $FOLDERID_PublicMusic = '{3214FAB5-9757-4298-BB61-92A9DEAA44FF}'
Global Const $FOLDERID_PublicPictures = '{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}'
Global Const $FOLDERID_PublicRingtones = '{E555AB60-153B-4D17-9F04-A5FE99FC15EC}'
Global Const $FOLDERID_PublicVideos = '{2400183A-6185-49FB-A2D8-4A392A602BA3}'
Global Const $FOLDERID_QuickLaunch = '{52A4F021-7B75-48A9-9F6B-4B87A210BC8F}'
Global Const $FOLDERID_Recent = '{AE50C081-EBD2-438A-8655-8A092E34987A}'
Global Const $FOLDERID_RecordedTVLibrary = '{1A6FDBA2-F42D-4358-A798-B74D745926C5}'
Global Const $FOLDERID_RecycleBinFolder = '{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}'
Global Const $FOLDERID_ResourceDir = '{8AD10C31-2ADB-4296-A8F7-E4701232C972}'
Global Const $FOLDERID_Ringtones = '{C870044B-F49E-4126-A9C3-B52A1FF411E8}'
Global Const $FOLDERID_RoamingAppData = '{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}'
Global Const $FOLDERID_SampleMusic = '{B250C668-F57D-4EE1-A63C-290EE7D1AA1F}'
Global Const $FOLDERID_SamplePictures = '{C4900540-2379-4C75-844B-64E6FAF8716B}'
Global Const $FOLDERID_SamplePlaylists = '{15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5}'
Global Const $FOLDERID_SampleVideos = '{859EAD94-2E85-48AD-A71A-0969CB56A6CD}'
Global Const $FOLDERID_SavedGames = '{4C5C32FF-BB9D-43B0-B5B4-2D72E54EAAA4}'
Global Const $FOLDERID_SavedSearches = '{7D1D3A04-DEBB-4115-95CF-2F29DA2920DA}'
Global Const $FOLDERID_SEARCH_CSC = '{EE32E446-31CA-4ABA-814F-A5EBD2FD6D5E}'
Global Const $FOLDERID_SEARCH_MAPI = '{98EC0E18-2098-4D44-8644-66979315A281}'
Global Const $FOLDERID_SearchHome = '{190337D1-B8CA-4121-A639-6D472D16972A}'
Global Const $FOLDERID_SendTo = '{8983036C-27C0-404B-8F08-102D10DCFD74}'
Global Const $FOLDERID_SidebarDefaultParts = '{7B396E54-9EC5-4300-BE0A-2482EBAE1A26}'
Global Const $FOLDERID_SidebarParts = '{A75D362E-50FC-4FB7-AC2C-A8BEAA314493}'
Global Const $FOLDERID_StartMenu = '{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}'
Global Const $FOLDERID_Startup = '{B97D20BB-F46A-4C97-BA10-5E3608430854}'
Global Const $FOLDERID_SyncManagerFolder = '{43668BF8-C14E-49B2-97C9-747784D784B7}'
Global Const $FOLDERID_SyncResultsFolder = '{289A9A43-BE44-4057-A41B-587A76D7E7F9}'
Global Const $FOLDERID_SyncSetupFolder = '{0F214138-B1D3-4A90-BBA9-27CBC0C5389A}'
Global Const $FOLDERID_System = '{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}'
Global Const $FOLDERID_SystemX86 = '{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}'
Global Const $FOLDERID_Templates = '{A63293E8-664E-48DB-A079-DF759E0509F7}'
Global Const $FOLDERID_UserPinned = '{9E3995AB-1F9C-4F13-B827-48B24B6C7174}'
Global Const $FOLDERID_UserProfiles = '{0762D272-C50A-4BB0-A382-697DCD729B80}'
Global Const $FOLDERID_UserProgramFiles = '{5CD7AEE2-2219-4A67-B85D-6C9CE15660CB}'
Global Const $FOLDERID_UserProgramFilesCommon = '{BCBD3057-CA5C-4622-B42D-BC56DB0AE516}'
Global Const $FOLDERID_UsersFiles = '{F3CE0F7C-4901-4ACC-8648-D5D44B04EF8F}'
Global Const $FOLDERID_UsersLibraries = '{A302545D-DEFF-464B-ABE8-61C8648D939B}'
Global Const $FOLDERID_Videos = '{18989B1D-99B5-455B-841C-AB7C74E4DDFC}'
Global Const $FOLDERID_VideosLibrary = '{491E922F-5643-4AF4-A7EB-4E7A138D8174}'
Global Const $FOLDERID_Windows = '{F38BF404-1D43-42F2-9305-67DE0B28FC23}'
Global Const $KF_FLAG_ALIAS_ONLY = 0x80000000
Global Const $KF_FLAG_CREATE = 0x00008000
Global Const $KF_FLAG_DONT_VERIFY = 0x00004000
Global Const $KF_FLAG_DONT_UNEXPAND = 0x00002000
Global Const $KF_FLAG_NO_ALIAS = 0x00001000
Global Const $KF_FLAG_INIT = 0x00000800
Global Const $KF_FLAG_DEFAULT_PATH = 0x00000400
Global Const $KF_FLAG_NO_APPCONTAINER_REDIRECTION = 0x00010000
Global Const $KF_FLAG_NOT_PARENT_RELATIVE = 0x00000200
Global Const $KF_FLAG_SIMPLE_IDLIST = 0x00000100
Global Const $URL_SCHEME_INVALID = -1
Global Const $URL_SCHEME_UNKNOWN = 0
Global Const $URL_SCHEME_FTP = 1
Global Const $URL_SCHEME_HTTP = 2
Global Const $URL_SCHEME_GOPHER = 3
Global Const $URL_SCHEME_MAILTO = 4
Global Const $URL_SCHEME_NEWS = 5
Global Const $URL_SCHEME_NNTP = 6
Global Const $URL_SCHEME_TELNET = 7
Global Const $URL_SCHEME_WAIS = 8
Global Const $URL_SCHEME_FILE = 9
Global Const $URL_SCHEME_MK = 10
Global Const $URL_SCHEME_HTTPS = 11
Global Const $URL_SCHEME_SHELL = 12
Global Const $URL_SCHEME_SNEWS = 13
Global Const $URL_SCHEME_LOCAL = 14
Global Const $URL_SCHEME_JAVASCRIPT = 15
Global Const $URL_SCHEME_VBSCRIPT = 16
Global Const $URL_SCHEME_ABOUT = 17
Global Const $URL_SCHEME_RES = 18
Global Const $URL_SCHEME_MSSHELLROOTED = 19
Global Const $URL_SCHEME_MSSHELLIDLIST = 20
Global Const $URL_SCHEME_MSHELP = 21
Global Const $URL_SCHEME_MSSHELLDEVICE = 22
Global Const $URL_SCHEME_WILDCARD = 23
Global Const $URL_SCHEME_SEARCH_MS = 24
Global Const $URL_SCHEME_SEARCH = 25
Global Const $URL_SCHEME_KNOWNFOLDER = 26
Global Const $GCT_INVALID = 0x00
Global Const $GCT_LFNCHAR = 0x01
Global Const $GCT_SEPARATOR = 0x08
Global Const $GCT_SHORTCHAR = 0x02
Global Const $GCT_WILD = 0x04
Global Const $URL_APPLY_DEFAULT = 0x01
Global Const $URL_APPLY_GUESSSCHEME = 0x02
Global Const $URL_APPLY_GUESSFILE = 0x04
Global Const $URL_APPLY_FORCEAPPLY = 0x08
Global Const $URL_DONT_SIMPLIFY = 0x08000000
Global Const $URL_ESCAPE_AS_UTF8 = 0x00040000
Global Const $URL_ESCAPE_PERCENT = 0x00001000
Global Const $URL_ESCAPE_SPACES_ONLY = 0x04000000
Global Const $URL_ESCAPE_UNSAFE = 0x20000000
Global Const $URL_NO_META = 0x08000000
Global Const $URL_PLUGGABLE_PROTOCOL = 0x40000000
Global Const $URL_UNESCAPE = 0x10000000
Global Const $URL_PART_HOSTNAME = 2
Global Const $URL_PART_PASSWORD = 4
Global Const $URL_PART_PORT = 5
Global Const $URL_PART_QUERY = 6
Global Const $URL_PART_SCHEME = 1
Global Const $URL_PART_USERNAME = 3
Global Const $URLIS_APPLIABLE = 4
Global Const $URLIS_DIRECTORY = 5
Global Const $URLIS_FILEURL = 3
Global Const $URLIS_HASQUERY = 6
Global Const $URLIS_NOHISTORY = 2
Global Const $URLIS_OPAQUE = 1
Global Const $URLIS_URL = 0
Func _WinAPI_CommandLineToArgv($sCmd)
Local $aRet[1] = [0]
$sCmd = StringStripWS($sCmd, $STR_STRIPLEADING + $STR_STRIPTRAILING)
If Not $sCmd Then
Return $aRet
EndIf
Local $aCall = DllCall('shell32.dll', 'ptr', 'CommandLineToArgvW', 'wstr', $sCmd, 'int*', 0)
If @error Or Not $aCall[0] Or (Not $aCall[2]) Then Return SetError(@error + 10, @extended, 0)
Local $tPtr = DllStructCreate('ptr[' & $aCall[2] & ']', $aCall[0])
Dim $aRet[$aCall[2] + 1] = [$aCall[2]]
For $i = 1 To $aCall[2]
$aRet[$i] = _WinAPI_GetString(DllStructGetData($tPtr, 1, $i))
Next
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $aCall[0])
Return $aRet
EndFunc
Func _WinAPI_IsNameInExpression($sString, $sPattern, $bCaseSensitive = False)
If Not $bCaseSensitive Then $sPattern = StringUpper($sPattern)
Local $tUS1 = __US($sPattern)
Local $tUS2 = __US($sString)
Local $aCall = DllCall('ntdll.dll', 'boolean', 'RtlIsNameInExpression', 'struct*', $tUS1, 'struct*', $tUS2,  'boolean', Not $bCaseSensitive, 'ptr', 0)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ParseURL($sUrl)
Local $tagPARSEDURL = 'dword Size;ptr Protocol;uint cchProtocol;ptr Suffix;uint cchSuffix;uint Scheme'
Local $tPURL = DllStructCreate($tagPARSEDURL)
DllStructSetData($tPURL, 1, DllStructGetSize($tPURL))
Local $tURL = DllStructCreate('wchar[4096]')
DllStructSetData($tURL, 1, $sUrl)
Local $aCall = DllCall('shlwapi.dll', 'long', 'ParseURLW', 'struct*', $tURL, 'struct*', $tPURL)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
Local $aRet[3]
$aRet[0] = DllStructGetData(DllStructCreate('wchar[' & DllStructGetData($tPURL, 3) & ']', DllStructGetData($tPURL, 2)), 1)
$aRet[1] = DllStructGetData(DllStructCreate('wchar[' & DllStructGetData($tPURL, 5) & ']', DllStructGetData($tPURL, 4)), 1)
$aRet[2] = DllStructGetData($tPURL, 6)
Return $aRet
EndFunc
Func _WinAPI_ParseUserName($sUser)
If Not __DLL('credui.dll') Then Return SetError(103, 0, 0)
Local $aCall = DllCall('credui.dll', 'dword', 'CredUIParseUserNameW', 'wstr', $sUser, 'wstr', '', 'ulong', 4096, 'wstr', '',  'ulong', 4096)
If @error Then Return SetError(@error, @extended, 0)
Switch $aCall[0]
Case 0
Case 1315
If StringStripWS($sUser, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$aCall[2] = $sUser
$aCall[4] = ''
Else
ContinueCase
EndIf
Case Else
Return SetError(10, $aCall[0], 0)
EndSwitch
Local $aRet[2]
$aRet[0] = $aCall[4]
$aRet[1] = $aCall[2]
Return $aRet
EndFunc
Func _WinAPI_PathAddBackslash($sFilePath)
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'ptr', 'PathAddBackslashW', 'struct*', $tPath)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return DllStructGetData($tPath, 1)
EndFunc
Func _WinAPI_PathAddExtension($sFilePath, $sExt = '')
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
If Not StringStripWS($sExt, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sExt = Null
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathAddExtensionW', 'struct*', $tPath, 'wstr', $sExt)
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($aCall[0], DllStructGetData($tPath, 1))
EndFunc
Func _WinAPI_PathAppend($sFilePath, $sMore)
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathAppendW', 'struct*', $tPath, 'wstr', $sMore)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return DllStructGetData($tPath, 1)
EndFunc
Func _WinAPI_PathBuildRoot($iDrive)
Local $aCall = DllCall('shlwapi.dll', 'ptr', 'PathBuildRootW', 'wstr', '', 'int', $iDrive)
If @error Then Return SetError(@error, @extended, '')
Return $aCall[1]
EndFunc
Func _WinAPI_PathCanonicalize($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathCanonicalizeW', 'wstr', '', 'wstr', $sFilePath)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, $sFilePath)
Return $aCall[1]
EndFunc
Func _WinAPI_PathCommonPrefix($sPath1, $sPath2)
Local $aCall = DllCall('shlwapi.dll', 'int', 'PathCommonPrefixW', 'wstr', $sPath1, 'wstr', $sPath2, 'wstr', '')
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($aCall[0], $aCall[3])
EndFunc
Func _WinAPI_PathCompactPath($hWnd, $sFilePath, $iWidth = 0)
If $iWidth < 1 Then
Local $tRECT = DllStructCreate($tagRECT)
DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hWnd, "struct*", $tRECT)
$iWidth += DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndIf
Local $aCall = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', $hWnd)
If @error Or Not $aCall[0] Then Return SetError(@error + 20, @extended, $sFilePath)
Local $hDC = $aCall[0]
Local Const $WM_GETFONT = 0x0031
$aCall = DllCall('user32.dll', 'ptr', 'SendMessage', 'hwnd', $hWnd, 'uint', $WM_GETFONT, 'wparam', 0, 'lparam', 0)
Local $hBack = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $aCall[0])
Local $iError = 0
$aCall = DllCall('shlwapi.dll', 'bool', 'PathCompactPathW', 'handle', $hDC, 'wstr', $sFilePath, 'int', $iWidth)
If @error Or Not $aCall[0] Then $iError = @error + 10
DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hBack[0])
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If $iError Then Return SetError($iError, 0, $sFilePath)
Return $aCall[2]
EndFunc
Func _WinAPI_PathCompactPathEx($sFilePath, $iMax)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathCompactPathExW', 'wstr', '', 'wstr', $sFilePath, 'uint', $iMax + 1, 'dword', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, $sFilePath)
Return $aCall[1]
EndFunc
Func _WinAPI_PathCreateFromUrl($sUrl)
Local $aCall = DllCall('shlwapi.dll', 'long', 'PathCreateFromUrlW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', 0)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
Return $aCall[2]
EndFunc
Func _WinAPI_PathFindExtension($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'wstr', 'PathFindExtensionW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aCall[0]
EndFunc
Func _WinAPI_PathFindFileName($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'wstr', 'PathFindFileNameW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, $sFilePath)
Return $aCall[0]
EndFunc
Func _WinAPI_PathFindNextComponent($sFilePath)
Local $tPath = DllStructCreate('wchar[' & (StringLen($sFilePath) + 1) & ']')
DllStructSetData($tPath, 1, $sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'ptr', 'PathFindNextComponentW', 'struct*', $tPath)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
Return _WinAPI_GetString($aCall[0])
EndFunc
Func _WinAPI_PathFindOnPath(Const $sFilePath, $aExtraPaths = "", Const $sPathDelimiter = @LF)
Local $iExtraCount = 0
If IsString($aExtraPaths) Then
If StringLen($aExtraPaths) Then
$aExtraPaths = StringSplit($aExtraPaths, $sPathDelimiter, $STR_ENTIRESPLIT + $STR_NOCOUNT)
$iExtraCount = UBound($aExtraPaths, $UBOUND_ROWS)
EndIf
ElseIf IsArray($aExtraPaths) Then
$iExtraCount = UBound($aExtraPaths)
EndIf
Local $tPaths, $tPathPtrs
If $iExtraCount Then
Local $tagStruct = ""
For $path In $aExtraPaths
$tagStruct &= "wchar[" & StringLen($path) + 1 & "];"
Next
$tPaths = DllStructCreate($tagStruct)
$tPathPtrs = DllStructCreate("ptr[" & $iExtraCount + 1 & "]")
For $i = 1 To $iExtraCount
DllStructSetData($tPaths, $i, $aExtraPaths[$i - 1])
DllStructSetData($tPathPtrs, 1, DllStructGetPtr($tPaths, $i), $i)
Next
DllStructSetData($tPathPtrs, 1, Ptr(0), $iExtraCount + 1)
EndIf
Local $aCall = DllCall("shlwapi.dll", "bool", "PathFindOnPathW", "wstr", $sFilePath, "struct*", $tPathPtrs)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, $sFilePath)
Return $aCall[1]
EndFunc
Func _WinAPI_PathGetArgs($sFilePath)
Local $tPath = DllStructCreate('wchar[' & (StringLen($sFilePath) + 1) & ']')
DllStructSetData($tPath, 1, $sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'ptr', 'PathGetArgsW', 'struct*', $tPath)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return _WinAPI_GetString($aCall[0])
EndFunc
Func _WinAPI_PathGetCharType($sChar)
Local $aCall = DllCall('shlwapi.dll', 'uint', 'PathGetCharTypeW', 'word', AscW($sChar))
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_PathGetDriveNumber($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'int', 'PathGetDriveNumberW', 'wstr', $sFilePath)
If @error Or ($aCall[0] = -1) Then Return SetError(@error, @extended, '')
Return Chr($aCall[0] + 65) & ':'
EndFunc
Func _WinAPI_PathIsContentType($sFilePath, $sType)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathIsContentTypeW', 'wstr', $sFilePath, 'wstr', $sType)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathIsExe($sFilePath)
Local $aCall = DllCall('shell32.dll', 'bool', 'PathIsExe', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathIsFileSpec($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathIsFileSpecW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathIsLFNFileSpec($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathIsLFNFileSpecW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathIsRelative($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathIsRelativeW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathIsRoot($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathIsRootW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathIsSameRoot($sPath1, $sPath2)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathIsSameRootW', 'wstr', $sPath1, 'wstr', $sPath2)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathIsSystemFolder($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathIsSystemFolderW', 'wstr', $sFilePath, 'dword', 0)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathIsUNC($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathIsUNCW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathIsUNCServer($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathIsUNCServerW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathIsUNCServerShare($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathIsUNCServerShareW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathMakeSystemFolder($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathMakeSystemFolderW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathMatchSpec($sFilePath, $sSpec)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathMatchSpecW', 'wstr', $sFilePath, 'wstr', $sSpec)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathParseIconLocation($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'int', 'PathParseIconLocationW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Local $aRet[2]
$aRet[0] = $aCall[1]
$aRet[1] = $aCall[0]
Return $aRet
EndFunc
Func _WinAPI_PathRelativePathTo($sPathFrom, $bDirFrom, $sPathTo, $bDirTo)
If $bDirFrom Then
$bDirFrom = 0x10
EndIf
If $bDirTo Then
$bDirTo = 0x10
EndIf
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathRelativePathToW', 'wstr', '', 'wstr', $sPathFrom, 'dword', $bDirFrom,  'wstr', $sPathTo, 'dword', $bDirTo)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return $aCall[1]
EndFunc
Func _WinAPI_PathRemoveArgs($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'none', 'PathRemoveArgsW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aCall[1]
EndFunc
Func _WinAPI_PathRemoveBackslash($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'ptr', 'PathRemoveBackslashW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aCall[1]
EndFunc
Func _WinAPI_PathRemoveExtension($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'none', 'PathRemoveExtensionW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aCall[1]
EndFunc
Func _WinAPI_PathRemoveFileSpec($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathRemoveFileSpecW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($aCall[0], $aCall[1])
EndFunc
Func _WinAPI_PathRenameExtension($sFilePath, $sExt)
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathRenameExtensionW', 'struct*', $tPath, 'wstr', $sExt)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return DllStructGetData($tPath, 1)
EndFunc
Func _WinAPI_PathSearchAndQualify($sFilePath, $bExists = False)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathSearchAndQualifyW', 'wstr', $sFilePath, 'wstr', '', 'int', 4096)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
If $bExists And Not FileExists($aCall[2]) Then Return SetError(20, 0, '')
Return $aCall[2]
EndFunc
Func _WinAPI_PathSkipRoot($sFilePath)
Local $tPath = DllStructCreate('wchar[' & (StringLen($sFilePath) + 1) & ']')
DllStructSetData($tPath, 1, $sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'ptr', 'PathSkipRootW', 'struct*', $tPath)
If @error Then Return SetError(@error, @extended, '')
If Not $aCall[0] Then Return $sFilePath
Return _WinAPI_GetString($aCall[0])
EndFunc
Func _WinAPI_PathStripPath($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'none', 'PathStripPathW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aCall[1]
EndFunc
Func _WinAPI_PathStripToRoot($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathStripToRootW', 'wstr', $sFilePath)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return $aCall[1]
EndFunc
Func _WinAPI_PathUndecorate($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'none', 'PathUndecorateW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aCall[1]
EndFunc
Func _WinAPI_PathUnExpandEnvStrings($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathUnExpandEnvStringsW', 'wstr', $sFilePath, 'wstr', '', 'uint', 4096)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_PathUnmakeSystemFolder($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathUnmakeSystemFolderW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_PathUnquoteSpaces($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'none', 'PathUnquoteSpacesW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aCall[1]
EndFunc
Func _WinAPI_PathYetAnotherMakeUniqueName($sFilePath)
Local $aCall = DllCall('shell32.dll', 'int', 'PathYetAnotherMakeUniqueName', 'wstr', '', 'wstr', $sFilePath, 'ptr', 0, 'ptr', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return $aCall[1]
EndFunc
Func _WinAPI_ShellGetImageList($bSmall = False)
Local $pLarge, $pSmall, $tPtr = DllStructCreate('ptr')
If $bSmall Then
$pLarge = 0
$pSmall = DllStructGetPtr($tPtr)
Else
$pLarge = DllStructGetPtr($tPtr)
$pSmall = 0
EndIf
Local $aCall = DllCall('shell32.dll', 'int', 'Shell_GetImageLists', 'ptr', $pLarge, 'ptr', $pSmall)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPtr, 1)
EndFunc
Func _WinAPI_UrlApplyScheme($sUrl, $iFlags = 1)
Local $aCall = DllCall('shlwapi.dll', 'long', 'UrlApplySchemeW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
Return $aCall[2]
EndFunc
Func _WinAPI_UrlCanonicalize($sUrl, $iFlags)
Local $aCall = DllCall('shlwapi.dll', 'long', 'UrlCanonicalizeW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
Return $aCall[2]
EndFunc
Func _WinAPI_UrlCombine($sUrl, $sPart, $iFlags = 0)
Local $aCall = DllCall('shlwapi.dll', 'long', 'UrlCombineW', 'wstr', $sUrl, 'wstr', $sPart, 'wstr', '', 'dword*', 4096,  'dword', $iFlags)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
Return $aCall[3]
EndFunc
Func _WinAPI_UrlCompare($sUrl1, $sUrl2, $bIgnoreSlash = False)
Local $aCall = DllCall('shlwapi.dll', 'int', 'UrlCompareW', 'wstr', $sUrl1, 'wstr', $sUrl2, 'bool', $bIgnoreSlash)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_UrlCreateFromPath($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'long', 'UrlCreateFromPathW', 'wstr', $sFilePath, 'wstr', '', 'dword*', 4096, 'dword', 0)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] < 0 Or $aCall[0] > 1 Then
Return SetError(10, $aCall[0], '')
EndIf
Return $aCall[2]
EndFunc
Func _WinAPI_UrlFixup($sUrl)
Local $aCall = DllCall('shlwapi.dll', 'long', 'UrlFixupW', 'wstr', $sUrl, 'wstr', '', 'dword', 4096)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
Return $aCall[2]
EndFunc
Func _WinAPI_UrlGetPart($sUrl, $iPart)
Local $aCall = DllCall('shlwapi.dll', 'long', 'UrlGetPartW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iPart,  'dword', 0)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
Return $aCall[2]
EndFunc
Func _WinAPI_UrlHash($sUrl, $iLength = 32)
If $iLength <= 0 Or $iLength > 256 Then Return SetError(256, 0, 0)
Local $tData = DllStructCreate('byte[' & $iLength & ']')
Local $aCall = DllCall('shlwapi.dll', 'long', 'UrlHashW', 'wstr', $sUrl, 'struct*', $tData, 'dword', $iLength)
If @error Then Return SetError(@error + 10, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return DllStructGetData($tData, 1)
EndFunc
Func _WinAPI_UrlIs($sUrl, $iType = 0)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'UrlIsW', 'wstr', $sUrl, 'uint', $iType)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func __US($sString, $iLength = 0)
If $iLength Then
$sString = StringLeft($sString, $iLength)
Else
$iLength = StringLen($sString)
EndIf
Local $tUS = DllStructCreate('ushort;ushort;ptr;wchar[' & ($iLength + 1) & ']')
DllStructSetData($tUS, 1, 2 * StringLen($sString))
DllStructSetData($tUS, 2, 2 * $iLength)
DllStructSetData($tUS, 3, DllStructGetPtr($tUS, 4))
DllStructSetData($tUS, 4, $sString)
Return $tUS
EndFunc
Global Const $tagNOTIFYICONDATA = 'struct;dword Size;hwnd hWnd;uint ID;uint Flags;uint CallbackMessage;ptr hIcon;wchar Tip[128];dword State;dword StateMask;wchar Info[256];uint Version;wchar InfoTitle[64];dword InfoFlags;endstruct'
Global Const $tagNOTIFYICONDATA_V3 = $tagNOTIFYICONDATA & ';' & $tagGUID
Global Const $tagNOTIFYICONDATA_V4 = $tagNOTIFYICONDATA_V3 & ';ptr hBalloonIcon;'
Global Const $tagSHELLEXECUTEINFO = 'dword Size;ulong Mask;hwnd hWnd;ptr Verb;ptr File;ptr Parameters;ptr Directory;int Show;ulong_ptr hInstApp;ptr IDList;ptr Class;ulong_ptr hKeyClass;dword HotKey;ptr hMonitor;ptr hProcess'
Global Const $tagSHFILEINFO = 'ptr hIcon;int iIcon;dword Attributes;wchar DisplayName[260];wchar TypeName[80]'
Global Const $tagSHFILEOPSTRUCT = 'hwnd hWnd;uint Func;ptr From;ptr To;dword Flags;int fAnyOperationsAborted;ptr hNameMappings;ptr ProgressTitle'
Global Const $tagSHFOLDERCUSTOMSETTINGS = 'dword Size;dword Mask;ptr GUID;ptr WebViewTemplate;dword SizeWVT;ptr WebViewTemplateVersion;ptr InfoTip;dword SizeIT;ptr CLSID;dword Flags;ptr IconFile;dword SizeIF;int IconIndex;ptr Logo;dword SizeL'
Global Const $tagSHSTOCKICONINFO = 'dword Size;ptr hIcon;int SysImageIndex;int iIcon;wchar Path[260]'
Func _WinAPI_DefSubclassProc($hWnd, $iMsg, $wParam, $lParam)
Local $aCall = DllCall('comctl32.dll', 'lresult', 'DefSubclassProc', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam,  'lparam', $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_DllGetVersion($sFilePath)
Local $tVersion = DllStructCreate('dword[5]')
DllStructSetData($tVersion, 1, DllStructGetSize($tVersion), 1)
Local $aCall = DllCall($sFilePath, 'uint', 'DllGetVersion', 'struct*', $tVersion)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Local $aRet[4]
For $i = 0 To 3
$aRet[$i] = DllStructGetData($tVersion, 1, $i + 2)
Next
Return $aRet
EndFunc
Func _WinAPI_FindExecutable($sFileName, $sDirectory = "")
Local $aCall = DllCall("shell32.dll", "INT", "FindExecutableW", "wstr", $sFileName, "wstr", $sDirectory, "wstr", "")
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] <= 32 Then Return SetError(10, $aCall[0], '')
Return SetExtended($aCall[0], $aCall[3])
EndFunc
Func _WinAPI_GetAllUsersProfileDirectory()
Local $aCall = DllCall('userenv.dll', 'bool', 'GetAllUsersProfileDirectoryW', 'wstr', '', 'dword*', 4096)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return $aCall[1]
EndFunc
Func _WinAPI_GetDefaultUserProfileDirectory()
Local $aCall = DllCall('userenv.dll', 'bool', 'GetDefaultUserProfileDirectoryW', 'wstr', '', 'dword*', 4096)
If @error Then Return SetError(@error, @extended, '')
Return $aCall[1]
EndFunc
Func _WinAPI_GetWindowSubclass($hWnd, $pSubclassProc, $idSubClass)
Local $aCall = DllCall('comctl32.dll', 'bool', 'GetWindowSubclass', 'hwnd', $hWnd, 'ptr', $pSubclassProc, 'uint_ptr', $idSubClass,  'dword_ptr*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $aCall[4]
EndFunc
Func _WinAPI_RemoveWindowSubclass($hWnd, $pSubclassProc, $idSubClass)
Local $aCall = DllCall('comctl32.dll', 'bool', 'RemoveWindowSubclass', 'hwnd', $hWnd, 'ptr', $pSubclassProc, 'uint_ptr', $idSubClass)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetCurrentProcessExplicitAppUserModelID($sAppID)
Local $aCall = DllCall('shell32.dll', 'long', 'SetCurrentProcessExplicitAppUserModelID', 'wstr', $sAppID)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_SetWindowSubclass($hWnd, $pSubclassProc, $idSubClass, $pData = 0)
Local $aCall = DllCall('comctl32.dll', 'bool', 'SetWindowSubclass', 'hwnd', $hWnd, 'ptr', $pSubclassProc, 'uint_ptr', $idSubClass,  'dword_ptr', $pData)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ShellAddToRecentDocs($sFilePath)
If StringStripWS($sFilePath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sFilePath = _WinAPI_PathSearchAndQualify($sFilePath, 1)
If Not $sFilePath Then
Return SetError(1, 0, 0)
EndIf
Else
$sFilePath = Null
EndIf
DllCall('shell32.dll', 'none', 'SHAddToRecentDocs', 'uint', 3, 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_ShellChangeNotify($iEvent, $iFlags, $iItem1 = 0, $iItem2 = 0)
Local $sTypeOfItem1 = 'dword_ptr', $sTypeOfItem2 = 'dword_ptr'
If IsString($iItem1) Then
$sTypeOfItem1 = 'wstr'
EndIf
If IsString($iItem2) Then
$sTypeOfItem2 = 'wstr'
EndIf
DllCall('shell32.dll', 'none', 'SHChangeNotify', 'long', $iEvent, 'uint', $iFlags, $sTypeOfItem1, $iItem1, $sTypeOfItem2, $iItem2)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_ShellChangeNotifyDeregister($iID)
Local $aCall = DllCall('shell32.dll', 'bool', 'SHChangeNotifyDeregister', 'ulong', $iID)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ShellChangeNotifyRegister($hWnd, $iMsg, $iEvents, $iSources, $aPaths, $bRecursive = False)
Local $iPath = $aPaths, $tagStruct = ''
If IsArray($aPaths) Then
If UBound($aPaths, $UBOUND_COLUMNS) Then Return SetError(1, 0, 0)
Else
Dim $aPaths[1] = [$iPath]
EndIf
For $i = 0 To UBound($aPaths) - 1
If Not _WinAPI_PathIsDirectory($aPaths[$i]) Then Return SetError(2, 0, 0)
Next
For $i = 0 To UBound($aPaths) - 1
$tagStruct &= 'ptr;int;'
Next
Local $tEntry = DllStructCreate($tagStruct)
For $i = 0 To UBound($aPaths) - 1
$aPaths[$i] = _WinAPI_ShellILCreateFromPath(_WinAPI_PathSearchAndQualify($aPaths[$i]))
DllStructSetData($tEntry, 2 * $i + 1, $aPaths[$i])
DllStructSetData($tEntry, 2 * $i + 2, $bRecursive)
Next
Local $iError = 0
Local $aCall = DllCall('shell32.dll', 'ulong', 'SHChangeNotifyRegister', 'hwnd', $hWnd, 'int', $iSources, 'long', $iEvents,  'uint', $iMsg, 'int', UBound($aPaths), 'struct*', $tEntry)
If @error Or Not $aCall[0] Then $iError = @error + 10
For $i = 0 To UBound($aPaths) - 1
_WinAPI_CoTaskMemFree($aPaths[$i])
Next
Return SetError($iError, 0, $aCall[0])
EndFunc
Func _WinAPI_ShellCreateDirectory($sFilePath, $hParent = 0, $tSecurity = 0)
Local $aCall = DllCall('shell32.dll', 'int', 'SHCreateDirectoryExW', 'hwnd', $hParent, 'wstr', $sFilePath, 'struct*', $tSecurity)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_ShellEmptyRecycleBin($sRoot = '', $iFlags = 0, $hParent = 0)
Local $aCall = DllCall('shell32.dll', 'long', 'SHEmptyRecycleBinW', 'hwnd', $hParent, 'wstr', $sRoot, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_ShellExecute($sFilePath, $sArgs = '', $sDir = '', $sVerb = '', $iShow = 1, $hParent = 0)
If Not StringStripWS($sArgs, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sArgs = Null
If Not StringStripWS($sDir, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sDir = Null
If Not StringStripWS($sVerb, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sVerb = Null
Local $aCall = DllCall('shell32.dll', 'ULONG_PTR', 'ShellExecuteW', 'hwnd', $hParent, 'wstr', $sVerb, 'wstr', $sFilePath,  'wstr', $sArgs, 'wstr', $sDir, 'int', $iShow)
If @error Then Return SetError(@error, @extended, False)
If $aCall[0] <= 32 Then Return SetError(10, $aCall[0], 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ShellExecuteEx(ByRef $tSHEXINFO)
Local $aCall = DllCall('shell32.dll', 'bool', 'ShellExecuteExW', 'struct*', $tSHEXINFO)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ShellExtractAssociatedIcon($sFilePath, $bSmall = False)
Local $iFlags = 0x00000100
If Not _WinAPI_PathIsDirectory($sFilePath) Then
$iFlags = BitOR($iFlags, 0x00000010)
EndIf
If $bSmall Then
$iFlags = BitOR($iFlags, 0x00000001)
EndIf
Local $tSHFILEINFO = DllStructCreate($tagSHFILEINFO)
If Not _WinAPI_ShellGetFileInfo($sFilePath, $iFlags, 0, $tSHFILEINFO) Then Return SetError(@error + 10, @extended, 0)
Return DllStructGetData($tSHFILEINFO, 'hIcon')
EndFunc
Func _WinAPI_ShellExtractIcon($sIcon, $iIndex, $iWidth, $iHeight)
Local $aCall = DllCall('shell32.dll', 'int', 'SHExtractIconsW', 'wstr', $sIcon, 'int', $iIndex, 'int', $iWidth,  'int', $iHeight, 'ptr*', 0, 'ptr*', 0, 'int', 1, 'int', 0)
If @error Or Not $aCall[0] Or Not $aCall[5] Then Return SetError(@error, @extended, 0)
Return $aCall[5]
EndFunc
Func _WinAPI_ShellFileOperation($sFrom, $sTo, $iFunc, $iFlags, $sTitle = '', $hParent = 0)
Local $iData
If Not IsArray($sFrom) Then
$iData = $sFrom
Dim $sFrom[1] = [$iData]
EndIf
Local $tFrom = _WinAPI_ArrayToStruct($sFrom)
If @error Then Return SetError(@error + 20, @extended, 0)
If Not IsArray($sTo) Then
$iData = $sTo
Dim $sTo[1] = [$iData]
EndIf
Local $tTo = _WinAPI_ArrayToStruct($sTo)
If @error Then Return SetError(@error + 30, @extended, 0)
Local $tSHFILEOPSTRUCT = DllStructCreate($tagSHFILEOPSTRUCT)
DllStructSetData($tSHFILEOPSTRUCT, 'hWnd', $hParent)
DllStructSetData($tSHFILEOPSTRUCT, 'Func', $iFunc)
DllStructSetData($tSHFILEOPSTRUCT, 'From', DllStructGetPtr($tFrom))
DllStructSetData($tSHFILEOPSTRUCT, 'To', DllStructGetPtr($tTo))
DllStructSetData($tSHFILEOPSTRUCT, 'Flags', $iFlags)
DllStructSetData($tSHFILEOPSTRUCT, 'ProgressTitle', $sTitle)
Local $aCall = DllCall('shell32.dll', 'int', 'SHFileOperationW', 'struct*', $tSHFILEOPSTRUCT)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $tSHFILEOPSTRUCT
EndFunc
Func _WinAPI_ShellFlushSFCache()
DllCall('shell32.dll', 'none', 'SHFlushSFCache')
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_ShellGetFileInfo($sFilePath, $iFlags, $iAttributes, ByRef $tSHFILEINFO)
Local $aCall = DllCall('shell32.dll', 'dword_ptr', 'SHGetFileInfoW', 'wstr', $sFilePath, 'dword', $iAttributes,  'struct*', $tSHFILEINFO, 'uint', DllStructGetSize($tSHFILEINFO), 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ShellGetIconOverlayIndex($sIcon, $iIndex)
If Not StringStripWS($sIcon, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sIcon = Null
Local $aCall = DllCall('shell32.dll', 'int', 'SHGetIconOverlayIndexW', 'wstr', $sIcon, 'int', $iIndex)
If @error Or ($aCall[0] = -1) Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_ShellGetKnownFolderIDList($sGUID, $iFlags = 0, $hToken = 0)
Local $tGUID = DllStructCreate($tagGUID)
Local $aCall = DllCall('ole32.dll', 'uint', 'CLSIDFromString', 'wstr', $sGUID, 'struct*', $tGUID)
If @error Or $aCall[0] Then Return SetError(@error + 20, @extended, 0)
$aCall = DllCall('shell32.dll', 'uint', 'SHGetKnownFolderIDList', 'struct*', $tGUID, 'dword', $iFlags, 'handle', $hToken, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[4]
EndFunc
Func _WinAPI_ShellGetKnownFolderPath($sGUID, $iFlags = 0, $hToken = 0)
Local $tGUID = DllStructCreate($tagGUID)
Local $aCall = DllCall('ole32.dll', 'long', 'CLSIDFromString', 'wstr', $sGUID, 'struct*', $tGUID)
If @error Or $aCall[0] Then Return SetError(@error + 20, @extended, '')
$aCall = DllCall('shell32.dll', 'long', 'SHGetKnownFolderPath', 'struct*', $tGUID, 'dword', $iFlags, 'handle', $hToken, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
Local $sPath = _WinAPI_GetString($aCall[4])
_WinAPI_CoTaskMemFree($aCall[4])
Return $sPath
EndFunc
Func _WinAPI_ShellGetLocalizedName($sFilePath)
Local $aCall = DllCall('shell32.dll', 'long', 'SHGetLocalizedName', 'wstr', $sFilePath, 'wstr', '', 'uint*', 0, 'int*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Local $aRet[2]
Local $aCall1 = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $aCall[2], "wstr", "", "dword", 4096)
$aRet[0] = $aCall1[2]
$aRet[1] = $aCall[4]
Return $aRet
EndFunc
Func _WinAPI_ShellGetPathFromIDList($pPIDL)
Local $aCall = DllCall('shell32.dll', 'bool', 'SHGetPathFromIDListW', 'struct*', $pPIDL, 'wstr', '')
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_ShellGetSetFolderCustomSettings($sFilePath, $iFlag, ByRef $tSHFCS)
Local $sProc = 'SHGetSetFolderCustomSettings'
If _WinAPI_GetVersion() < 6.0 Then $sProc &= 'W'
Local $aCall = DllCall('shell32.dll', 'long', $sProc, 'struct*', $tSHFCS, 'wstr', $sFilePath, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_ShellGetSettings($iFlags)
Local $tSHELLSTATE = DllStructCreate('uint[8]')
DllCall('shell32.dll', 'none', 'SHGetSetSettings', 'struct*', $tSHELLSTATE, 'dword', $iFlags, 'bool', 0)
If @error Then Return SetError(@error, @extended, 0)
Local $iVal1 = DllStructGetData($tSHELLSTATE, 1, 1)
Local $iVal2 = DllStructGetData($tSHELLSTATE, 1, 8)
Local $iResult = 0
Local $aOpt[20][2] =  [[0x00000001, 0x00000001],  [0x00000002, 0x00000002],  [0x00000004, 0x00008000],  [0x00000008, 0x00000020],  [0x00000010, 0x00000008],  [0x00000020, 0x00000080],  [0x00000040, 0x00000200],  [0x00000080, 0x00000400],  [0x00000100, 0x00000800],  [0x00000400, 0x00001000],  [0x00000800, 0x00002000],  [0x00001000, 0x00004000],  [0x00002000, 0x00020000],  [0x00008000, 0x00040000],  [0x00010000, 0x00100000],  [0x00000001, 0x00080000],  [0x00000002, 0x00200000],  [0x00000008, 0x00800000],  [0x00000010, 0x01000000],  [0x00000020, 0x02000000]]
For $i = 0 To 14
If BitAND($iVal1, $aOpt[$i][0]) Then
$iResult += $aOpt[$i][1]
EndIf
Next
For $i = 15 To 19
If BitAND($iVal2, $aOpt[$i][0]) Then
$iResult += $aOpt[$i][1]
EndIf
Next
Return $iResult
EndFunc
Func _WinAPI_ShellGetSpecialFolderLocation($iCSIDL)
Local $aCall = DllCall('shell32.dll', 'long', 'SHGetSpecialFolderLocation', 'hwnd', 0, 'int', $iCSIDL, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _WinAPI_ShellGetSpecialFolderPath($iCSIDL, $bCreate = False)
Local $aCall = DllCall('shell32.dll', 'bool', 'SHGetSpecialFolderPathW', 'hwnd', 0, 'wstr', '', 'int', $iCSIDL, 'bool', $bCreate)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_ShellGetStockIconInfo($iSIID, $iFlags)
Local $tSHSTOCKICONINFO = DllStructCreate($tagSHSTOCKICONINFO)
DllStructSetData($tSHSTOCKICONINFO, 'Size', DllStructGetSize($tSHSTOCKICONINFO))
Local $aCall = DllCall('shell32.dll', 'long', 'SHGetStockIconInfo', 'int', $iSIID, 'uint', $iFlags, 'struct*', $tSHSTOCKICONINFO)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $tSHSTOCKICONINFO
EndFunc
Func _WinAPI_ShellILCreateFromPath($sFilePath)
Local $aCall = DllCall('shell32.dll', 'long', 'SHILCreateFromPath', 'wstr', $sFilePath, 'ptr*', 0, 'dword*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[2]
EndFunc
Func _WinAPI_ShellNotifyIcon($iMessage, ByRef $tNOTIFYICONDATA)
Local $aCall = DllCall('shell32.dll', 'bool', 'Shell_NotifyIconW', 'dword', $iMessage, 'struct*', $tNOTIFYICONDATA)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ShellNotifyIconGetRect($hWnd, $iID, $tGUID = 0)
Local $tNII = DllStructCreate('dword;hwnd;uint;' & $tagGUID)
DllStructSetData($tNII, 1, DllStructGetSize($tNII))
DllStructSetData($tNII, 2, $hWnd)
DllStructSetData($tNII, 3, $iID)
If IsDllStruct($tGUID) Then
If Not _WinAPI_MoveMemory(DllStructGetPtr($tNII, 4), $tGUID, 16) Then Return SetError(@error + 10, @extended, 0)
EndIf
Local $tRECT = DllStructCreate($tagRECT)
Local $aCall = DllCall('shell32.dll', 'long', 'Shell_NotifyIconGetRect', 'struct*', $tNII, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $tRECT
EndFunc
Func _WinAPI_ShellObjectProperties($sFilePath, $iType = 2, $sProperty = '', $hParent = 0)
If Not StringStripWS($sProperty, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sProperty = Null
Local $aCall = DllCall('shell32.dll', 'bool', 'SHObjectProperties', 'hwnd', $hParent, 'dword', $iType, 'wstr', $sFilePath,  'wstr', $sProperty)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ShellOpenFolderAndSelectItems($sFilePath, $aNames = 0, $iStart = 0, $iEnd = -1, $iFlags = 0)
Local $pPIDL, $aCall, $tPtr = 0, $iCount = 0, $iObj = 0, $iError = 0
$sFilePath = _WinAPI_PathRemoveBackslash(_WinAPI_PathSearchAndQualify($sFilePath))
If IsArray($aNames) Then
If $sFilePath And Not _WinAPI_PathIsDirectory($sFilePath) Then Return SetError(@error + 20, @extended, 0)
EndIf
$pPIDL = _WinAPI_ShellILCreateFromPath($sFilePath)
If @error Then Return SetError(@error + 30, @extended, 0)
If Not __CheckErrorArrayBounds($aNames, $iStart, $iEnd) Then
$tPtr = DllStructCreate('ptr[' & ($iEnd - $iStart + 1) & ']')
For $i = $iStart To $iEnd
$iCount += 1
If $aNames[$i] Then
DllStructSetData($tPtr, 1, _WinAPI_ShellILCreateFromPath($sFilePath & '\' & $aNames[$i]), $iCount)
Else
DllStructSetData($tPtr, 1, 0, $iCount)
EndIf
Next
EndIf
If _WinAPI_CoInitialize() Then $iObj = 1
$aCall = DllCall('shell32.dll', 'long', 'SHOpenFolderAndSelectItems', 'ptr', $pPIDL, 'uint', $iCount, 'struct*', $tPtr,  'dword', $iFlags)
If @error Then
$iError = @error + 10
Else
If $aCall[0] Then $iError = 10
EndIf
If $iObj Then _WinAPI_CoUninitialize()
_WinAPI_CoTaskMemFree($pPIDL)
For $i = 1 To $iCount
$pPIDL = DllStructGetData($tPtr, $i)
If $pPIDL Then
_WinAPI_CoTaskMemFree($pPIDL)
EndIf
Next
If $iError = 10 Then Return SetError(10, $aCall[0], 0)
If $iError Then Return SetError($iError, 0, 0)
Return 1
EndFunc
Func _WinAPI_ShellQueryRecycleBin($sRoot = '')
Local $tagSHQUERYRBINFO = (@AutoItX64 ? '' : 'align 1;') & 'dword cbSize;int64 Size;int64 nbFiles'
Local $tSHQRBI = DllStructCreate($tagSHQUERYRBINFO)
DllStructSetData($tSHQRBI, 1, DllStructGetSize($tSHQRBI))
Local $aCall = DllCall('shell32.dll', 'long', 'SHQueryRecycleBinW', 'wstr', $sRoot, 'struct*', $tSHQRBI)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Local $aRet[2]
$aRet[0] = DllStructGetData($tSHQRBI, 2)
$aRet[1] = DllStructGetData($tSHQRBI, 3)
Return $aRet
EndFunc
Func _WinAPI_ShellQueryUserNotificationState()
Local $aCall = DllCall('shell32.dll', 'long', 'SHQueryUserNotificationState', 'uint*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[1]
EndFunc
Func _WinAPI_ShellRemoveLocalizedName($sFilePath)
Local $aCall = DllCall('shell32.dll', 'long', 'SHRemoveLocalizedName', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_ShellRestricted($iRestriction)
Local $aCall = DllCall('shell32.dll', 'dword', 'SHRestricted', 'uint', $iRestriction)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ShellSetKnownFolderPath($sGUID, $sFilePath, $iFlags = 0, $hToken = 0)
Local $tGUID = DllStructCreate($tagGUID)
Local $aCall = DllCall('ole32.dll', 'long', 'CLSIDFromString', 'wstr', $sGUID, 'struct*', $tGUID)
If @error Or $aCall[0] Then Return SetError(@error + 20, @extended, 0)
$aCall = DllCall('shell32.dll', 'long', 'SHSetKnownFolderPath', 'struct*', $tGUID, 'dword', $iFlags, 'handle', $hToken, 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_ShellSetLocalizedName($sFilePath, $sModule, $iResID)
Local $aCall = DllCall('shell32.dll', 'long', 'SHSetLocalizedName', 'wstr', $sFilePath, 'wstr', $sModule, 'int', $iResID)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_ShellSetSettings($iFlags, $bSet)
Local $iVal1 = 0, $iVal2 = 0
Local $aOpt[20][2] =  [[0x00000001, 0x00000001],  [0x00000002, 0x00000002],  [0x00000004, 0x00008000],  [0x00000008, 0x00000020],  [0x00000010, 0x00000008],  [0x00000020, 0x00000080],  [0x00000040, 0x00000200],  [0x00000080, 0x00000400],  [0x00000100, 0x00000800],  [0x00000400, 0x00001000],  [0x00000800, 0x00002000],  [0x00001000, 0x00004000],  [0x00002000, 0x00020000],  [0x00008000, 0x00040000],  [0x00010000, 0x00100000],  [0x00000001, 0x00080000],  [0x00000002, 0x00200000],  [0x00000008, 0x00800000],  [0x00000010, 0x01000000],  [0x00000020, 0x02000000]]
If $bSet Then
For $i = 0 To 14
If BitAND($iFlags, $aOpt[$i][1]) Then
$iVal1 += $aOpt[$i][0]
EndIf
Next
For $i = 15 To 19
If BitAND($iFlags, $aOpt[$i][1]) Then
$iVal2 += $aOpt[$i][0]
EndIf
Next
EndIf
Local $tSHELLSTATE = DllStructCreate('uint[8]')
DllStructSetData($tSHELLSTATE, 1, $iVal1, 1)
DllStructSetData($tSHELLSTATE, 1, $iVal2, 8)
DllCall('shell32.dll', 'none', 'SHGetSetSettings', 'struct*', $tSHELLSTATE, 'dword', $iFlags, 'bool', 1)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_ShellUpdateImage($sIcon, $iIndex, $iImage, $iFlags = 0)
DllCall('shell32.dll', 'none', 'SHUpdateImageW', 'wstr', $sIcon, 'int', $iIndex, 'uint', $iFlags, 'int', $iImage)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Global $__g_pFRBuffer = 0, $__g_iFRBufferSize = 16385
Global Const $tagDEVNAMES = 'ushort DriverOffset;ushort DeviceOffset;ushort OutputOffset;ushort Default'
Global Const $tagFINDREPLACE = 'dword Size;hwnd hOwner;ptr hInstance;dword Flags;ptr FindWhat;ptr ReplaceWith;ushort FindWhatLen;ushort ReplaceWithLen;lparam lParam;ptr Hook;ptr TemplateName'
Global Const $tagMSGBOXPARAMS = 'uint Size;hwnd hOwner;ptr hInstance;int_ptr Text;int_ptr Caption;dword Style;int_ptr Icon;dword_ptr ContextHelpId;ptr MsgBoxCallback;dword LanguageId'
Global Const $tagPAGESETUPDLG = 'dword Size;hwnd hOwner;ptr hDevMode;ptr hDevNames;dword Flags;long PaperWidth;long PaperHeight;long MarginMinLeft;long MarginMinTop;long MarginMinRight;long MarginMinBottom;long MarginLeft;long MarginTop;long MarginRight;long MarginBottom;ptr hInstance;lparam lParam;ptr PageSetupHook;ptr PagePaintHook;ptr PageSetupTemplateName;ptr hPageSetupTemplate'
Global Const $tagPRINTDLG = (@AutoItX64 ? '' : 'align 1;') & 'dword Size;hwnd hOwner;handle hDevMode;handle hDevNames;handle hDC;dword Flags;word FromPage;word ToPage;word MinPage;word MaxPage;word Copies;handle hInstance;lparam lParam;ptr PrintHook;ptr SetupHook;ptr PrintTemplateName;ptr SetupTemplateName;handle hPrintTemplate;handle hSetupTemplate'
Global Const $tagPRINTDLGEX = 'dword Size;hwnd hOwner;handle hDevMode;handle hDevNames;handle hDC;dword Flags;dword Flags2;dword ExclusionFlags;dword NumPageRanges;dword MaxPageRanges;ptr PageRanges;dword MinPage;dword MaxPage;dword Copies;handle hInstance;ptr PrintTemplateName;lparam lParam;dword NumPropertyPages;ptr hPropertyPages;dword StartPage;dword ResultAction'
Global Const $tagPRINTPAGERANGE = 'dword FromPage;dword ToPage'
Func _WinAPI_BrowseForFolderDlg($sRoot = '', $sText = '', $iFlags = 0, $pBrowseProc = 0, $lParam = 0, $hParent = 0)
Local Const $tagBROWSEINFO = 'hwnd hwndOwner;ptr pidlRoot;ptr pszDisplayName; ptr lpszTitle;uint ulFlags;ptr lpfn;lparam lParam;int iImage'
Local $tBROWSEINFO = DllStructCreate($tagBROWSEINFO & ';wchar[' & (StringLen($sText) + 1) & '];wchar[260]')
Local $pPIDL = 0, $sResult = ''
If StringStripWS($sRoot, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
Local $sPath = _WinAPI_PathSearchAndQualify($sRoot, 1)
If @error Then
$sPath = $sRoot
EndIf
$pPIDL = _WinAPI_ShellILCreateFromPath($sPath)
If @error Then
EndIf
EndIf
DllStructSetData($tBROWSEINFO, 1, $hParent)
DllStructSetData($tBROWSEINFO, 2, $pPIDL)
DllStructSetData($tBROWSEINFO, 3, DllStructGetPtr($tBROWSEINFO, 10))
DllStructSetData($tBROWSEINFO, 4, DllStructGetPtr($tBROWSEINFO, 9))
DllStructSetData($tBROWSEINFO, 5, $iFlags)
DllStructSetData($tBROWSEINFO, 6, $pBrowseProc)
DllStructSetData($tBROWSEINFO, 7, $lParam)
DllStructSetData($tBROWSEINFO, 8, 0)
DllStructSetData($tBROWSEINFO, 9, $sText)
Local $aCall = DllCall('shell32.dll', 'ptr', 'SHBrowseForFolderW', 'struct*', $tBROWSEINFO)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
$sResult = _WinAPI_ShellGetPathFromIDList($aCall[0])
_WinAPI_CoTaskMemFree($aCall[0])
If $pPIDL Then
_WinAPI_CoTaskMemFree($pPIDL)
EndIf
If Not $sResult Then Return SetError(10, 0, '')
Return $sResult
EndFunc
Func _WinAPI_CommDlgExtendedError()
Local Const $CDERR_DIALOGFAILURE = 0xFFFF
Local Const $CDERR_FINDRESFAILURE = 0x06
Local Const $CDERR_INITIALIZATION = 0x02
Local Const $CDERR_LOADRESFAILURE = 0x07
Local Const $CDERR_LOADSTRFAILURE = 0x05
Local Const $CDERR_LOCKRESFAILURE = 0x08
Local Const $CDERR_MEMALLOCFAILURE = 0x09
Local Const $CDERR_MEMLOCKFAILURE = 0x0A
Local Const $CDERR_NOHINSTANCE = 0x04
Local Const $CDERR_NOHOOK = 0x0B
Local Const $CDERR_NOTEMPLATE = 0x03
Local Const $CDERR_REGISTERMSGFAIL = 0x0C
Local Const $CDERR_STRUCTSIZE = 0x01
Local Const $FNERR_BUFFERTOOSMALL = 0x3003
Local Const $FNERR_INVALIDFILENAME = 0x3002
Local Const $FNERR_SUBCLASSFAILURE = 0x3001
Local $aCall = DllCall("comdlg32.dll", "dword", "CommDlgExtendedError")
If Not @error Then
Switch $aCall[0]
Case $CDERR_DIALOGFAILURE
Return SetError($aCall[0], 0, "The dialog box could not be created." & @LF &  "The common dialog box function's call to the DialogBox function failed." & @LF &  "For example, this error occurs if the common dialog box call specifies an invalid window handle.")
Case $CDERR_FINDRESFAILURE
Return SetError($aCall[0], 0, "The common dialog box function failed to find a specified resource.")
Case $CDERR_INITIALIZATION
Return SetError($aCall[0], 0, "The common dialog box function failed during initialization." & @LF & "This error often occurs when sufficient memory is not available.")
Case $CDERR_LOADRESFAILURE
Return SetError($aCall[0], 0, "The common dialog box function failed to load a specified resource.")
Case $CDERR_LOADSTRFAILURE
Return SetError($aCall[0], 0, "The common dialog box function failed to load a specified string.")
Case $CDERR_LOCKRESFAILURE
Return SetError($aCall[0], 0, "The common dialog box function failed to lock a specified resource.")
Case $CDERR_MEMALLOCFAILURE
Return SetError($aCall[0], 0, "The common dialog box function was unable to allocate memory for internal structures.")
Case $CDERR_MEMLOCKFAILURE
Return SetError($aCall[0], 0, "The common dialog box function was unable to lock the memory associated with a handle.")
Case $CDERR_NOHINSTANCE
Return SetError($aCall[0], 0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF &  "but you failed to provide a corresponding instance handle.")
Case $CDERR_NOHOOK
Return SetError($aCall[0], 0, "The ENABLEHOOK flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF &  "but you failed to provide a pointer to a corresponding hook procedure.")
Case $CDERR_NOTEMPLATE
Return SetError($aCall[0], 0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF &  "but you failed to provide a corresponding template.")
Case $CDERR_REGISTERMSGFAIL
Return SetError($aCall[0], 0, "The RegisterWindowMessage function returned an error code when it was called by the common dialog box function.")
Case $CDERR_STRUCTSIZE
Return SetError($aCall[0], 0, "The lStructSize member of the initialization structure for the corresponding common dialog box is invalid")
Case $FNERR_BUFFERTOOSMALL
Return SetError($aCall[0], 0, "The buffer pointed to by the lpstrFile member of the OPENFILENAME structure is too small for the file name specified by the user." & @LF &  "The first two bytes of the lpstrFile buffer contain an integer value specifying the size, in TCHARs, required to receive the full name.")
Case $FNERR_INVALIDFILENAME
Return SetError($aCall[0], 0, "A file name is invalid.")
Case $FNERR_SUBCLASSFAILURE
Return SetError($aCall[0], 0, "An attempt to subclass a list box failed because sufficient memory was not available.")
EndSwitch
EndIf
Return SetError(@error, @extended, '0x' & Hex($aCall[0]))
EndFunc
Func _WinAPI_CommDlgExtendedErrorEx()
Local $aCall = DllCall('comdlg32.dll', 'dword', 'CommDlgExtendedError')
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ConfirmCredentials($sTarget, $bConfirm)
If Not __DLL('credui.dll') Then Return SetError(103, 0, 0)
Local $aCall = DllCall('credui.dll', 'dword', 'CredUIConfirmCredentialsW', 'wstr', $sTarget, 'bool', $bConfirm)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_FindTextDlg($hOwner, $sFindWhat = '', $iFlags = 0, $pFindProc = 0, $lParam = 0)
$__g_pFRBuffer = __HeapReAlloc($__g_pFRBuffer, 2 * $__g_iFRBufferSize)
If @error Then Return SetError(@error + 20, @extended, 0)
DllStructSetData(DllStructCreate('wchar[' & $__g_iFRBufferSize & ']', $__g_pFRBuffer), 1, StringLeft($sFindWhat, $__g_iFRBufferSize - 1))
Local $tFR = DllStructCreate($tagFINDREPLACE)
DllStructSetData($tFR, 'Size', DllStructGetSize($tFR))
DllStructSetData($tFR, 'hOwner', $hOwner)
DllStructSetData($tFR, 'hInstance', 0)
DllStructSetData($tFR, 'Flags', $iFlags)
DllStructSetData($tFR, 'FindWhat', $__g_pFRBuffer)
DllStructSetData($tFR, 'ReplaceWith', 0)
DllStructSetData($tFR, 'FindWhatLen', $__g_iFRBufferSize * 2)
DllStructSetData($tFR, 'ReplaceWithLen', 0)
DllStructSetData($tFR, 'lParam', $lParam)
DllStructSetData($tFR, 'Hook', $pFindProc)
DllStructSetData($tFR, 'TemplateName', 0)
Local $aCall = DllCall('comdlg32.dll', 'hwnd', 'FindTextW', 'struct*', $tFR)
If @error Or Not $aCall[0] Then
Local $iError = @error + 30
__HeapFree($__g_pFRBuffer)
If IsArray($aCall) Then
Return SetError(10, _WinAPI_CommDlgExtendedErrorEx(), 0)
Else
Return SetError($iError, @extended, 0)
EndIf
EndIf
Return $aCall[0]
EndFunc
Func _WinAPI_FlushFRBuffer()
If Not __HeapFree($__g_pFRBuffer, 1) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_FormatDriveDlg($sDrive, $iOption = 0, $hParent = 0)
If Not IsString($sDrive) Then Return SetError(10, 0, 0)
$sDrive = StringLeft(StringUpper(StringStripWS($sDrive, $STR_STRIPLEADING)), 1)
If Not $sDrive Then Return SetError(11, 0, 0)
$sDrive = Asc($sDrive) - 65
If ($sDrive < 0) Or ($sDrive > 25) Then Return SetError(12, 0, 0)
Local $aCall = DllCall('shell32.dll', 'dword', 'SHFormatDrive', 'hwnd', $hParent, 'uint', $sDrive, 'uint', 0xFFFF,  'uint', $iOption)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] < 0 Then Return SetError($aCall[0], 0, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetConnectedDlg($iDlg, $iFlags = 0, $hParent = 0)
If Not __DLL('connect.dll') Then Return SetError(103, 0, 0)
Switch $iDlg
Case 0
$iDlg = 'GetNetworkConnected'
Case 1
$iDlg = 'GetInternetConnected'
Case 2
$iDlg = 'GetVPNConnected'
Case Else
Return SetError(1, 0, 0)
EndSwitch
Local $sStr = ''
If BitAND($iFlags, 1) Then
$sStr &= '-SkipInternetDetection '
EndIf
If BitAND($iFlags, 2) Then
$sStr &= '-SkipExistingConnections '
EndIf
If BitAND($iFlags, 4) Then
$sStr &= '-HideFinishPage '
EndIf
Local $aCall = DllCall('connect.dll', 'long', $iDlg, 'hwnd', $hParent, 'dword', 0, 'dword', 0, 'dword', 0, 'handle', 0,  'wstr', StringStripWS($sStr, $STR_STRIPTRAILING))
If @error Then Return SetError(@error, @extended, 0)
If Not ($aCall[0] = 0 Or $aCall[0] = 1) Then Return SetError(10, $aCall[0], 0)
Return Number(Not $aCall[0])
EndFunc
Func _WinAPI_GetFRBuffer()
Return $__g_iFRBufferSize - 1
EndFunc
Func _WinAPI_GetOpenFileName($sTitle = "", $sFilter = "All files (*.*)", $sInitalDir = ".", $sDefaultFile = "", $sDefaultExt = "", $iFilterIndex = 1, $iFlags = 0, $iFlagsEx = 0, $hWndOwner = 0)
Local $vResult = __OFNDlg(0, $sTitle, $sInitalDir, $sFilter, $iFilterIndex, $sDefaultFile, $sDefaultExt, $iFlags, $iFlagsEx, 0, 0, $hWndOwner)
If @error Then Return SetError(@error, @extended, $vResult)
If BitAND($iFlags, $OFN_ALLOWMULTISELECT) Then
Return __WinAPI_ParseMultiSelectFileDialogPath($vResult)
Else
Return __WinAPI_ParseFileDialogPath($vResult)
EndIf
EndFunc
Func _WinAPI_GetSaveFileName($sTitle = "", $sFilter = "All files (*.*)", $sInitalDir = ".", $sDefaultFile = "", $sDefaultExt = "", $iFilterIndex = 1, $iFlags = 0, $iFlagsEx = 0, $hWndOwner = 0)
Local $vReturn = __OFNDlg(1, $sTitle, $sInitalDir, $sFilter, $iFilterIndex, $sDefaultFile, $sDefaultExt, $iFlags, $iFlagsEx, 0, 0, $hWndOwner)
If @error Then Return SetError(@error, @extended, $vReturn)
Return __WinAPI_ParseFileDialogPath($vReturn)
EndFunc
Func _WinAPI_MessageBoxCheck($iType, $sTitle, $sText, $sRegVal, $iDefault = -1, $hParent = 0)
Local $aCall = DllCall('shlwapi.dll', 'int', 'SHMessageBoxCheckW', 'hwnd', $hParent, 'wstr', $sText, 'wstr', $sTitle,  'uint', $iType, 'int', $iDefault, 'wstr', $sRegVal)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_MessageBoxIndirect($tMSGBOXPARAMS)
Local $aCall = DllCall('user32.dll', 'int', 'MessageBoxIndirectW', 'struct*', $tMSGBOXPARAMS)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_OpenFileDlg($sTitle = '', $sInitDir = '', $sFilters = '', $iDefaultFilter = 0, $sDefaultFilePath = '', $sDefaultExt = '', $iFlags = 0, $iFlagsEx = 0, $pOFNProc = 0, $pData = 0, $hParent = 0)
Local $vResult = __OFNDlg(0, $sTitle, $sInitDir, $sFilters, $iDefaultFilter, $sDefaultFilePath, $sDefaultExt, $iFlags, $iFlagsEx, $pOFNProc, $pData, $hParent)
If @error Then Return SetError(@error, @extended, $vResult)
Return $vResult
EndFunc
Func _WinAPI_PageSetupDlg(ByRef $tPAGESETUPDLG)
Local $aCall = DllCall('comdlg32.dll', 'int', 'PageSetupDlgW', 'struct*', $tPAGESETUPDLG)
If @error Then Return SetError(@error, @extended, 0)
If Not $aCall[0] Then Return SetError(10, _WinAPI_CommDlgExtendedErrorEx(), 0)
Return $aCall[0]
EndFunc
Func _WinAPI_PickIconDlg($sIcon = '', $iIndex = 0, $hParent = 0)
Local $aCall = DllCall('shell32.dll', 'int', 'PickIconDlg', 'hwnd', $hParent, 'wstr', $sIcon, 'int', 4096, 'int*', $iIndex)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aRet[2]
Local $aRes = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $aCall[2], "wstr", "", "dword", 4096)
$aRet[0] = $aRes[2]
$aRet[1] = $aCall[4]
Return $aRet
EndFunc
Func _WinAPI_PrintDlg(ByRef $tPRINTDLG)
Local $aCall = DllCall('comdlg32.dll', 'long', 'PrintDlgW', 'struct*', $tPRINTDLG)
If @error Then Return SetError(@error, @extended, 0)
If Not $aCall[0] Then Return SetError(10, _WinAPI_CommDlgExtendedErrorEx(), 0)
Return $aCall[0]
EndFunc
Func _WinAPI_PrintDlgEx(ByRef $tPRINTDLGEX)
Local $tPDEX = DllStructCreate($tagPRINTDLGEX, DllStructGetPtr($tPRINTDLGEX))
Local $aCall = DllCall('comdlg32.dll', 'long', 'PrintDlgExW', 'struct*', $tPDEX)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return SetExtended(DllStructGetData($tPDEX, 'ResultAction'), 1)
EndFunc
Func _WinAPI_ReplaceTextDlg($hOwner, $sFindWhat = '', $sReplaceWith = '', $iFlags = 0, $pReplaceProc = 0, $lParam = 0)
$__g_pFRBuffer = __HeapReAlloc($__g_pFRBuffer, 4 * $__g_iFRBufferSize)
If @error Then Return SetError(@error + 100, @extended, 0)
Local $tBuff = DllStructCreate('wchar[' & $__g_iFRBufferSize & '];wchar[' & $__g_iFRBufferSize & ']', $__g_pFRBuffer)
DllStructSetData($tBuff, 1, StringLeft($sFindWhat, $__g_iFRBufferSize - 1))
DllStructSetData($tBuff, 2, StringLeft($sReplaceWith, $__g_iFRBufferSize - 1))
Local $tFR = DllStructCreate($tagFINDREPLACE)
DllStructSetData($tFR, 'Size', DllStructGetSize($tFR))
DllStructSetData($tFR, 'hOwner', $hOwner)
DllStructSetData($tFR, 'hInstance', 0)
DllStructSetData($tFR, 'Flags', $iFlags)
DllStructSetData($tFR, 'FindWhat', DllStructGetPtr($tBuff, 1))
DllStructSetData($tFR, 'ReplaceWith', DllStructGetPtr($tBuff, 2))
DllStructSetData($tFR, 'FindWhatLen', $__g_iFRBufferSize * 2)
DllStructSetData($tFR, 'ReplaceWithLen', $__g_iFRBufferSize * 2)
DllStructSetData($tFR, 'lParam', $lParam)
DllStructSetData($tFR, 'Hook', $pReplaceProc)
DllStructSetData($tFR, 'TemplateName', 0)
Local $aCall = DllCall('comdlg32.dll', 'hwnd', 'ReplaceTextW', 'struct*', $tFR)
If @error Or Not $aCall[0] Then
Local $iError = @error
__HeapFree($__g_pFRBuffer)
If IsArray($aCall) Then
Return SetError(10, _WinAPI_CommDlgExtendedErrorEx(), 0)
Else
Return SetError($iError, 0, 0)
EndIf
EndIf
Return $aCall[0]
EndFunc
Func _WinAPI_RestartDlg($sText = '', $iFlags = 2, $hParent = 0)
Local $aCall = DllCall('shell32.dll', 'int', 'RestartDialog', 'hwnd', $hParent, 'wstr', $sText, 'int', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SaveFileDlg($sTitle = "", $sInitDir = "", $sFilters = "", $iDefaultFilter = 0, $sDefaultFilePath = "", $sDefaultExt = "", $iFlags = 0, $iFlagsEx = 0, $pOFNProc = 0, $pData = 0, $hParent = 0)
Local $vResult = __OFNDlg(1, $sTitle, $sInitDir, $sFilters, $iDefaultFilter, $sDefaultFilePath, $sDefaultExt, $iFlags, $iFlagsEx, $pOFNProc, $pData, $hParent)
If @error Then Return SetError(@error, @extended, $vResult)
Return $vResult
EndFunc
Func _WinAPI_SetFRBuffer($iChars)
$iChars = Number($iChars)
If $iChars < 80 Then
$iChars = 80
EndIf
$__g_iFRBufferSize = $iChars + 1
Return 1
EndFunc
Func _WinAPI_ShellAboutDlg($sTitle, $sName, $sText, $hIcon = 0, $hParent = 0)
Local $aCall = DllCall('shell32.dll', 'int', 'ShellAboutW', 'hwnd', $hParent, 'wstr', $sTitle & '#' & $sName, 'wstr', $sText,  'handle', $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ShellOpenWithDlg($sFilePath, $iFlags = 0, $hParent = 0)
Local $tOPENASINFO = DllStructCreate('ptr;ptr;dword;wchar[' & (StringLen($sFilePath) + 1) & ']')
DllStructSetData($tOPENASINFO, 1, DllStructGetPtr($tOPENASINFO, 4))
DllStructSetData($tOPENASINFO, 2, 0)
DllStructSetData($tOPENASINFO, 3, $iFlags)
DllStructSetData($tOPENASINFO, 4, $sFilePath)
Local $aCall = DllCall('shell32.dll', 'long', 'SHOpenWithDialog', 'hwnd', $hParent, 'struct*', $tOPENASINFO)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_ShellStartNetConnectionDlg($sRemote = '', $iFlags = 0, $hParent = 0)
If Not StringStripWS($sRemote, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sRemote = Null
DllCall('shell32.dll', 'long', 'SHStartNetConnectionDialogW', 'hwnd', $hParent, 'wstr', $sRemote, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_ShellUserAuthenticationDlg($sCaption, $sMessage, $sUser, $sPassword, $sTarget, $iFlags = 0, $iError = 0, $bSave = False, $hBitmap = 0, $hParent = 0)
If Not __DLL('credui.dll') Then Return SetError(103, 0, 0)
Local $tInfo = DllStructCreate('dword;hwnd;ptr;ptr;ptr;wchar[' & (StringLen($sMessage) + 1) & '];wchar[' & (StringLen($sCaption) + 1) & ']')
DllStructSetData($tInfo, 1, DllStructGetPtr($tInfo, 6) - DllStructGetPtr($tInfo))
DllStructSetData($tInfo, 2, $hParent)
DllStructSetData($tInfo, 3, DllStructGetPtr($tInfo, 6))
DllStructSetData($tInfo, 4, DllStructGetPtr($tInfo, 7))
DllStructSetData($tInfo, 5, $hBitmap)
DllStructSetData($tInfo, 6, $sMessage)
DllStructSetData($tInfo, 7, $sCaption)
Local $aCall = DllCall('credui.dll', 'dword', 'CredUIPromptForCredentialsW', 'struct*', $tInfo, 'wstr', $sTarget, 'ptr', 0,  'dword', $iError, 'wstr', $sUser, 'ulong', 4096, 'wstr', $sPassword, 'ulong', 4096, 'bool*', $bSave,  'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Local $aRet[3]
$aRet[0] = $aCall[5]
$aRet[1] = $aCall[7]
$aRet[2] = $aCall[9]
Return $aRet
EndFunc
Func _WinAPI_ShellUserAuthenticationDlgEx($sCaption, $sMessage, $sUser, $sPassword, $iFlags = 0, $iAuthError = 0, $bSave = False, $iPackage = 0, $hParent = 0)
If Not __DLL('credui.dll') Then Return SetError(103, 0, 0)
Local $tBLOB = 0, $aCall
If StringLen($sUser) Then
$aCall = DllCall('credui.dll', 'bool', 'CredPackAuthenticationBufferW', 'dword', 1, 'wstr', $sUser, 'wstr', $sPassword,  'ptr', 0, 'dword*', 0)
If @error Or Not $aCall[5] Then Return SetError(@error + 10, @extended, 0)
$tBLOB = DllStructCreate('byte[' & $aCall[5] & ']')
$aCall = DllCall('credui.dll', 'bool', 'CredPackAuthenticationBufferW', 'dword', 1, 'wstr', $sUser, 'wstr', $sPassword,  'struct*', $tBLOB, 'dword*', $aCall[5])
If @error Or Not $aCall[0] Then Return SetError(@error + 20, @extended, 0)
EndIf
Local $tInfo = DllStructCreate('dword;hwnd;ptr;ptr;ptr;wchar[' & (StringLen($sMessage) + 1) & '];wchar[' & (StringLen($sCaption) + 1) & ']')
DllStructSetData($tInfo, 1, DllStructGetPtr($tInfo, 6) - DllStructGetPtr($tInfo))
DllStructSetData($tInfo, 2, $hParent)
DllStructSetData($tInfo, 3, DllStructGetPtr($tInfo, 6))
DllStructSetData($tInfo, 4, DllStructGetPtr($tInfo, 7))
DllStructSetData($tInfo, 5, 0)
DllStructSetData($tInfo, 6, $sMessage)
DllStructSetData($tInfo, 7, $sCaption)
$aCall = DllCall('credui.dll', 'dword', 'CredUIPromptForWindowsCredentialsW', 'struct*', $tInfo, 'dword', $iAuthError,  'ulong*', $iPackage, 'struct*', $tBLOB, 'ulong', DllStructGetSize($tBLOB), 'ptr*', 0, 'ulong*', 0,  'bool*', $bSave, 'dword', $iFlags)
If @error Then Return SetError(@error + 30, @extended, 0)
If $aCall[0] Then Return SetError(30, $aCall[0], 0)
Local $aRet[4], $iError = 0
$aRet[2] = $aCall[8]
$aRet[3] = $aCall[3]
Local $pBLOB = $aCall[6]
Local $iSize = $aCall[7]
$aCall = DllCall('credui.dll', 'bool', 'CredUnPackAuthenticationBufferW', 'dword', 1, 'ptr', $pBLOB, 'dword', $iSize,  'wstr', '', 'dword*', 4096, 'wstr', '', 'dword*', 4096, 'wstr', '', 'dword*', 4096)
If Not @error And $aCall[0] Then
$aRet[0] = $aCall[4]
$aRet[1] = $aCall[8]
Else
$iError = @error + 40
EndIf
If Not _WinAPI_ZeroMemory($pBLOB, $iSize) Then
EndIf
_WinAPI_CoTaskMemFree($pBLOB)
If $iError Then Return SetError($iError, 0, 0)
Return $aRet
EndFunc
Func __OFNDlg($iDlg, $sTitle, $sInitDir, $sFilters, $iDefFilter, $sDefFile, $sDefExt, $iFlags, $iFlagsEx, $pOFNProc, $pData, $hParent)
Local $vError[1] = [0]
If BitAND($iFlags, $OFN_ALLOWMULTISELECT) = 0 Then $vError = ''
Local $tBuffer = DllStructCreate('wchar[32768]')
Local $tFilters = 0, $tDefExt = 0, $tInitDir = 0, $tTitle = 0
Local $tOFN = DllStructCreate($tagOPENFILENAME)
DllStructSetData($tOFN, "StructSize", DllStructGetSize($tOFN))
DllStructSetData($tOFN, "hwndOwner", $hParent)
DllStructSetData($tOFN, 3, 0)
Local $aData = StringSplit($sFilters, '|')
Local $aFilters[$aData[0] * 2]
Local $iCount = 0
For $i = 1 To $aData[0]
$aFilters[$iCount + 0] = StringStripWS($aData[$i], $STR_STRIPLEADING + $STR_STRIPTRAILING)
$aFilters[$iCount + 1] = StringStripWS(StringRegExpReplace($aData[$i], '.*\((.*)\)', '\1'), $STR_STRIPALL)
If $aFilters[$iCount + 1] Then
$iCount += 2
EndIf
Next
If $iCount Then
$tFilters = _WinAPI_ArrayToStruct($aFilters, 0, $iCount - 1)
If @error Then
EndIf
EndIf
DllStructSetData($tOFN, "lpstrFilter", DllStructGetPtr($tFilters))
DllStructSetData($tOFN, 5, 0)
DllStructSetData($tOFN, 6, 0)
DllStructSetData($tOFN, "nFilterIndex", $iDefFilter)
$sDefFile = StringStripWS($sDefFile, $STR_STRIPLEADING + $STR_STRIPTRAILING)
If $sDefFile Then
DllStructSetData($tBuffer, 1, $sDefFile)
EndIf
DllStructSetData($tOFN, "lpstrFile", DllStructGetPtr($tBuffer))
DllStructSetData($tOFN, "nMaxFile", 32768)
DllStructSetData($tOFN, 10, 0)
DllStructSetData($tOFN, 11, 0)
$sInitDir = StringStripWS($sInitDir, $STR_STRIPLEADING + $STR_STRIPTRAILING)
If $sInitDir Then
$tInitDir = DllStructCreate('wchar[' & (StringLen($sInitDir) + 1) & ']')
EndIf
DllStructSetData($tInitDir, 1, $sInitDir)
DllStructSetData($tOFN, "lpstrInitialDir", DllStructGetPtr($tInitDir))
$sTitle = StringStripWS($sTitle, $STR_STRIPLEADING + $STR_STRIPTRAILING)
If $sTitle Then
$tTitle = DllStructCreate('wchar[' & (StringLen($sTitle) + 1) & ']')
EndIf
DllStructSetData($tTitle, 1, $sTitle)
DllStructSetData($tOFN, "lpstrTitle", DllStructGetPtr($tTitle))
DllStructSetData($tOFN, "Flags", $iFlags)
DllStructSetData($tOFN, 15, 0)
DllStructSetData($tOFN, 16, 0)
$sDefExt = StringStripWS($sDefExt, $STR_STRIPLEADING + $STR_STRIPTRAILING)
If $sDefExt Then
$tDefExt = DllStructCreate('wchar[' & (StringLen($tDefExt) + 1) & ']')
EndIf
DllStructSetData($tDefExt, 1, StringReplace($sDefExt, '.', ''))
DllStructSetData($tOFN, "lpstrDefExt", DllStructGetPtr($tDefExt))
DllStructSetData($tOFN, "lCustData", $pData)
DllStructSetData($tOFN, "lpfnHook", $pOFNProc)
DllStructSetData($tOFN, 20, 0)
DllStructSetData($tOFN, 21, 0)
DllStructSetData($tOFN, 22, 0)
DllStructSetData($tOFN, "FlagsEx", $iFlagsEx)
Local $aCall
Switch $iDlg
Case 0
$aCall = DllCall('comdlg32.dll', 'bool', 'GetOpenFileNameW', 'struct*', $tOFN)
Case 1
$aCall = DllCall('comdlg32.dll', 'bool', 'GetSaveFileNameW', 'struct*', $tOFN)
Case Else
EndSwitch
If @error Or Not $aCall[0] Then Return SetError(@error + 10, _WinAPI_CommDlgExtendedErrorEx(), $vError)
If BitAND($iFlags, $OFN_ALLOWMULTISELECT) Then
If BitAND($iFlags, $OFN_EXPLORER) Then
$aData = _WinAPI_StructToArray($tBuffer)
If @error Then
Return SetError(11, 0, $vError)
EndIf
Else
$aData = StringSplit(DllStructGetData($tBuffer, 1), ' ')
EndIf
Switch $aData[0]
Case 0
Return SetError(12, 0, $vError)
Case 1
Case Else
Local $sPath = $aData[1]
For $i = 2 To $aData[0]
$aData[$i - 1] = _WinAPI_PathAppend($sPath, $aData[$i])
Next
ReDim $aData[$aData[0]]
$aData[0] -= 1
EndSwitch
Else
$aData = DllStructGetData($tBuffer, 1)
EndIf
$__g_vExt = $tOFN
Return $aData
EndFunc
Func __WinAPI_ParseMultiSelectFileDialogPath($aPath)
Local $aFiles[UBound($aPath) + 1]
$aFiles[0] = UBound($aPath)
$aFiles[1] = StringMid($aPath[1], 1, StringInStr($aPath[1], "\", $STR_NOCASESENSEBASIC, -1) - 1)
For $i = 1 To UBound($aPath) - 1
$aFiles[$i + 1] = StringMid($aPath[$i], StringInStr($aPath[$i], "\", $STR_NOCASESENSEBASIC, -1) + 1)
Next
Return $aFiles
EndFunc
Func __WinAPI_ParseFileDialogPath($sPath)
Local $aFiles[3]
$aFiles[0] = 2
$aFiles[1] = StringMid($sPath, 1, StringInStr($sPath, "\", $STR_NOCASESENSEBASIC, -1) - 1)
$aFiles[2] = StringMid($sPath, StringInStr($sPath, "\", $STR_NOCASESENSEBASIC, -1) + 1)
Return $aFiles
EndFunc
Global Const $BACKUP_ALTERNATE_DATA = 0x00000004
Global Const $BACKUP_DATA = 0x00000001
Global Const $BACKUP_EA_DATA = 0x00000002
Global Const $BACKUP_LINK = 0x00000005
Global Const $BACKUP_OBJECT_ID = 0x00000007
Global Const $BACKUP_PROPERTY_DATA = 0x00000006
Global Const $BACKUP_REPARSE_DATA = 0x00000008
Global Const $BACKUP_SECURITY_DATA = 0x00000003
Global Const $BACKUP_SPARSE_BLOCK = 0x00000009
Global Const $BACKUP_TXFS_DATA = 0x0000000A
Global Const $COPY_FILE_ALLOW_DECRYPTED_DESTINATION = 0x0008
Global Const $COPY_FILE_COPY_SYMLINK = 0x0800
Global Const $COPY_FILE_FAIL_IF_EXISTS = 0x0001
Global Const $COPY_FILE_NO_BUFFERING = 0x1000
Global Const $COPY_FILE_OPEN_SOURCE_FOR_WRITE = 0x0004
Global Const $COPY_FILE_RESTARTABLE = 0x0002
Global Const $MOVE_FILE_COPY_ALLOWED = 0x0002
Global Const $MOVE_FILE_CREATE_HARDLINK = 0x0010
Global Const $MOVE_FILE_DELAY_UNTIL_REBOOT = 0x0004
Global Const $MOVE_FILE_FAIL_IF_NOT_TRACKABLE = 0x0020
Global Const $MOVE_FILE_REPLACE_EXISTING = 0x0001
Global Const $MOVE_FILE_WRITE_THROUGH = 0x0008
Global Const $PROGRESS_CONTINUE = 0
Global Const $PROGRESS_CANCEL = 1
Global Const $PROGRESS_STOP = 2
Global Const $PROGRESS_QUIET = 3
Global Const $FILE_APPEND_DATA = 0x0004
Global Const $FILE_DELETE_CHILD = 0x0040
Global Const $FILE_EXECUTE = 0x0020
Global Const $FILE_READ_ATTRIBUTES = 0x0080
Global Const $FILE_READ_DATA = 0x0001
Global Const $FILE_READ_EA = 0x0008
Global Const $FILE_WRITE_ATTRIBUTES = 0x0100
Global Const $FILE_WRITE_DATA = 0x0002
Global Const $FILE_WRITE_EA = 0x0010
Global Const $FILE_ADD_FILE = $FILE_WRITE_DATA
Global Const $FILE_ADD_SUBDIRECTORY = $FILE_APPEND_DATA
Global Const $FILE_CREATE_PIPE_INSTANCE = $FILE_APPEND_DATA
Global Const $FILE_LIST_DIRECTORY = $FILE_READ_DATA
Global Const $FILE_TRAVERSE = $FILE_EXECUTE
Global Const $FILE_ALL_ACCESS = 0x001F01FF
Global Const $FILE_FLAG_BACKUP_SEMANTICS = 0x02000000
Global Const $FILE_FLAG_DELETE_ON_CLOSE = 0x04000000
Global Const $FILE_FLAG_NO_BUFFERING = 0x20000000
Global Const $FILE_FLAG_OPEN_NO_RECALL = 0x00100000
Global Const $FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000
Global Const $FILE_FLAG_OVERLAPPED = 0x40000000
Global Const $FILE_FLAG_POSIX_SEMANTICS = 0x0100000
Global Const $FILE_FLAG_RANDOM_ACCESS = 0x10000000
Global Const $FILE_FLAG_SEQUENTIAL_SCAN = 0x08000000
Global Const $FILE_FLAG_WRITE_THROUGH = 0x80000000
Global Const $SECURITY_ANONYMOUS = 0x00000000
Global Const $SECURITY_CONTEXT_TRACKING = 0x00040000
Global Const $SECURITY_DELEGATION = 0x00030000
Global Const $SECURITY_EFFECTIVE_ONLY = 0x00080000
Global Const $SECURITY_IDENTIFICATION = 0x00010000
Global Const $SECURITY_IMPERSONATION = 0x00020000
Global Const $SEC_COMMIT = 0x08000000
Global Const $SEC_IMAGE = 0x01000000
Global Const $SEC_LARGE_PAGES = 0x80000000
Global Const $SEC_NOCACHE = 0x10000000
Global Const $SEC_RESERVE = 0x04000000
Global Const $SEC_WRITECOMBINE = 0x40000000
Global Const $SECTION_EXTEND_SIZE = 0x0010
Global Const $SECTION_MAP_EXECUTE = 0x0008
Global Const $SECTION_MAP_READ = 0x0004
Global Const $SECTION_MAP_WRITE = 0x0002
Global Const $SECTION_QUERY = 0x0001
Global Const $SECTION_ALL_ACCESS = 0x001F001F
Global Const $FILE_MAP_COPY = 0x0001
Global Const $FILE_MAP_EXECUTE = 0x0020
Global Const $FILE_MAP_READ = 0x0004
Global Const $FILE_MAP_WRITE = 0x0002
Global Const $FILE_MAP_ALL_ACCESS = $SECTION_ALL_ACCESS
Global Const $DDD_EXACT_MATCH_ON_REMOVE = 0x04
Global Const $DDD_NO_BROADCAST_SYSTEM = 0x08
Global Const $DDD_RAW_TARGET_PATH = 0x01
Global Const $DDD_REMOVE_DEFINITION = 0x02
Global Const $FSCTL_ALLOW_EXTENDED_DASD_IO = 0x00090083
Global Const $FSCTL_CREATE_OR_GET_OBJECT_ID = 0x000900C0
Global Const $FSCTL_CREATE_USN_JOURNAL = 0x000900E7
Global Const $FSCTL_DELETE_OBJECT_ID = 0x000900A0
Global Const $FSCTL_DELETE_REPARSE_POINT = 0x000900AC
Global Const $FSCTL_DELETE_USN_JOURNAL = 0x000900F8
Global Const $FSCTL_DISMOUNT_VOLUME = 0x00090020
Global Const $FSCTL_DUMP_PROPERTY_DATA = 0x00090097
Global Const $FSCTL_ENABLE_UPGRADE = 0x000980D0
Global Const $FSCTL_ENCRYPTION_FSCTL_IO = 0x000900DB
Global Const $FSCTL_ENUM_USN_DATA = 0x000900B3
Global Const $FSCTL_EXTEND_VOLUME = 0x000900F0
Global Const $FSCTL_FILESYSTEM_GET_STATISTICS = 0x00090060
Global Const $FSCTL_FIND_FILES_BY_SID = 0x0009008F
Global Const $FSCTL_GET_COMPRESSION = 0x0009003C
Global Const $FSCTL_GET_NTFS_FILE_RECORD = 0x00090068
Global Const $FSCTL_GET_NTFS_VOLUME_DATA = 0x00090064
Global Const $FSCTL_GET_OBJECT_ID = 0x0009009C
Global Const $FSCTL_GET_REPARSE_POINT = 0x000900A8
Global Const $FSCTL_GET_RETRIEVAL_POINTERS = 0x00090073
Global Const $FSCTL_GET_VOLUME_BITMAP = 0x0009006F
Global Const $FSCTL_HSM_DATA = 0x0009C113
Global Const $FSCTL_HSM_MSG = 0x0009C108
Global Const $FSCTL_INVALIDATE_VOLUMES = 0x00090054
Global Const $FSCTL_IS_PATHNAME_VALID = 0x0009002C
Global Const $FSCTL_IS_VOLUME_DIRTY = 0x00090078
Global Const $FSCTL_IS_VOLUME_MOUNTED = 0x00090028
Global Const $FSCTL_LOCK_VOLUME = 0x00090018
Global Const $FSCTL_MARK_AS_SYSTEM_HIVE = 0x0009004F
Global Const $FSCTL_MARK_HANDLE = 0x000900FC
Global Const $FSCTL_MARK_VOLUME_DIRTY = 0x00090030
Global Const $FSCTL_MOVE_FILE = 0x00090074
Global Const $FSCTL_OPBATCH_ACK_CLOSE_PENDING = 0x00090010
Global Const $FSCTL_OPLOCK_BREAK_ACK_NO_2 = 0x00090050
Global Const $FSCTL_OPLOCK_BREAK_ACKNOWLEDGE = 0x0009000C
Global Const $FSCTL_OPLOCK_BREAK_NOTIFY = 0x00090014
Global Const $FSCTL_QUERY_ALLOCATED_RANGES = 0x000940CF
Global Const $FSCTL_QUERY_FAT_BPB = 0x00090058
Global Const $FSCTL_QUERY_RETRIEVAL_POINTERS = 0x0009003B
Global Const $FSCTL_QUERY_USN_JOURNAL = 0x000900F4
Global Const $FSCTL_READ_FILE_USN_DATA = 0x000900EB
Global Const $FSCTL_READ_PROPERTY_DATA = 0x00090087
Global Const $FSCTL_READ_RAW_ENCRYPTED = 0x000900E3
Global Const $FSCTL_READ_USN_JOURNAL = 0x000900BB
Global Const $FSCTL_RECALL_FILE = 0x00090117
Global Const $FSCTL_REQUEST_BATCH_OPLOCK = 0x00090008
Global Const $FSCTL_REQUEST_FILTER_OPLOCK = 0x0009005C
Global Const $FSCTL_REQUEST_OPLOCK_LEVEL_1 = 0x00090000
Global Const $FSCTL_REQUEST_OPLOCK_LEVEL_2 = 0x00090004
Global Const $FSCTL_SECURITY_ID_CHECK = 0x000940B7
Global Const $FSCTL_SET_COMPRESSION = 0x0009C040
Global Const $FSCTL_SET_ENCRYPTION = 0x000900D7
Global Const $FSCTL_SET_OBJECT_ID = 0x00090098
Global Const $FSCTL_SET_OBJECT_ID_EXTENDED = 0x000900BC
Global Const $FSCTL_SET_REPARSE_POINT = 0x000900A4
Global Const $FSCTL_SET_SPARSE = 0x000900C4
Global Const $FSCTL_SET_ZERO_DATA = 0x000980C8
Global Const $FSCTL_SIS_COPYFILE = 0x00090100
Global Const $FSCTL_SIS_LINK_FILES = 0x0009C104
Global Const $FSCTL_UNLOCK_VOLUME = 0x0009001C
Global Const $FSCTL_WRITE_PROPERTY_DATA = 0x0009008B
Global Const $FSCTL_WRITE_RAW_ENCRYPTED = 0x000900DF
Global Const $FSCTL_WRITE_USN_CLOSE_RECORD = 0x000900EF
Global Const $IOCTL_AACS_END_SESSION = 0x003350CC
Global Const $IOCTL_AACS_GENERATE_BINDING_NONCE = 0x0033D0F0
Global Const $IOCTL_AACS_GET_CERTIFICATE = 0x003350D4
Global Const $IOCTL_AACS_GET_CHALLENGE_KEY = 0x003350D8
Global Const $IOCTL_AACS_READ_BINDING_NONCE = 0x003350EC
Global Const $IOCTL_AACS_READ_MEDIA_ID = 0x003350E8
Global Const $IOCTL_AACS_READ_MEDIA_KEY_BLOCK = 0x003350C4
Global Const $IOCTL_AACS_READ_MEDIA_KEY_BLOCK_SIZE = 0x003350C0
Global Const $IOCTL_AACS_READ_SERIAL_NUMBER = 0x003350E4
Global Const $IOCTL_AACS_READ_VOLUME_ID = 0x003350E0
Global Const $IOCTL_AACS_SEND_CERTIFICATE = 0x003350D0
Global Const $IOCTL_AACS_SEND_CHALLENGE_KEY = 0x003350DC
Global Const $IOCTL_AACS_START_SESSION = 0x003350C8
Global Const $IOCTL_ATA_PASS_THROUGH = 0x0004D02C
Global Const $IOCTL_ATA_PASS_THROUGH_DIRECT = 0x0004D030
Global Const $IOCTL_CDROM_CHECK_VERIFY = 0x00024800
Global Const $IOCTL_CDROM_DISK_TYPE = 0x00020040
Global Const $IOCTL_CDROM_EJECT_MEDIA = 0x00024808
Global Const $IOCTL_CDROM_FIND_NEW_DEVICES = 0x00024818
Global Const $IOCTL_CDROM_GET_CONFIGURATION = 0x00024058
Global Const $IOCTL_CDROM_GET_CONTROL = 0x00024034
Global Const $IOCTL_CDROM_GET_DRIVE_GEOMETRY = 0x0002404C
Global Const $IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX = 0x00024050
Global Const $IOCTL_CDROM_GET_LAST_SESSION = 0x00024038
Global Const $IOCTL_CDROM_GET_VOLUME = 0x00024014
Global Const $IOCTL_CDROM_LOAD_MEDIA = 0x0002480C
Global Const $IOCTL_CDROM_MEDIA_REMOVAL = 0x00024804
Global Const $IOCTL_CDROM_PAUSE_AUDIO = 0x0002400C
Global Const $IOCTL_CDROM_PLAY_AUDIO_MSF = 0x00024018
Global Const $IOCTL_CDROM_RAW_READ = 0x0002403E
Global Const $IOCTL_CDROM_READ_Q_CHANNEL = 0x0002402C
Global Const $IOCTL_CDROM_READ_TOC = 0x00024000
Global Const $IOCTL_CDROM_READ_TOC_EX = 0x00024054
Global Const $IOCTL_CDROM_RELEASE = 0x00024814
Global Const $IOCTL_CDROM_RESERVE = 0x00024810
Global Const $IOCTL_CDROM_RESUME_AUDIO = 0x00024010
Global Const $IOCTL_CDROM_SEEK_AUDIO_MSF = 0x00024004
Global Const $IOCTL_CDROM_SET_VOLUME = 0x00024028
Global Const $IOCTL_CDROM_STOP_AUDIO = 0x00024008
Global Const $IOCTL_CDROM_UNLOAD_DRIVER = 0x00025008
Global Const $IOCTL_DISK_CHECK_VERIFY = 0x00074800
Global Const $IOCTL_DISK_CONTROLLER_NUMBER = 0x00070044
Global Const $IOCTL_DISK_CREATE_DISK = 0x0007C058
Global Const $IOCTL_DISK_DELETE_DRIVE_LAYOUT = 0x0007C100
Global Const $IOCTL_DISK_EJECT_MEDIA = 0x00074808
Global Const $IOCTL_DISK_FIND_NEW_DEVICES = 0x00074818
Global Const $IOCTL_DISK_FORMAT_TRACKS = 0x0007C018
Global Const $IOCTL_DISK_FORMAT_TRACKS_EX = 0x0007C02C
Global Const $IOCTL_DISK_GET_CACHE_INFORMATION = 0x000740D4
Global Const $IOCTL_DISK_GET_DRIVE_GEOMETRY = 0x00070000
Global Const $IOCTL_DISK_GET_DRIVE_GEOMETRY_EX = 0x000700A0
Global Const $IOCTL_DISK_GET_DRIVE_LAYOUT = 0x0007400C
Global Const $IOCTL_DISK_GET_DRIVE_LAYOUT_EX = 0x00070050
Global Const $IOCTL_DISK_GET_LENGTH_INFO = 0x0007405C
Global Const $IOCTL_DISK_GET_MEDIA_TYPES = 0x00070C00
Global Const $IOCTL_DISK_GET_PARTITION_INFO = 0x00074004
Global Const $IOCTL_DISK_GET_PARTITION_INFO_EX = 0x00070048
Global Const $IOCTL_DISK_GET_WRITE_CACHE_STATE = 0x000740DC
Global Const $IOCTL_DISK_GROW_PARTITION = 0x0007C0D0
Global Const $IOCTL_DISK_HISTOGRAM_DATA = 0x00070034
Global Const $IOCTL_DISK_HISTOGRAM_RESET = 0x00070038
Global Const $IOCTL_DISK_HISTOGRAM_STRUCTURE = 0x00070030
Global Const $IOCTL_DISK_INTERNAL_CLEAR_VERIFY = 0x00070407
Global Const $IOCTL_DISK_INTERNAL_SET_NOTIFY = 0x00070408
Global Const $IOCTL_DISK_INTERNAL_SET_VERIFY = 0x00070403
Global Const $IOCTL_DISK_IS_WRITABLE = 0x00070024
Global Const $IOCTL_DISK_LOAD_MEDIA = 0x0007480C
Global Const $IOCTL_DISK_LOGGING = 0x00070028
Global Const $IOCTL_DISK_MEDIA_REMOVAL = 0x00074804
Global Const $IOCTL_DISK_PERFORMANCE = 0x00070020
Global Const $IOCTL_DISK_PERFORMANCE_OFF = 0x00070060
Global Const $IOCTL_DISK_REASSIGN_BLOCKS = 0x0007C01C
Global Const $IOCTL_DISK_RELEASE = 0x00074814
Global Const $IOCTL_DISK_REQUEST_DATA = 0x00070040
Global Const $IOCTL_DISK_REQUEST_STRUCTURE = 0x0007003C
Global Const $IOCTL_DISK_RESERVE = 0x00074810
Global Const $IOCTL_DISK_SET_CACHE_INFORMATION = 0x0007C0D8
Global Const $IOCTL_DISK_SET_DRIVE_LAYOUT = 0x0007C010
Global Const $IOCTL_DISK_SET_DRIVE_LAYOUT_EX = 0x0007C054
Global Const $IOCTL_DISK_SET_PARTITION_INFO = 0x0007C008
Global Const $IOCTL_DISK_SET_PARTITION_INFO_EX = 0x0007C04C
Global Const $IOCTL_DISK_UPDATE_DRIVE_SIZE = 0x0007C0C8
Global Const $IOCTL_DISK_UPDATE_PROPERTIES = 0x00070140
Global Const $IOCTL_DISK_VERIFY = 0x00070014
Global Const $IOCTL_DVD_END_SESSION = 0x0033500C
Global Const $IOCTL_DVD_GET_REGION = 0x00335014
Global Const $IOCTL_DVD_READ_KEY = 0x00335004
Global Const $IOCTL_DVD_READ_STRUCTURE = 0x00335140
Global Const $IOCTL_DVD_SEND_KEY = 0x00335008
Global Const $IOCTL_DVD_SEND_KEY2 = 0x0033D018
Global Const $IOCTL_DVD_SET_READ_AHEAD = 0x00335010
Global Const $IOCTL_DVD_START_SESSION = 0x00335000
Global Const $IOCTL_MOUNTDEV_LINK_CREATED = 0x004D0010
Global Const $IOCTL_MOUNTDEV_LINK_DELETED = 0x004D0014
Global Const $IOCTL_MOUNTDEV_QUERY_STABLE_GUID = 0x004D0018
Global Const $IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME = 0x004D000C
Global Const $IOCTL_MOUNTDEV_QUERY_UNIQUE_ID = 0x004D0000
Global Const $IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY = 0x004D0004
Global Const $IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS = 0x006DC014
Global Const $IOCTL_MOUNTMGR_CHANGE_NOTIFY = 0x006D4020
Global Const $IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES = 0x006D4028
Global Const $IOCTL_MOUNTMGR_CREATE_POINT = 0x006DC000
Global Const $IOCTL_MOUNTMGR_DELETE_POINTS = 0x006DC004
Global Const $IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY = 0x006DC00C
Global Const $IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE = 0x006DC024
Global Const $IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER = 0x006DC010
Global Const $IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH = 0x006D0030
Global Const $IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS = 0x006D0034
Global Const $IOCTL_MOUNTMGR_QUERY_POINTS = 0x006D0008
Global Const $IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION = 0x006D402C
Global Const $IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED = 0x006DC018
Global Const $IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED = 0x006DC01C
Global Const $IOCTL_SCSI_GET_INQUIRY_DATA = 0x0004100C
Global Const $IOCTL_SCSI_GET_CAPABILITIES = 0x00041010
Global Const $IOCTL_SCSI_GET_ADDRESS = 0x00041018
Global Const $IOCTL_SCSI_MINIPORT = 0x0004D008
Global Const $IOCTL_SCSI_PASS_THROUGH = 0x0004D004
Global Const $IOCTL_SCSI_PASS_THROUGH_DIRECT = 0x0004D014
Global Const $IOCTL_SCSI_RESCAN_BUS = 0x0004101C
Global Const $IOCTL_STORAGE_BREAK_RESERVATION = 0x002D5014
Global Const $IOCTL_STORAGE_CHECK_VERIFY = 0x002D4800
Global Const $IOCTL_STORAGE_CHECK_VERIFY2 = 0x002D0800
Global Const $IOCTL_STORAGE_EJECT_MEDIA = 0x002D4808
Global Const $IOCTL_STORAGE_EJECTION_CONTROL = 0x002D0940
Global Const $IOCTL_STORAGE_FIND_NEW_DEVICES = 0x002D4818
Global Const $IOCTL_STORAGE_GET_DEVICE_NUMBER = 0x002D1080
Global Const $IOCTL_STORAGE_GET_HOTPLUG_INFO = 0x002D0C14
Global Const $IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER = 0x002D0C10
Global Const $IOCTL_STORAGE_GET_MEDIA_TYPES = 0x002D0C00
Global Const $IOCTL_STORAGE_GET_MEDIA_TYPES_EX = 0x002D0C04
Global Const $IOCTL_STORAGE_LOAD_MEDIA = 0x002D480C
Global Const $IOCTL_STORAGE_LOAD_MEDIA2 = 0x002D080C
Global Const $IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES = 0x002D9404
Global Const $IOCTL_STORAGE_MCN_CONTROL = 0x002D0944
Global Const $IOCTL_STORAGE_MEDIA_REMOVAL = 0x002D4804
Global Const $IOCTL_STORAGE_PERSISTENT_RESERVE_IN = 0x002D5018
Global Const $IOCTL_STORAGE_PERSISTENT_RESERVE_OUT = 0x002D501C
Global Const $IOCTL_STORAGE_PREDICT_FAILURE = 0x002D1100
Global Const $IOCTL_STORAGE_QUERY_PROPERTY = 0x002D1400
Global Const $IOCTL_STORAGE_RELEASE = 0x002D4814
Global Const $IOCTL_STORAGE_RESERVE = 0x002D4810
Global Const $IOCTL_STORAGE_RESET_BUS = 0x002D5000
Global Const $IOCTL_STORAGE_RESET_DEVICE = 0x002D5004
Global Const $IOCTL_STORAGE_SET_HOTPLUG_INFO = 0x002DCC18
Global Const $IOCTL_STORAGE_SET_READ_AHEAD = 0x002D4400
Global Const $IOCTL_VOLUME_GET_GPT_ATTRIBUTES = 0x00560038
Global Const $IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS = 0x00560000
Global Const $IOCTL_VOLUME_IS_CLUSTERED = 0x00560030
Global Const $IOCTL_VOLUME_IS_IO_CAPABLE = 0x00560014
Global Const $IOCTL_VOLUME_IS_OFFLINE = 0x00560010
Global Const $IOCTL_VOLUME_IS_PARTITION = 0x00560028
Global Const $IOCTL_VOLUME_LOGICAL_TO_PHYSICAL = 0x00560020
Global Const $IOCTL_VOLUME_OFFLINE = 0x0056C00C
Global Const $IOCTL_VOLUME_ONLINE = 0x0056C008
Global Const $IOCTL_VOLUME_PHYSICAL_TO_LOGICAL = 0x00560024
Global Const $IOCTL_VOLUME_QUERY_FAILOVER_SET = 0x00560018
Global Const $IOCTL_VOLUME_QUERY_VOLUME_NUMBER = 0x0056001C
Global Const $IOCTL_VOLUME_READ_PLEX = 0x0056402E
Global Const $IOCTL_VOLUME_SET_GPT_ATTRIBUTES = 0x00560034
Global Const $IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE = 0x00560004
Global Const $SMART_GET_VERSION = 0x00074080
Global Const $SMART_RCV_DRIVE_DATA = 0x0007C088
Global Const $SMART_SEND_DRIVE_COMMAND = 0x0007C084
Global Const $FILE_ENCRYPTABLE = 0
Global Const $FILE_IS_ENCRYPTED = 1
Global Const $FILE_READ_ONLY = 8
Global Const $FILE_ROOT_DIR = 3
Global Const $FILE_SYSTEM_ATTR = 2
Global Const $FILE_SYSTEM_DIR = 4
Global Const $FILE_SYSTEM_NOT_SUPPORT = 6
Global Const $FILE_UNKNOWN = 5
Global Const $FILE_USER_DISALLOWED = 7
Global Const $SCS_32BIT_BINARY = 0
Global Const $SCS_64BIT_BINARY = 6
Global Const $SCS_DOS_BINARY = 1
Global Const $SCS_OS216_BINARY = 5
Global Const $SCS_PIF_BINARY = 3
Global Const $SCS_POSIX_BINARY = 4
Global Const $SCS_WOW_BINARY = 2
Global Const $DRIVE_BUS_TYPE_UNKNOWN = 0x00
Global Const $DRIVE_BUS_TYPE_SCSI = 0x01
Global Const $DRIVE_BUS_TYPE_ATAPI = 0x02
Global Const $DRIVE_BUS_TYPE_ATA = 0x03
Global Const $DRIVE_BUS_TYPE_1394 = 0x04
Global Const $DRIVE_BUS_TYPE_SSA = 0x05
Global Const $DRIVE_BUS_TYPE_FIBRE = 0x06
Global Const $DRIVE_BUS_TYPE_USB = 0x07
Global Const $DRIVE_BUS_TYPE_RAID = 0x08
Global Const $DRIVE_BUS_TYPE_ISCSI = 0x09
Global Const $DRIVE_BUS_TYPE_SAS = 0x0A
Global Const $DRIVE_BUS_TYPE_SATA = 0x0B
Global Const $DRIVE_BUS_TYPE_SD = 0x0C
Global Const $DRIVE_BUS_TYPE_MMC = 0x0D
Global Const $DRIVE_UNKNOWN = 0
Global Const $DRIVE_NO_ROOT_DIR = 1
Global Const $DRIVE_REMOVABLE = 2
Global Const $DRIVE_FIXED = 3
Global Const $DRIVE_REMOTE = 4
Global Const $DRIVE_CDROM = 5
Global Const $DRIVE_RAMDISK = 6
Global Const $FILE_TYPE_CHAR = 0x0002
Global Const $FILE_TYPE_DISK = 0x0001
Global Const $FILE_TYPE_PIPE = 0x0003
Global Const $FILE_TYPE_REMOTE = 0x8000
Global Const $FILE_TYPE_UNKNOWN = 0x0000
Global Const $FILE_NAME_NORMALIZED = 0x0
Global Const $FILE_NAME_OPENED = 0x8
Global Const $VOLUME_NAME_DOS = 0x0
Global Const $VOLUME_NAME_GUID = 0x1
Global Const $VOLUME_NAME_NONE = 0x4
Global Const $VOLUME_NAME_NT = 0x2
Global Const $IMAGE_FILE_MACHINE_UNKNOWN = 0x0000
Global Const $IMAGE_FILE_MACHINE_AM33 = 0x01D3
Global Const $IMAGE_FILE_MACHINE_AMD64 = 0x8664
Global Const $IMAGE_FILE_MACHINE_ARM = 0x01C0
Global Const $IMAGE_FILE_MACHINE_EBC = 0x0EBC
Global Const $IMAGE_FILE_MACHINE_I386 = 0x014C
Global Const $IMAGE_FILE_MACHINE_IA64 = 0x0200
Global Const $IMAGE_FILE_MACHINE_M32R = 0x9041
Global Const $IMAGE_FILE_MACHINE_MIPS16 = 0x0266
Global Const $IMAGE_FILE_MACHINE_MIPSFPU = 0x0366
Global Const $IMAGE_FILE_MACHINE_MIPSFPU16 = 0x0466
Global Const $IMAGE_FILE_MACHINE_POWERPC = 0x01F0
Global Const $IMAGE_FILE_MACHINE_POWERPCFP = 0x01F1
Global Const $IMAGE_FILE_MACHINE_R4000 = 0x0166
Global Const $IMAGE_FILE_MACHINE_SH3 = 0x01A2
Global Const $IMAGE_FILE_MACHINE_SH3DSP = 0x01A3
Global Const $IMAGE_FILE_MACHINE_SH4 = 0x01A6
Global Const $IMAGE_FILE_MACHINE_SH5 = 0x01A8
Global Const $IMAGE_FILE_MACHINE_THUMB = 0x01C2
Global Const $IMAGE_FILE_MACHINE_WCEMIPSV2 = 0x0169
Global Const $FILE_CASE_PRESERVED_NAMES = 0x00000002
Global Const $FILE_CASE_SENSITIVE_SEARCH = 0x00000001
Global Const $FILE_FILE_COMPRESSION = 0x00000010
Global Const $FILE_NAMED_STREAMS = 0x00040000
Global Const $FILE_PERSISTENT_ACLS = 0x00000008
Global Const $FILE_READ_ONLY_VOLUME = 0x00080000
Global Const $FILE_SEQUENTIAL_WRITE_ONCE = 0x00100000
Global Const $FILE_SUPPORTS_ENCRYPTION = 0x00020000
Global Const $FILE_SUPPORTS_EXTENDED_ATTRIBUTES = 0x00800000
Global Const $FILE_SUPPORTS_HARD_LINKS = 0x00400000
Global Const $FILE_SUPPORTS_OBJECT_IDS = 0x00010000
Global Const $FILE_SUPPORTS_OPEN_BY_FILE_ID = 0x01000000
Global Const $FILE_SUPPORTS_REPARSE_POINTS = 0x00000080
Global Const $FILE_SUPPORTS_SPARSE_FILES = 0x00000040
Global Const $FILE_SUPPORTS_TRANSACTIONS = 0x00200000
Global Const $FILE_SUPPORTS_USN_JOURNAL = 0x02000000
Global Const $FILE_UNICODE_ON_DISK = 0x00000004
Global Const $FILE_VOLUME_IS_COMPRESSED = 0x00008000
Global Const $FILE_VOLUME_QUOTAS = 0x00000020
Global Const $FILE_DEVICE_8042_PORT = 0x0027
Global Const $FILE_DEVICE_ACPI = 0x0032
Global Const $FILE_DEVICE_BATTERY = 0x0029
Global Const $FILE_DEVICE_BEEP = 0x0001
Global Const $FILE_DEVICE_BUS_EXTENDER = 0x002A
Global Const $FILE_DEVICE_CD_ROM = 0x0002
Global Const $FILE_DEVICE_CD_ROM_FILE_SYSTEM = 0x0003
Global Const $FILE_DEVICE_CHANGER = 0x0030
Global Const $FILE_DEVICE_CONTROLLER = 0x0004
Global Const $FILE_DEVICE_DATALINK = 0x0005
Global Const $FILE_DEVICE_DFS = 0x0006
Global Const $FILE_DEVICE_DFS_FILE_SYSTEM = 0x0035
Global Const $FILE_DEVICE_DFS_VOLUME = 0x0036
Global Const $FILE_DEVICE_DISK = 0x0007
Global Const $FILE_DEVICE_DISK_FILE_SYSTEM = 0x0008
Global Const $FILE_DEVICE_DVD = 0x0033
Global Const $FILE_DEVICE_FILE_SYSTEM = 0x0009
Global Const $FILE_DEVICE_FIPS = 0x003A
Global Const $FILE_DEVICE_FULLSCREEN_VIDEO = 0x0034
Global Const $FILE_DEVICE_INPORT_PORT = 0x000A
Global Const $FILE_DEVICE_KEYBOARD = 0x000B
Global Const $FILE_DEVICE_KS = 0x002F
Global Const $FILE_DEVICE_KSEC = 0x0039
Global Const $FILE_DEVICE_MAILSLOT = 0x000C
Global Const $FILE_DEVICE_MASS_STORAGE = 0x002D
Global Const $FILE_DEVICE_MIDI_IN = 0x000D
Global Const $FILE_DEVICE_MIDI_OUT = 0x000E
Global Const $FILE_DEVICE_MODEM = 0x002B
Global Const $FILE_DEVICE_MOUSE = 0x000F
Global Const $FILE_DEVICE_MULTI_UNC_PROVIDER = 0x0010
Global Const $FILE_DEVICE_NAMED_PIPE = 0x0011
Global Const $FILE_DEVICE_NETWORK = 0x0012
Global Const $FILE_DEVICE_NETWORK_BROWSER = 0x0013
Global Const $FILE_DEVICE_NETWORK_FILE_SYSTEM = 0x0014
Global Const $FILE_DEVICE_NETWORK_REDIRECTOR = 0x0028
Global Const $FILE_DEVICE_NULL = 0x0015
Global Const $FILE_DEVICE_PARALLEL_PORT = 0x0016
Global Const $FILE_DEVICE_PHYSICAL_NETCARD = 0x0017
Global Const $FILE_DEVICE_PRINTER = 0x0018
Global Const $FILE_DEVICE_SCANNER = 0x0019
Global Const $FILE_DEVICE_SCREEN = 0x001C
Global Const $FILE_DEVICE_SERENUM = 0x0037
Global Const $FILE_DEVICE_SERIAL_MOUSE_PORT = 0x001A
Global Const $FILE_DEVICE_SERIAL_PORT = 0x001B
Global Const $FILE_DEVICE_SMARTCARD = 0x0031
Global Const $FILE_DEVICE_SMB = 0x002E
Global Const $FILE_DEVICE_SOUND = 0x001D
Global Const $FILE_DEVICE_STREAMS = 0x001E
Global Const $FILE_DEVICE_TAPE = 0x001F
Global Const $FILE_DEVICE_TAPE_FILE_SYSTEM = 0x0020
Global Const $FILE_DEVICE_TERMSRV = 0x0038
Global Const $FILE_DEVICE_TRANSPORT = 0x0021
Global Const $FILE_DEVICE_UNKNOWN = 0x0022
Global Const $FILE_DEVICE_VDM = 0x002C
Global Const $FILE_DEVICE_VIDEO = 0x0023
Global Const $FILE_DEVICE_VIRTUAL_DISK = 0x0024
Global Const $FILE_DEVICE_WAVE_IN = 0x0025
Global Const $FILE_DEVICE_WAVE_OUT = 0x0026
Global Const $FILE_ANY_ACCESS = 0x00
Global Const $FILE_SPECIAL_ACCESS = $FILE_ANY_ACCESS
Global Const $FILE_READ_ACCESS = 0x01
Global Const $FILE_WRITE_ACCESS = 0x02
Global Const $METHOD_BUFFERED = 0
Global Const $METHOD_IN_DIRECT = 1
Global Const $METHOD_OUT_DIRECT = 2
Global Const $METHOD_NEITHER = 3
Global Const $FILE_NOTIFY_CHANGE_FILE_NAME = 0x0001
Global Const $FILE_NOTIFY_CHANGE_DIR_NAME = 0x0002
Global Const $FILE_NOTIFY_CHANGE_ATTRIBUTES = 0x0004
Global Const $FILE_NOTIFY_CHANGE_SIZE = 0x0008
Global Const $FILE_NOTIFY_CHANGE_LAST_WRITE = 0x0010
Global Const $FILE_NOTIFY_CHANGE_LAST_ACCESS = 0x0020
Global Const $FILE_NOTIFY_CHANGE_CREATION = 0x0040
Global Const $FILE_NOTIFY_CHANGE_SECURITY = 0x0100
Global Const $FILE_ACTION_ADDED = 0x0001
Global Const $FILE_ACTION_REMOVED = 0x0002
Global Const $FILE_ACTION_MODIFIED = 0x0003
Global Const $FILE_ACTION_RENAMED_OLD_NAME = 0x0004
Global Const $FILE_ACTION_RENAMED_NEW_NAME = 0x0005
Global Const $REPLACEFILE_WRITE_THROUGH = 0x01
Global Const $REPLACEFILE_IGNORE_MERGE_ERRORS = 0x02
Global Const $REPLACEFILE_IGNORE_ACL_ERRORS = 0x04
Global Const $BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE = 0x00000001
Global Const $BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE = 0x00010000
Global Const $BASE_SEARCH_PATH_PERMANENT = 0x00008000
Global $__g_iHeapSize = 8388608
Global Const $tagFILEINFO = 'uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;uint64 ChangeTime;dword Attributes'
Global Const $tagFILE_ID_DESCRIPTOR = 'dword Size;uint Type;' & $tagGUID
Global Const $tagWIN32_FIND_STREAM_DATA = 'int64 StreamSize;wchar StreamName[296]'
Global Const $tagWIN32_STREAM_ID = 'dword StreamId;dword StreamAttributes;int64 Size;dword StreamNameSize;wchar StreamName[1]'
Func _WinAPI_BackupRead($hFile, $pBuffer, $iLength, ByRef $iBytes, ByRef $pContext, $bSecurity = False)
$iBytes = 0
Local $aCall = DllCall('kernel32.dll', 'bool', 'BackupRead', 'handle', $hFile, 'struct*', $pBuffer, 'dword', $iLength,  'dword*', 0, 'bool', 0, 'bool', $bSecurity, 'ptr*', $pContext)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, False)
$iBytes = $aCall[4]
$pContext = $aCall[7]
Return $aCall[0]
EndFunc
Func _WinAPI_BackupReadAbort(ByRef $pContext)
Local $aCall = DllCall('kernel32.dll', 'bool', 'BackupRead', 'handle', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'bool', 1,  'bool', 0, 'ptr*', $pContext)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, False)
$pContext = $aCall[7]
Return $aCall[0]
EndFunc
Func _WinAPI_BackupSeek($hFile, $iSeek, ByRef $iBytes, ByRef $pContext)
$iBytes = 0
Local $aCall = DllCall('kernel32.dll', 'bool', 'BackupSeek', 'handle', $hFile, 'dword', _WinAPI_LoDWord($iSeek),  'dword', _WinAPI_HiDWord($iSeek), 'dword*', 0, 'dword*', 0, 'ptr*', $pContext)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, False)
$iBytes = __WinAPI_MakeQWord($aCall[4], $aCall[5])
$pContext = $aCall[6]
Return $aCall[0]
EndFunc
Func _WinAPI_BackupWrite($hFile, $pBuffer, $iLength, ByRef $iBytes, ByRef $pContext, $bSecurity = False)
$iBytes = 0
Local $aCall = DllCall('kernel32.dll', 'bool', 'BackupWrite', 'handle', $hFile, 'struct*', $pBuffer, 'dword', $iLength,  'dword*', 0, 'bool', 0, 'bool', $bSecurity, 'ptr*', $pContext)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, False)
$iBytes = $aCall[4]
$pContext = $aCall[7]
Return $aCall[0]
EndFunc
Func _WinAPI_BackupWriteAbort(ByRef $pContext)
Local $aCall = DllCall('kernel32.dll', 'bool', 'BackupWrite', 'handle', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'bool', 1,  'bool', 0, 'ptr*', $pContext)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, False)
$pContext = $aCall[7]
Return $aCall[0]
EndFunc
Func _WinAPI_CopyFileEx($sExistingFile, $sNewFile, $iFlags = 0, $pProgressProc = 0, $pData = 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'CopyFileExW', 'wstr', $sExistingFile, 'wstr', $sNewFile,  'ptr', $pProgressProc, 'struct*', $pData, 'bool*', 0, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateDirectory($sDir, $tSecurity = 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'CreateDirectoryW', 'wstr', $sDir, 'struct*', $tSecurity)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateDirectoryEx($sNewDir, $sTemplateDir, $tSecurity = 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'CreateDirectoryExW', 'wstr', $sTemplateDir, 'wstr', $sNewDir, 'struct*', $tSecurity)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateFileEx($sFilePath, $iCreation, $iAccess = 0, $iShare = 0, $iFlagsAndAttributes = 0, $tSecurity = 0, $hTemplate = 0)
Local $aCall = DllCall('kernel32.dll', 'handle', 'CreateFileW', 'wstr', $sFilePath, 'dword', $iAccess, 'dword', $iShare,  'struct*', $tSecurity, 'dword', $iCreation, 'dword', $iFlagsAndAttributes, 'handle', $hTemplate)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] = Ptr(-1) Then Return SetError(10, _WinAPI_GetLastError(), 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateFileMapping($hFile, $iSize = 0, $sName = '', $iProtect = 0x0004, $tSecurity = 0)
If Not StringStripWS($sName, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sName = Null
Local $aCall = DllCall('kernel32.dll', 'handle', 'CreateFileMappingW', 'handle', $hFile, 'struct*', $tSecurity,  'dword', $iProtect, 'dword', _WinAPI_HiDWord($iSize), 'dword', _WinAPI_LoDWord($iSize),  'wstr', $sName)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended(_WinAPI_GetLastError(), $aCall[0])
EndFunc
Func _WinAPI_CreateHardLink($sNewFile, $sExistingFile)
Local $aCall = DllCall('kernel32.dll', 'bool', 'CreateHardLinkW', 'wstr', $sNewFile, 'wstr', $sExistingFile, 'ptr', 0)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateObjectID($sFilePath)
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $tFOID = DllStructCreate('byte[16];byte[48]')
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x000900C0, 'ptr', 0,  'dword', 0, 'struct*', $tFOID, 'dword', DllStructGetSize($tFOID), 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aCall, $hFile) Then Return SetError(@error, @extended, 0)
Local $tGUID = DllStructCreate($tagGUID)
_WinAPI_MoveMemory($tGUID, $tFOID, 16)
Return $tGUID
EndFunc
Func _WinAPI_CreateSymbolicLink($sSymlink, $sTarget, $bDirectory = False)
If $bDirectory Then
$bDirectory = 1
EndIf
Local $aCall = DllCall('kernel32.dll', 'boolean', 'CreateSymbolicLinkW', 'wstr', $sSymlink, 'wstr', $sTarget, 'dword', $bDirectory)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DecryptFile($sFilePath)
Local $aCall = DllCall('advapi32.dll', 'bool', 'DecryptFileW', 'wstr', $sFilePath, 'dword', 0)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DefineDosDevice($sDevice, $iFlags, $sFilePath = '')
If Not StringStripWS($sFilePath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sFilePath = Null
Local $aCall = DllCall('kernel32.dll', 'bool', 'DefineDosDeviceW', 'dword', $iFlags, 'wstr', $sDevice, 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DeleteFile($sFilePath)
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeleteFileW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DeleteObjectID($sFilePath)
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, $GENERIC_WRITE, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x000900A0, 'ptr', 0,  'dword', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aCall, $hFile) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_DeleteVolumeMountPoint($sMountedPath)
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeleteVolumeMountPointW', 'wstr', $sMountedPath)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_DeviceIoControl($hDevice, $iControlCode, $pInBuffer = 0, $iInBufferSize = 0, $pOutBuffer = 0, $iOutBufferSize = 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hDevice, 'dword', $iControlCode,  'struct*', $pInBuffer, 'dword', $iInBufferSize, 'struct*', $pOutBuffer, 'dword', $iOutBufferSize,  'dword*', 0, 'ptr', 0)
If @error Then Return SetError(@error, @extended, False)
Return SetExtended($aCall[7], $aCall[0])
EndFunc
Func _WinAPI_DuplicateEncryptionInfoFile($sSrcFilePath, $sDestFilePath, $iCreation = 2, $iAttributes = 0, $tSecurity = 0)
Local $aCall = DllCall('advapi32.dll', 'dword', 'DuplicateEncryptionInfoFile', 'wstr', $sSrcFilePath, 'wstr', $sDestFilePath,  'dword', $iCreation, 'dword', $iAttributes, 'struct*', $tSecurity)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_EjectMedia($sDrive)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x002D4808, 'ptr', 0,  'dword', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aCall, $hFile) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_EncryptFile($sFilePath)
Local $aCall = DllCall('advapi32.dll', 'bool', 'EncryptFileW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_EncryptionDisable($sDir, $bDisable)
Local $aCall = DllCall('advapi32.dll', 'bool', 'EncryptionDisable', 'wstr', $sDir, 'bool', $bDisable)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_EnumFiles($sDir, $iFlag = 0, $sTemplate = '', $bExclude = False)
Local $aCall, $iError = 0
Local $aData[501][7] = [[0]]
Local $hDir = _WinAPI_CreateFileEx($sDir, $OPEN_EXISTING, 0x00000001, $FILE_SHARE_ANY, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $pBuffer = __HeapAlloc($__g_iHeapSize)
If @error Then
$iError = @error
Else
Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
$aCall = DllCall('ntdll.dll', 'uint', 'ZwQueryDirectoryFile', 'handle', $hDir, 'ptr', 0, 'ptr', 0, 'ptr', 0,  'struct*', $tIOSB, 'struct*', $pBuffer, 'ulong', 8388608, 'uint', 1, 'boolean', 0, 'ptr', 0, 'boolean', 1)
If @error Or $aCall[0] Then
$iError = @error + 40
EndIf
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hDir)
If $iError Then
__HeapFree($pBuffer, 1)
If IsArray($aCall) Then
Return SetError(10, $aCall[0], 0)
Else
Return SetError($iError, 0, 0)
EndIf
EndIf
Local $tFDI, $iAttrib, $sTarget, $iLength = 0, $iOffset = 0
Do
$iLength += $iOffset
$tFDI = DllStructCreate('ulong;ulong;int64;int64;int64;int64;int64;int64;ulong;ulong;wchar[' & (DllStructGetData(DllStructCreate('ulong', $pBuffer + $iLength + 60), 1) / 2) & ']', $pBuffer + $iLength)
$sTarget = DllStructGetData($tFDI, 11)
$iAttrib = DllStructGetData($tFDI, 9)
$iOffset = DllStructGetData($tFDI, 1)
Switch $sTarget
Case '.', '..'
ContinueLoop
Case Else
Switch $iFlag
Case 1, 2
If BitAND($iAttrib, 0x00000010) Then
If $iFlag = 1 Then
ContinueLoop
EndIf
Else
If $iFlag = 2 Then
ContinueLoop
EndIf
EndIf
EndSwitch
If $sTemplate Then
$aCall = DllCall('shlwapi.dll', 'int', 'PathMatchSpecW', 'wstr', $sTarget, 'wstr', $sTemplate)
If @error Or ($aCall[0] And $bExclude) Or (Not $aCall[0] And Not $bExclude) Then
ContinueLoop
EndIf
EndIf
EndSwitch
__Inc($aData, 500)
$aData[$aData[0][0]][0] = $sTarget
$aData[$aData[0][0]][1] = DllStructGetData($tFDI, 3)
$aData[$aData[0][0]][2] = DllStructGetData($tFDI, 4)
$aData[$aData[0][0]][3] = DllStructGetData($tFDI, 5)
$aData[$aData[0][0]][4] = DllStructGetData($tFDI, 7)
$aData[$aData[0][0]][5] = DllStructGetData($tFDI, 8)
$aData[$aData[0][0]][6] = $iAttrib
Until Not $iOffset
__HeapFree($pBuffer)
__Inc($aData, -1)
Return $aData
EndFunc
Func _WinAPI_EnumFileStreams($sFilePath)
Local $tData = DllStructCreate('byte[32768]')
Local $pData = DllStructGetPtr($tData)
Local $aData[101][2] = [[0]]
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $iError = 0
Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
Local $aCall = DllCall('ntdll.dll', 'long', 'ZwQueryInformationFile', 'handle', $hFile, 'struct*', $tIOSB, 'ptr', $pData,  'ulong', 32768, 'uint', 22)
If @error Then $iError = @error
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $iError Then Return SetError($iError, 0, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Local $tFSI, $iLength = 0, $iOffset = 0
Do
$iLength += $iOffset
$tFSI = DllStructCreate('ulong;ulong;int64;int64;wchar[' & (DllStructGetData(DllStructCreate('ulong', $pData + $iLength + 4), 1) / 2) & ']', $pData + $iLength)
__Inc($aData)
$aData[$aData[0][0]][0] = DllStructGetData($tFSI, 5)
$aData[$aData[0][0]][1] = DllStructGetData($tFSI, 3)
$iOffset = DllStructGetData($tFSI, 1)
Until Not $iOffset
__Inc($aData, -1)
Return $aData
EndFunc
Func _WinAPI_EnumHardLinks($sFilePath)
Local $tData = DllStructCreate('byte[32768]')
Local $pData = DllStructGetPtr($tData)
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $iError = 0
Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
Local $aCall = DllCall('ntdll.dll', 'long', 'ZwQueryInformationFile', 'handle', $hFile, 'struct*', $tIOSB, 'ptr', $pData,  'ulong', 32768, 'uint', 46)
If @error Or $aCall[0] Then
$iError = @error + 10
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $aCall Then Return SetError($iError, 0, 0)
If $aCall[0] Then Return SetError(10, $iError, 0)
EndIf
Local $iCount = DllStructGetData(DllStructCreate('ulong;ulong', $pData), 2)
Local $aData[$iCount + 1] = [$iCount]
Local $tFLEI, $hPath, $sPath, $iLength = 8
For $i = 1 To $iCount
$tFLEI = DllStructCreate('ulong;int64;ulong;wchar[' & (DllStructGetData(DllStructCreate('ulong', $pData + $iLength + 16), 1)) & ']', $pData + $iLength)
$iError = 0
Do
$hPath = _WinAPI_OpenFileById($hFile, DllStructGetData($tFLEI, 2), 0x00100080, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then
$iError = @error + 100
ExitLoop
EndIf
$sPath = _WinAPI_GetFinalPathNameByHandleEx($hPath)
If @error Then
$iError = @error + 200
ExitLoop
EndIf
Until 1
If $hPath Then
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hPath)
EndIf
If $iError Then ExitLoop
$aData[$i] = _WinAPI_PathAppend($sPath, DllStructGetData($tFLEI, 4))
$iLength += DllStructGetData($tFLEI, 1)
Next
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $iError Then Return SetError($iError, 0, 0)
Return $aData
EndFunc
Func _WinAPI_FileEncryptionStatus($sFilePath)
Local $aCall = DllCall('advapi32.dll', 'bool', 'FileEncryptionStatusW', 'wstr', $sFilePath, 'dword*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, -1)
Return $aCall[2]
EndFunc
Func _WinAPI_FileExists($sFilePath)
If Not FileExists($sFilePath) Then Return 0
If _WinAPI_PathIsDirectory($sFilePath) Then Return SetExtended(1, 0)
Return 1
EndFunc
Func _WinAPI_FileInUse($sFilePath)
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, $GENERIC_READ)
If @error Then
If @extended = 32 Then Return 1
Return SetError(@error, @extended, 0)
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
Return 0
EndFunc
Func _WinAPI_FindClose($hSearch)
Local $aCall = DllCall('kernel32.dll', 'bool', 'FindClose', 'handle', $hSearch)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_FindCloseChangeNotification($hChange)
Local $aCall = DllCall('kernel32.dll', 'bool', 'FindCloseChangeNotification', 'handle', $hChange)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_FindFirstChangeNotification($sDirectory, $iFlags, $bSubtree = False)
Local $aCall = DllCall('kernel32.dll', 'handle', 'FindFirstChangeNotificationW', 'wstr', $sDirectory, 'bool', $bSubtree,  'dword', $iFlags)
If @error Or ($aCall[0] = Ptr(-1)) Then Return SetError(@error + 10, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_FindFirstFile($sFilePath, $tData)
Local $aCall = DllCall('kernel32.dll', 'handle', 'FindFirstFileW', 'wstr', $sFilePath, 'struct*', $tData)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] = Ptr(-1) Then Return SetError(10, _WinAPI_GetLastError(), 0)
Return $aCall[0]
EndFunc
Func _WinAPI_FindFirstFileName($sFilePath, ByRef $sLink)
$sLink = ''
Local $aCall = DllCall('kernel32.dll', 'handle', 'FindFirstFileNameW', 'wstr', $sFilePath, 'dword', 0, 'dword*', 4096, 'wstr', '')
If @error Or ($aCall[0] = Ptr(-1)) Then Return SetError(@error + 10, @extended, 0)
$sLink = $aCall[4]
Return $aCall[0]
EndFunc
Func _WinAPI_FindFirstStream($sFilePath, $tData)
Local $aCall = DllCall('kernel32.dll', 'handle', 'FindFirstStreamW', 'wstr', $sFilePath, 'uint', 0, 'struct*', $tData, 'dword', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] = Ptr(-1) Then Return SetError(10, _WinAPI_GetLastError(), 0)
Return $aCall[0]
EndFunc
Func _WinAPI_FindNextChangeNotification($hChange)
Local $aCall = DllCall('kernel32.dll', 'bool', 'FindNextChangeNotification', 'handle', $hChange)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_FindNextFile($hSearch, $tData)
Local $aCall = DllCall('kernel32.dll', 'bool', 'FindNextFileW', 'handle', $hSearch, 'struct*', $tData)
If @error Then Return SetError(@error, @extended, False)
If Not $aCall[0] Then Return SetError(10, _WinAPI_GetLastError(), 0)
Return $aCall[0]
EndFunc
Func _WinAPI_FindNextFileName($hSearch, ByRef $sLink)
$sLink = ''
Local $aCall = DllCall('kernel32.dll', 'bool', 'FindNextFileNameW', 'handle', $hSearch, 'dword*', 4096, 'wstr', '')
If @error Then Return SetError(@error, @extended, False)
If Not $aCall[0] Then Return SetError(10, _WinAPI_GetLastError(), 0)
$sLink = $aCall[3]
Return $aCall[0]
EndFunc
Func _WinAPI_FindNextStream($hSearch, $tData)
Local $aCall = DllCall('kernel32.dll', 'bool', 'FindNextStreamW', 'handle', $hSearch, 'struct*', $tData)
If @error Then Return SetError(@error, @extended, False)
If Not $aCall[0] Then Return SetError(10, _WinAPI_GetLastError(), 0)
Return $aCall[0]
EndFunc
Func _WinAPI_FlushFileBuffers($hFile)
Local $aCall = DllCall("kernel32.dll", "bool", "FlushFileBuffers", "handle", $hFile)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_FlushViewOfFile($pAddress, $iBytes = 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'FlushViewOfFile', 'struct*', $pAddress, 'dword', $iBytes)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetBinaryType($sFilePath)
Local $aCall = DllCall('kernel32.dll', 'int', 'GetBinaryTypeW', 'wstr', $sFilePath, 'dword*', 0)
If @error Then Return SetError(@error, @extended, 0)
If Not $aCall[0] Then $aCall[2] = 0
Return SetExtended($aCall[2], $aCall[0])
EndFunc
Func _WinAPI_GetCDType($sDrive)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $tagSCSI_PASS_THROUGH = 'struct;ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16];endstruct'
Local $tSPT = DllStructCreate($tagSCSI_PASS_THROUGH & ';byte Hdr[8]')
Local $tCDB = DllStructCreate('byte;byte;byte[2];byte[3];byte[2];byte;byte[2];byte[4]', DllStructGetPtr($tSPT, 'Cdb'))
Local $tHDR = DllStructCreate('byte[4];byte;byte;byte[2]', DllStructGetPtr($tSPT, 'Hdr'))
Local $iSize = DllStructGetPtr($tSPT, 'Hdr') - DllStructGetPtr($tSPT)
DllStructSetData($tSPT, 'Length', $iSize)
DllStructSetData($tSPT, 'ScsiStatus', 0)
DllStructSetData($tSPT, 'PathId', 0)
DllStructSetData($tSPT, 'TargetId', 0)
DllStructSetData($tSPT, 'Lun', 0)
DllStructSetData($tSPT, 'CdbLength', 12)
DllStructSetData($tSPT, 'SenseInfoLength', 0)
DllStructSetData($tSPT, 'DataIn', 1)
DllStructSetData($tSPT, 'DataTransferLength', 8)
DllStructSetData($tSPT, 'TimeOutValue', 86400)
DllStructSetData($tSPT, 'DataBufferOffset', $iSize)
DllStructSetData($tSPT, 'SenseInfoOffset', 0)
DllStructSetData($tCDB, 1, 0x46)
DllStructSetData($tCDB, 2, 0)
DllStructSetData($tCDB, 3, 0, 1)
DllStructSetData($tCDB, 3, 0, 2)
DllStructSetData($tCDB, 5, 0, 1)
DllStructSetData($tCDB, 5, 8, 2)
DllStructSetData($tCDB, 6, 0)
DllStructSetData($tCDB, 7, 0, 1)
DllStructSetData($tCDB, 7, 0, 2)
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x0004D004, 'struct*', $tSPT,  'dword', $iSize, 'struct*', $tSPT, 'dword', DllStructGetSize($tSPT), 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aCall, $hFile) Then Return SetError(@error, @extended, 0)
Return BitOR(BitShift(DllStructGetData($tHDR, 4, 1), -8), DllStructGetData($tHDR, 4, 2))
EndFunc
Func _WinAPI_GetCompressedFileSize($sFilePath)
Local $aCall = DllCall('kernel32.dll', 'dword', 'GetCompressedFileSizeW', 'wstr', $sFilePath, 'dword*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] = -1 Then
Local $iLastError = _WinAPI_GetLastError()
If $aCall[2] = 0 Then Return SetError(10, $iLastError, 0)
If $iLastError Then Return SetError(11, $iLastError, 0)
EndIf
Return __WinAPI_MakeQWord($aCall[0], $aCall[2])
EndFunc
Func _WinAPI_GetCompression($sFilePath)
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x0009003C, 'ptr', 0, 'dword', 0,  'ushort*', 0, 'dword', 2, 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aCall, $hFile) Then Return SetError(@error, @extended, -1)
Return $aCall[5]
EndFunc
Func _WinAPI_GetCurrentDirectory()
Local $aCall = DllCall('kernel32.dll', 'dword', 'GetCurrentDirectoryW', 'dword', 4096, 'wstr', '')
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($aCall[0], $aCall[2])
EndFunc
Func _WinAPI_GetDiskFreeSpaceEx($sDrive)
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetDiskFreeSpaceEx', 'str', $sDrive, 'int64*', 0, 'int64*', 0, 'int64*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aRet[3]
For $i = 0 To 2
$aRet[$i] = $aCall[$i + 2]
Next
Return $aRet
EndFunc
Func _WinAPI_GetDriveBusType($sDrive)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, -1)
Local $tagSTORAGE_PROPERTY_QUERY = 'ulong PropertyId;ulong QueryType;byte AdditionalParameters[1]'
Local $tSPQ = DllStructCreate($tagSTORAGE_PROPERTY_QUERY)
Local $tSDD = DllStructCreate('ulong Version;ulong Size;byte DeviceType;byte DeviceTypeModifier;byte RemovableMedia;byte CommandQueueing;ulong VendorIdOffset;ulong ProductIdOffset;ulong ProductRevisionOffset;ulong SerialNumberOffset;ulong BusType;ulong RawPropertiesLength;byte RawDeviceProperties[1]')
DllStructSetData($tSPQ, 'PropertyId', 0)
DllStructSetData($tSPQ, 'QueryType', 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x002D1400, 'struct*', $tSPQ,  'dword', DllStructGetSize($tSPQ), 'struct*', $tSDD, 'dword', DllStructGetSize($tSDD),  'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aCall, $hFile) Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSDD, 'BusType')
EndFunc
Func _WinAPI_GetDriveGeometryEx($iDrive)
Local $hFile = _WinAPI_CreateFileEx('\\.\PhysicalDrive' & $iDrive, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $tDGEX = DllStructCreate('uint64;dword;dword;dword;dword;uint64')
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x000700A0, 'ptr', 0,  'dword', 0, 'struct*', $tDGEX, 'dword', DllStructGetSize($tDGEX), 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aCall, $hFile) Then Return SetError(@error, @extended, 0)
Local $aRet[6]
For $i = 0 To 5
$aRet[$i] = DllStructGetData($tDGEX, $i + 1)
Next
Return $aRet
EndFunc
Func _WinAPI_GetDriveNumber($sDrive)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $tSDN = DllStructCreate('dword;dword;dword')
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x002D1080, 'ptr', 0,  'dword', 0, 'struct*', $tSDN, 'dword', DllStructGetSize($tSDN), 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aCall, $hFile) Then Return SetError(@error, @extended, 0)
Local $aRet[3]
For $i = 0 To 2
$aRet[$i] = DllStructGetData($tSDN, $i + 1)
Next
Return $aRet
EndFunc
Func _WinAPI_GetDriveType($sDrive = '')
If Not StringStripWS($sDrive, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sDrive = Null
Local $aCall = DllCall('kernel32.dll', 'uint', 'GetDriveType', 'str', $sDrive)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetFileAttributes($sFilePath)
Local $aCall = DllCall('kernel32.dll', 'dword', 'GetFileAttributesW', 'wstr', $sFilePath)
If @error Or ($aCall[0] = 4294967295) Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetFileID($hFile)
Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
Local $aCall = DllCall('ntdll.dll', 'long', 'ZwQueryInformationFile', 'handle', $hFile, 'struct*', $tIOSB, 'int64*', 0,  'ulong', 8, 'uint', 6)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[3]
EndFunc
Func _WinAPI_GetFileInformationByHandle($hFile)
Local $tBHFI = DllStructCreate('dword;dword[2];dword[2];dword[2];dword;dword;dword;dword;dword;dword')
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetFileInformationByHandle', 'handle', $hFile, 'struct*', $tBHFI)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aRet[8]
$aRet[0] = DllStructGetData($tBHFI, 1)
For $i = 1 To 3
If DllStructGetData($tBHFI, $i + 1) Then
$aRet[$i] = DllStructCreate($tagFILETIME)
_WinAPI_MoveMemory($aRet[$i], DllStructGetPtr($tBHFI, $i + 1), 8)
Else
$aRet[$i] = 0
EndIf
Next
$aRet[4] = DllStructGetData($tBHFI, 5)
$aRet[5] = __WinAPI_MakeQWord(DllStructGetData($tBHFI, 7), DllStructGetData($tBHFI, 6))
$aRet[6] = DllStructGetData($tBHFI, 8)
$aRet[7] = __WinAPI_MakeQWord(DllStructGetData($tBHFI, 9), DllStructGetData($tBHFI, 10))
Return $aRet
EndFunc
Func _WinAPI_GetFileInformationByHandleEx($hFile)
Local $tFI = DllStructCreate($tagFILEINFO)
Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
Local $aCall = DllCall('ntdll.dll', 'long', 'ZwQueryInformationFile', 'handle', $hFile, 'struct*', $tIOSB, 'struct*', $tFI,  'ulong', DllStructGetSize($tFI), 'uint', 4)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $tFI
EndFunc
Func _WinAPI_GetFilePointerEx($hFile)
Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
Local $aCall = DllCall('ntdll.dll', 'long', 'ZwQueryInformationFile', 'handle', $hFile, 'struct*', $tIOSB, 'int64*', 0,  'ulong', 8, 'uint', 14)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
Return $aCall[3]
EndFunc
Func _WinAPI_GetFileSizeEx($hFile)
Local $aCall = DllCall("kernel32.dll", "bool", "GetFileSizeEx", "handle", $hFile, "int64*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, -1)
Return $aCall[2]
EndFunc
Func _WinAPI_GetFileSizeOnDisk($sFilePath)
Local $iSize = FileGetSize($sFilePath)
If @error Then Return SetError(@error + 10, @extended, 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetDiskFreeSpaceW',  'wstr', _WinAPI_PathStripToRoot(_WinAPI_GetFullPathName($sFilePath)), 'dword*', 0, 'dword*', 0,  'dword*', 0, 'dword*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return Ceiling($iSize / ($aCall[2] * $aCall[3])) * ($aCall[2] * $aCall[3])
EndFunc
Func _WinAPI_GetFileTitle($sFilePath)
Local $aCall = DllCall('comdlg32.dll', 'short', 'GetFileTitleW', 'wstr', $sFilePath, 'wstr', '', 'word', 4096)
If @error Or $aCall[0] Then Return SetError(@error + 10, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_GetFileType($hFile)
Local $aCall = DllCall('kernel32.dll', 'dword', 'GetFileType', 'handle', $hFile)
If @error Then Return SetError(@error, @extended, -1)
Local $iLastError = _WinAPI_GetLastError()
If Not $aCall[0] And $iLastError Then Return SetError(10, $iLastError, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_GetFinalPathNameByHandle($hFile)
Local $tFNI = DllStructCreate('ulong;wchar[4096]')
Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
Local $aCall = DllCall('ntdll.dll', 'long', 'ZwQueryInformationFile', 'handle', $hFile, 'struct*', $tIOSB, 'struct*', $tFNI,  'ulong', DllStructGetSize($tFNI), 'uint', 9)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
Local $iLength = DllStructGetData($tFNI, 1)
If Not $iLength Then Return SetError(12, 0, '')
Return DllStructGetData(DllStructCreate('wchar[' & ($iLength / 2) & ']', DllStructGetPtr($tFNI, 2)), 1)
EndFunc
Func _WinAPI_GetFinalPathNameByHandleEx($hFile, $iFlags = 0)
Local $aCall = DllCall('kernel32.dll', 'dword', 'GetFinalPathNameByHandleW', 'handle', $hFile, 'wstr', '', 'dword', 4096,  'dword', $iFlags)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_GetFullPathName($sFilePath)
Local $aCall = DllCall('kernel32.dll', 'dword', 'GetFullPathNameW', 'wstr', $sFilePath, 'dword', 4096, 'wstr', '', 'ptr', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return $aCall[3]
EndFunc
Func _WinAPI_GetLogicalDrives()
Local $aCall = DllCall('kernel32.dll', 'dword', 'GetLogicalDrives')
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetObjectID($sFilePath)
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $tFOID = DllStructCreate('byte[16];byte[48]')
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x0009009C, 'ptr', 0,  'dword', 0, 'struct*', $tFOID, 'dword', DllStructGetSize($tFOID), 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aCall, $hFile) Then Return SetError(@error, @extended, 0)
Local $tGUID = DllStructCreate($tagGUID)
_WinAPI_MoveMemory($tGUID, $tFOID, 16)
Return $tGUID
EndFunc
Func _WinAPI_GetOverlappedResult($hFile, $tOverlapped, ByRef $iBytes, $bWait = False)
Local $aCall = DllCall("kernel32.dll", "bool", "GetOverlappedResult", "handle", $hFile, "struct*", $tOverlapped, "dword*", 0,  "bool", $bWait)
If @error Then Return SetError(@error, @extended, False)
$iBytes = $aCall[3]
Return $aCall[0]
EndFunc
Func _WinAPI_GetPEType($sFilePath)
Local $tData = DllStructCreate('ushort[2]')
Local $tUInt = DllStructCreate('uint', DllStructGetPtr($tData))
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $iError = 0, $iVal
Do
Local $aCall = DllCall('kernel32.dll', 'bool', 'ReadFile', 'handle', $hFile, 'struct*', $tData, 'dword', 2, 'dword*', 0, 'ptr', 0)
If @error Or (Not $aCall[0]) Or ($aCall[4] <> 2) Then
$iError = @error + 30
ExitLoop
EndIf
$iVal = DllStructGetData($tData, 1, 1)
If $iVal <> 0x00005A4D Then
$iError = 3
ExitLoop
EndIf
If Not _WinAPI_SetFilePointerEx($hFile, 0x0000003C) Then
$iError = @error + 40
ExitLoop
EndIf
$aCall = DllCall('kernel32.dll', 'bool', 'ReadFile', 'handle', $hFile, 'struct*', $tData, 'dword', 4, 'dword*', 0, 'ptr', 0)
If @error Or (Not $aCall[0]) Or ($aCall[4] <> 4) Then
$iError = @error + 50
ExitLoop
EndIf
If Not _WinAPI_SetFilePointerEx($hFile, DllStructGetData($tUInt, 1)) Then
$iError = @error + 60
ExitLoop
EndIf
$aCall = DllCall('kernel32.dll', 'bool', 'ReadFile', 'handle', $hFile, 'struct*', $tData, 'dword', 4, 'dword*', 0, 'ptr', 0)
If @error Or (Not $aCall[0]) Or ($aCall[4] <> 4) Then
$iError = @error + 70
ExitLoop
EndIf
$iVal = DllStructGetData($tUInt, 1)
If $iVal <> 0x00004550 Then
$iError = 4
ExitLoop
EndIf
$aCall = DllCall('kernel32.dll', 'bool', 'ReadFile', 'handle', $hFile, 'struct*', $tData, 'dword', 2, 'dword*', 0, 'ptr', 0)
If @error Or (Not $aCall[0]) Or ($aCall[4] <> 2) Then
$iError = @error + 80
ExitLoop
EndIf
$iVal = DllStructGetData($tData, 1, 1)
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $iError Then Return SetError($iError, 0, 0)
Return $iVal
EndFunc
Func _WinAPI_GetProfilesDirectory()
Local $aCall = DllCall('userenv.dll', 'bool', 'GetProfilesDirectoryW', 'wstr', '', 'dword*', 4096)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
Return $aCall[1]
EndFunc
Func _WinAPI_GetTempFileName($sFilePath, $sPrefix = '')
Local $aCall = DllCall('kernel32.dll', 'uint', 'GetTempFileNameW', 'wstr', $sFilePath, 'wstr', $sPrefix, 'uint', 0, 'wstr', '')
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
Return $aCall[4]
EndFunc
Func _WinAPI_GetVolumeInformation($sRoot = '')
If Not StringStripWS($sRoot, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sRoot = Null
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetVolumeInformationW', 'wstr', $sRoot, 'wstr', '', 'dword', 4096,  'dword*', 0, 'dword*', 0, 'dword*', 0, 'wstr', '', 'dword', 4096)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aRet[5]
For $i = 0 To 4
Switch $i
Case 0
$aRet[$i] = $aCall[2]
Case Else
$aRet[$i] = $aCall[$i + 3]
EndSwitch
Next
Return $aRet
EndFunc
Func _WinAPI_GetVolumeInformationByHandle($hFile)
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetVolumeInformationByHandleW', 'handle', $hFile, 'wstr', '', 'dword', 4096,  'dword*', 0, 'dword*', 0, 'dword*', 0, 'wstr', '', 'dword', 4096)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aRet[5]
For $i = 0 To 4
Switch $i
Case 0
$aRet[$i] = $aCall[2]
Case Else
$aRet[$i] = $aCall[$i + 3]
EndSwitch
Next
Return $aRet
EndFunc
Func _WinAPI_GetVolumeNameForVolumeMountPoint($sMountedPath)
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetVolumeNameForVolumeMountPointW', 'wstr', $sMountedPath, 'wstr', '', 'dword', 80)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_IOCTL($iDeviceType, $iFunction, $iMethod, $iAccess)
Return BitOR(BitShift($iDeviceType, -16), BitShift($iAccess, -14), BitShift($iFunction, -2), $iMethod)
EndFunc
Func _WinAPI_IsDoorOpen($sDrive)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, False)
Local $tSPT = DllStructCreate('ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;byte Alignment[3];ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16]' & (@AutoItX64 ? ';byte[4]' : '') & ';byte Hdr[8]')
Local $tCDB = DllStructCreate('byte;byte;byte[6];byte[2];byte;byte;byte[4]', DllStructGetPtr($tSPT, 'Cdb'))
Local $tHDR = DllStructCreate('byte;byte;byte[3];byte;byte[2]', DllStructGetPtr($tSPT, 'Hdr'))
Local $iSize = DllStructGetPtr($tSPT, 'Hdr') - DllStructGetPtr($tSPT)
DllStructSetData($tSPT, 'Length', $iSize)
DllStructSetData($tSPT, 'ScsiStatus', 0)
DllStructSetData($tSPT, 'PathId', 0)
DllStructSetData($tSPT, 'TargetId', 0)
DllStructSetData($tSPT, 'Lun', 0)
DllStructSetData($tSPT, 'CdbLength', 12)
DllStructSetData($tSPT, 'SenseInfoLength', 0)
DllStructSetData($tSPT, 'DataIn', 1)
DllStructSetData($tSPT, 'DataTransferLength', 8)
DllStructSetData($tSPT, 'TimeOutValue', 86400)
DllStructSetData($tSPT, 'DataBufferOffset', $iSize)
DllStructSetData($tSPT, 'SenseInfoOffset', 0)
DllStructSetData($tCDB, 1, 0xBD)
DllStructSetData($tCDB, 2, 0)
DllStructSetData($tCDB, 4, 0, 1)
DllStructSetData($tCDB, 4, 8, 2)
DllStructSetData($tCDB, 5, 0)
DllStructSetData($tCDB, 6, 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x0004D004, 'struct*', $tSPT,  'dword', $iSize, 'struct*', $tSPT, 'dword', DllStructGetSize($tSPT), 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aCall, $hFile) Then Return SetError(@error, @extended, False)
Return (BitAND(DllStructGetData($tHDR, 2), 0x10) = 0x10)
EndFunc
Func _WinAPI_IsPathShared($sFilePath)
If Not __DLL('ntshrui.dll') Then Return SetError(103, 0, 0)
Local $aCall = DllCall('ntshrui.dll', 'bool', 'IsPathSharedW', 'wstr', _WinAPI_PathRemoveBackslash($sFilePath), 'int', 1)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_IsWritable($sDrive)
DriveGetFileSystem($sDrive)
If @error Then Return SetError(40 + @error, _WinAPI_GetLastError(), 0)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x00070024, 'ptr', 0, 'dword', 0,  'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)
Local Const $ERROR_WRITE_PROTECT = 19
If __CheckErrorCloseHandle($aCall, $hFile, 1) <> 10 And @extended = $ERROR_WRITE_PROTECT Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_LoadMedia($sDrive)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, False)
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x002D480C, 'ptr', 0, 'dword', 0,  'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aCall, $hFile) Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_LockDevice($sDrive, $bLock)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, False)
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x002D4804, 'boolean*', $bLock,  'dword', 1, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aCall, $hFile) Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_LockFile($hFile, $iOffset, $iLength)
Local $aCall = DllCall('kernel32.dll', 'bool', 'LockFile', 'handle', $hFile,  'dword', _WinAPI_LoDWord($iOffset), 'dword', _WinAPI_HiDWord($iOffset),  'dword', _WinAPI_LoDWord($iLength), 'dword', _WinAPI_HiDWord($iLength))
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_MapViewOfFile($hMapping, $iOffset = 0, $iBytes = 0, $iAccess = 0x0006)
Local $aCall = DllCall('kernel32.dll', 'ptr', 'MapViewOfFile', 'handle', $hMapping, 'dword', $iAccess,  'dword', _WinAPI_HiDWord($iOffset), 'dword', _WinAPI_LoDWord($iOffset), 'ulong_ptr', $iBytes)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_MoveFileEx($sExistingFile, $sNewFile, $iFlags = 0, $pProgressProc = 0, $pData = 0)
If Not StringStripWS($sNewFile, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sNewFile = Null
If BitAND($iFlags, $MOVE_FILE_DELAY_UNTIL_REBOOT) Then
If $sNewFile = 0 Then $sNewFile = Null
EndIf
Local $aCall = DllCall('kernel32.dll', 'bool', 'MoveFileWithProgressW', 'wstr', $sExistingFile, 'wstr', $sNewFile,  'ptr', $pProgressProc, 'ptr', $pData, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_OpenFileById($hFile, $vID, $iAccess = 0, $iShare = 0, $iFlags = 0)
Local $tFIDD = DllStructCreate('dword;uint;int64;int64')
Local $hObj, $aCall, $iType, $iError = 0
Select
Case IsString($vID)
$aCall = DllCall('ole32.dll', 'long', 'CLSIDFromString', 'wstr', $vID, 'ptr', DllStructGetPtr($tFIDD, 3))
If @error Or $aCall[0] Then
Return SetError(@error + 30, 0, 0)
EndIf
$iType = 1
Case IsDllStruct($vID)
If Not _WinAPI_MoveMemory(DllStructGetPtr($tFIDD, 3), DllStructGetPtr($vID), 16) Then
Return SetError(@error + 40, 0, 0)
EndIf
$iType = 1
Case Else
DllStructSetData($tFIDD, 3, $vID)
$iType = 0
EndSelect
DllStructSetData($tFIDD, 1, DllStructGetSize($tFIDD))
DllStructSetData($tFIDD, 2, $iType)
If IsString($hFile) Then
$hObj = _WinAPI_CreateFileEx($hFile, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Else
$hObj = $hFile
EndIf
$aCall = DllCall('kernel32.dll', 'handle', 'OpenFileById', 'handle', $hObj, 'struct*', $tFIDD, 'dword', $iAccess,  'dword', $iShare, 'ptr', 0, 'dword', $iFlags)
If @error Or ($aCall[0] = Ptr(-1)) Then $iError = @error + 10
If IsString($hFile) Then
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hObj)
EndIf
If $iError Then Return SetError($iError, 0, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_OpenFileMapping($sName, $iAccess = 0x0006, $bInherit = False)
Local $aCall = DllCall('kernel32.dll', 'handle', 'OpenFileMappingW', 'dword', $iAccess, 'bool', $bInherit, 'wstr', $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_PathIsDirectoryEmpty($sFilePath)
Local $aCall = DllCall('shlwapi.dll', 'bool', 'PathIsDirectoryEmptyW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_QueryDosDevice($sDevice)
If Not StringStripWS($sDevice, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sDevice = Null
Local $tData = DllStructCreate('wchar[16384]')
Local $aCall = DllCall('kernel32.dll', 'dword', 'QueryDosDeviceW', 'wstr', $sDevice, 'struct*', $tData, 'dword', 16384)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
Local $aRet = _WinAPI_StructToArray($tData)
If IsString($sDevice) Then
$aRet = $aRet[1]
EndIf
Return $aRet
EndFunc
Func _WinAPI_ReadDirectoryChanges($hDirectory, $iFilter, $pBuffer, $iLength, $bSubtree = 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'ReadDirectoryChangesW', 'handle', $hDirectory, 'struct*', $pBuffer,  'dword', $iLength - Mod($iLength, 4), 'bool', $bSubtree, 'dword', $iFilter, 'dword*', 0, 'ptr', 0, 'ptr', 0)
If @error Or Not $aCall[0] Or (Not $aCall[6]) Then Return SetError(@error + 10, @extended, 0)
$pBuffer = $aCall[2]
Local $aData[101][2] = [[0]]
Local $tFNI, $iBuffer = 0, $iOffset = 0
Do
$iBuffer += $iOffset
$tFNI = DllStructCreate('dword NextEntryOffset;dword Action;dword FileNameLength;wchar FileName[' & (DllStructGetData(DllStructCreate('dword FileNameLength', $pBuffer + $iBuffer + 8), 1) / 2) & ']', $pBuffer + $iBuffer)
__Inc($aData)
$aData[$aData[0][0]][0] = DllStructGetData($tFNI, "FileName")
$aData[$aData[0][0]][1] = DllStructGetData($tFNI, "Action")
$iOffset = DllStructGetData($tFNI, "NextEntryOffset")
Until Not $iOffset
__Inc($aData, -1)
Return $aData
EndFunc
Func _WinAPI_RemoveDirectory($sDirPath)
Local $aCall = DllCall('kernel32.dll', 'bool', 'RemoveDirectoryW', 'wstr', $sDirPath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ReOpenFile($hFile, $iAccess, $iShare, $iFlags = 0)
Local $aCall = DllCall('kernel32.dll', 'handle', 'ReOpenFile', 'handle', $hFile, 'dword', $iAccess, 'dword', $iShare, 'dword', $iFlags)
If @error Or ($aCall[0] = Ptr(-1)) Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ReplaceFile($sReplacedFile, $sReplacementFile, $sBackupFile = '', $iFlags = 0)
If Not StringStripWS($sBackupFile, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sBackupFile = Null
Local $aCall = DllCall('kernel32.dll', 'bool', 'ReplaceFileW', 'wstr', $sReplacedFile, 'wstr', $sReplacementFile,  'wstr', $sBackupFile, 'dword', $iFlags, 'ptr', 0, 'ptr', 0)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SearchPath($sFilePath, $sSearchPath = '')
If Not StringStripWS($sSearchPath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sSearchPath = Null
Local $aCall = DllCall('kernel32.dll', 'dword', 'SearchPathW', 'wstr', $sSearchPath, 'wstr', $sFilePath, 'ptr', 0, 'dword', 4096, 'wstr', '', 'ptr', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
Return $aCall[5]
EndFunc
Func _WinAPI_SetCompression($sFilePath, $iCompression)
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x0009C040,  'ushort*', $iCompression, 'dword', 2, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aCall, $hFile) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_SetCurrentDirectory($sDir)
Local $aCall = DllCall('kernel32.dll', 'int', 'SetCurrentDirectoryW', 'wstr', $sDir)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetEndOfFile($hFile)
Local $aCall = DllCall("kernel32.dll", "bool", "SetEndOfFile", "handle", $hFile)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetFileAttributes($sFilePath, $iAttributes)
Local $aCall = DllCall('kernel32.dll', 'int', 'SetFileAttributesW', 'wstr', $sFilePath, 'dword', $iAttributes)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetFileInformationByHandleEx($hFile, $tFILEINFO)
Local $aCall = DllCall('ntdll.dll', 'long', 'ZwSetInformationFile', 'handle', $hFile, 'struct*', $tFILEINFO,  'struct*', $tFILEINFO, 'ulong', DllStructGetSize($tFILEINFO), 'uint', 4)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_SetFilePointer($hFile, $iPos, $iMethod = 0)
Local $aCall = DllCall("kernel32.dll", "INT", "SetFilePointer", "handle", $hFile, "long", $iPos, "ptr", 0, "long", $iMethod)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_SetFilePointerEx($hFile, $iPos, $iMethod = 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'SetFilePointerEx', 'handle', $hFile, 'int64', $iPos, 'int64*', 0, 'dword', $iMethod)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetFileShortName($hFile, $sShortName)
Local $aCall = DllCall('kernel32.dll', 'bool', 'SetFileShortNameW', 'handle', $hFile, 'wstr', $sShortName)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetFileValidData($hFile, $iLength)
Local $aCall = DllCall('kernel32.dll', 'bool', 'SetFileValidData', 'handle', $hFile, 'int64', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetSearchPathMode($iFlags)
Local $aCall = DllCall('kernel32.dll', 'bool', 'SetSearchPathMode', 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetVolumeMountPoint($sFilePath, $sGUID)
Local $aCall = DllCall('kernel32.dll', 'bool', 'SetVolumeMountPointW', 'wstr', $sFilePath, 'wstr', $sGUID)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SfcIsFileProtected($sFilePath)
If Not __DLL('sfc.dll') Then Return SetError(103, 0, False)
Local $aCall = DllCall('sfc.dll', 'bool', 'SfcIsFileProtected', 'handle', 0, 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_UnlockFile($hFile, $iOffset, $iLength)
Local $aCall = DllCall('kernel32.dll', 'bool', 'UnlockFile', 'handle', $hFile,  'dword', _WinAPI_LoDWord($iOffset), 'dword', _WinAPI_HiDWord($iOffset),  'dword', _WinAPI_LoDWord($iLength), 'dword', _WinAPI_HiDWord($iLength))
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_UnmapViewOfFile($pAddress)
Local $aCall = DllCall('kernel32.dll', 'bool', 'UnmapViewOfFile', 'ptr', $pAddress)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_Wow64EnableWow64FsRedirection($bEnable)
Local $aCall = DllCall('kernel32.dll', 'boolean', 'Wow64EnableWow64FsRedirection', 'boolean', $bEnable)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func __WinAPI_MakeQWord($iLoDWORD, $iHiDWORD)
Local $tInt64 = DllStructCreate("uint64")
Local $tDwords = DllStructCreate("dword;dword", DllStructGetPtr($tInt64))
DllStructSetData($tDwords, 1, $iLoDWORD)
DllStructSetData($tDwords, 2, $iHiDWORD)
Return DllStructGetData($tInt64, 1)
EndFunc
Global Const $CREATE_BREAKAWAY_FROM_JOB = 0x01000000
Global Const $CREATE_DEFAULT_ERROR_MODE = 0x04000000
Global Const $CREATE_NEW_CONSOLE = 0x00000010
Global Const $CREATE_NEW_PROCESS_GROUP = 0x00000200
Global Const $CREATE_NO_WINDOW = 0x08000000
Global Const $CREATE_PROTECTED_PROCESS = 0x00040000
Global Const $CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000
Global Const $CREATE_SEPARATE_WOW_VDM = 0x00000800
Global Const $CREATE_SHARED_WOW_VDM = 0x00001000
Global Const $CREATE_SUSPENDED = 0x00000004
Global Const $CREATE_UNICODE_ENVIRONMENT = 0x00000400
Global Const $LIST_MODULES_32BIT = 1
Global Const $LIST_MODULES_64BIT = 2
Global Const $LIST_MODULES_ALL = 3
Global Const $LIST_MODULES_DEFAULT = 0
Global Const $ABOVE_NORMAL_PRIORITY_CLASS = 0x00008000
Global Const $BELOW_NORMAL_PRIORITY_CLASS = 0x00004000
Global Const $HIGH_PRIORITY_CLASS = 0x00000080
Global Const $IDLE_PRIORITY_CLASS = 0x00000040
Global Const $NORMAL_PRIORITY_CLASS = 0x00000020
Global Const $REALTIME_PRIORITY_CLASS = 0x00000100
Global Const $PROCESS_MODE_BACKGROUND_BEGIN = 0x00100000
Global Const $PROCESS_MODE_BACKGROUND_END = 0x00200000
Global Const $MUTEX_MODIFY_STATE = 0x0001
Global Const $MUTEX_ALL_ACCESS = 0x001F0001
Global Const $JOB_OBJECT_ASSIGN_PROCESS = 0x0001
Global Const $JOB_OBJECT_QUERY = 0x0004
Global Const $JOB_OBJECT_SET_ATTRIBUTES = 0x0002
Global Const $JOB_OBJECT_SET_SECURITY_ATTRIBUTES = 0x0010
Global Const $JOB_OBJECT_TERMINATE = 0x0008
Global Const $JOB_OBJECT_ALL_ACCESS = 0x001F001F
Global Const $JOB_OBJECT_LIMIT_ACTIVE_PROCESS = 0x00000008
Global Const $JOB_OBJECT_LIMIT_AFFINITY = 0x00000010
Global Const $JOB_OBJECT_LIMIT_BREAKAWAY_OK = 0x00000800
Global Const $JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 0x00000400
Global Const $JOB_OBJECT_LIMIT_JOB_MEMORY = 0x00000200
Global Const $JOB_OBJECT_LIMIT_JOB_TIME = 0x00000004
Global Const $JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = 0x00002000
Global Const $JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = 0x00000040
Global Const $JOB_OBJECT_LIMIT_PRIORITY_CLASS = 0x00000020
Global Const $JOB_OBJECT_LIMIT_PROCESS_MEMORY = 0x00000100
Global Const $JOB_OBJECT_LIMIT_PROCESS_TIME = 0x00000002
Global Const $JOB_OBJECT_LIMIT_SCHEDULING_CLASS = 0x00000080
Global Const $JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = 0x00001000
Global Const $JOB_OBJECT_LIMIT_WORKINGSET = 0x00000001
Global Const $JOB_OBJECT_UILIMIT_DESKTOP = 0x00000040
Global Const $JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = 0x00000010
Global Const $JOB_OBJECT_UILIMIT_EXITWINDOWS = 0x00000080
Global Const $JOB_OBJECT_UILIMIT_GLOBALATOMS = 0x00000020
Global Const $JOB_OBJECT_UILIMIT_HANDLES = 0x00000001
Global Const $JOB_OBJECT_UILIMIT_READCLIPBOARD = 0x00000002
Global Const $JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 0x00000008
Global Const $JOB_OBJECT_UILIMIT_WRITECLIPBOARD = 0x00000004
Global Const $JOB_OBJECT_SECURITY_FILTER_TOKENS = 0x00000008
Global Const $JOB_OBJECT_SECURITY_NO_ADMIN = 0x00000001
Global Const $JOB_OBJECT_SECURITY_ONLY_TOKEN = 0x00000004
Global Const $JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 0x00000002
Global Const $JOB_OBJECT_TERMINATE_AT_END_OF_JOB = 0
Global Const $JOB_OBJECT_POST_AT_END_OF_JOB = 1
Global Const $SEMAPHORE_MODIFY_STATE = 0x0002
Global Const $SEMAPHORE_QUERY_STATE = 0x0001
Global Const $SEMAPHORE_ALL_ACCESS = 0x001F0003
Global Const $ES_AWAYMODE_REQUIRED = 0x00000040
Global Const $ES_CONTINUOUS = 0x80000000
Global Const $ES_DISPLAY_REQUIRED = 0x00000002
Global Const $ES_SYSTEM_REQUIRED = 0x00000001
Global Const $ES_USER_PRESENT = 0x00000004
Global Const $tagIO_COUNTERS = 'struct;uint64 ReadOperationCount;uint64 WriteOperationCount;uint64 OtherOperationCount;uint64 ReadTransferCount;uint64 WriteTransferCount;uint64 OtherTransferCount;endstruct'
Global Const $tagJOBOBJECT_ASSOCIATE_COMPLETION_PORT = 'ulong_ptr CompletionKey;ptr CompletionPort'
Global Const $tagJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = 'struct;int64 TotalUserTime;int64 TotalKernelTime;int64 ThisPeriodTotalUserTime;int64 ThisPeriodTotalKernelTime;dword TotalPageFaultCount;dword TotalProcesses;dword ActiveProcesses;dword TotalTerminatedProcesses;endstruct'
Global Const $tagJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = $tagJOBOBJECT_BASIC_ACCOUNTING_INFORMATION & ';' & $tagIO_COUNTERS
Global Const $tagJOBOBJECT_BASIC_LIMIT_INFORMATION = 'struct;int64 PerProcessUserTimeLimit;int64 PerJobUserTimeLimit;dword LimitFlags;ulong_ptr MinimumWorkingSetSize;ulong_ptr MaximumWorkingSetSize;dword ActiveProcessLimit;ulong_ptr Affinity;dword PriorityClass;dword SchedulingClass;endstruct'
Global Const $tagJOBOBJECT_BASIC_PROCESS_ID_LIST = 'dword NumberOfAssignedProcesses;dword NumberOfProcessIdsInList'
Global Const $tagJOBOBJECT_BASIC_UI_RESTRICTIONS = 'dword UIRestrictionsClass'
Global Const $tagJOBOBJECT_END_OF_JOB_TIME_INFORMATION = 'dword EndOfJobTimeAction'
Global Const $tagJOBOBJECT_EXTENDED_LIMIT_INFORMATION = $tagJOBOBJECT_BASIC_LIMIT_INFORMATION & ';' & $tagIO_COUNTERS & ';ulong_ptr ProcessMemoryLimit;ulong_ptr JobMemoryLimit;ulong_ptr PeakProcessMemoryUsed;ulong_ptr PeakJobMemoryUsed'
Global Const $tagJOBOBJECT_GROUP_INFORMATION = ''
Global Const $tagJOBOBJECT_SECURITY_LIMIT_INFORMATION = 'dword SecurityLimitFlags;ptr JobToken;ptr SidsToDisable;ptr PrivilegesToDelete;ptr RestrictedSids'
Global Const $tagMODULEINFO = 'ptr BaseOfDll;dword SizeOfImage;ptr EntryPoint'
Global Const $tagPROCESSENTRY32 = 'dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]'
Func _WinAPI_AdjustTokenPrivileges($hToken, $aPrivileges, $iAttributes, ByRef $aAdjust)
$aAdjust = 0
If Not $aPrivileges And IsNumber($aPrivileges) Then Return 0
Local $tTP1 = 0, $tTP2, $iCount, $aCall, $bDisable = False
If $aPrivileges = -1 Then
$tTP2 = DllStructCreate('dword')
$aCall = DllCall('advapi32.dll', 'bool', 'AdjustTokenPrivileges', 'handle', $hToken, 'bool', 1, 'ptr', 0,  'dword', 0, 'struct*', $tTP2, 'dword*', 0)
If @error Then Return SetError(@error, @extended, 0)
Local $iLastError = _WinAPI_GetLastError()
Switch $iLastError
Case 122
$tTP2 = DllStructCreate('dword;dword[' & ($aCall[6] / 4 - 1) & ']')
If @error Then
ContinueCase
EndIf
Case Else
Return SetError(10, $iLastError, 0)
EndSwitch
$bDisable = True
Else
Local $aPrev = 0
If Not IsArray($aPrivileges) Then
Dim $aPrev[1][2]
$aPrev[0][0] = $aPrivileges
$aPrev[0][1] = $iAttributes
Else
If Not UBound($aPrivileges, $UBOUND_COLUMNS) Then
$iCount = UBound($aPrivileges)
Dim $aPrev[$iCount][2]
For $i = 0 To $iCount - 1
$aPrev[$i][0] = $aPrivileges[$i]
$aPrev[$i][1] = $iAttributes
Next
EndIf
EndIf
If IsArray($aPrev) Then
$aPrivileges = $aPrev
EndIf
Local $tagStruct = 'dword;dword[' & (3 * UBound($aPrivileges)) & ']'
$tTP1 = DllStructCreate($tagStruct)
$tTP2 = DllStructCreate($tagStruct)
If @error Then Return SetError(@error + 20, 0, 0)
DllStructSetData($tTP1, 1, UBound($aPrivileges))
For $i = 0 To UBound($aPrivileges) - 1
DllStructSetData($tTP1, 2, $aPrivileges[$i][1], 3 * $i + 3)
$aCall = DllCall('advapi32.dll', 'bool', 'LookupPrivilegeValueW', 'ptr', 0, 'wstr', $aPrivileges[$i][0],  'ptr', DllStructGetPtr($tTP1, 2) + 12 * $i)
If @error Or Not $aCall[0] Then Return SetError(@error + 100, @extended, 0)
Next
EndIf
$aCall = DllCall('advapi32.dll', 'bool', 'AdjustTokenPrivileges', 'handle', $hToken, 'bool', $bDisable,  'struct*', $tTP1, 'dword', DllStructGetSize($tTP2), 'struct*', $tTP2, 'dword*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 200, @extended, 0)
Local $iResult
Switch _WinAPI_GetLastError()
Case 1300
$iResult = 1
Case Else
$iResult = 0
EndSwitch
$iCount = DllStructGetData($tTP2, 1)
If $iCount Then
Local $tData = DllStructCreate('wchar[128]')
Dim $aPrivileges[$iCount][2]
For $i = 0 To $iCount - 1
$aCall = DllCall('advapi32.dll', 'bool', 'LookupPrivilegeNameW', 'ptr', 0,  'ptr', DllStructGetPtr($tTP2, 2) + 12 * $i, 'struct*', $tData, 'dword*', 128)
If @error Or Not $aCall[0] Then Return SetError(@error + 300, @extended, 0)
$aPrivileges[$i][1] = DllStructGetData($tTP2, 2, 3 * $i + 3)
$aPrivileges[$i][0] = DllStructGetData($tData, 1)
Next
$aAdjust = $aPrivileges
EndIf
Return SetExtended($iResult, 1)
EndFunc
Func _WinAPI_AssignProcessToJobObject($hJob, $hProcess)
Local $aCall = DllCall('kernel32.dll', 'bool', 'AssignProcessToJobObject', 'handle', $hJob, 'handle', $hProcess)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_AttachConsole($iPID = -1)
Local $aCall = DllCall("kernel32.dll", "bool", "AttachConsole", "dword", $iPID)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_AttachThreadInput($iAttach, $iAttachTo, $bAttach)
Local $aCall = DllCall("user32.dll", "bool", "AttachThreadInput", "dword", $iAttach, "dword", $iAttachTo, "bool", $bAttach)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateEvent($tAttributes = 0, $bManualReset = True, $bInitialState = True, $sName = "")
If $sName = "" Then $sName = Null
Local $aCall = DllCall("kernel32.dll", "handle", "CreateEventW", "struct*", $tAttributes, "bool", $bManualReset,  "bool", $bInitialState, "wstr", $sName)
If @error Then Return SetError(@error, @extended, 0)
Local $iLastError = _WinAPI_GetLastError()
If $iLastError Then Return SetExtended($iLastError, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateJobObject($sName = '', $tSecurity = 0)
If Not StringStripWS($sName, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sName = Null
Local $aCall = DllCall('kernel32.dll', 'handle', 'CreateJobObjectW', 'struct*', $tSecurity, 'wstr', $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateMutex($sMutex, $bInitial = True, $tSecurity = 0)
Local $aCall = DllCall('kernel32.dll', 'handle', 'CreateMutexW', 'struct*', $tSecurity, 'bool', $bInitial, 'wstr', $sMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateProcess($sAppName, $sCommand, $tSecurity, $tThread, $bInherit, $iFlags, $pEnviron, $sDir, $tStartupInfo, $tProcess)
Local $tCommand = 0
If $sAppName = "" Then $sAppName = Null
If $sCommand <> "" Then
$tCommand = DllStructCreate("wchar Text[" & 260 + 1 & "]")
DllStructSetData($tCommand, "Text", $sCommand)
EndIf
If $sDir = "" Then $sDir = Null
Local $aCall = DllCall("kernel32.dll", "bool", "CreateProcessW", "wstr", $sAppName, "struct*", $tCommand,  "struct*", $tSecurity, "struct*", $tThread, "bool", $bInherit, "dword", $iFlags, "struct*", $pEnviron, "wstr", $sDir,  "struct*", $tStartupInfo, "struct*", $tProcess)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateProcessWithToken($sApp, $sCmd, $iFlags, $tStartupInfo, $tProcessInfo, $hToken, $iLogon = 0, $pEnvironment = 0, $sDir = '')
If Not StringStripWS($sApp, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sApp = Null
If Not StringStripWS($sCmd, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sCmd = Null
If Not StringStripWS($sDir, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sDir = Null
Local $aCall = DllCall('advapi32.dll', 'bool', 'CreateProcessWithTokenW', 'handle', $hToken, 'dword', $iLogon,  'wstr', $sApp, 'wstr', $sCmd, 'dword', $iFlags, 'struct*', $pEnvironment,  'wstr', $sDir, 'struct*', $tStartupInfo, 'struct*', $tProcessInfo)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateSemaphore($sSemaphore, $iInitial, $iMaximum, $tSecurity = 0)
Local $aCall = DllCall('kernel32.dll', 'handle', 'CreateSemaphoreW', 'struct*', $tSecurity, 'long', $iInitial,  'long', $iMaximum, 'wstr', $sSemaphore)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_DuplicateTokenEx($hToken, $iAccess, $iLevel, $iType = 1, $tSecurity = 0)
Local $aCall = DllCall('advapi32.dll', 'bool', 'DuplicateTokenEx', 'handle', $hToken, 'dword', $iAccess,  'struct*', $tSecurity, 'int', $iLevel, 'int', $iType, 'handle*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[6]
EndFunc
Func _WinAPI_EmptyWorkingSet($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', ((_WinAPI_GetVersion() < 6.0) ? 0x00000500 : 0x00001100),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $aCall = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EmptyWorkingSet', 'handle', $hProcess[0])
If __CheckErrorCloseHandle($aCall, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_EnumChildProcess($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)
If @error Or ($hSnapshot[0] = Ptr(-1)) Then Return SetError(@error + 10, @extended, 0)
Local $tPROCESSENTRY32 = DllStructCreate($tagPROCESSENTRY32)
Local $aRet[101][2] = [[0]]
$hSnapshot = $hSnapshot[0]
DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
Local $aCall = DllCall('kernel32.dll', 'bool', 'Process32FirstW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
Local $iError = @error
While (Not @error) And ($aCall[0])
If DllStructGetData($tPROCESSENTRY32, 'ParentProcessID') = $iPID Then
__Inc($aRet)
$aRet[$aRet[0][0]][0] = DllStructGetData($tPROCESSENTRY32, 'ProcessID')
$aRet[$aRet[0][0]][1] = DllStructGetData($tPROCESSENTRY32, 'ExeFile')
EndIf
$aCall = DllCall('kernel32.dll', 'bool', 'Process32NextW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
$iError = @error
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $aRet[0][0] Then Return SetError($iError + 20, 0, 0)
__Inc($aRet, -1)
Return $aRet
EndFunc
Func _WinAPI_EnumDeviceDrivers()
Local $aCall = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumDeviceDrivers', 'ptr', 0, 'dword', 0, 'dword*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $iSize
If @AutoItX64 Then
$iSize = $aCall[3] / 8
Else
$iSize = $aCall[3] / 4
EndIf
Local $tData = DllStructCreate('ptr[' & $iSize & ']')
$aCall = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumDeviceDrivers', 'struct*', $tData,  'dword', DllStructGetSize($tData), 'dword*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 20, @extended, 0)
Local $aRet[$iSize + 1] = [$iSize]
For $i = 1 To $iSize
$aRet[$i] = DllStructGetData($tData, 1, $i)
Next
Return $aRet
EndFunc
Func _WinAPI_EnumProcessHandles($iPID = 0, $iType = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $aRet[101][4] = [[0]]
Local $tagSYSTEM_HANDLE_TABLE_ENTRY_INFO = 'ulong ProcessId;byte ObjectTypeNumber;byte Flags;ushort Handle;ptr Object;ulong GrantedAccess'
Local $tHandle = DllStructCreate($tagSYSTEM_HANDLE_TABLE_ENTRY_INFO)
Local $iEntrySize = DllStructGetSize($tHandle)
Local $iMaxEntries = 262143
Local $tSHI = DllStructCreate('ulong_ptr NumberOfHandles;byte Data[' & ($iMaxEntries + 1) * $iEntrySize & ']')
Local $aCall = DllCall('ntdll.dll', 'long', 'ZwQuerySystemInformation', 'uint', 16,  'struct*', $tSHI, 'ulong', DllStructGetSize($tSHI), 'ulong*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Local $pData = DllStructGetPtr($tSHI, 'Data')
Local $i, $iNumberOfHandles = DllStructGetData($tSHI, 'NumberOfHandles')
For $i = 1 To $iNumberOfHandles
If $i > $iMaxEntries Then ExitLoop
$tHandle = DllStructCreate($tagSYSTEM_HANDLE_TABLE_ENTRY_INFO, $pData + ($i - 1) * $iEntrySize)
If (DllStructGetData($tHandle, 'ProcessId') = $iPID) And ((Not $iType) Or ($iType = DllStructGetData($tHandle, 'ObjectTypeNumber'))) Then
__Inc($aRet)
$aRet[$aRet[0][0]][0] = Ptr(DllStructGetData($tHandle, 'Handle'))
$aRet[$aRet[0][0]][1] = DllStructGetData($tHandle, 'ObjectTypeNumber')
$aRet[$aRet[0][0]][2] = DllStructGetData($tHandle, 'Flags')
$aRet[$aRet[0][0]][3] = DllStructGetData($tHandle, 'GrantedAccess')
EndIf
Next
If Not $aRet[0][0] Then Return SetError(11, 0, 0)
__Inc($aRet, -1)
If $i < $iNumberOfHandles Then Return SetExtended($iNumberOfHandles, $aRet)
Return $aRet
EndFunc
Func _WinAPI_EnumProcessModules($iPID = 0, $iFlag = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', ((_WinAPI_GetVersion() < 6.0) ? 0x00000410 : 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $iCount, $aCall, $iError = 0
Do
If _WinAPI_GetVersion() >= 6.0 Then
$aCall = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModulesEx', 'handle', $hProcess[0], 'ptr', 0,  'dword', 0, 'dword*', 0, 'dword', $iFlag)
Else
$aCall = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModules', 'handle', $hProcess[0], 'ptr', 0,  'dword', 0, 'dword*', 0)
EndIf
If @error Or Not $aCall[0] Then
$iError = @error + 10
ExitLoop
EndIf
If @AutoItX64 Then
$iCount = $aCall[4] / 8
Else
$iCount = $aCall[4] / 4
EndIf
Local $tPtr = DllStructCreate('ptr[' & $iCount & ']')
If @error Then
$iError = @error + 30
ExitLoop
EndIf
If _WinAPI_GetVersion() >= 6.0 Then
$aCall = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModulesEx', 'handle', $hProcess[0], 'struct*', $tPtr,  'dword', DllStructGetSize($tPtr), 'dword*', 0, 'dword', $iFlag)
Else
$aCall = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModules', 'handle', $hProcess[0], 'struct*', $tPtr,  'dword', DllStructGetSize($tPtr), 'dword*', 0)
EndIf
If @error Or Not $aCall[0] Then
$iError = @error + 40
ExitLoop
EndIf
Local $aRet[$iCount + 1][2] = [[$iCount]]
For $i = 1 To $iCount
$aRet[$i][0] = DllStructGetData($tPtr, 1, $i)
$aRet[$i][1] = _WinAPI_GetModuleFileNameEx($hProcess[0], $aRet[$i][0])
Next
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Return $aRet
EndFunc
Func _WinAPI_EnumProcessThreads($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000004, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 10, @extended, 0)
Local Const $tagTHREADENTRY32 = 'dword Size;dword Usage;dword ThreadID;dword OwnerProcessID;long BasePri;long DeltaPri;dword Flags'
Local $tTHREADENTRY32 = DllStructCreate($tagTHREADENTRY32)
Local $aRet[101] = [0]
$hSnapshot = $hSnapshot[0]
DllStructSetData($tTHREADENTRY32, 'Size', DllStructGetSize($tTHREADENTRY32))
Local $aCall = DllCall('kernel32.dll', 'bool', 'Thread32First', 'handle', $hSnapshot, 'struct*', $tTHREADENTRY32)
While Not @error And $aCall[0]
If DllStructGetData($tTHREADENTRY32, 'OwnerProcessID') = $iPID Then
__Inc($aRet)
$aRet[$aRet[0]] = DllStructGetData($tTHREADENTRY32, 'ThreadID')
EndIf
$aCall = DllCall('kernel32.dll', 'bool', 'Thread32Next', 'handle', $hSnapshot, 'struct*', $tTHREADENTRY32)
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $aRet[0] Then Return SetError(1, 0, 0)
__Inc($aRet, -1)
Return $aRet
EndFunc
Func _WinAPI_EnumProcessWindows($iPID = 0, $bVisible = True)
Local $aThreads = _WinAPI_EnumProcessThreads($iPID)
If @error Then Return SetError(@error, @extended, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
For $i = 1 To $aThreads[0]
DllCall('user32.dll', 'bool', 'EnumThreadWindows', 'dword', $aThreads[$i], 'ptr', DllCallbackGetPtr($hEnumProc),  'lparam', $bVisible)
If @error Then
ExitLoop
EndIf
Next
DllCallbackFree($hEnumProc)
If Not $__g_vEnum[0][0] Then Return SetError(11, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_FatalAppExit($sMessage)
DllCall("kernel32.dll", "none", "FatalAppExitW", "uint", 0, "wstr", $sMessage)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_GetCurrentProcessExplicitAppUserModelID()
Local $aCall = DllCall('shell32.dll', 'long', 'GetCurrentProcessExplicitAppUserModelID', 'ptr*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aCall[0] Then Return SetError(10, $aCall[0], '')
Local $sID = _WinAPI_GetString($aCall[1])
_WinAPI_CoTaskMemFree($aCall[1])
Return $sID
EndFunc
Func _WinAPI_GetCurrentProcessID()
Local $aCall = DllCall("kernel32.dll", "dword", "GetCurrentProcessId")
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetCurrentThread()
Local $aCall = DllCall("kernel32.dll", "handle", "GetCurrentThread")
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetCurrentThreadId()
Local $aCall = DllCall("kernel32.dll", "dword", "GetCurrentThreadId")
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetDeviceDriverBaseName($pDriver)
Local $aCall = DllCall(@SystemDir & '\psapi.dll', 'dword', 'GetDeviceDriverBaseNameW', 'ptr', $pDriver, 'wstr', '',  'dword', 4096)
If @error Then Return SetError(@error, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_GetDeviceDriverFileName($pDriver)
Local $aCall = DllCall(@SystemDir & '\psapi.dll', 'dword', 'GetDeviceDriverFileNameW', 'ptr', $pDriver, 'wstr', '',  'dword', 4096)
If @error Then Return SetError(@error, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_GetExitCodeProcess($hProcess)
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetExitCodeProcess', 'handle', $hProcess, 'dword*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[2]
EndFunc
Func _WinAPI_GetGuiResources($iFlag = 0, $hProcess = -1)
If $hProcess = -1 Then $hProcess = _WinAPI_GetCurrentProcess()
Local $aCall = DllCall("user32.dll", "dword", "GetGuiResources", "handle", $hProcess, "dword", $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetModuleFileNameEx($hProcess, $hModule = 0)
Local $aCall = DllCall(@SystemDir & '\psapi.dll', 'dword', 'GetModuleFileNameExW', 'handle', $hProcess, 'handle', $hModule,  'wstr', '', 'int', 4096)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
Return $aCall[3]
EndFunc
Func _WinAPI_GetModuleInformation($hProcess, $hModule = 0)
Local $tMODULEINFO = DllStructCreate($tagMODULEINFO)
Local $aCall = DllCall(@SystemDir & '\psapi.dll', 'bool', 'GetModuleInformation', 'handle', $hProcess, 'handle', $hModule,  'struct*', $tMODULEINFO, 'dword', DllStructGetSize($tMODULEINFO))
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tMODULEINFO
EndFunc
Func _WinAPI_GetParentProcess($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 10, @extended, 0)
Local $tPROCESSENTRY32 = DllStructCreate($tagPROCESSENTRY32)
Local $iResult = 0
$hSnapshot = $hSnapshot[0]
DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
Local $aCall = DllCall('kernel32.dll', 'bool', 'Process32FirstW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
Local $iError = @error
While (Not @error) And ($aCall[0])
If DllStructGetData($tPROCESSENTRY32, 'ProcessID') = $iPID Then
$iResult = DllStructGetData($tPROCESSENTRY32, 'ParentProcessID')
ExitLoop
EndIf
$aCall = DllCall('kernel32.dll', 'bool', 'Process32NextW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
$iError = @error
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $iResult Then Return SetError($iError, 0, 0)
Return $iResult
EndFunc
Func _WinAPI_GetPriorityClass($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', ((_WinAPI_GetVersion() < 6.0) ? 0x00000400 : 0x00001000), 'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $iError = 0
Local $aCall = DllCall('kernel32.dll', 'dword', 'GetPriorityClass', 'handle', $hProcess[0])
If @error Then $iError = @error
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetProcessAffinityMask($hProcess)
Local $aCall = DllCall("kernel32.dll", "bool", "GetProcessAffinityMask", "handle", $hProcess, "dword_ptr*", 0, "dword_ptr*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aMask[3]
$aMask[0] = True
$aMask[1] = $aCall[2]
$aMask[2] = $aCall[3]
Return $aMask
EndFunc
Func _WinAPI_GetProcessCommandLine($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', ((_WinAPI_GetVersion() < 6.0) ? 0x00000410 : 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, '')
$hProcess = $hProcess[0]
Local $tPBI = DllStructCreate('ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId')
Local $tPEB = DllStructCreate('byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId')
Local $tUPP = DllStructCreate('ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5')
Local $tCMD
Local $aCall, $iError = 0
Do
$aCall = DllCall('ntdll.dll', 'long', 'NtQueryInformationProcess', 'handle', $hProcess, 'ulong', 0, 'struct*', $tPBI,  'ulong', DllStructGetSize($tPBI), 'ulong*', 0)
If @error Or $aCall[0] Then
$iError = @error + 30
ExitLoop
EndIf
$aCall = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPBI, 'PebBaseAddress'), 'struct*', $tPEB,  'ulong_ptr', DllStructGetSize($tPEB), 'ulong_ptr*', 0)
If @error Or Not $aCall[0] Or (Not $aCall[5]) Then
$iError = @error + 40
ExitLoop
EndIf
$aCall = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPEB, 'ProcessParameters'), 'struct*', $tUPP,  'ulong_ptr', DllStructGetSize($tUPP), 'ulong_ptr*', 0)
If @error Or Not $aCall[0] Or (Not $aCall[5]) Then
$iError = @error + 50
ExitLoop
EndIf
$tCMD = DllStructCreate('byte[' & DllStructGetData($tUPP, 'MaxLengthCommandLine') & ']')
If @error Then
$iError = @error + 60
ExitLoop
EndIf
$aCall = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tUPP, 'CommandLine'), 'struct*', $tCMD,  'ulong_ptr', DllStructGetSize($tCMD), 'ulong_ptr*', 0)
If @error Or Not $aCall[0] Or (Not $aCall[5]) Then
$iError = @error + 70
ExitLoop
EndIf
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If $iError Then Return SetError($iError, 0, '')
Return StringStripWS(_WinAPI_PathGetArgs(_WinAPI_GetString(DllStructGetPtr($tCMD, 1))), $STR_STRIPLEADING + $STR_STRIPTRAILING)
EndFunc
Func _WinAPI_GetProcessFileName($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', ((_WinAPI_GetVersion() < 6.0) ? 0x00000410 : 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, '')
Local $sPath = _WinAPI_GetModuleFileNameEx($hProcess[0])
Local $iError = @error
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError(@error, 0, '')
Return $sPath
EndFunc
Func _WinAPI_GetProcessHandleCount($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', ((_WinAPI_GetVersion() < 6.0) ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetProcessHandleCount', 'handle', $hProcess[0], 'dword*', 0)
If __CheckErrorCloseHandle($aCall, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Return $aCall[2]
EndFunc
Func _WinAPI_GetProcessID($hProcess)
Local $aCall = DllCall('kernel32.dll', 'dword', 'GetProcessId', 'handle', $hProcess)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetProcessIoCounters($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', ((_WinAPI_GetVersion() < 6.0) ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $tIO_COUNTERS = DllStructCreate('uint64[6]')
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetProcessIoCounters', 'handle', $hProcess[0], 'struct*', $tIO_COUNTERS)
If __CheckErrorCloseHandle($aCall, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Local $aRet[6]
For $i = 0 To 5
$aRet[$i] = DllStructGetData($tIO_COUNTERS, 1, $i + 1)
Next
Return $aRet
EndFunc
Func _WinAPI_GetProcessMemoryInfo($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', ((_WinAPI_GetVersion() < 6.0) ? 0x00000410 : 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $tPMC_EX = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr')
Local $aCall = DllCall(@SystemDir & '\psapi.dll', 'bool', 'GetProcessMemoryInfo', 'handle', $hProcess[0], 'struct*', $tPMC_EX,  'int', DllStructGetSize($tPMC_EX))
If __CheckErrorCloseHandle($aCall, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Local $aRet[10]
For $i = 0 To 9
$aRet[$i] = DllStructGetData($tPMC_EX, $i + 2)
Next
Return $aRet
EndFunc
Func _WinAPI_GetProcessName($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 20, @extended, '')
$hSnapshot = $hSnapshot[0]
Local $tPROCESSENTRY32 = DllStructCreate($tagPROCESSENTRY32)
DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
Local $aCall = DllCall('kernel32.dll', 'bool', 'Process32FirstW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
Local $iError = @error
While (Not @error) And ($aCall[0])
If DllStructGetData($tPROCESSENTRY32, 'ProcessID') = $iPID Then
ExitLoop
EndIf
$aCall = DllCall('kernel32.dll', 'bool', 'Process32NextW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
$iError = @error
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If $iError Then Return SetError($iError, 0, '')
If Not $aCall[0] Then SetError(10, 0, '')
Return DllStructGetData($tPROCESSENTRY32, 'ExeFile')
EndFunc
Func _WinAPI_GetProcessTimes($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', ((_WinAPI_GetVersion() < 6.0) ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $tFILETIME = DllStructCreate($tagFILETIME)
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetProcessTimes', 'handle', $hProcess[0], 'struct*', $tFILETIME, 'uint64*', 0,  'uint64*', 0, 'uint64*', 0)
If __CheckErrorCloseHandle($aCall, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Local $aRet[3]
$aRet[0] = $tFILETIME
$aRet[1] = $aCall[4]
$aRet[2] = $aCall[5]
Return $aRet
EndFunc
Func _WinAPI_GetProcessUser($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $tSID, $hToken, $aCall
Local $iError = 0
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', ((_WinAPI_GetVersion() < 6.0) ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Do
$hToken = _WinAPI_OpenProcessToken(0x00000008, $hProcess[0])
If Not $hToken Then
$iError = @error + 10
ExitLoop
EndIf
$tSID = DllStructCreate('ptr;byte[1024]')
$aCall = DllCall('advapi32.dll', 'bool', 'GetTokenInformation', 'handle', $hToken, 'uint', 1, 'struct*', $tSID,  'dword', DllStructGetSize($tSID), 'dword*', 0)
If @error Or Not $aCall[0] Then
$iError = @error + 30
ExitLoop
EndIf
$aCall = DllCall('advapi32.dll', 'bool', 'LookupAccountSidW', 'ptr', 0, 'ptr', DllStructGetData($tSID, 1), 'wstr', '',  'dword*', 2048, 'wstr', '', 'dword*', 2048, 'uint*', 0)
If @error Or Not $aCall[0] Then
$iError = @error + 40
ExitLoop
EndIf
Until 1
If $hToken Then
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Local $aRet[2]
$aRet[0] = $aCall[3]
$aRet[1] = $aCall[5]
Return $aRet
EndFunc
Func _WinAPI_GetProcessWorkingDirectory($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $aCall, $iError = 0
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', ((_WinAPI_GetVersion() < 6.0) ? 0x00000410 : 0x00001010), 'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, '')
$hProcess = $hProcess[0]
Local $tPBI = DllStructCreate('ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId')
Local $tPEB = DllStructCreate('byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId')
Local $tUPP = DllStructCreate('ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5')
Local $tDIR
Do
$aCall = DllCall('ntdll.dll', 'long', 'NtQueryInformationProcess', 'handle', $hProcess, 'ulong', 0, 'struct*', $tPBI,  'ulong', DllStructGetSize($tPBI), 'ulong*', 0)
If @error Or ($aCall[0]) Then
$iError = @error + 10
ExitLoop
EndIf
$aCall = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPBI, 'PebBaseAddress'), 'struct*', $tPEB,  'ulong_ptr', DllStructGetSize($tPEB), 'ulong_ptr*', 0)
If @error Or (Not $aCall[0]) Or (Not $aCall[5]) Then
$iError = @error + 30
ExitLoop
EndIf
$aCall = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPEB, 'ProcessParameters'), 'struct*', $tUPP,  'ulong_ptr', DllStructGetSize($tUPP), 'ulong_ptr*', 0)
If @error Or (Not $aCall[0]) Or (Not $aCall[5]) Then
$iError = @error + 40
ExitLoop
EndIf
$tDIR = DllStructCreate('byte[' & DllStructGetData($tUPP, 'MaxLengthCurrentDirectory') & ']')
If @error Then
$iError = @error + 50
ExitLoop
EndIf
$aCall = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tUPP, 'CurrentDirectory'), 'struct*', $tDIR,  'ulong_ptr', DllStructGetSize($tDIR), 'ulong_ptr*', 0)
If @error Or (Not $aCall[0]) Or (Not $aCall[5]) Then
$iError = @error + 60
ExitLoop
EndIf
$iError = 0
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If $iError Then Return SetError($iError, 0, '')
Return _WinAPI_PathRemoveBackslash(_WinAPI_GetString(DllStructGetPtr($tDIR)))
EndFunc
Func _WinAPI_GetThreadDesktop($iThreadId)
Local $aCall = DllCall('user32.dll', 'handle', 'GetThreadDesktop', 'dword', $iThreadId)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetThreadErrorMode()
Local $aCall = DllCall('kernel32.dll', 'dword', 'GetThreadErrorMode')
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetWindowFileName($hWnd)
Local $iPID = 0
Local $aCall = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hWnd)
If $aCall[0] Then
$aCall = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
$iPID = $aCall[2]
EndIf
If Not $iPID Then Return SetError(1, 0, '')
Local $sResult = _WinAPI_GetProcessFileName($iPID)
If @error Then Return SetError(@error, @extended, '')
Return $sResult
EndFunc
Func _WinAPI_IsElevated()
Local $iElev, $aCall, $iError = 0
Local $hToken = _WinAPI_OpenProcessToken(0x0008)
If Not $hToken Then Return SetError(@error + 10, @extended, False)
Do
$aCall = DllCall('advapi32.dll', 'bool', 'GetTokenInformation', 'handle', $hToken, 'uint', 20, 'uint*', 0, 'dword', 4,  'dword*', 0)
If @error Or Not $aCall[0] Then
$iError = @error + 10
ExitLoop
EndIf
$iElev = $aCall[3]
$aCall = DllCall('advapi32.dll', 'bool', 'GetTokenInformation', 'handle', $hToken, 'uint', 18, 'uint*', 0, 'dword', 4,  'dword*', 0)
If @error Or Not $aCall[0] Then
$iError = @error + 20
ExitLoop
EndIf
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
If $iError Then Return SetError($iError, 0, False)
Return SetExtended($aCall[0] - 1, $iElev)
EndFunc
Func _WinAPI_IsProcessInJob($hProcess, $hJob = 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'IsProcessInJob', 'handle', $hProcess, 'handle', $hJob, 'bool*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, False)
Return $aCall[3]
EndFunc
Func _WinAPI_OpenJobObject($sName, $iAccess = $JOB_OBJECT_ALL_ACCESS, $bInherit = False)
Local $aCall = DllCall('kernel32.dll', 'handle', 'OpenJobObjectW', 'dword', $iAccess, 'bool', $bInherit, 'wstr', $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_OpenMutex($sMutex, $iAccess = $MUTEX_ALL_ACCESS, $bInherit = False)
Local $aCall = DllCall('kernel32.dll', 'handle', 'OpenMutexW', 'dword', $iAccess, 'bool', $bInherit, 'wstr', $sMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_OpenProcess($iAccess, $bInherit, $iPID, $bDebugPriv = False)
Local $aCall = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return $aCall[0]
If Not $bDebugPriv Then Return SetError(100, 0, 0)
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 10, @extended, 0)
_Security__SetPrivilege($hToken, $SE_DEBUG_NAME, True)
Local $iError = @error
Local $iExtended = @extended
Local $iRet = 0
If Not @error Then
$aCall = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
$iError = @error
$iExtended = @extended
If $aCall[0] Then $iRet = $aCall[0]
_Security__SetPrivilege($hToken, $SE_DEBUG_NAME, False)
If @error Then
$iError = @error + 20
$iExtended = @extended
EndIf
Else
$iError = @error + 30
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
Return SetError($iError, $iExtended, $iRet)
EndFunc
Func _WinAPI_OpenProcessToken($iAccess, $hProcess = 0)
If Not $hProcess Then
$hProcess = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
$hProcess = $hProcess[0]
EndIf
Local $aCall = DllCall('advapi32.dll', 'bool', 'OpenProcessToken', 'handle', $hProcess, 'dword', $iAccess, 'handle*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[3]
EndFunc
Func _WinAPI_OpenSemaphore($sSemaphore, $iAccess = 0x001F0003, $bInherit = False)
Local $aCall = DllCall('kernel32.dll', 'handle', 'OpenSemaphoreW', 'dword', $iAccess, 'bool', $bInherit, 'wstr', $sSemaphore)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_QueryInformationJobObject($hJob, $iJobObjectInfoClass, ByRef $tJobObjectInfo)
Local $aCall = DllCall('kernel32.dll', 'bool', 'QueryInformationJobObject', 'handle', $hJob, 'int', $iJobObjectInfoClass,  'struct*', $tJobObjectInfo, 'dword', DllStructGetSize($tJobObjectInfo), 'dword*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[5]
EndFunc
Func _WinAPI_ReleaseMutex($hMutex)
Local $aCall = DllCall('kernel32.dll', 'bool', 'ReleaseMutex', 'handle', $hMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ReleaseSemaphore($hSemaphore, $iIncrease = 1)
Local $aCall = DllCall('kernel32.dll', 'bool', 'ReleaseSemaphore', 'handle', $hSemaphore, 'long', $iIncrease, 'long*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $aCall[3]
EndFunc
Func _WinAPI_ResetEvent($hEvent)
Local $aCall = DllCall('kernel32.dll', 'bool', 'ResetEvent', 'handle', $hEvent)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetEvent($hEvent)
Local $aCall = DllCall("kernel32.dll", "bool", "SetEvent", "handle", $hEvent)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetInformationJobObject($hJob, $iJobObjectInfoClass, $tJobObjectInfo)
Local $aCall = DllCall('kernel32.dll', 'bool', 'SetInformationJobObject', 'handle', $hJob, 'int', $iJobObjectInfoClass,  'struct*', $tJobObjectInfo, 'dword', DllStructGetSize($tJobObjectInfo))
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetPriorityClass($iPriority, $iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', ((_WinAPI_GetVersion() < 6.0) ? 0x00000600 : 0x00001200),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 10, @extended, 0)
Local $iError = 0
Local $aCall = DllCall('kernel32.dll', 'bool', 'SetPriorityClass', 'handle', $hProcess[0], 'dword', $iPriority)
If @error Then $iError = @error
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetProcessAffinityMask($hProcess, $iMask)
Local $aCall = DllCall("kernel32.dll", "bool", "SetProcessAffinityMask", "handle", $hProcess, "ulong_ptr", $iMask)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetThreadDesktop($hDesktop)
Local $aCall = DllCall('user32.dll', 'bool', 'SetThreadDesktop', 'handle', $hDesktop)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetThreadErrorMode($iMode)
Local $aCall = DllCall('kernel32.dll', 'bool', 'SetThreadErrorMode', 'dword', $iMode, 'dword*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $aCall[2]
EndFunc
Func _WinAPI_SetThreadExecutionState($iFlags)
Local $aCall = DllCall('kernel32.dll', 'dword', 'SetThreadExecutionState', 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_TerminateJobObject($hJob, $iExitCode = 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'TerminateJobObject', 'handle', $hJob, 'uint', $iExitCode)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_TerminateProcess($hProcess, $iExitCode = 0)
Local $aCall = DllCall('kernel32.dll', 'bool', 'TerminateProcess', 'handle', $hProcess, 'uint', $iExitCode)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_UserHandleGrantAccess($hObject, $hJob, $bGrant)
Local $aCall = DllCall('kernel32.dll', 'bool', 'UserHandleGrantAccess', 'handle', $hObject, 'handle', $hJob, 'bool', $bGrant)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_WaitForInputIdle($hProcess, $iTimeout = -1)
Local $aCall = DllCall("user32.dll", "dword", "WaitForInputIdle", "handle", $hProcess, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_WaitForMultipleObjects($iCount, $paHandles, $bWaitAll = False, $iTimeout = -1)
Local $aCall = DllCall("kernel32.dll", "INT", "WaitForMultipleObjects", "dword", $iCount, "struct*", $paHandles, "bool", $bWaitAll, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_WaitForSingleObject($hHandle, $iTimeout = -1)
Local $aCall = DllCall("kernel32.dll", "INT", "WaitForSingleObject", "handle", $hHandle, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_WriteConsole($hConsole, $sText)
Local $aCall = DllCall("kernel32.dll", "bool", "WriteConsoleW", "handle", $hConsole, "wstr", $sText,  "dword", StringLen($sText), "dword*", 0, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Global Const $KLF_ACTIVATE = 0x00000001
Global Const $KLF_NOTELLSHELL = 0x00000080
Global Const $KLF_REORDER = 0x00000008
Global Const $KLF_REPLACELANG = 0x00000010
Global Const $KLF_RESET = 0x40000000
Global Const $KLF_SETFORPROCESS = 0x00000100
Global Const $KLF_SHIFTLOCK = 0x00010000
Global Const $KLF_SUBSTITUTE_OK = 0x00000002
Global Const $HKL_NEXT = 1
Global Const $HKL_PREV = 0
Global Const $AW_ACTIVATE = 0x00020000
Global Const $AW_BLEND = 0x00080000
Global Const $AW_CENTER = 0x00000010
Global Const $AW_HIDE = 0x00010000
Global Const $AW_HOR_NEGATIVE = 0x00000002
Global Const $AW_HOR_POSITIVE = 0x00000001
Global Const $AW_SLIDE = 0x00040000
Global Const $AW_VER_NEGATIVE = 0x00000008
Global Const $AW_VER_POSITIVE = 0x00000004
Global Const $BSF_ALLOWSFW = 0x0080
Global Const $BSF_FLUSHDISK = 0x0004
Global Const $BSF_FORCEIFHUNG = 0x0020
Global Const $BSF_IGNORECURRENTTASK = 0x0002
Global Const $BSF_NOHANG = 0x0008
Global Const $BSF_NOTIMEOUTIFNOTHUNG = 0x0040
Global Const $BSF_POSTMESSAGE = 0x0010
Global Const $BSF_QUERY = 0x0001
Global Const $BSF_SENDNOTIFYMESSAGE = 0x0100
Global Const $BSM_ALLCOMPONENTS = 0x00
Global Const $BSM_ALLDESKTOPS = 0x08
Global Const $BSM_APPLICATIONS = 0x10
Global Const $BSM_INSTALLABLEDRIVERS = 0x04
Global Const $BSM_NETDRIVER = 0x02
Global Const $BSM_VXDS = 0x01
Global Const $MDITILE_HORIZONTAL = 0x01
Global Const $MDITILE_SKIPDISABLED = 0x02
Global Const $MDITILE_VERTICAL = 0x00
Global Const $MDITILE_ZORDER = 0x04
Global Const $MSGFLT_ALLOW = 1
Global Const $MSGFLT_DISALLOW = 2
Global Const $MSGFLT_RESET = 0
Global Const $MSGFLTINFO_ALLOWED_HIGHER = 3
Global Const $MSGFLTINFO_ALREADYALLOWED_FORWND = 1
Global Const $MSGFLTINFO_ALREADYDISALLOWED_FORWND = 2
Global Const $MSGFLTINFO_NONE = 0
Global Const $CWP_ALL = 0x00
Global Const $CWP_SKIPINVISIBLE = 0x01
Global Const $CWP_SKIPDISABLED = 0x02
Global Const $CWP_SKIPTRANSPARENT = 0x04
Global Const $COMPRESSION_FORMAT_NONE = 0x0000
Global Const $COMPRESSION_FORMAT_DEFAULT = 0x0001
Global Const $COMPRESSION_FORMAT_LZNT1 = 0x0002
Global Const $COMPRESSION_FORMAT_XPRESS = 0x0003
Global Const $COMPRESSION_FORMAT_XPRESS_HUFF = 0x0004
Global Const $COMPRESSION_ENGINE_STANDARD = 0x0000
Global Const $COMPRESSION_ENGINE_MAXIMUM = 0x0100
Global Const $COMPRESSION_ENGINE_HIBER = 0x0200
Global Const $WINSTA_ACCESSCLIPBOARD = 0x0004
Global Const $WINSTA_ACCESSGLOBALATOMS = 0x0020
Global Const $WINSTA_CREATEDESKTOP = 0x0008
Global Const $WINSTA_ENUMDESKTOPS = 0x0001
Global Const $WINSTA_ENUMERATE = 0x0100
Global Const $WINSTA_EXITWINDOWS = 0x0040
Global Const $WINSTA_READATTRIBUTES = 0x0002
Global Const $WINSTA_READSCREEN = 0x0200
Global Const $WINSTA_WRITEATTRIBUTES = 0x0010
Global Const $WINSTA_ALL_ACCESS = BitOR($WINSTA_ACCESSCLIPBOARD, $WINSTA_ACCESSGLOBALATOMS, $WINSTA_CREATEDESKTOP, $WINSTA_ENUMDESKTOPS, $WINSTA_ENUMERATE, $WINSTA_EXITWINDOWS, $WINSTA_READATTRIBUTES, $WINSTA_READSCREEN, $WINSTA_WRITEATTRIBUTES)
Global Const $CWF_CREATE_ONLY = 0x01
Global Const $GCL_CBCLSEXTRA = -20
Global Const $GCL_CBWNDEXTRA = -18
Global Const $GCL_HBRBACKGROUND = -10
Global Const $GCL_HCURSOR = -12
Global Const $GCL_HICON = -14
Global Const $GCL_HICONSM = -34
Global Const $GCL_HMODULE = -16
Global Const $GCL_MENUNAME = -8
Global Const $GCL_STYLE = -26
Global Const $GCL_WNDPROC = -24
Global Const $DOCKINFO_DOCKED = 0x02
Global Const $DOCKINFO_UNDOCKED = 0x01
Global Const $DOCKINFO_USER_SUPPLIED = 0x04
Global Const $DOCKINFO_USER_DOCKED = 0x05
Global Const $DOCKINFO_USER_UNDOCKED = 0x06
Global Const $GUI_CARETBLINKING = 0x0001
Global Const $GUI_INMENUMODE = 0x0004
Global Const $GUI_INMOVESIZE = 0x0002
Global Const $GUI_POPUPMENUMODE = 0x0010
Global Const $GUI_SYSTEMMENUMODE = 0x0008
Global Const $HANDLE_FLAG_INHERIT = 0x00000001
Global Const $HANDLE_FLAG_PROTECT_FROM_CLOSE = 0x00000002
Global Const $GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS = 0x0004
Global Const $GET_MODULE_HANDLE_EX_FLAG_PIN = 0x0001
Global Const $GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT = 0x0002
Global Const $GET_MODULE_HANDLE_EX_FLAG_DEFAULT = 0x0000
Global Const $PROCESSOR_ARCHITECTURE_AMD64 = 9
Global Const $PROCESSOR_ARCHITECTURE_IA64 = 6
Global Const $PROCESSOR_ARCHITECTURE_INTEL = 0
Global Const $PROCESSOR_ARCHITECTURE_UNKNOWN = 0xFFFF
Global Const $PROCESSOR_INTEL_386 = 386
Global Const $PROCESSOR_INTEL_486 = 486
Global Const $PROCESSOR_INTEL_PENTIUM = 586
Global Const $PROCESSOR_INTEL_IA64 = 2200
Global Const $PROCESSOR_AMD_X8664 = 8664
Global Const $UOI_FLAGS = 1
Global Const $UOI_HEAPSIZE = 5
Global Const $UOI_IO = 6
Global Const $UOI_NAME = 2
Global Const $UOI_TYPE = 3
Global Const $UOI_USER_SID = 4
Global Const $DF_ALLOWOTHERACCOUNTHOOK = 0x01
Global Const $WSF_VISIBLE = 0x01
Global Const $VER_SUITE_BACKOFFICE = 0x00000004
Global Const $VER_SUITE_BLADE = 0x00000400
Global Const $VER_SUITE_COMPUTE_SERVER = 0x00004000
Global Const $VER_SUITE_DATACENTER = 0x00000080
Global Const $VER_SUITE_ENTERPRISE = 0x00000002
Global Const $VER_SUITE_EMBEDDEDNT = 0x00000040
Global Const $VER_SUITE_PERSONAL = 0x00000200
Global Const $VER_SUITE_SINGLEUSERTS = 0x00000100
Global Const $VER_SUITE_SMALLBUSINESS = 0x00000001
Global Const $VER_SUITE_SMALLBUSINESS_RESTRICTED = 0x00000020
Global Const $VER_SUITE_STORAGE_SERVER = 0x00002000
Global Const $VER_SUITE_TERMINAL = 0x00000010
Global Const $VER_SUITE_WH_SERVER = 0x00008000
Global Const $VER_NT_DOMAIN_CONTROLLER = 0x0000002
Global Const $VER_NT_SERVER = 0x0000003
Global Const $VER_NT_WORKSTATION = 0x0000001
Global Const $WDA_MONITOR = 0x01
Global Const $WDA_NONE = 0x00
Global Const $PF_3DNOW_INSTRUCTIONS_AVAILABLE = 7
Global Const $PF_CHANNELS_ENABLED = 16
Global Const $PF_COMPARE_EXCHANGE_DOUBLE = 2
Global Const $PF_COMPARE_EXCHANGE128 = 14
Global Const $PF_COMPARE64_EXCHANGE128 = 15
Global Const $PF_FLOATING_POINT_EMULATED = 1
Global Const $PF_FLOATING_POINT_PRECISION_ERRATA = 0
Global Const $PF_MMX_INSTRUCTIONS_AVAILABLE = 3
Global Const $PF_NX_ENABLED = 12
Global Const $PF_PAE_ENABLED = 9
Global Const $PF_RDTSC_INSTRUCTION_AVAILABLE = 8
Global Const $PF_SSE3_INSTRUCTIONS_AVAILABLE = 13
Global Const $PF_XMMI_INSTRUCTIONS_AVAILABLE = 6
Global Const $PF_XMMI64_INSTRUCTIONS_AVAILABLE = 10
Global Const $PF_XSAVE_ENABLED = 17
Global Const $KEYEVENTF_EXTENDEDKEY = 0x01
Global Const $KEYEVENTF_KEYUP = 0x02
Global Const $LIM_SMALL = 0
Global Const $LIM_LARGE = 1
Global Const $MAPVK_VK_TO_CHAR = 2
Global Const $MAPVK_VK_TO_VSC = 0
Global Const $MAPVK_VK_TO_VSC_EX = 4
Global Const $MAPVK_VSC_TO_VK = 1
Global Const $MAPVK_VSC_TO_VK_EX = 3
Global Const $MOD_ALT = 0x0001
Global Const $MOD_CONTROL = 0x0002
Global Const $MOD_NOREPEAT = 0x4000
Global Const $MOD_SHIFT = 0x0004
Global Const $MOD_WIN = 0x0008
Global Const $GUID_ACDC_POWER_SOURCE = '{5D3E9A59-E9D5-4B00-A6BD-FF34FF516548}'
Global Const $GUID_BATTERY_PERCENTAGE_REMAINING = '{A7AD8041-B45A-4CAE-87A3-EECBB468A9E1}'
Global Const $GUID_IDLE_BACKGROUND_TASK = '{515C31D8-F734-163D-A0FD-11A08C91E8F1}'
Global Const $GUID_MONITOR_POWER_ON = '{02731015-4510-4526-99E6-E5A17EBD1AEA}'
Global Const $GUID_POWERSCHEME_PERSONALITY = '{245D8541-3943-4422-B025-13A784F679B7}'
Global Const $GUID_SYSTEM_AWAYMODE = '{98A7F580-01F7-48AA-9C0F-44352C29E5C0}'
Global Const $GUID_MIN_POWER_SAVINGS = '{8C5E7FDA-E8BF-4A96-9A85-A6E23A8C635C}'
Global Const $GUID_MAX_POWER_SAVINGS = '{A1841308-3541-4FAB-BC81-F71556F20B4A}'
Global Const $GUID_TYPICAL_POWER_SAVINGS = '{381B4222-F694-41F0-9685-FF5BB260DF2E}'
Global Const $HSHELL_WINDOWCREATED = 1
Global Const $HSHELL_WINDOWDESTROYED = 2
Global Const $HSHELL_ACTIVATESHELLWINDOW = 3
Global Const $HSHELL_WINDOWACTIVATED = 4
Global Const $HSHELL_GETMINRECT = 5
Global Const $HSHELL_REDRAW = 6
Global Const $HSHELL_TASKMAN = 7
Global Const $HSHELL_LANGUAGE = 8
Global Const $HSHELL_SYSMENU = 9
Global Const $HSHELL_ENDTASK = 10
Global Const $HSHELL_ACCESSIBILITYSTATE = 11
Global Const $HSHELL_APPCOMMAND = 12
Global Const $HSHELL_WINDOWREPLACED = 13
Global Const $HSHELL_WINDOWREPLACING = 14
Global Const $HSHELL_RUDEAPPACTIVATED = 32772
Global Const $HSHELL_FLASH = 32774
Global Const $HWND_BROADCAST = 0xFFFF
Global Const $SMTO_BLOCK = 0x0001
Global Const $SMTO_NORMAL = 0x0000
Global Const $SMTO_ABORTIFHUNG = 0x0002
Global Const $SMTO_NOTIMEOUTIFNOTHUNG = 0x0008
Global Const $SMTO_ERRORONEXIT = 0x0020
Global Const $INPUTLANGCHANGE_BACKWARD = 0x0004
Global Const $INPUTLANGCHANGE_FORWARD = 0x0002
Global Const $INPUTLANGCHANGE_SYSCHARSET = 0x0001
Global Const $EVENT_MIN = 0x00000001
Global Const $EVENT_SYSTEM_SOUND = 0x00000001
Global Const $EVENT_SYSTEM_ALERT = 0x00000002
Global Const $EVENT_SYSTEM_FOREGROUND = 0x00000003
Global Const $EVENT_SYSTEM_MENUSTART = 0x00000004
Global Const $EVENT_SYSTEM_MENUEND = 0x00000005
Global Const $EVENT_SYSTEM_MENUPOPUPSTART = 0x00000006
Global Const $EVENT_SYSTEM_MENUPOPUPEND = 0x00000007
Global Const $EVENT_SYSTEM_CAPTURESTART = 0x00000008
Global Const $EVENT_SYSTEM_CAPTUREEND = 0x00000009
Global Const $EVENT_SYSTEM_MOVESIZESTART = 0x0000000A
Global Const $EVENT_SYSTEM_MOVESIZEEND = 0x0000000B
Global Const $EVENT_SYSTEM_CONTEXTHELPSTART = 0x0000000C
Global Const $EVENT_SYSTEM_CONTEXTHELPEND = 0x0000000D
Global Const $EVENT_SYSTEM_DRAGDROPSTART = 0x0000000E
Global Const $EVENT_SYSTEM_DRAGDROPEND = 0x0000000F
Global Const $EVENT_SYSTEM_DIALOGSTART = 0x00000010
Global Const $EVENT_SYSTEM_DIALOGEND = 0x00000011
Global Const $EVENT_SYSTEM_SCROLLINGSTART = 0x00000012
Global Const $EVENT_SYSTEM_SCROLLINGEND = 0x00000013
Global Const $EVENT_SYSTEM_SWITCHSTART = 0x00000014
Global Const $EVENT_SYSTEM_SWITCHEND = 0x00000015
Global Const $EVENT_SYSTEM_MINIMIZESTART = 0x00000016
Global Const $EVENT_SYSTEM_MINIMIZEEND = 0x00000017
Global Const $EVENT_SYSTEM_DESKTOPSWITCH = 0x00000020
Global Const $EVENT_OBJECT_CREATE = 0x00008000
Global Const $EVENT_OBJECT_DESTROY = 0x00008001
Global Const $EVENT_OBJECT_SHOW = 0x00008002
Global Const $EVENT_OBJECT_HIDE = 0x00008003
Global Const $EVENT_OBJECT_REORDER = 0x00008004
Global Const $EVENT_OBJECT_FOCUS = 0x00008005
Global Const $EVENT_OBJECT_SELECTION = 0x00008006
Global Const $EVENT_OBJECT_SELECTIONADD = 0x00008007
Global Const $EVENT_OBJECT_SELECTIONREMOVE = 0x00008008
Global Const $EVENT_OBJECT_SELECTIONWITHIN = 0x00008009
Global Const $EVENT_OBJECT_STATECHANGE = 0x0000800A
Global Const $EVENT_OBJECT_LOCATIONCHANGE = 0x0000800B
Global Const $EVENT_OBJECT_NAMECHANGE = 0x0000800C
Global Const $EVENT_OBJECT_DESCRIPTIONCHANGE = 0x0000800D
Global Const $EVENT_OBJECT_VALUECHANGE = 0x0000800E
Global Const $EVENT_OBJECT_PARENTCHANGE = 0x0000800F
Global Const $EVENT_OBJECT_HELPCHANGE = 0x00008010
Global Const $EVENT_OBJECT_DEFACTIONCHANGE = 0x00008011
Global Const $EVENT_OBJECT_ACCELERATORCHANGE = 0x00008012
Global Const $EVENT_OBJECT_INVOKED = 0x00008013
Global Const $EVENT_OBJECT_TEXTSELECTIONCHANGED = 0x00008014
Global Const $EVENT_OBJECT_CONTENTSCROLLED = 0x00008015
Global Const $EVENT_MAX = 0x7FFFFFFF
Global Const $WINEVENT_INCONTEXT = 0x04
Global Const $WINEVENT_OUTOFCONTEXT = 0x00
Global Const $WINEVENT_SKIPOWNPROCESS = 0x02
Global Const $WINEVENT_SKIPOWNTHREAD = 0x01
Global Const $TME_CANCEL = 0x80000000
Global Const $TME_HOVER = 0x00000001
Global Const $TME_LEAVE = 0x00000002
Global Const $TME_NONCLIENT = 0x00000010
Global Const $TME_QUERY = 0x40000000
Global Const $DESKTOP_CREATEMENU = 0x0004
Global Const $DESKTOP_CREATEWINDOW = 0x0002
Global Const $DESKTOP_ENUMERATE = 0x0040
Global Const $DESKTOP_HOOKCONTROL = 0x0008
Global Const $DESKTOP_JOURNALPLAYBACK = 0x0020
Global Const $DESKTOP_JOURNALRECORD = 0x0010
Global Const $DESKTOP_READOBJECTS = 0x0001
Global Const $DESKTOP_SWITCHDESKTOP = 0x0100
Global Const $DESKTOP_WRITEOBJECTS = 0x0080
Global Const $DESKTOP_ALL_ACCESS = BitOR($DESKTOP_CREATEMENU, $DESKTOP_CREATEWINDOW, $DESKTOP_ENUMERATE, $DESKTOP_HOOKCONTROL, $DESKTOP_JOURNALPLAYBACK, $DESKTOP_JOURNALRECORD, $DESKTOP_READOBJECTS, $DESKTOP_SWITCHDESKTOP, $DESKTOP_WRITEOBJECTS)
Global Const $RIDEV_APPKEYS = 0x00000400
Global Const $RIDEV_CAPTUREMOUSE = 0x00000200
Global Const $RIDEV_DEVNOTIFY = 0x00002000
Global Const $RIDEV_EXCLUDE = 0x00000010
Global Const $RIDEV_EXINPUTSINK = 0x00001000
Global Const $RIDEV_INPUTSINK = 0x00000100
Global Const $RIDEV_NOHOTKEYS = 0x00000200
Global Const $RIDEV_NOLEGACY = 0x00000030
Global Const $RIDEV_PAGEONLY = 0x00000020
Global Const $RIDEV_REMOVE = 0x00000001
Global Const $RID_HEADER = 0x10000005
Global Const $RID_INPUT = 0x10000003
Global Const $RIM_TYPEHID = 2
Global Const $RIM_TYPEKEYBOARD = 1
Global Const $RIM_TYPEMOUSE = 0
Global Const $RIDI_DEVICENAME = 0x20000007
Global Const $RIDI_DEVICEINFO = 0x2000000B
Global Const $RIDI_PREPARSEDDATA = 0x20000005
Global Const $MOUSE_ATTRIBUTES_CHANGED = 0x04
Global Const $MOUSE_MOVE_ABSOLUTE = 0x01
Global Const $MOUSE_MOVE_RELATIVE = 0x00
Global Const $MOUSE_VIRTUAL_DESKTOP = 0x02
Global Const $RI_MOUSE_LEFT_BUTTON_DOWN = 0x0001
Global Const $RI_MOUSE_LEFT_BUTTON_UP = 0x0002
Global Const $RI_MOUSE_MIDDLE_BUTTON_DOWN = 0x0010
Global Const $RI_MOUSE_MIDDLE_BUTTON_UP = 0x0020
Global Const $RI_MOUSE_RIGHT_BUTTON_DOWN = 0x0004
Global Const $RI_MOUSE_RIGHT_BUTTON_UP = 0x0008
Global Const $RI_MOUSE_BUTTON_1_DOWN = $RI_MOUSE_LEFT_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_1_UP = $RI_MOUSE_LEFT_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_2_DOWN = $RI_MOUSE_RIGHT_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_2_UP = $RI_MOUSE_RIGHT_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_3_DOWN = $RI_MOUSE_MIDDLE_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_3_UP = $RI_MOUSE_MIDDLE_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_4_DOWN = 0x0040
Global Const $RI_MOUSE_BUTTON_4_UP = 0x0080
Global Const $RI_MOUSE_BUTTON_5_DOWN = 0x0100
Global Const $RI_MOUSE_BUTTON_5_UP = 0x0200
Global Const $RI_MOUSE_WHEEL = 0x0400
Global Const $RI_KEY_BREAK = 1
Global Const $RI_KEY_E0 = 2
Global Const $RI_KEY_E1 = 4
Global Const $RI_KEY_MAKE = 0
Global Const $FLASHW_CAPTION = 0x00000001
Global Const $FLASHW_TRAY = 0x00000002
Global Const $FLASHW_TIMER = 0x00000004
Global Const $FLASHW_TIMERNOFG = 0x0000000C
Global Const $tagUPDATELAYEREDWINDOWINFO = 'dword Size;hwnd hDstDC;long DstX;long DstY;long cX;long cY;hwnd hSrcDC;long SrcX;long SrcY;dword crKey;byte BlendOp;byte BlendFlags;byte Alpha;byte AlphaFormat;dword Flags;long DirtyLeft;long DirtyTop;long DirtyRight;long DirtyBottom'
Global Const $tagWINDOWINFO = 'dword Size;struct;long rWindow[4];endstruct;struct;long rClient[4];endstruct;dword Style;dword ExStyle;dword WindowStatus;uint cxWindowBorders;uint cyWindowBorders;word atomWindowType;word CreatorVersion'
Global Const $tagWNDCLASS = 'uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName'
Global Const $tagWNDCLASSEX = 'uint Size;uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName;ptr hIconSm'
Global Const $tagFLASHWINFO = "uint Size;hwnd hWnd;dword Flags;uint Count;dword TimeOut"
Func _WinAPI_AdjustWindowRectEx(ByRef $tRECT, $iStyle, $iExStyle = 0, $bMenu = False)
Local $aCall = DllCall('user32.dll', 'bool', 'AdjustWindowRectEx', 'struct*', $tRECT, 'dword', $iStyle, 'bool', $bMenu,  'dword', $iExStyle)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_AnimateWindow($hWnd, $iFlags, $iDuration = 1000)
Local $aCall = DllCall('user32.dll', 'bool', 'AnimateWindow', 'hwnd', $hWnd, 'dword', $iDuration, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_BeginDeferWindowPos($iAmount = 1)
Local $aCall = DllCall('user32.dll', 'handle', 'BeginDeferWindowPos', 'int', $iAmount)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_BringWindowToTop($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'BringWindowToTop', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_BroadcastSystemMessage($iMsg, $wParam = 0, $lParam = 0, $iFlags = 0, $iRecipients = 0)
Local $aCall = DllCall('user32.dll', 'long', 'BroadcastSystemMessageW', 'dword', $iFlags, 'dword*', $iRecipients,  'uint', $iMsg, 'wparam', $wParam, 'lparam', $lParam)
If @error Or ($aCall[0] = -1) Then Return SetError(@error, @extended, -1)
Return SetExtended($aCall[2], $aCall[0])
EndFunc
Func _WinAPI_CallWindowProc($pPrevWndFunc, $hWnd, $iMsg, $wParam, $lParam)
Local $aCall = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", $pPrevWndFunc, "hwnd", $hWnd, "uint", $iMsg,  "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_CallWindowProcW($pPrevWndProc, $hWnd, $iMsg, $wParam, $lParam)
Local $aCall = DllCall('user32.dll', 'lresult', 'CallWindowProcW', 'ptr', $pPrevWndProc, 'hwnd', $hWnd, 'uint', $iMsg,  'wparam', $wParam, 'lparam', $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CascadeWindows($aWnds, $tRECT = 0, $hParent = 0, $iFlags = 0, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aWnds, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $iCount = $iEnd - $iStart + 1
Local $tWnds = DllStructCreate('hwnd[' & $iCount & ']')
$iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tWnds, 1, $aWnds[$i], $iCount)
$iCount += 1
Next
Local $aCall = DllCall('user32.dll', 'word', 'CascadeWindows', 'hwnd', $hParent, 'uint', $iFlags, 'struct*', $tRECT,  'uint', $iCount - 1, 'struct*', $tWnds)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ChangeWindowMessageFilterEx($hWnd, $iMsg, $iAction)
Local $tCFS, $aCall
If $hWnd And (_WinAPI_GetVersion() > 6.0) Then
Local Const $tagCHANGEFILTERSTRUCT = 'dword cbSize; dword ExtStatus'
$tCFS = DllStructCreate($tagCHANGEFILTERSTRUCT)
DllStructSetData($tCFS, 1, DllStructGetSize($tCFS))
$aCall = DllCall('user32.dll', 'bool', 'ChangeWindowMessageFilterEx', 'hwnd', $hWnd, 'uint', $iMsg, 'dword', $iAction,  'struct*', $tCFS)
Else
$tCFS = 0
$aCall = DllCall('user32.dll', 'bool', 'ChangeWindowMessageFilter', 'uint', $iMsg, 'dword', $iAction)
EndIf
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended(DllStructGetData($tCFS, 2), 1)
EndFunc
Func _WinAPI_ChildWindowFromPointEx($hWnd, $tPOINT, $iFlags = 0)
Local $aCall = DllCall('user32.dll', 'hwnd', 'ChildWindowFromPointEx', 'hwnd', $hWnd, 'struct', $tPOINT, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CloseWindow($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'CloseWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DeferWindowPos($hInfo, $hWnd, $hAfter, $iX, $iY, $iWidth, $iHeight, $iFlags)
Local $aCall = DllCall('user32.dll', 'handle', 'DeferWindowPos', 'handle', $hInfo, 'hwnd', $hWnd, 'hwnd', $hAfter,  'int', $iX, 'int', $iY, 'int', $iWidth, 'int', $iHeight, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_DefWindowProc($hWnd, $iMsg, $wParam, $lParam)
Local $aCall = DllCall("user32.dll", "lresult", "DefWindowProc", "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam,  "lparam", $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_DefWindowProcW($hWnd, $iMsg, $wParam, $lParam)
Local $aCall = DllCall('user32.dll', 'lresult', 'DefWindowProcW', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam,  'lparam', $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_DeregisterShellHookWindow($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'DeregisterShellHookWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_DragAcceptFiles($hWnd, $bAccept = True)
DllCall('shell32.dll', 'none', 'DragAcceptFiles', 'hwnd', $hWnd, 'bool', $bAccept)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_DragFinish($hDrop)
DllCall('shell32.dll', 'none', 'DragFinish', 'handle', $hDrop)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_DragQueryFileEx($hDrop, $iFlag = 0)
Local $aCall = DllCall('shell32.dll', 'uint', 'DragQueryFileW', 'handle', $hDrop, 'uint', -1, 'ptr', 0, 'uint', 0)
If @error Then Return SetError(@error, @extended, 0)
If Not $aCall[0] Then Return SetError(10, 0, 0)
Local $iCount = $aCall[0], $iValidRow = 0
Local $aRet[$iCount + 1]
For $i = 0 To $iCount - 1
$aCall = DllCall('shell32.dll', 'uint', 'DragQueryFileW', 'handle', $hDrop, 'uint', $i, 'wstr', '', 'uint', 4096)
If Not $aCall[0] Then Return SetError(11, 0, 0)
If $iFlag Then
Local $bDir = _WinAPI_PathIsDirectory($aCall[3])
If (($iFlag = 1) And $bDir) Or (($iFlag = 2) And Not $bDir) Then
ContinueLoop
EndIf
EndIf
$iValidRow += 1
$aRet[$iValidRow] = $aCall[3]
$aRet[0] += 1
Next
If Not $aRet[0] Then Return SetError(12, 0, 0)
__Inc($aRet, -1)
Return $aRet
EndFunc
Func _WinAPI_DragQueryPoint($hDrop)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aCall = DllCall('shell32.dll', 'bool', 'DragQueryPoint', 'handle', $hDrop, 'struct*', $tPOINT)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_EndDeferWindowPos($hInfo)
Local $aCall = DllCall('user32.dll', 'bool', 'EndDeferWindowPos', 'handle', $hInfo)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_EnumChildWindows($hWnd, $bVisible = True)
If Not _WinAPI_GetWindow($hWnd, 5) Then Return SetError(2, 0, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
DllCall('user32.dll', 'bool', 'EnumChildWindows', 'hwnd', $hWnd, 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $bVisible)
If @error Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_FindWindow($sClassName, $sWindowName)
Local $aCall = DllCall("user32.dll", "hwnd", "FindWindowW", "wstr", $sClassName, "wstr", $sWindowName)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_FlashWindow($hWnd, $bInvert = True)
Local $aCall = DllCall("user32.dll", "bool", "FlashWindow", "hwnd", $hWnd, "bool", $bInvert)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_FlashWindowEx($hWnd, $iFlags = 3, $iCount = 3, $iTimeout = 0)
Local $tFlash = DllStructCreate($tagFLASHWINFO)
Local $iFlash = DllStructGetSize($tFlash)
Local $iMode = 0
If BitAND($iFlags, 1) <> 0 Then $iMode = BitOR($iMode, $FLASHW_CAPTION)
If BitAND($iFlags, 2) <> 0 Then $iMode = BitOR($iMode, $FLASHW_TRAY)
If BitAND($iFlags, 4) <> 0 Then $iMode = BitOR($iMode, $FLASHW_TIMER)
If BitAND($iFlags, 8) <> 0 Then $iMode = BitOR($iMode, $FLASHW_TIMERNOFG)
DllStructSetData($tFlash, "Size", $iFlash)
DllStructSetData($tFlash, "hWnd", $hWnd)
DllStructSetData($tFlash, "Flags", $iMode)
DllStructSetData($tFlash, "Count", $iCount)
DllStructSetData($tFlash, "Timeout", $iTimeout)
Local $aCall = DllCall("user32.dll", "bool", "FlashWindowEx", "struct*", $tFlash)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_GetAncestor($hWnd, $iFlags = 1)
Local $aCall = DllCall("user32.dll", "hwnd", "GetAncestor", "hwnd", $hWnd, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetClassInfoEx($sClass, $hInstance = 0)
Local $sTypeOfClass = 'wstr'
If Not IsString($sClass) Then $sTypeOfClass = 'ptr'
Local $tWNDCLASSEX = DllStructCreate($tagWNDCLASSEX)
Local $aCall = DllCall('user32.dll', 'bool', 'GetClassInfoExW', 'handle', $hInstance, $sTypeOfClass, $sClass,  'struct*', $tWNDCLASSEX)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tWNDCLASSEX
EndFunc
Func _WinAPI_GetClassLongEx($hWnd, $iIndex)
Local $aCall
If @AutoItX64 Then
$aCall = DllCall('user32.dll', 'ulong_ptr', 'GetClassLongPtrW', 'hwnd', $hWnd, 'int', $iIndex)
Else
$aCall = DllCall('user32.dll', 'dword', 'GetClassLongW', 'hwnd', $hWnd, 'int', $iIndex)
EndIf
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetClientHeight($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top")
EndFunc
Func _WinAPI_GetClientWidth($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndFunc
Func _WinAPI_GetDlgItem($hWnd, $iItemID)
Local $aCall = DllCall("user32.dll", "hwnd", "GetDlgItem", "hwnd", $hWnd, "int", $iItemID)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetForegroundWindow()
Local $aCall = DllCall("user32.dll", "hwnd", "GetForegroundWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetGUIThreadInfo($iThreadId)
Local Const $tagGUITHREADINFO = 'dword Size;dword Flags;hwnd hWndActive;hwnd hWndFocus;hwnd hWndCapture;hwnd hWndMenuOwner;hwnd hWndMoveSize;hwnd hWndCaret;struct rcCaret;long left;long top;long right;long bottom;endstruct'
Local $tGTI = DllStructCreate($tagGUITHREADINFO)
DllStructSetData($tGTI, 1, DllStructGetSize($tGTI))
Local $aCall = DllCall('user32.dll', 'bool', 'GetGUIThreadInfo', 'dword', $iThreadId, 'struct*', $tGTI)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aRet[11]
For $i = 0 To 10
$aRet[$i] = DllStructGetData($tGTI, $i + 2)
Next
For $i = 9 To 10
$aRet[$i] -= $aRet[$i - 2]
Next
Return $aRet
EndFunc
Func _WinAPI_GetLastActivePopup($hWnd)
Local $aCall = DllCall('user32.dll', 'hwnd', 'GetLastActivePopup', 'hwnd', $hWnd)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
If $aCall[0] = $hWnd Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetLayeredWindowAttributes($hWnd, ByRef $iTransColor, ByRef $iTransGUI, $bColorRef = False)
$iTransColor = -1
$iTransGUI = -1
Local $aCall = DllCall("user32.dll", "bool", "GetLayeredWindowAttributes", "hwnd", $hWnd, "INT*", $iTransColor,  "byte*", $iTransGUI, "dword*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
If Not $bColorRef Then
$aCall[2] = Int(BinaryMid($aCall[2], 3, 1) & BinaryMid($aCall[2], 2, 1) & BinaryMid($aCall[2], 1, 1))
EndIf
$iTransColor = $aCall[2]
$iTransGUI = $aCall[3]
Return $aCall[4]
EndFunc
Func _WinAPI_GetMessageExtraInfo()
Local $aCall = DllCall('user32.dll', 'lparam', 'GetMessageExtraInfo')
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetShellWindow()
Local $aCall = DllCall('user32.dll', 'hwnd', 'GetShellWindow')
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetTopWindow($hWnd)
Local $aCall = DllCall('user32.dll', 'hwnd', 'GetTopWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetWindowDisplayAffinity($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'GetWindowDisplayAffinity', 'hwnd', $hWnd, 'dword*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $aCall[2]
EndFunc
Func _WinAPI_GetWindowInfo($hWnd)
Local $tWINDOWINFO = DllStructCreate($tagWINDOWINFO)
DllStructSetData($tWINDOWINFO, 'Size', DllStructGetSize($tWINDOWINFO))
Local $aCall = DllCall('user32.dll', 'bool', 'GetWindowInfo', 'hwnd', $hWnd, 'struct*', $tWINDOWINFO)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tWINDOWINFO
EndFunc
Func _WinAPI_GetWindowPlacement($hWnd)
Local $tWindowPlacement = DllStructCreate($tagWINDOWPLACEMENT)
DllStructSetData($tWindowPlacement, "length", DllStructGetSize($tWindowPlacement))
Local $aCall = DllCall("user32.dll", "bool", "GetWindowPlacement", "hwnd", $hWnd, "struct*", $tWindowPlacement)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tWindowPlacement
EndFunc
Func _WinAPI_IsChild($hWnd, $hWndParent)
Local $aCall = DllCall('user32.dll', 'bool', 'IsChild', 'hwnd', $hWndParent, 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_IsHungAppWindow($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'IsHungAppWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_IsIconic($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'IsIconic', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_IsWindowUnicode($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'IsWindowUnicode', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_IsZoomed($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'IsZoomed', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_KillTimer($hWnd, $iTimerID)
Local $aCall = DllCall('user32.dll', 'bool', 'KillTimer', 'hwnd', $hWnd, 'uint_ptr', $iTimerID)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_OpenIcon($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'OpenIcon', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_PostMessage($hWnd, $iMsg, $wParam, $lParam)
Local $aCall = DllCall("user32.dll", "bool", "PostMessage", "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam,  "lparam", $lParam)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_RegisterClass($tWNDCLASS)
Local $aCall = DllCall('user32.dll', 'word', 'RegisterClassW', 'struct*', $tWNDCLASS)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_RegisterClassEx($tWNDCLASSEX)
Local $aCall = DllCall('user32.dll', 'word', 'RegisterClassExW', 'struct*', $tWNDCLASSEX)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_RegisterShellHookWindow($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'RegisterShellHookWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_RegisterWindowMessage($sMessage)
Local $aCall = DllCall("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $sMessage)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SendMessageTimeout($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iTimeout = 1000, $iFlags = 0)
Local $aCall = DllCall('user32.dll', 'lresult', 'SendMessageTimeoutW', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam,  'lparam', $lParam, 'uint', $iFlags, 'uint', $iTimeout, 'dword_ptr*', 0)
If @error Then Return SetError(@error, @extended, -1)
If Not $aCall[0] Then Return SetError(10, _WinAPI_GetLastError(), -1)
Return $aCall[7]
EndFunc
Func _WinAPI_SetClassLongEx($hWnd, $iIndex, $iNewLong)
Local $aCall
If @AutoItX64 Then
$aCall = DllCall('user32.dll', 'ulong_ptr', 'SetClassLongPtrW', 'hwnd', $hWnd, 'int', $iIndex, 'long_ptr', $iNewLong)
Else
$aCall = DllCall('user32.dll', 'dword', 'SetClassLongW', 'hwnd', $hWnd, 'int', $iIndex, 'long', $iNewLong)
EndIf
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetForegroundWindow($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'SetForegroundWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetLayeredWindowAttributes($hWnd, $iTransColor, $iTransGUI = 255, $iFlags = 0x03, $bColorRef = False)
If $iFlags = Default Or $iFlags = "" Or $iFlags < 0 Then $iFlags = 0x03
If Not $bColorRef Then
$iTransColor = Int(BinaryMid($iTransColor, 3, 1) & BinaryMid($iTransColor, 2, 1) & BinaryMid($iTransColor, 1, 1))
EndIf
Local $aCall = DllCall("user32.dll", "bool", "SetLayeredWindowAttributes", "hwnd", $hWnd, "INT", $iTransColor,  "byte", $iTransGUI, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetMessageExtraInfo($lParam)
Local $aCall = DllCall('user32.dll', 'lparam', 'SetMessageExtraInfo', 'lparam', $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetSysColors($vElements, $vColors)
Local $bIsEArray = IsArray($vElements), $bIsCArray = IsArray($vColors)
Local $iElementNum
If Not $bIsCArray And Not $bIsEArray Then
$iElementNum = 1
ElseIf $bIsCArray Or $bIsEArray Then
If Not $bIsCArray Or Not $bIsEArray Then Return SetError(-1, -1, False)
If UBound($vElements) <> UBound($vColors) Then Return SetError(-1, -1, False)
$iElementNum = UBound($vElements)
EndIf
Local $tElements = DllStructCreate("int Element[" & $iElementNum & "]")
Local $tColors = DllStructCreate("INT NewColor[" & $iElementNum & "]")
If Not $bIsEArray Then
DllStructSetData($tElements, "Element", $vElements, 1)
Else
For $x = 0 To $iElementNum - 1
DllStructSetData($tElements, "Element", $vElements[$x], $x + 1)
Next
EndIf
If Not $bIsCArray Then
DllStructSetData($tColors, "NewColor", $vColors, 1)
Else
For $x = 0 To $iElementNum - 1
DllStructSetData($tColors, "NewColor", $vColors[$x], $x + 1)
Next
EndIf
Local $aCall = DllCall("user32.dll", "bool", "SetSysColors", "int", $iElementNum, "struct*", $tElements, "struct*", $tColors)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetTimer($hWnd, $iTimerID, $iElapse, $pTimerFunc)
Local $aCall = DllCall('user32.dll', 'uint_ptr', 'SetTimer', 'hwnd', $hWnd, 'uint_ptr', $iTimerID, 'uint', $iElapse,  'ptr', $pTimerFunc)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetWindowDisplayAffinity($hWnd, $iAffinity)
Local $aCall = DllCall('user32.dll', 'bool', 'SetWindowDisplayAffinity', 'hwnd', $hWnd, 'dword', $iAffinity)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetWindowLong($hWnd, $iIndex, $iValue)
_WinAPI_SetLastError(0)
Local $sFuncName = "SetWindowLongW"
If @AutoItX64 Then $sFuncName = "SetWindowLongPtrW"
Local $aCall = DllCall("user32.dll", "long_ptr", $sFuncName, "hwnd", $hWnd, "int", $iIndex, "long_ptr", $iValue)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetWindowPlacement($hWnd, $tWindowPlacement)
Local $aCall = DllCall("user32.dll", "bool", "SetWindowPlacement", "hwnd", $hWnd, "struct*", $tWindowPlacement)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ShowOwnedPopups($hWnd, $bShow)
Local $aCall = DllCall('user32.dll', 'bool', 'ShowOwnedPopups', 'hwnd', $hWnd, 'bool', $bShow)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SwitchToThisWindow($hWnd, $bAltTab = False)
DllCall('user32.dll', 'none', 'SwitchToThisWindow', 'hwnd', $hWnd, 'bool', $bAltTab)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_TileWindows($aWnds, $tRECT = 0, $hParent = 0, $iFlags = 0, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aWnds, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $iCount = $iEnd - $iStart + 1
Local $tWnds = DllStructCreate('hwnd[' & $iCount & ']')
$iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tWnds, 1, $aWnds[$i], $iCount)
$iCount += 1
Next
Local $aCall = DllCall('user32.dll', 'word', 'TileWindows', 'hwnd', $hParent, 'uint', $iFlags, 'struct*', $tRECT,  'uint', $iCount - 1, 'struct*', $tWnds)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_UnregisterClass($sClass, $hInstance = 0)
Local $sTypeOfClass = 'wstr'
If Not IsString($sClass) Then $sTypeOfClass = 'ptr'
Local $aCall = DllCall('user32.dll', 'bool', 'UnregisterClassW', $sTypeOfClass, $sClass, 'handle', $hInstance)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_UpdateLayeredWindow($hWnd, $hDestDC, $tPTDest, $tSize, $hSrcDC, $tPTSrce, $iRGB, $tBlend, $iFlags)
Local $aCall = DllCall("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $hWnd, "handle", $hDestDC, "struct*", $tPTDest,  "struct*", $tSize, "handle", $hSrcDC, "struct*", $tPTSrce, "dword", $iRGB, "struct*", $tBlend, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_UpdateLayeredWindowEx($hWnd, $iX, $iY, $hBitmap, $iOpacity = 255, $bDelete = False)
Local $aCall = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', $hWnd)
Local $hDC = $aCall[0]
$aCall = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hDestDC = $aCall[0]
$aCall = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hBitmap)
Local $hDestSv = $aCall[0]
Local $tPOINT
If ($iX = -1) And ($iY = -1) Then
$tPOINT = DllStructCreate('int;int')
Else
$tPOINT = DllStructCreate('int;int;int;int')
DllStructSetData($tPOINT, 3, $iX)
DllStructSetData($tPOINT, 4, $iY)
EndIf
DllStructSetData($tPOINT, 1, 0)
DllStructSetData($tPOINT, 2, 0)
Local $tBLENDFUNCTION = DllStructCreate($tagBLENDFUNCTION)
DllStructSetData($tBLENDFUNCTION, 1, 0)
DllStructSetData($tBLENDFUNCTION, 2, 0)
DllStructSetData($tBLENDFUNCTION, 3, $iOpacity)
DllStructSetData($tBLENDFUNCTION, 4, 1)
Local Const $tagBITMAP = 'struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct'
Local $tObj = DllStructCreate($tagBITMAP)
DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
Local $tSize = DllStructCreate($tagSIZE, DllStructGetPtr($tObj, "bmWidth"))
$aCall = DllCall('user32.dll', 'bool', 'UpdateLayeredWindow', 'hwnd', $hWnd, 'handle', $hDC, 'ptr', DllStructGetPtr($tPOINT, 3),  'struct*', $tSize, 'handle', $hDestDC, 'struct*', $tPOINT, 'dword', 0, 'struct*', $tBLENDFUNCTION, 'dword', 0x02)
Local $iError = @error
DllCall('user32.dll', 'bool', 'ReleaseDC', 'hwnd', $hWnd, 'handle', $hDC)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hDestSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hDestDC)
If $iError Then Return SetError($iError, 0, False)
If $bDelete Then
DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hBitmap)
EndIf
Return $aCall[0]
EndFunc
Func _WinAPI_UpdateLayeredWindowIndirect($hWnd, $tULWINFO)
Local $aCall = DllCall('user32.dll', 'bool', 'UpdateLayeredWindowIndirect', 'hwnd', $hWnd, 'struct*', $tULWINFO)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_WindowFromPoint(ByRef $tPOINT)
Local $aCall = DllCall("user32.dll", "hwnd", "WindowFromPoint", "struct", $tPOINT)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func __EnumDefaultProc($pData, $lParam)
#forceref $lParam
Local $iLength = _WinAPI_StrLen($pData)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' & ($iLength + 1) & ']', $pData), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = ''
EndIf
Return 1
EndFunc
Global Const $tagOSVERSIONINFOEX = $tagOSVERSIONINFO & ';ushort ServicePackMajor;ushort ServicePackMinor;ushort SuiteMask;byte ProductType;byte Reserved'
Global Const $tagRAWINPUTDEVICE = 'struct;ushort UsagePage;ushort Usage;dword Flags;hwnd hTarget;endstruct'
Global Const $tagRAWINPUTHEADER = 'struct;dword Type;dword Size;handle hDevice;wparam wParam;endstruct'
Global Const $tagRAWMOUSE = 'ushort Flags;ushort Alignment;ushort ButtonFlags;ushort ButtonData;ulong RawButtons;long LastX;long LastY;ulong ExtraInformation;'
Global Const $tagRAWKEYBOARD = 'ushort MakeCode;ushort Flags;ushort Reserved;ushort VKey;uint Message;ulong ExtraInformation;'
Global Const $tagRAWHID = 'dword SizeHid;dword Count;'
Global Const $tagRAWINPUTMOUSE = $tagRAWINPUTHEADER & ';' & $tagRAWMOUSE
Global Const $tagRAWINPUTKEYBOARD = $tagRAWINPUTHEADER & ';' & $tagRAWKEYBOARD
Global Const $tagRAWINPUTHID = $tagRAWINPUTHEADER & ';' & $tagRAWHID
Global Const $tagRID_DEVICE_INFO_MOUSE = 'struct;dword Id;dword NumberOfButtons;dword SampleRate;int HasHorizontalWheel;endstruc'
Global Const $tagRID_DEVICE_INFO_KEYBOARD = 'struct;dword KbType;dword KbSubType;dword KeyboardMode;dword NumberOfFunctionKeys;dword NumberOfIndicators;dword NumberOfKeysTotal;endstruct'
Global Const $tagRID_DEVICE_INFO_HID = 'struct;dword VendorId;dword ProductId;dword VersionNumber;ushort UsagePage;ushort Usage;endstruc'
Global Const $tagRID_INFO_MOUSE = 'dword Size;dword Type;' & $tagRID_DEVICE_INFO_MOUSE & ';dword Unused[2];'
Global Const $tagRID_INFO_KEYBOARD = 'dword Size;dword Type;' & $tagRID_DEVICE_INFO_KEYBOARD
Global Const $tagRID_INFO_HID = 'dword Size;dword Type;' & $tagRID_DEVICE_INFO_HID & ';dword Unused[2]'
Global Const $tagUSEROBJECTFLAGS = 'int Inherit;int Reserved;dword Flags'
Func _WinAPI_ActivateKeyboardLayout($hLocale, $iFlag = 0)
Local $aCall = DllCall('user32.dll', 'handle', 'ActivateKeyboardLayout', 'handle', $hLocale, 'uint', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_AddClipboardFormatListener($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'AddClipboardFormatListener', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_CallNextHookEx($hHook, $iCode, $wParam, $lParam)
Local $aCall = DllCall("user32.dll", "lresult", "CallNextHookEx", "handle", $hHook, "int", $iCode, "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_CloseDesktop($hDesktop)
Local $aCall = DllCall('user32.dll', 'bool', 'CloseDesktop', 'handle', $hDesktop)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_CloseWindowStation($hStation)
Local $aCall = DllCall('user32.dll', 'bool', 'CloseWindowStation', 'handle', $hStation)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_CompressBuffer($pUncompressedBuffer, $iUncompressedSize, $pCompressedBuffer, $iCompressedSize, $iFormatAndEngine = 0x0002)
Local $aCall, $pWorkSpace = 0, $iError = 0
Do
$aCall = DllCall('ntdll.dll', 'uint', 'RtlGetCompressionWorkSpaceSize', 'ushort', $iFormatAndEngine, 'ulong*', 0, 'ulong*', 0)
If @error Or $aCall[0] Then
$iError = @error + 20
ExitLoop
EndIf
$pWorkSpace = __HeapAlloc($aCall[2])
If @error Then
$iError = @error + 100
ExitLoop
EndIf
$aCall = DllCall('ntdll.dll', 'uint', 'RtlCompressBuffer', 'ushort', $iFormatAndEngine, 'struct*', $pUncompressedBuffer,  'ulong', $iUncompressedSize, 'struct*', $pCompressedBuffer, 'ulong', $iCompressedSize, 'ulong', 4096,  'ulong*', 0, 'ptr', $pWorkSpace)
If @error Or $aCall[0] Or Not $aCall[7] Then
$iError = @error + 30
ExitLoop
EndIf
Until 1
__HeapFree($pWorkSpace)
If $iError Then
If IsArray($aCall) Then
Return SetError(10, $aCall[0], 0)
Else
Return SetError($iError, 0, 0)
EndIf
EndIf
Return $aCall[7]
EndFunc
Func _WinAPI_ComputeCrc32($pMemory, $iLength)
If _WinAPI_IsBadReadPtr($pMemory, $iLength) Then Return SetError(1, @extended, 0)
Local $aCall = DllCall('ntdll.dll', 'dword', 'RtlComputeCrc32', 'dword', 0, 'struct*', $pMemory, 'int', $iLength)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateDesktop($sName, $iAccess = 0x0002, $iFlags = 0, $iHeap = 0, $tSecurity = 0)
Local $aCall
If $iHeap Then
$aCall = DllCall('user32.dll', 'handle', 'CreateDesktopExW', 'wstr', $sName, 'ptr', 0, 'ptr', 0, 'dword', $iFlags,  'dword', $iAccess, 'struct*', $tSecurity, 'ulong', $iHeap, 'ptr', 0)
Else
$aCall = DllCall('user32.dll', 'handle', 'CreateDesktopW', 'wstr', $sName, 'ptr', 0, 'ptr', 0, 'dword', $iFlags,  'dword', $iAccess, 'struct*', $tSecurity)
EndIf
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_CreateWindowStation($sName = '', $iAccess = 0, $iFlags = 0, $tSecurity = 0)
Local $aCall = DllCall('user32.dll', 'handle', 'CreateWindowStationW', 'wstr', $sName, 'dword', $iFlags, 'dword', $iAccess,  'struct*', $tSecurity)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_DecompressBuffer($pUncompressedBuffer, $iUncompressedSize, $pCompressedBuffer, $iCompressedSize, $iFormat = 0x0002)
Local $aCall = DllCall('ntdll.dll', 'long', 'RtlDecompressBuffer', 'ushort', $iFormat, 'struct*', $pUncompressedBuffer,  'ulong', $iUncompressedSize, 'struct*', $pCompressedBuffer, 'ulong', $iCompressedSize, 'ulong*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return $aCall[6]
EndFunc
Func _WinAPI_DefRawInputProc($paRawInput, $iInput)
Local $aCall = DllCall('user32.dll', 'lresult', 'DefRawInputProc', 'ptr', $paRawInput, 'int', $iInput,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] Then Return SetError(10, $aCall[0], 0)
Return 1
EndFunc
Func _WinAPI_EnumDesktops($hStation)
If StringCompare(_WinAPI_GetUserObjectInformation($hStation, 3), 'WindowStation') Then Return SetError(1, 0, 0)
Local $hEnumProc = DllCallbackRegister('__EnumDefaultProc', 'bool', 'ptr;lparam')
Dim $__g_vEnum[101] = [0]
Local $aCall = DllCall('user32.dll', 'bool', 'EnumDesktopsW', 'handle', $hStation, 'ptr', DllCallbackGetPtr($hEnumProc),  'lparam', 0)
If @error Or Not $aCall[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumDesktopWindows($hDesktop, $bVisible = True)
If StringCompare(_WinAPI_GetUserObjectInformation($hDesktop, 3), 'Desktop') Then Return SetError(1, 0, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
Local $aCall = DllCall('user32.dll', 'bool', 'EnumDesktopWindows', 'handle', $hDesktop, 'ptr', DllCallbackGetPtr($hEnumProc),  'lparam', $bVisible)
If @error Or Not $aCall[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumPageFiles()
Local $aInfo = _WinAPI_GetSystemInfo()
Local $hEnumProc = DllCallbackRegister('__EnumPageFilesProc', 'bool', 'lparam;ptr;ptr')
Dim $__g_vEnum[101][4] = [[0]]
Local $aCall = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumPageFilesW', 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $aInfo[1])
If @error Or Not $aCall[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumRawInputDevices()
Local Const $tagRAWINPUTDEVICELIST = 'struct;handle hDevice;dword Type;endstruct'
Local $tRIDL, $iLength = DllStructGetSize(DllStructCreate($tagRAWINPUTDEVICELIST))
Local $aCall = DllCall('user32.dll', 'uint', 'GetRawInputDeviceList', 'ptr', 0, 'uint*', 0, 'uint', $iLength)
If @error Then Return SetError(@error + 10, @extended, 0)
If ($aCall[0] = 4294967295) Or (Not $aCall[2]) Then Return SetError(10, -1, 0)
Local $tData = DllStructCreate('byte[' & ($aCall[2] * $iLength) & ']')
Local $pData = DllStructGetPtr($tData)
If @error Then Return SetError(@error + 20, 0, 0)
$aCall = DllCall('user32.dll', 'uint', 'GetRawInputDeviceList', 'ptr', $pData, 'uint*', $aCall[2], 'uint', $iLength)
If ($aCall[0] = 4294967295) Or (Not $aCall[0]) Then Return SetError(1, -1, 0)
Local $aRet[$aCall[2] + 1][2] = [[$aCall[2]]]
For $i = 1 To $aCall[2]
$tRIDL = DllStructCreate('ptr;dword', $pData + $iLength * ($i - 1))
For $j = 0 To 1
$aRet[$i][$j] = DllStructGetData($tRIDL, $j + 1)
Next
Next
Return $aRet
EndFunc
Func _WinAPI_EnumWindowStations()
Local $hEnumProc = DllCallbackRegister('__EnumDefaultProc', 'bool', 'ptr;lparam')
Dim $__g_vEnum[101] = [0]
Local $aCall = DllCall('user32.dll', 'bool', 'EnumWindowStationsW', 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
If @error Or Not $aCall[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_ExpandEnvironmentStrings($sString)
Local $aCall = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $sString, "wstr", "", "dword", 4096)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, "")
Return $aCall[2]
EndFunc
Func _WinAPI_GetActiveWindow()
Local $aCall = DllCall('user32.dll', 'hwnd', 'GetActiveWindow')
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetAsyncKeyState($iKey)
Local $aCall = DllCall("user32.dll", "short", "GetAsyncKeyState", "int", $iKey)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetClipboardSequenceNumber()
Local $aCall = DllCall('user32.dll', 'dword', 'GetClipboardSequenceNumber')
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetCurrentHwProfile()
Local $tagHW_PROFILE_INFO = 'dword DockInfo;wchar szHwProfileGuid[39];wchar szHwProfileName[80]'
Local $tHWPI = DllStructCreate($tagHW_PROFILE_INFO)
Local $aCall = DllCall('advapi32.dll', 'bool', 'GetCurrentHwProfileW', 'struct*', $tHWPI)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aRet[3]
For $i = 0 To 2
$aRet[$i] = DllStructGetData($tHWPI, $i + 1)
Next
Return $aRet
EndFunc
Func _WinAPI_GetDefaultPrinter()
Local $aCall = DllCall('winspool.drv', 'bool', 'GetDefaultPrinterW', 'wstr', '', 'dword*', 2048)
If @error Then Return SetError(@error, @extended, '')
If Not $aCall[0] Then Return SetError(10, _WinAPI_GetLastError(), '')
Return $aCall[1]
EndFunc
Func _WinAPI_GetDllDirectory()
Local $aCall = DllCall('kernel32.dll', 'dword', 'GetDllDirectoryW', 'dword', 4096, 'wstr', '')
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_GetEffectiveClientRect($hWnd, $aCtrl, $iStart = 0, $iEnd = -1)
If Not IsArray($aCtrl) Then
Local $iCtrl = $aCtrl
Dim $aCtrl[1] = [$iCtrl]
$iStart = 0
$iEnd = 0
EndIf
If __CheckErrorArrayBounds($aCtrl, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $iCount = $iEnd - $iStart + 1
Local $tCtrl = DllStructCreate('uint64[' & ($iCount + 2) & ']')
$iCount = 2
For $i = $iStart To $iEnd
If IsHWnd($aCtrl[$i]) Then
$aCtrl[$i] = _WinAPI_GetDlgCtrlID($aCtrl[$i])
EndIf
DllStructSetData($tCtrl, 1, _WinAPI_MakeQWord(1, $aCtrl[$i]), $iCount)
$iCount += 1
Next
Local $tRECT = DllStructCreate($tagRECT)
DllCall('comctl32.dll', 'none', 'GetEffectiveClientRect', 'hwnd', $hWnd, 'struct*', $tRECT, 'struct*', $tCtrl)
If @error Then Return SetError(@error, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetHandleInformation($hObject)
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetHandleInformation', 'handle', $hObject, 'dword*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[2]
EndFunc
Func _WinAPI_GetIdleTime()
Local $tLASTINPUTINFO = DllStructCreate('uint;dword')
DllStructSetData($tLASTINPUTINFO, 1, DllStructGetSize($tLASTINPUTINFO))
Local $aCall = DllCall('user32.dll', 'bool', 'GetLastInputInfo', 'struct*', $tLASTINPUTINFO)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return _WinAPI_GetTickCount() - DllStructGetData($tLASTINPUTINFO, 2)
EndFunc
Func _WinAPI_GetKeyboardLayout($hWnd)
Local $aCall = DllCall('user32.dll', 'dword', 'GetWindowThreadProcessId', 'hwnd', $hWnd, 'ptr', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
$aCall = DllCall('user32.dll', 'handle', 'GetKeyboardLayout', 'dword', $aCall[0])
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetKeyboardLayoutList()
Local $aCall = DllCall('user32.dll', 'uint', 'GetKeyboardLayoutList', 'int', 0, 'ptr', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 20, @extended, 0)
Local $tData = DllStructCreate('handle[' & $aCall[0] & ']')
$aCall = DllCall('user32.dll', 'uint', 'GetKeyboardLayoutList', 'int', $aCall[0], 'struct*', $tData)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aList[$aCall[0] + 1] = [$aCall[0]]
For $i = 1 To $aList[0]
$aList[$i] = DllStructGetData($tData, 1, $i)
Next
Return $aList
EndFunc
Func _WinAPI_GetKeyboardState()
Local $tData = DllStructCreate('byte[256]')
Local $aCall = DllCall('user32.dll', 'bool', 'GetKeyboardState', 'struct*', $tData)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tData
EndFunc
Func _WinAPI_GetKeyboardType($iType)
Local $aCall = DllCall('user32.dll', 'int', 'GetKeyboardType', 'int', $iType)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetKeyNameText($lParam)
Local $aCall = DllCall('user32.dll', 'int', 'GetKeyNameTextW', 'long', $lParam, 'wstr', '', 'int', 128)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_GetKeyState($vKey)
Local $aCall = DllCall('user32.dll', 'short', 'GetKeyState', 'int', $vKey)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetModuleHandleEx($sModule, $iFlags = 0)
If StringStripWS($sModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) = "" Then $sModule = Null
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetModuleHandleExW', 'dword', $iFlags, "wstr", $sModule, 'ptr*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[3]
EndFunc
Func _WinAPI_GetMUILanguage()
Local $aCall = DllCall('comctl32.dll', 'word', 'GetMUILanguage')
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetPerformanceInfo()
Local $tPI = DllStructCreate('dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;dword;dword;dword')
Local $aCall = DllCall(@SystemDir & '\psapi.dll', 'bool', 'GetPerformanceInfo', 'struct*', $tPI, 'dword', DllStructGetSize($tPI))
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aRet[13]
For $i = 0 To 12
$aRet[$i] = DllStructGetData($tPI, $i + 2)
Next
For $i = 0 To 8
$aRet[$i] *= $aRet[9]
Next
Return $aRet
EndFunc
Func _WinAPI_GetProcAddress($hModule, $vName)
Local $sType = "str"
If IsNumber($vName) Then $sType = "word"
Local $aCall = DllCall("kernel32.dll", "ptr", "GetProcAddress", "handle", $hModule, $sType, $vName)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetPhysicallyInstalledSystemMemory()
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetPhysicallyInstalledSystemMemory', 'uint64*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[1]
EndFunc
Func _WinAPI_GetProcessShutdownParameters()
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetProcessShutdownParameters', 'dword*', 0, 'dword*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended(Number(Not $aCall[2]), $aCall[1])
EndFunc
Func _WinAPI_GetProcessWindowStation()
Local $aCall = DllCall('user32.dll', 'handle', 'GetProcessWindowStation')
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetPwrCapabilities()
If Not __DLL('powrprof.dll') Then Return SetError(103, 0, 0)
Local $tSPC = DllStructCreate('byte[18];byte[3];byte;byte[8];byte[2];ulong[6];ulong[5]')
Local $aCall = DllCall('powrprof.dll', 'boolean', 'GetPwrCapabilities', 'struct*', $tSPC)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aRet[25]
For $i = 0 To 17
$aRet[$i] = DllStructGetData($tSPC, 1, $i + 1)
Next
$aRet[18] = DllStructGetData($tSPC, 3)
For $i = 19 To 20
$aRet[$i] = DllStructGetData($tSPC, 5, $i - 18)
Next
For $i = 21 To 24
$aRet[$i] = DllStructGetData($tSPC, 7, $i - 20)
Next
Return $aRet
EndFunc
Func _WinAPI_GetRawInputBuffer($pBuffer, $iLength)
Local $aCall = DllCall('user32.dll', 'uint', 'GetRawInputBuffer', 'struct*', $pBuffer, 'uint*', $iLength,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If ($aCall[0] = 4294967295) Or (Not $aCall[1]) Then Return SetError(10, -1, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetRawInputBufferLength()
Local $aCall = DllCall('user32.dll', 'uint', 'GetRawInputBuffer', 'ptr', 0, 'uint*', 0,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] = 4294967295 Then Return SetError(10, -1, 0)
Return $aCall[2] * 8
EndFunc
Func _WinAPI_GetRawInputData($hRawInput, $pBuffer, $iLength, $iFlag)
Local $aCall = DllCall('user32.dll', 'uint', 'GetRawInputData', 'handle', $hRawInput, 'uint', $iFlag, 'struct*', $pBuffer,  'uint*', $iLength, 'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] = 4294967295 Then Return SetError(10, -1, 0)
Return ($aCall[3] ? $aCall[0] : $aCall[4])
EndFunc
Func _WinAPI_GetRawInputDeviceInfo($hDevice, $pBuffer, $iLength, $iFlag)
Local $aCall = DllCall('user32.dll', 'uint', 'GetRawInputDeviceInfoW', 'handle', $hDevice, 'uint', $iFlag, 'struct*', $pBuffer,  'uint*', $iLength)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] = 4294967295 Then Return SetError(10, -1, 0)
Return ($aCall[3] ? $aCall[0] : $aCall[4])
EndFunc
Func _WinAPI_GetRegisteredRawInputDevices($pBuffer, $iLength)
Local $iLengthRAW = DllStructGetSize(DllStructCreate($tagRAWINPUTDEVICE))
Local $aCall = DllCall('user32.dll', 'uint', 'GetRegisteredRawInputDevices', 'struct*', $pBuffer,  'uint*', Floor($iLength / $iLengthRAW), 'uint', $iLengthRAW)
If @error Then Return SetError(@error, @extended, 0)
If $aCall[0] = 4294967295 Then
Local $iLastError = _WinAPI_GetLastError()
If $iLastError = 122 Then Return SetExtended($iLastError, $aCall[2] * $iLengthRAW)
Return SetError(10, $iLastError, 0)
EndIf
Return $aCall[0]
EndFunc
Func _WinAPI_GetStartupInfo()
Local $tSI = DllStructCreate($tagSTARTUPINFO)
DllCall('kernel32.dll', 'none', 'GetStartupInfoW', 'struct*', $tSI)
If @error Then Return SetError(@error, @extended, 0)
Return $tSI
EndFunc
Func _WinAPI_GetSystemDEPPolicy()
Local $aCall = DllCall('kernel32.dll', 'uint', 'GetSystemDEPPolicy')
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _WinAPI_GetSystemInfo()
Local $sProc
If _WinAPI_IsWow64Process() Then
$sProc = 'GetNativeSystemInfo'
Else
$sProc = 'GetSystemInfo'
EndIf
Local Const $tagSYSTEMINFO = 'struct;word ProcessorArchitecture;word Reserved; endstruct;dword PageSize;' &  'ptr MinimumApplicationAddress;ptr MaximumApplicationAddress;dword_ptr ActiveProcessorMask;dword NumberOfProcessors;' &  'dword ProcessorType;dword AllocationGranularity;word ProcessorLevel;word ProcessorRevision'
Local $tSystemInfo = DllStructCreate($tagSYSTEMINFO)
DllCall('kernel32.dll', 'none', $sProc, 'struct*', $tSystemInfo)
If @error Then Return SetError(@error, @extended, 0)
Local $aRet[10]
$aRet[0] = DllStructGetData($tSystemInfo, 1)
For $i = 1 To 9
$aRet[$i] = DllStructGetData($tSystemInfo, $i + 2)
Next
Return $aRet
EndFunc
Func _WinAPI_GetSystemPowerStatus()
Local $tagSYSTEM_POWER_STATUS = 'byte ACLineStatus;byte BatteryFlag;byte BatteryLifePercent;byte Reserved1;' &  'int BatteryLifeTime;int BatteryFullLifeTime'
Local $tSYSTEM_POWER_STATUS = DllStructCreate($tagSYSTEM_POWER_STATUS)
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetSystemPowerStatus', 'struct*', $tSYSTEM_POWER_STATUS)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aRet[5]
$aRet[0] = DllStructGetData($tSYSTEM_POWER_STATUS, 1)
$aRet[1] = DllStructGetData($tSYSTEM_POWER_STATUS, 2)
$aRet[2] = DllStructGetData($tSYSTEM_POWER_STATUS, 3)
$aRet[3] = DllStructGetData($tSYSTEM_POWER_STATUS, 5)
$aRet[4] = DllStructGetData($tSYSTEM_POWER_STATUS, 6)
Return $aRet
EndFunc
Func _WinAPI_GetSystemTimes()
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetSystemTimes', 'uint64*', 0, 'uint64*', 0, 'uint64*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Local $aRet[3]
For $i = 0 To 2
$aRet[$i] = $aCall[$i + 1]
Next
Return $aRet
EndFunc
Func _WinAPI_GetSystemWow64Directory()
Local $aCall = DllCall('kernel32.dll', 'uint', 'GetSystemWow64DirectoryW', 'wstr', '', 'uint', 4096)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, _WinAPI_GetLastError(), '')
Return $aCall[1]
EndFunc
Func _WinAPI_GetTickCount()
Local $aCall = DllCall('kernel32.dll', 'dword', 'GetTickCount')
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetTickCount64()
Local $aCall = DllCall('kernel32.dll', 'uint64', 'GetTickCount64')
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_GetUserObjectInformation($hObject, $iIndex)
Local $aCall = DllCall('user32.dll', 'bool', 'GetUserObjectInformationW', 'handle', $hObject, 'int', $iIndex, 'ptr', 0,  'dword', 0, 'dword*', 0)
If @error Or Not $aCall[5] Then Return SetError(@error + 10, @extended, 0)
Local $tData
Switch $iIndex
Case 1
$tData = DllStructCreate($tagUSEROBJECTFLAGS)
Case 5, 6
$tData = DllStructCreate('uint')
Case 2, 3
$tData = DllStructCreate('wchar[' & $aCall[5] & ']')
Case 4
$tData = DllStructCreate('byte[' & $aCall[5] & ']')
Case Else
Return SetError(20, 0, 0)
EndSwitch
$aCall = DllCall('user32.dll', 'bool', 'GetUserObjectInformationW', 'handle', $hObject, 'int', $iIndex, 'struct*', $tData,  'dword', DllStructGetSize($tData), 'dword*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 30, @extended, 0)
Switch $iIndex
Case 1, 4
Return $tData
Case Else
Return DllStructGetData($tData, 1)
EndSwitch
EndFunc
Func _WinAPI_GetVersionEx()
Local $tOSVERSIONINFOEX = DllStructCreate($tagOSVERSIONINFOEX)
DllStructSetData($tOSVERSIONINFOEX, 'OSVersionInfoSize', DllStructGetSize($tOSVERSIONINFOEX))
Local $aCall = DllCall('kernel32.dll', 'bool', 'GetVersionExW', 'struct*', $tOSVERSIONINFOEX)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tOSVERSIONINFOEX
EndFunc
Func _WinAPI_GetWorkArea()
Local $tRECT = DllStructCreate($tagRECT)
Local $aCall = DllCall('user32.dll', 'int', 'SystemParametersInfo', 'uint', 48, 'uint', 0, 'struct*', $tRECT, 'uint', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_InitMUILanguage($iLanguage)
DllCall('comctl32.dll', 'none', 'InitMUILanguage', 'word', $iLanguage)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_IsLoadKBLayout($iLanguage)
Local $aLayout = _WinAPI_GetKeyboardLayoutList()
If @error Then Return SetError(@error, @extended, False)
For $i = 1 To $aLayout[0]
If $aLayout[$i] = $iLanguage Then Return True
Next
Return False
EndFunc
Func _WinAPI_IsProcessorFeaturePresent($iFeature)
Local $aCall = DllCall('kernel32.dll', 'bool', 'IsProcessorFeaturePresent', 'dword', $iFeature)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_IsWindowEnabled($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'IsWindowEnabled', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_Keybd_Event($vKey, $iFlags, $iScanCode = 0, $iExtraInfo = 0)
DllCall('user32.dll', 'none', 'keybd_event', 'byte', $vKey, 'byte', $iScanCode, 'dword', $iFlags, 'ulong_ptr', $iExtraInfo)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_LoadKeyboardLayout($iLanguage, $iFlag = 0)
Local $aCall = DllCall('user32.dll', 'handle', 'LoadKeyboardLayoutW', 'wstr', Hex($iLanguage, 8), 'uint', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_LockWorkStation()
Local $aCall = DllCall('user32.dll', 'bool', 'LockWorkStation')
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_MapVirtualKey($iCode, $iType, $hLocale = 0)
Local $aCall = DllCall('user32.dll', 'INT', 'MapVirtualKeyExW', 'uint', $iCode, 'uint', $iType, 'uint_ptr', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_Mouse_Event($iFlags, $iX = 0, $iY = 0, $iData = 0, $iExtraInfo = 0)
DllCall("user32.dll", "none", "mouse_event", "dword", $iFlags, "dword", $iX, "dword", $iY, "dword", $iData,  "ulong_ptr", $iExtraInfo)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_OpenDesktop($sName, $iAccess = 0, $iFlags = 0, $bInherit = False)
Local $aCall = DllCall('user32.dll', 'handle', 'OpenDesktopW', 'wstr', $sName, 'dword', $iFlags, 'bool', $bInherit,  'dword', $iAccess)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_OpenInputDesktop($iAccess = 0, $iFlags = 0, $bInherit = False)
Local $aCall = DllCall('user32.dll', 'handle', 'OpenInputDesktop', 'dword', $iFlags, 'bool', $bInherit, 'dword', $iAccess)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_OpenWindowStation($sName, $iAccess = 0, $bInherit = False)
Local $aCall = DllCall('user32.dll', 'handle', 'OpenWindowStationW', 'wstr', $sName, 'bool', $bInherit, 'dword', $iAccess)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_QueryPerformanceCounter()
Local $aCall = DllCall('kernel32.dll', 'bool', 'QueryPerformanceCounter', 'int64*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[1]
EndFunc
Func _WinAPI_QueryPerformanceFrequency()
Local $aCall = DllCall('kernel32.dll', 'bool', 'QueryPerformanceFrequency', 'int64*', 0)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $aCall[1]
EndFunc
Func _WinAPI_RegisterHotKey($hWnd, $iID, $iModifiers, $vKey)
Local $aCall = DllCall('user32.dll', 'bool', 'RegisterHotKey', 'hwnd', $hWnd, 'int', $iID, 'uint', $iModifiers, 'uint', $vKey)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_RegisterPowerSettingNotification($hWnd, $sGUID)
Local $tGUID = DllStructCreate($tagGUID)
Local $aCall = DllCall('ole32.dll', 'long', 'CLSIDFromString', 'wstr', $sGUID, 'struct*', $tGUID)
If @error Or $aCall[0] Then Return SetError(@error + 20, @extended, 0)
$aCall = DllCall('user32.dll', 'handle', 'RegisterPowerSettingNotification', 'handle', $hWnd, 'struct*', $tGUID, 'dword', 0)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_RegisterRawInputDevices($paDevice, $iCount = 1)
Local $aCall = DllCall('user32.dll', 'bool', 'RegisterRawInputDevices', 'struct*', $paDevice, 'uint', $iCount,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTDEVICE)))
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ReleaseCapture()
Local $aCall = DllCall("user32.dll", "bool", "ReleaseCapture")
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_RemoveClipboardFormatListener($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'RemoveClipboardFormatListener', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetActiveWindow($hWnd)
Local $aCall = DllCall('user32.dll', 'int', 'SetActiveWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetCapture($hWnd)
Local $aCall = DllCall("user32.dll", "hwnd", "SetCapture", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetDefaultPrinter($sPrinter)
Local $aCall = DllCall("winspool.drv", "bool", "SetDefaultPrinterW", "wstr", $sPrinter)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetDllDirectory($sDirPath = Default)
If $sDirPath = Default Then $sDirPath = Null
Local $aCall = DllCall('kernel32.dll', 'bool', 'SetDllDirectoryW', 'wstr', $sDirPath)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetKeyboardLayout($hWnd, $iLanguage, $iFlags = 0)
If Not _WinAPI_IsWindow($hWnd) Then Return SetError(@error + 10, @extended, 0)
Local $hLocale = 0
If $iLanguage Then
$hLocale = _WinAPI_LoadKeyboardLayout($iLanguage)
If Not $hLocale Then Return SetError(10, 0, 0)
EndIf
Local Const $WM_INPUTLANGCHANGEREQUEST = 0x0050
DllCall('user32.dll', 'none', 'SendMessage', 'hwnd', $hWnd, 'uint', $WM_INPUTLANGCHANGEREQUEST, 'uint', $iFlags, 'uint_ptr', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_SetKeyboardState(ByRef $tState)
Local $aCall = DllCall('user32.dll', 'int', 'SetKeyboardState', 'struct*', $tState)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetProcessShutdownParameters($iLevel, $bDialog = False)
Local $aCall = DllCall('kernel32.dll', 'bool', 'SetProcessShutdownParameters', 'dword', $iLevel, 'dword', Not $bDialog)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetProcessWindowStation($hStation)
Local $aCall = DllCall('user32.dll', 'bool', 'SetProcessWindowStation', 'handle', $hStation)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetUserObjectInformation($hObject, $iIndex, ByRef $tData)
If $iIndex <> 1 Then Return SetError(10, 0, False)
Local $aCall = DllCall('user32.dll', 'bool', 'SetUserObjectInformationW', 'handle', $hObject, 'int', 1, 'struct*', $tData,  'dword', DllStructGetSize($tData))
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SetWindowsHookEx($iHook, $pProc, $hDll, $iThreadId = 0)
Local $aCall = DllCall("user32.dll", "handle", "SetWindowsHookEx", "int", $iHook, "ptr", $pProc, "handle", $hDll,  "dword", $iThreadId)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_SetWinEventHook($iEventMin, $iEventMax, $pEventProc, $iPID = 0, $iThreadId = 0, $iFlags = 0)
Local $aCall = DllCall('user32.dll', 'handle', 'SetWinEventHook', 'uint', $iEventMin, 'uint', $iEventMax, 'ptr', 0,  'ptr', $pEventProc, 'dword', $iPID, 'dword', $iThreadId, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_ShutdownBlockReasonCreate($hWnd, $sText)
Local $aCall = DllCall('user32.dll', 'bool', 'ShutdownBlockReasonCreate', 'hwnd', $hWnd, 'wstr', $sText)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ShutdownBlockReasonDestroy($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'ShutdownBlockReasonDestroy', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_ShutdownBlockReasonQuery($hWnd)
Local $aCall = DllCall('user32.dll', 'bool', 'ShutdownBlockReasonQuery', 'hwnd', $hWnd, 'wstr', '', 'dword*', 4096)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, '')
Return $aCall[2]
EndFunc
Func _WinAPI_SwitchDesktop($hDesktop)
Local $aCall = DllCall('user32.dll', 'bool', 'SwitchDesktop', 'handle', $hDesktop)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_SystemParametersInfo($iAction, $iParam = 0, $vParam = 0, $iWinIni = 0)
Local $aCall = DllCall("user32.dll", "bool", "SystemParametersInfoW", "uint", $iAction, "uint", $iParam, "struct*", $vParam,  "uint", $iWinIni)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_TrackMouseEvent($hWnd, $iFlags, $iTime = -1)
Local $tTME = DllStructCreate('dword;dword;hwnd;dword')
DllStructSetData($tTME, 1, DllStructGetSize($tTME))
DllStructSetData($tTME, 2, $iFlags)
DllStructSetData($tTME, 3, $hWnd)
DllStructSetData($tTME, 4, $iTime)
Local $aCall = DllCall('user32.dll', 'bool', 'TrackMouseEvent', 'struct*', $tTME)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_UnhookWindowsHookEx($hHook)
Local $aCall = DllCall("user32.dll", "bool", "UnhookWindowsHookEx", "handle", $hHook)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_UnhookWinEvent($hEventHook)
Local $aCall = DllCall('user32.dll', 'bool', 'UnhookWinEvent', 'handle', $hEventHook)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _WinAPI_UnloadKeyboardLayout($hLocale)
Local $aCall = DllCall('user32.dll', 'bool', 'UnloadKeyboardLayout', 'handle', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_UnregisterHotKey($hWnd, $iID)
Local $aCall = DllCall('user32.dll', 'bool', 'UnregisterHotKey', 'hwnd', $hWnd, 'int', $iID)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _WinAPI_UnregisterPowerSettingNotification($hNotify)
Local $aCall = DllCall('user32.dll', 'bool', 'UnregisterPowerSettingNotification', 'handle', $hNotify)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func __EnumPageFilesProc($iSize, $pInfo, $pFile)
Local $tEPFI = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr', $pInfo)
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData(DllStructCreate('wchar[' & (_WinAPI_StrLen($pFile) + 1) & ']', $pFile), 1)
For $i = 1 To 3
$__g_vEnum[$__g_vEnum[0][0]][$i] = DllStructGetData($tEPFI, $i + 2) * $iSize
Next
Return 1
EndFunc
Global Const $WC_ANIMATE = 'SysAnimate32'
Global Const $WC_BUTTON = 'Button'
Global Const $WC_COMBOBOX = 'ComboBox'
Global Const $WC_COMBOBOXEX = 'ComboBoxEx32'
Global Const $WC_DATETIMEPICK = 'SysDateTimePick32'
Global Const $WC_EDIT = 'Edit'
Global Const $WC_HEADER = 'SysHeader32'
Global Const $WC_HOTKEY = 'msctls_hotkey32'
Global Const $WC_IPADDRESS = 'SysIPAddress32'
Global Const $WC_LINK = 'SysLink'
Global Const $WC_LISTBOX = 'ListBox'
Global Const $WC_LISTVIEW = 'SysListView32'
Global Const $WC_MONTHCAL = 'SysMonthCal32'
Global Const $WC_NATIVEFONTCTL = 'NativeFontCtl'
Global Const $WC_PAGESCROLLER = 'SysPager'
Global Const $WC_PROGRESS = 'msctls_progress32'
Global Const $WC_REBAR = 'ReBarWindow32'
Global Const $WC_SCROLLBAR = 'ScrollBar'
Global Const $WC_STATIC = 'Static'
Global Const $WC_STATUSBAR = 'msctls_statusbar32'
Global Const $WC_TABCONTROL = 'SysTabControl32'
Global Const $WC_TOOLBAR = 'ToolbarWindow32'
Global Const $WC_TOOLTIPS = 'tooltips_class32'
Global Const $WC_TRACKBAR = 'msctls_trackbar32'
Global Const $WC_TREEVIEW = 'SysTreeView32'
Global Const $WC_UPDOWN = 'msctls_updown32'
Global Const $WS_OVERLAPPED = 0
Global Const $WS_TILED = $WS_OVERLAPPED
Global Const $WS_MAXIMIZEBOX = 0x00010000
Global Const $WS_MINIMIZEBOX = 0x00020000
Global Const $WS_TABSTOP = 0x00010000
Global Const $WS_GROUP = 0x00020000
Global Const $WS_SIZEBOX = 0x00040000
Global Const $WS_THICKFRAME = $WS_SIZEBOX
Global Const $WS_SYSMENU = 0x00080000
Global Const $WS_HSCROLL = 0x00100000
Global Const $WS_VSCROLL = 0x00200000
Global Const $WS_DLGFRAME = 0x00400000
Global Const $WS_BORDER = 0x00800000
Global Const $WS_CAPTION = 0x00C00000
Global Const $WS_OVERLAPPEDWINDOW = BitOR($WS_CAPTION, $WS_MAXIMIZEBOX, $WS_MINIMIZEBOX, $WS_OVERLAPPED, $WS_SYSMENU, $WS_THICKFRAME)
Global Const $WS_TILEDWINDOW = $WS_OVERLAPPEDWINDOW
Global Const $WS_MAXIMIZE = 0x01000000
Global Const $WS_CLIPCHILDREN = 0x02000000
Global Const $WS_CLIPSIBLINGS = 0x04000000
Global Const $WS_DISABLED = 0x08000000
Global Const $WS_VISIBLE = 0x10000000
Global Const $WS_MINIMIZE = 0x20000000
Global Const $WS_ICONIC = $WS_MINIMIZE
Global Const $WS_CHILD = 0x40000000
Global Const $WS_CHILDWINDOW = $WS_CHILD
Global Const $WS_POPUP = 0x80000000
Global Const $WS_POPUPWINDOW = 0x80880000
Global Const $DS_3DLOOK = 0x0004
Global Const $DS_ABSALIGN = 0x0001
Global Const $DS_CENTER = 0x0800
Global Const $DS_CENTERMOUSE = 0x1000
Global Const $DS_CONTEXTHELP = 0x2000
Global Const $DS_CONTROL = 0x0400
Global Const $DS_FIXEDSYS = 0x0008
Global Const $DS_LOCALEDIT = 0x0020
Global Const $DS_MODALFRAME = 0x0080
Global Const $DS_NOFAILCREATE = 0x0010
Global Const $DS_NOIDLEMSG = 0x0100
Global Const $DS_SETFONT = 0x0040
Global Const $DS_SETFOREGROUND = 0x0200
Global Const $DS_SHELLFONT = BitOR($DS_FIXEDSYS, $DS_SETFONT)
Global Const $DS_SYSMODAL = 0x0002
Global Const $WS_EX_ACCEPTFILES = 0x00000010
Global Const $WS_EX_APPWINDOW = 0x00040000
Global Const $WS_EX_COMPOSITED = 0x02000000
Global Const $WS_EX_CONTROLPARENT = 0x10000
Global Const $WS_EX_CLIENTEDGE = 0x00000200
Global Const $WS_EX_CONTEXTHELP = 0x00000400
Global Const $WS_EX_DLGMODALFRAME = 0x00000001
Global Const $WS_EX_LAYERED = 0x00080000
Global Const $WS_EX_LAYOUTRTL = 0x00400000
Global Const $WS_EX_LEFT = 0x00000000
Global Const $WS_EX_LEFTSCROLLBAR = 0x00004000
Global Const $WS_EX_LTRREADING = 0x00000000
Global Const $WS_EX_MDICHILD = 0x00000040
Global Const $WS_EX_NOACTIVATE = 0x08000000
Global Const $WS_EX_NOINHERITLAYOUT = 0x00100000
Global Const $WS_EX_NOPARENTNOTIFY = 0x00000004
Global Const $WS_EX_NOREDIRECTIONBITMAP = 0x00200000
Global Const $WS_EX_RIGHT = 0x00001000
Global Const $WS_EX_RIGHTSCROLLBAR = 0x00000000
Global Const $WS_EX_RTLREADING = 0x2000
Global Const $WS_EX_STATICEDGE = 0x00020000
Global Const $WS_EX_TOOLWINDOW = 0x00000080
Global Const $WS_EX_TOPMOST = 0x00000008
Global Const $WS_EX_TRANSPARENT = 0x00000020
Global Const $WS_EX_WINDOWEDGE = 0x00000100
Global Const $WS_EX_OVERLAPPEDWINDOW = BitOR($WS_EX_CLIENTEDGE, $WS_EX_WINDOWEDGE)
Global Const $WS_EX_PALETTEWINDOW = BitOR($WS_EX_TOOLWINDOW, $WS_EX_TOPMOST, $WS_EX_WINDOWEDGE)
Global Const $WM_NULL = 0x0000
Global Const $WM_CREATE = 0x0001
Global Const $WM_DESTROY = 0x0002
Global Const $WM_MOVE = 0x0003
Global Const $WM_SIZEWAIT = 0x0004
Global Const $WM_SIZE = 0x0005
Global Const $WM_ACTIVATE = 0x0006
Global Const $WM_SETFOCUS = 0x0007
Global Const $WM_KILLFOCUS = 0x0008
Global Const $WM_SETVISIBLE = 0x0009
Global Const $WM_ENABLE = 0x000A
Global Const $WM_SETREDRAW = 0x000B
Global Const $WM_SETTEXT = 0x000C
Global Const $WM_GETTEXT = 0x000D
Global Const $WM_GETTEXTLENGTH = 0x000E
Global Const $WM_PAINT = 0x000F
Global Const $WM_CLOSE = 0x0010
Global Const $WM_QUERYENDSESSION = 0x0011
Global Const $WM_QUIT = 0x0012
Global Const $WM_ERASEBKGND = 0x0014
Global Const $WM_QUERYOPEN = 0x0013
Global Const $WM_SYSCOLORCHANGE = 0x0015
Global Const $WM_ENDSESSION = 0x0016
Global Const $WM_SYSTEMERROR = 0x0017
Global Const $WM_SHOWWINDOW = 0x0018
Global Const $WM_CTLCOLOR = 0x0019
Global Const $WM_SETTINGCHANGE = 0x001A
Global Const $WM_WININICHANGE = 0x001A
Global Const $WM_DEVMODECHANGE = 0x001B
Global Const $WM_ACTIVATEAPP = 0x001C
Global Const $WM_FONTCHANGE = 0x001D
Global Const $WM_TIMECHANGE = 0x001E
Global Const $WM_CANCELMODE = 0x001F
Global Const $WM_SETCURSOR = 0x0020
Global Const $WM_MOUSEACTIVATE = 0x0021
Global Const $WM_CHILDACTIVATE = 0x0022
Global Const $WM_QUEUESYNC = 0x0023
Global Const $WM_GETMINMAXINFO = 0x0024
Global Const $WM_LOGOFF = 0x0025
Global Const $WM_PAINTICON = 0x0026
Global Const $WM_ICONERASEBKGND = 0x0027
Global Const $WM_NEXTDLGCTL = 0x0028
Global Const $WM_ALTTABACTIVE = 0x0029
Global Const $WM_SPOOLERSTATUS = 0x002A
Global Const $WM_DRAWITEM = 0x002B
Global Const $WM_MEASUREITEM = 0x002C
Global Const $WM_DELETEITEM = 0x002D
Global Const $WM_VKEYTOITEM = 0x002E
Global Const $WM_CHARTOITEM = 0x002F
Global Const $WM_SETFONT = 0x0030
Global Const $WM_GETFONT = 0x0031
Global Const $WM_SETHOTKEY = 0x0032
Global Const $WM_GETHOTKEY = 0x0033
Global Const $WM_FILESYSCHANGE = 0x0034
Global Const $WM_ISACTIVEICON = 0x0035
Global Const $WM_QUERYPARKICON = 0x0036
Global Const $WM_QUERYDRAGICON = 0x0037
Global Const $WM_WINHELP = 0x0038
Global Const $WM_COMPAREITEM = 0x0039
Global Const $WM_FULLSCREEN = 0x003A
Global Const $WM_CLIENTSHUTDOWN = 0x003B
Global Const $WM_DDEMLEVENT = 0x003C
Global Const $WM_GETOBJECT = 0x003D
Global Const $WM_CALCSCROLL = 0x003F
Global Const $WM_TESTING = 0x0040
Global Const $WM_COMPACTING = 0x0041
Global Const $WM_OTHERWINDOWCREATED = 0x0042
Global Const $WM_OTHERWINDOWDESTROYED = 0x0043
Global Const $WM_COMMNOTIFY = 0x0044
Global Const $WM_MEDIASTATUSCHANGE = 0x0045
Global Const $WM_WINDOWPOSCHANGING = 0x0046
Global Const $WM_WINDOWPOSCHANGED = 0x0047
Global Const $WM_POWER = 0x0048
Global Const $WM_COPYGLOBALDATA = 0x0049
Global Const $WM_COPYDATA = 0x004A
Global Const $WM_CANCELJOURNAL = 0x004B
Global Const $WM_LOGONNOTIFY = 0x004C
Global Const $WM_KEYF1 = 0x004D
Global Const $WM_NOTIFY = 0x004E
Global Const $WM_ACCESS_WINDOW = 0x004F
Global Const $WM_INPUTLANGCHANGEREQUEST = 0x0050
Global Const $WM_INPUTLANGCHANGE = 0x0051
Global Const $WM_TCARD = 0x0052
Global Const $WM_HELP = 0x0053
Global Const $WM_USERCHANGED = 0x0054
Global Const $WM_NOTIFYFORMAT = 0x0055
Global Const $WM_QM_ACTIVATE = 0x0060
Global Const $WM_HOOK_DO_CALLBACK = 0x0061
Global Const $WM_SYSCOPYDATA = 0x0062
Global Const $WM_FINALDESTROY = 0x0070
Global Const $WM_MEASUREITEM_CLIENTDATA = 0x0071
Global Const $WM_CONTEXTMENU = 0x007B
Global Const $WM_STYLECHANGING = 0x007C
Global Const $WM_STYLECHANGED = 0x007D
Global Const $WM_DISPLAYCHANGE = 0x007E
Global Const $WM_GETICON = 0x007F
Global Const $WM_SETICON = 0x0080
Global Const $WM_NCCREATE = 0x0081
Global Const $WM_NCDESTROY = 0x0082
Global Const $WM_NCCALCSIZE = 0x0083
Global Const $WM_NCHITTEST = 0x0084
Global Const $WM_NCPAINT = 0x0085
Global Const $WM_NCACTIVATE = 0x0086
Global Const $WM_GETDLGCODE = 0x0087
Global Const $WM_SYNCPAINT = 0x0088
Global Const $WM_SYNCTASK = 0x0089
Global Const $WM_KLUDGEMINRECT = 0x008B
Global Const $WM_LPKDRAWSWITCHWND = 0x008C
Global Const $WM_UAHDESTROYWINDOW = 0x0090
Global Const $WM_UAHDRAWMENU = 0x0091
Global Const $WM_UAHDRAWMENUITEM = 0x0092
Global Const $WM_UAHINITMENU = 0x0093
Global Const $WM_UAHMEASUREMENUITEM = 0x0094
Global Const $WM_UAHNCPAINTMENUPOPUP = 0x0095
Global Const $WM_NCMOUSEMOVE = 0x00A0
Global Const $WM_NCLBUTTONDOWN = 0x00A1
Global Const $WM_NCLBUTTONUP = 0x00A2
Global Const $WM_NCLBUTTONDBLCLK = 0x00A3
Global Const $WM_NCRBUTTONDOWN = 0x00A4
Global Const $WM_NCRBUTTONUP = 0x00A5
Global Const $WM_NCRBUTTONDBLCLK = 0x00A6
Global Const $WM_NCMBUTTONDOWN = 0x00A7
Global Const $WM_NCMBUTTONUP = 0x00A8
Global Const $WM_NCMBUTTONDBLCLK = 0x00A9
Global Const $WM_NCXBUTTONDOWN = 0x00AB
Global Const $WM_NCXBUTTONUP = 0x00AC
Global Const $WM_NCXBUTTONDBLCLK = 0x00AD
Global Const $WM_NCUAHDRAWCAPTION = 0x00AE
Global Const $WM_NCUAHDRAWFRAME = 0x00AF
Global Const $WM_INPUT_DEVICE_CHANGE = 0x00FE
Global Const $WM_INPUT = 0x00FF
Global Const $WM_KEYDOWN = 0x0100
Global Const $WM_KEYFIRST = 0x0100
Global Const $WM_KEYUP = 0x0101
Global Const $WM_CHAR = 0x0102
Global Const $WM_DEADCHAR = 0x0103
Global Const $WM_SYSKEYDOWN = 0x0104
Global Const $WM_SYSKEYUP = 0x0105
Global Const $WM_SYSCHAR = 0x0106
Global Const $WM_SYSDEADCHAR = 0x0107
Global Const $WM_YOMICHAR = 0x0108
Global Const $WM_KEYLAST = 0x0109
Global Const $WM_UNICHAR = 0x0109
Global Const $WM_CONVERTREQUEST = 0x010A
Global Const $WM_CONVERTRESULT = 0x010B
Global Const $WM_IM_INFO = 0x010C
Global Const $WM_IME_STARTCOMPOSITION = 0x010D
Global Const $WM_IME_ENDCOMPOSITION = 0x010E
Global Const $WM_IME_COMPOSITION = 0x010F
Global Const $WM_IME_KEYLAST = 0x010F
Global Const $WM_INITDIALOG = 0x0110
Global Const $WM_COMMAND = 0x0111
Global Const $WM_SYSCOMMAND = 0x0112
Global Const $WM_TIMER = 0x0113
Global Const $WM_HSCROLL = 0x0114
Global Const $WM_VSCROLL = 0x0115
Global Const $WM_INITMENU = 0x0116
Global Const $WM_INITMENUPOPUP = 0x0117
Global Const $WM_SYSTIMER = 0x0118
Global Const $WM_GESTURE = 0x0119
Global Const $WM_GESTURENOTIFY = 0x011A
Global Const $WM_GESTUREINPUT = 0x011B
Global Const $WM_GESTURENOTIFIED = 0x011C
Global Const $WM_MENUSELECT = 0x011F
Global Const $WM_MENUCHAR = 0x0120
Global Const $WM_ENTERIDLE = 0x0121
Global Const $WM_MENURBUTTONUP = 0x0122
Global Const $WM_MENUDRAG = 0x0123
Global Const $WM_MENUGETOBJECT = 0x0124
Global Const $WM_UNINITMENUPOPUP = 0x0125
Global Const $WM_MENUCOMMAND = 0x0126
Global Const $WM_CHANGEUISTATE = 0x0127
Global Const $WM_UPDATEUISTATE = 0x0128
Global Const $WM_QUERYUISTATE = 0x0129
Global Const $WM_LBTRACKPOINT = 0x0131
Global Const $WM_CTLCOLORMSGBOX = 0x0132
Global Const $WM_CTLCOLOREDIT = 0x0133
Global Const $WM_CTLCOLORLISTBOX = 0x0134
Global Const $WM_CTLCOLORBTN = 0x0135
Global Const $WM_CTLCOLORDLG = 0x0136
Global Const $WM_CTLCOLORSCROLLBAR = 0x0137
Global Const $WM_CTLCOLORSTATIC = 0x0138
Global Const $MN_GETHMENU = 0x01E1
Global Const $WM_PARENTNOTIFY = 0x0210
Global Const $WM_ENTERMENULOOP = 0x0211
Global Const $WM_EXITMENULOOP = 0x0212
Global Const $WM_NEXTMENU = 0x0213
Global Const $WM_SIZING = 0x0214
Global Const $WM_CAPTURECHANGED = 0x0215
Global Const $WM_MOVING = 0x0216
Global Const $WM_POWERBROADCAST = 0x0218
Global Const $WM_DEVICECHANGE = 0x0219
Global Const $WM_MDICREATE = 0x0220
Global Const $WM_MDIDESTROY = 0x0221
Global Const $WM_MDIACTIVATE = 0x0222
Global Const $WM_MDIRESTORE = 0x0223
Global Const $WM_MDINEXT = 0x0224
Global Const $WM_MDIMAXIMIZE = 0x0225
Global Const $WM_MDITILE = 0x0226
Global Const $WM_MDICASCADE = 0x0227
Global Const $WM_MDIICONARRANGE = 0x0228
Global Const $WM_MDIGETACTIVE = 0x0229
Global Const $WM_DROPOBJECT = 0x022A
Global Const $WM_QUERYDROPOBJECT = 0x022B
Global Const $WM_BEGINDRAG = 0x022C
Global Const $WM_DRAGLOOP = 0x022D
Global Const $WM_DRAGSELECT = 0x022E
Global Const $WM_DRAGMOVE = 0x022F
Global Const $WM_MDISETMENU = 0x0230
Global Const $WM_ENTERSIZEMOVE = 0x0231
Global Const $WM_EXITSIZEMOVE = 0x0232
Global Const $WM_DROPFILES = 0x0233
Global Const $WM_MDIREFRESHMENU = 0x0234
Global Const $WM_TOUCH = 0x0240
Global Const $WM_IME_SETCONTEXT = 0x0281
Global Const $WM_IME_NOTIFY = 0x0282
Global Const $WM_IME_CONTROL = 0x0283
Global Const $WM_IME_COMPOSITIONFULL = 0x0284
Global Const $WM_IME_SELECT = 0x0285
Global Const $WM_IME_CHAR = 0x0286
Global Const $WM_IME_SYSTEM = 0x0287
Global Const $WM_IME_REQUEST = 0x0288
Global Const $WM_IME_KEYDOWN = 0x0290
Global Const $WM_IME_KEYUP = 0x0291
Global Const $WM_NCMOUSEHOVER = 0x02A0
Global Const $WM_MOUSEHOVER = 0x02A1
Global Const $WM_NCMOUSELEAVE = 0x02A2
Global Const $WM_MOUSELEAVE = 0x02A3
Global Const $WM_WTSSESSION_CHANGE = 0x02B1
Global Const $WM_TABLET_FIRST = 0x02C0
Global Const $WM_TABLET_LAST = 0x02DF
Global Const $WM_CUT = 0x0300
Global Const $WM_COPY = 0x0301
Global Const $WM_PASTE = 0x0302
Global Const $WM_CLEAR = 0x0303
Global Const $WM_UNDO = 0x0304
Global Const $WM_PALETTEISCHANGING = 0x0310
Global Const $WM_HOTKEY = 0x0312
Global Const $WM_PALETTECHANGED = 0x0311
Global Const $WM_SYSMENU = 0x0313
Global Const $WM_HOOKMSG = 0x0314
Global Const $WM_EXITPROCESS = 0x0315
Global Const $WM_WAKETHREAD = 0x0316
Global Const $WM_PRINT = 0x0317
Global Const $WM_PRINTCLIENT = 0x0318
Global Const $WM_APPCOMMAND = 0x0319
Global Const $WM_QUERYNEWPALETTE = 0x030F
Global Const $WM_THEMECHANGED = 0x031A
Global Const $WM_UAHINIT = 0x031B
Global Const $WM_DESKTOPNOTIFY = 0x031C
Global Const $WM_CLIPBOARDUPDATE = 0x031D
Global Const $WM_DWMCOMPOSITIONCHANGED = 0x031E
Global Const $WM_DWMNCRENDERINGCHANGED = 0x031F
Global Const $WM_DWMCOLORIZATIONCOLORCHANGED = 0x0320
Global Const $WM_DWMWINDOWMAXIMIZEDCHANGE = 0x0321
Global Const $WM_DWMEXILEFRAME = 0x0322
Global Const $WM_DWMSENDICONICTHUMBNAIL = 0x0323
Global Const $WM_MAGNIFICATION_STARTED = 0x0324
Global Const $WM_MAGNIFICATION_ENDED = 0x0325
Global Const $WM_DWMSENDICONICLIVEPREVIEWBITMAP = 0x0326
Global Const $WM_DWMTHUMBNAILSIZECHANGED = 0x0327
Global Const $WM_MAGNIFICATION_OUTPUT = 0x0328
Global Const $WM_MEASURECONTROL = 0x0330
Global Const $WM_GETACTIONTEXT = 0x0331
Global Const $WM_FORWARDKEYDOWN = 0x0333
Global Const $WM_FORWARDKEYUP = 0x0334
Global Const $WM_GETTITLEBARINFOEX = 0x033F
Global Const $WM_NOTIFYWOW = 0x0340
Global Const $WM_HANDHELDFIRST = 0x0358
Global Const $WM_HANDHELDLAST = 0x035F
Global Const $WM_AFXFIRST = 0x0360
Global Const $WM_AFXLAST = 0x037F
Global Const $WM_PENWINFIRST = 0x0380
Global Const $WM_PENWINLAST = 0x038F
Global Const $WM_DDE_INITIATE = 0x03E0
Global Const $WM_DDE_TERMINATE = 0x03E1
Global Const $WM_DDE_ADVISE = 0x03E2
Global Const $WM_DDE_UNADVISE = 0x03E3
Global Const $WM_DDE_ACK = 0x03E4
Global Const $WM_DDE_DATA = 0x03E5
Global Const $WM_DDE_REQUEST = 0x03E6
Global Const $WM_DDE_POKE = 0x03E7
Global Const $WM_DDE_EXECUTE = 0x03E8
Global Const $WM_DBNOTIFICATION = 0x03FD
Global Const $WM_NETCONNECT = 0x03FE
Global Const $WM_HIBERNATE = 0x03FF
Global Const $WM_USER = 0x0400
Global Const $WM_APP = 0x8000
Global Const $NM_FIRST = 0
Global Const $NM_OUTOFMEMORY = $NM_FIRST - 1
Global Const $NM_CLICK = $NM_FIRST - 2
Global Const $NM_DBLCLK = $NM_FIRST - 3
Global Const $NM_RETURN = $NM_FIRST - 4
Global Const $NM_RCLICK = $NM_FIRST - 5
Global Const $NM_RDBLCLK = $NM_FIRST - 6
Global Const $NM_SETFOCUS = $NM_FIRST - 7
Global Const $NM_KILLFOCUS = $NM_FIRST - 8
Global Const $NM_CUSTOMDRAW = $NM_FIRST - 12
Global Const $NM_HOVER = $NM_FIRST - 13
Global Const $NM_NCHITTEST = $NM_FIRST - 14
Global Const $NM_KEYDOWN = $NM_FIRST - 15
Global Const $NM_RELEASEDCAPTURE = $NM_FIRST - 16
Global Const $NM_SETCURSOR = $NM_FIRST - 17
Global Const $NM_CHAR = $NM_FIRST - 18
Global Const $NM_TOOLTIPSCREATED = $NM_FIRST - 19
Global Const $NM_LDOWN = $NM_FIRST - 20
Global Const $NM_RDOWN = $NM_FIRST - 21
Global Const $NM_THEMECHANGED = $NM_FIRST - 22
Global Const $WM_MOUSEFIRST = 0x0200
Global Const $WM_MOUSEMOVE = 0x0200
Global Const $WM_LBUTTONDOWN = 0x0201
Global Const $WM_LBUTTONUP = 0x0202
Global Const $WM_LBUTTONDBLCLK = 0x0203
Global Const $WM_RBUTTONDOWN = 0x0204
Global Const $WM_RBUTTONUP = 0x0205
Global Const $WM_RBUTTONDBLCLK = 0x0206
Global Const $WM_MBUTTONDOWN = 0x0207
Global Const $WM_MBUTTONUP = 0x0208
Global Const $WM_MBUTTONDBLCLK = 0x0209
Global Const $WM_MOUSEWHEEL = 0x020A
Global Const $WM_XBUTTONDOWN = 0x020B
Global Const $WM_XBUTTONUP = 0x020C
Global Const $WM_XBUTTONDBLCLK = 0x020D
Global Const $WM_MOUSEHWHEEL = 0x020E
Global Const $PS_SOLID = 0
Global Const $PS_DASH = 1
Global Const $PS_DOT = 2
Global Const $PS_DASHDOT = 3
Global Const $PS_DASHDOTDOT = 4
Global Const $PS_NULL = 5
Global Const $PS_INSIDEFRAME = 6
Global Const $PS_USERSTYLE = 7
Global Const $PS_ALTERNATE = 8
Global Const $PS_ENDCAP_ROUND = 0x00000000
Global Const $PS_ENDCAP_SQUARE = 0x00000100
Global Const $PS_ENDCAP_FLAT = 0x00000200
Global Const $PS_JOIN_BEVEL = 0x00001000
Global Const $PS_JOIN_MITER = 0x00002000
Global Const $PS_JOIN_ROUND = 0x00000000
Global Const $PS_GEOMETRIC = 0x00010000
Global Const $PS_COSMETIC = 0x00000000
Global Const $LWA_ALPHA = 0x2
Global Const $LWA_COLORKEY = 0x1
Global Const $RGN_AND = 1
Global Const $RGN_OR = 2
Global Const $RGN_XOR = 3
Global Const $RGN_DIFF = 4
Global Const $RGN_COPY = 5
Global Const $ERRORREGION = 0
Global Const $NULLREGION = 1
Global Const $SIMPLEREGION = 2
Global Const $COMPLEXREGION = 3
Global Const $TRANSPARENT = 1
Global Const $OPAQUE = 2
Global Const $CCM_FIRST = 0x2000
Global Const $CCM_GETUNICODEFORMAT = ($CCM_FIRST + 6)
Global Const $CCM_SETUNICODEFORMAT = ($CCM_FIRST + 5)
Global Const $CCM_SETBKCOLOR = $CCM_FIRST + 1
Global Const $CCM_SETCOLORSCHEME = $CCM_FIRST + 2
Global Const $CCM_GETCOLORSCHEME = $CCM_FIRST + 3
Global Const $CCM_GETDROPTARGET = $CCM_FIRST + 4
Global Const $CCM_SETWINDOWTHEME = $CCM_FIRST + 11
Global Const $GA_PARENT = 1
Global Const $GA_ROOT = 2
Global Const $GA_ROOTOWNER = 3
Global Const $SM_CXSCREEN = 0
Global Const $SM_CYSCREEN = 1
Global Const $SM_CXVSCROLL = 2
Global Const $SM_CYHSCROLL = 3
Global Const $SM_CYCAPTION = 4
Global Const $SM_CXBORDER = 5
Global Const $SM_CYBORDER = 6
Global Const $SM_CXFIXEDFRAME = 7
Global Const $SM_CXDLGFRAME = $SM_CXFIXEDFRAME
Global Const $SM_CYFIXEDFRAME = 8
Global Const $SM_CYDLGFRAME = $SM_CYFIXEDFRAME
Global Const $SM_CYVTHUMB = 9
Global Const $SM_CXHTHUMB = 10
Global Const $SM_CXICON = 11
Global Const $SM_CYICON = 12
Global Const $SM_CXCURSOR = 13
Global Const $SM_CYCURSOR = 14
Global Const $SM_CYMENU = 15
Global Const $SM_CXFULLSCREEN = 16
Global Const $SM_CYFULLSCREEN = 17
Global Const $SM_CYKANJIWINDOW = 18
Global Const $SM_MOUSEPRESENT = 19
Global Const $SM_CYVSCROLL = 20
Global Const $SM_CXHSCROLL = 21
Global Const $SM_DEBUG = 22
Global Const $SM_SWAPBUTTON = 23
Global Const $SM_RESERVED1 = 24
Global Const $SM_RESERVED2 = 25
Global Const $SM_RESERVED3 = 26
Global Const $SM_RESERVED4 = 27
Global Const $SM_CXMIN = 28
Global Const $SM_CYMIN = 29
Global Const $SM_CXSIZE = 30
Global Const $SM_CYSIZE = 31
Global Const $SM_CXSIZEFRAME = 32
Global Const $SM_CXFRAME = $SM_CXSIZEFRAME
Global Const $SM_CYSIZEFRAME = 33
Global Const $SM_CYFRAME = $SM_CYSIZEFRAME
Global Const $SM_CXMINTRACK = 34
Global Const $SM_CYMINTRACK = 35
Global Const $SM_CXDOUBLECLK = 36
Global Const $SM_CYDOUBLECLK = 37
Global Const $SM_CXICONSPACING = 38
Global Const $SM_CYICONSPACING = 39
Global Const $SM_MENUDROPALIGNMENT = 40
Global Const $SM_PENWINDOWS = 41
Global Const $SM_DBCSENABLED = 42
Global Const $SM_CMOUSEBUTTONS = 43
Global Const $SM_SECURE = 44
Global Const $SM_CXEDGE = 45
Global Const $SM_CYEDGE = 46
Global Const $SM_CXMINSPACING = 47
Global Const $SM_CYMINSPACING = 48
Global Const $SM_CXSMICON = 49
Global Const $SM_CYSMICON = 50
Global Const $SM_CYSMCAPTION = 51
Global Const $SM_CXSMSIZE = 52
Global Const $SM_CYSMSIZE = 53
Global Const $SM_CXMENUSIZE = 54
Global Const $SM_CYMENUSIZE = 55
Global Const $SM_ARRANGE = 56
Global Const $SM_CXMINIMIZED = 57
Global Const $SM_CYMINIMIZED = 58
Global Const $SM_CXMAXTRACK = 59
Global Const $SM_CYMAXTRACK = 60
Global Const $SM_CXMAXIMIZED = 61
Global Const $SM_CYMAXIMIZED = 62
Global Const $SM_NETWORK = 63
Global Const $SM_CLEANBOOT = 67
Global Const $SM_CXDRAG = 68
Global Const $SM_CYDRAG = 69
Global Const $SM_SHOWSOUNDS = 70
Global Const $SM_CXMENUCHECK = 71
Global Const $SM_CYMENUCHECK = 72
Global Const $SM_SLOWMACHINE = 73
Global Const $SM_MIDEASTENABLED = 74
Global Const $SM_MOUSEWHEELPRESENT = 75
Global Const $SM_XVIRTUALSCREEN = 76
Global Const $SM_YVIRTUALSCREEN = 77
Global Const $SM_CXVIRTUALSCREEN = 78
Global Const $SM_CYVIRTUALSCREEN = 79
Global Const $SM_CMONITORS = 80
Global Const $SM_SAMEDISPLAYFORMAT = 81
Global Const $SM_IMMENABLED = 82
Global Const $SM_CXFOCUSBORDER = 83
Global Const $SM_CYFOCUSBORDER = 84
Global Const $SM_TABLETPC = 86
Global Const $SM_MEDIACENTER = 87
Global Const $SM_STARTER = 88
Global Const $SM_SERVERR2 = 89
Global Const $SM_CMETRICS = 90
Global Const $SM_REMOTESESSION = 0x1000
Global Const $SM_SHUTTINGDOWN = 0x2000
Global Const $SM_REMOTECONTROL = 0x2001
Global Const $SM_CARETBLINKINGENABLED = 0x2002
Global Const $BLACKNESS = 0x00000042
Global Const $CAPTUREBLT = 0X40000000
Global Const $DSTINVERT = 0x00550009
Global Const $MERGECOPY = 0x00C000CA
Global Const $MERGEPAINT = 0x00BB0226
Global Const $NOMIRRORBITMAP = 0X80000000
Global Const $NOTSRCCOPY = 0x00330008
Global Const $NOTSRCERASE = 0x001100A6
Global Const $PATCOPY = 0x00F00021
Global Const $PATINVERT = 0x005A0049
Global Const $PATPAINT = 0x00FB0A09
Global Const $SRCAND = 0x008800C6
Global Const $SRCCOPY = 0x00CC0020
Global Const $SRCERASE = 0x00440328
Global Const $SRCINVERT = 0x00660046
Global Const $SRCPAINT = 0x00EE0086
Global Const $WHITENESS = 0x00FF0062
Global Const $DT_BOTTOM = 0x8
Global Const $DT_CALCRECT = 0x400
Global Const $DT_CENTER = 0x1
Global Const $DT_EDITCONTROL = 0x2000
Global Const $DT_END_ELLIPSIS = 0x8000
Global Const $DT_EXPANDTABS = 0x40
Global Const $DT_EXTERNALLEADING = 0x200
Global Const $DT_HIDEPREFIX = 0x100000
Global Const $DT_INTERNAL = 0x1000
Global Const $DT_LEFT = 0x0
Global Const $DT_MODIFYSTRING = 0x10000
Global Const $DT_NOCLIP = 0x100
Global Const $DT_NOFULLWIDTHCHARBREAK = 0x80000
Global Const $DT_NOPREFIX = 0x800
Global Const $DT_PATH_ELLIPSIS = 0x4000
Global Const $DT_PREFIXONLY = 0x200000
Global Const $DT_RIGHT = 0x2
Global Const $DT_RTLREADING = 0x20000
Global Const $DT_SINGLELINE = 0x20
Global Const $DT_TABSTOP = 0x80
Global Const $DT_TOP = 0x0
Global Const $DT_VCENTER = 0x4
Global Const $DT_WORDBREAK = 0x10
Global Const $DT_WORD_ELLIPSIS = 0x40000
Global Const $RDW_ERASE = 0x0004
Global Const $RDW_FRAME = 0x0400
Global Const $RDW_INTERNALPAINT = 0x0002
Global Const $RDW_INVALIDATE = 0x0001
Global Const $RDW_NOERASE = 0x0020
Global Const $RDW_NOFRAME = 0x0800
Global Const $RDW_NOINTERNALPAINT = 0x0010
Global Const $RDW_VALIDATE = 0x0008
Global Const $RDW_ERASENOW = 0x0200
Global Const $RDW_UPDATENOW = 0x0100
Global Const $RDW_ALLCHILDREN = 0x0080
Global Const $RDW_NOCHILDREN = 0x0040
Global Const $WM_RENDERFORMAT = 0x0305
Global Const $WM_RENDERALLFORMATS = 0x0306
Global Const $WM_DESTROYCLIPBOARD = 0x0307
Global Const $WM_DRAWCLIPBOARD = 0x0308
Global Const $WM_PAINTCLIPBOARD = 0x0309
Global Const $WM_VSCROLLCLIPBOARD = 0x030A
Global Const $WM_SIZECLIPBOARD = 0x030B
Global Const $WM_ASKCBFORMATNAME = 0x030C
Global Const $WM_CHANGECBCHAIN = 0x030D
Global Const $WM_HSCROLLCLIPBOARD = 0x030E
Global Const $HTERROR = -2
Global Const $HTTRANSPARENT = -1
Global Const $HTNOWHERE = 0
Global Const $HTCLIENT = 1
Global Const $HTCAPTION = 2
Global Const $HTSYSMENU = 3
Global Const $HTGROWBOX = 4
Global Const $HTSIZE = $HTGROWBOX
Global Const $HTMENU = 5
Global Const $HTHSCROLL = 6
Global Const $HTVSCROLL = 7
Global Const $HTMINBUTTON = 8
Global Const $HTMAXBUTTON = 9
Global Const $HTLEFT = 10
Global Const $HTRIGHT = 11
Global Const $HTTOP = 12
Global Const $HTTOPLEFT = 13
Global Const $HTTOPRIGHT = 14
Global Const $HTBOTTOM = 15
Global Const $HTBOTTOMLEFT = 16
Global Const $HTBOTTOMRIGHT = 17
Global Const $HTBORDER = 18
Global Const $HTREDUCE = $HTMINBUTTON
Global Const $HTZOOM = $HTMAXBUTTON
Global Const $HTSIZEFIRST = $HTLEFT
Global Const $HTSIZELAST = $HTBOTTOMRIGHT
Global Const $HTOBJECT = 19
Global Const $HTCLOSE = 20
Global Const $HTHELP = 21
Global Const $COLOR_SCROLLBAR = 0
Global Const $COLOR_BACKGROUND = 1
Global Const $COLOR_ACTIVECAPTION = 2
Global Const $COLOR_INACTIVECAPTION = 3
Global Const $COLOR_MENU = 4
Global Const $COLOR_WINDOW = 5
Global Const $COLOR_WINDOWFRAME = 6
Global Const $COLOR_MENUTEXT = 7
Global Const $COLOR_WINDOWTEXT = 8
Global Const $COLOR_CAPTIONTEXT = 9
Global Const $COLOR_ACTIVEBORDER = 10
Global Const $COLOR_INACTIVEBORDER = 11
Global Const $COLOR_APPWORKSPACE = 12
Global Const $COLOR_HIGHLIGHT = 13
Global Const $COLOR_HIGHLIGHTTEXT = 14
Global Const $COLOR_BTNFACE = 15
Global Const $COLOR_BTNSHADOW = 16
Global Const $COLOR_GRAYTEXT = 17
Global Const $COLOR_BTNTEXT = 18
Global Const $COLOR_INACTIVECAPTIONTEXT = 19
Global Const $COLOR_BTNHIGHLIGHT = 20
Global Const $COLOR_3DDKSHADOW = 21
Global Const $COLOR_3DLIGHT = 22
Global Const $COLOR_INFOTEXT = 23
Global Const $COLOR_INFOBK = 24
Global Const $COLOR_HOTLIGHT = 26
Global Const $COLOR_GRADIENTACTIVECAPTION = 27
Global Const $COLOR_GRADIENTINACTIVECAPTION = 28
Global Const $COLOR_MENUHILIGHT = 29
Global Const $COLOR_MENUBAR = 30
Global Const $COLOR_DESKTOP = 1
Global Const $COLOR_3DFACE = 15
Global Const $COLOR_3DSHADOW = 16
Global Const $COLOR_3DHIGHLIGHT = 20
Global Const $COLOR_3DHILIGHT = 20
Global Const $COLOR_BTNHILIGHT = 20
Global Const $HINST_COMMCTRL = -1
Global Const $IDB_STD_SMALL_COLOR = 0
Global Const $IDB_STD_LARGE_COLOR = 1
Global Const $IDB_VIEW_SMALL_COLOR = 4
Global Const $IDB_VIEW_LARGE_COLOR = 5
Global Const $IDB_HIST_SMALL_COLOR = 8
Global Const $IDB_HIST_LARGE_COLOR = 9
Global Const $STARTF_FORCEOFFFEEDBACK = 0x80
Global Const $STARTF_FORCEONFEEDBACK = 0x40
Global Const $STARTF_PREVENTPINNING = 0x00002000
Global Const $STARTF_RUNFULLSCREEN = 0x20
Global Const $STARTF_TITLEISAPPID = 0x00001000
Global Const $STARTF_TITLEISLINKNAME = 0x00000800
Global Const $STARTF_USECOUNTCHARS = 0x8
Global Const $STARTF_USEFILLATTRIBUTE = 0x10
Global Const $STARTF_USEHOTKEY = 0x200
Global Const $STARTF_USEPOSITION = 0x4
Global Const $STARTF_USESHOWWINDOW = 0x1
Global Const $STARTF_USESIZE = 0x2
Global Const $STARTF_USESTDHANDLES = 0x100
Global Const $CDDS_PREPAINT = 0x00000001
Global Const $CDDS_POSTPAINT = 0x00000002
Global Const $CDDS_PREERASE = 0x00000003
Global Const $CDDS_POSTERASE = 0x00000004
Global Const $CDDS_ITEM = 0x00010000
Global Const $CDDS_ITEMPREPAINT = 0x00010001
Global Const $CDDS_ITEMPOSTPAINT = 0x00010002
Global Const $CDDS_ITEMPREERASE = 0x00010003
Global Const $CDDS_ITEMPOSTERASE = 0x00010004
Global Const $CDDS_SUBITEM = 0x00020000
Global Const $CDIS_SELECTED = 0x0001
Global Const $CDIS_GRAYED = 0x0002
Global Const $CDIS_DISABLED = 0x0004
Global Const $CDIS_CHECKED = 0x0008
Global Const $CDIS_FOCUS = 0x0010
Global Const $CDIS_DEFAULT = 0x0020
Global Const $CDIS_HOT = 0x0040
Global Const $CDIS_MARKED = 0x0080
Global Const $CDIS_INDETERMINATE = 0x0100
Global Const $CDIS_SHOWKEYBOARDCUES = 0x0200
Global Const $CDIS_NEARHOT = 0x0400
Global Const $CDIS_OTHERSIDEHOT = 0x0800
Global Const $CDIS_DROPHILITED = 0x1000
Global Const $CDRF_DODEFAULT = 0x00000000
Global Const $CDRF_NEWFONT = 0x00000002
Global Const $CDRF_SKIPDEFAULT = 0x00000004
Global Const $CDRF_NOTIFYPOSTPAINT = 0x00000010
Global Const $CDRF_NOTIFYITEMDRAW = 0x00000020
Global Const $CDRF_NOTIFYSUBITEMDRAW = 0x00000020
Global Const $CDRF_NOTIFYPOSTERASE = 0x00000040
Global Const $CDRF_DOERASE = 0x00000008
Global Const $CDRF_SKIPPOSTPAINT = 0x00000100
Global Const $GUI_SS_DEFAULT_GUI = BitOR($WS_MINIMIZEBOX, $WS_CAPTION, $WS_POPUP, $WS_SYSMENU)
Global Const $VK_LBUTTON = 0x01
Global Const $VK_RBUTTON = 0x02
Global Const $VK_CANCEL = 0x03
Global Const $VK_MBUTTON = 0x04
Global Const $VK_XBUTTON1 = 0x05
Global Const $VK_XBUTTON2 = 0x06
Global Const $VK_BACK = 0x08
Global Const $VK_TAB = 0x09
Global Const $VK_CLEAR = 0x0C
Global Const $VK_RETURN = 0x0D
Global Const $VK_SHIFT = 0x10
Global Const $VK_CONTROL = 0x11
Global Const $VK_MENU = 0x12
Global Const $VK_PAUSE = 0x13
Global Const $VK_CAPITAL = 0x14
Global Const $VK_KANA = 0x15
Global Const $VK_HANGUL = 0x15
Global Const $VK_JUNJA = 0x17
Global Const $VK_FINAL = 0x18
Global Const $VK_HANJA = 0x19
Global Const $VK_KANJI = 0x19
Global Const $VK_ESCAPE = 0x1B
Global Const $VK_CONVERT = 0x1C
Global Const $VK_NONCONVERT = 0x1D
Global Const $VK_ACCEPT = 0x1E
Global Const $VK_MODECHANGE = 0x1F
Global Const $VK_SPACE = 0x20
Global Const $VK_PRIOR = 0x21
Global Const $VK_NEXT = 0x22
Global Const $VK_END = 0x23
Global Const $VK_HOME = 0x24
Global Const $VK_LEFT = 0x25
Global Const $VK_UP = 0x26
Global Const $VK_RIGHT = 0x27
Global Const $VK_DOWN = 0x28
Global Const $VK_SELECT = 0x29
Global Const $VK_PRINT = 0x2A
Global Const $VK_EXECUTE = 0x2B
Global Const $VK_SNAPSHOT = 0x2C
Global Const $VK_INSERT = 0x2D
Global Const $VK_DELETE = 0x2E
Global Const $VK_HELP = 0x2F
Global Const $VK_0 = 0x30
Global Const $VK_1 = 0x31
Global Const $VK_2 = 0x32
Global Const $VK_3 = 0x33
Global Const $VK_4 = 0x34
Global Const $VK_5 = 0x35
Global Const $VK_6 = 0x36
Global Const $VK_7 = 0x37
Global Const $VK_8 = 0x38
Global Const $VK_9 = 0x39
Global Const $VK_A = 0x41
Global Const $VK_B = 0x42
Global Const $VK_C = 0x43
Global Const $VK_D = 0x44
Global Const $VK_E = 0x45
Global Const $VK_F = 0x46
Global Const $VK_G = 0x47
Global Const $VK_H = 0x48
Global Const $VK_I = 0x49
Global Const $VK_J = 0x4A
Global Const $VK_K = 0x4B
Global Const $VK_L = 0x4C
Global Const $VK_M = 0x4D
Global Const $VK_N = 0x4E
Global Const $VK_O = 0x4F
Global Const $VK_P = 0x50
Global Const $VK_Q = 0x51
Global Const $VK_R = 0x52
Global Const $VK_S = 0x53
Global Const $VK_T = 0x54
Global Const $VK_U = 0x55
Global Const $VK_V = 0x56
Global Const $VK_W = 0x57
Global Const $VK_X = 0x58
Global Const $VK_Y = 0x59
Global Const $VK_Z = 0x5A
Global Const $VK_LWIN = 0x5B
Global Const $VK_RWIN = 0x5C
Global Const $VK_APPS = 0x5D
Global Const $VK_SLEEP = 0x5F
Global Const $VK_NUMPAD0 = 0x60
Global Const $VK_NUMPAD1 = 0x61
Global Const $VK_NUMPAD2 = 0x62
Global Const $VK_NUMPAD3 = 0x63
Global Const $VK_NUMPAD4 = 0x64
Global Const $VK_NUMPAD5 = 0x65
Global Const $VK_NUMPAD6 = 0x66
Global Const $VK_NUMPAD7 = 0x67
Global Const $VK_NUMPAD8 = 0x68
Global Const $VK_NUMPAD9 = 0x69
Global Const $VK_MULTIPLY = 0x6A
Global Const $VK_ADD = 0x6B
Global Const $VK_SEPARATOR = 0x6C
Global Const $VK_SUBTRACT = 0x6D
Global Const $VK_DECIMAL = 0x6E
Global Const $VK_DIVIDE = 0x6F
Global Const $VK_F1 = 0x70
Global Const $VK_F2 = 0x71
Global Const $VK_F3 = 0x72
Global Const $VK_F4 = 0x73
Global Const $VK_F5 = 0x74
Global Const $VK_F6 = 0x75
Global Const $VK_F7 = 0x76
Global Const $VK_F8 = 0x77
Global Const $VK_F9 = 0x78
Global Const $VK_F10 = 0x79
Global Const $VK_F11 = 0x7A
Global Const $VK_F12 = 0x7B
Global Const $VK_F13 = 0x7C
Global Const $VK_F14 = 0x7D
Global Const $VK_F15 = 0x7E
Global Const $VK_F16 = 0x7F
Global Const $VK_F17 = 0x80
Global Const $VK_F18 = 0x81
Global Const $VK_F19 = 0x82
Global Const $VK_F20 = 0x83
Global Const $VK_F21 = 0x84
Global Const $VK_F22 = 0x85
Global Const $VK_F23 = 0x86
Global Const $VK_F24 = 0x87
Global Const $VK_NUMLOCK = 0x90
Global Const $VK_SCROLL = 0x91
Global Const $VK_LSHIFT = 0xA0
Global Const $VK_RSHIFT = 0xA1
Global Const $VK_LCONTROL = 0xA2
Global Const $VK_RCONTROL = 0xA3
Global Const $VK_LMENU = 0xA4
Global Const $VK_RMENU = 0xA5
Global Const $VK_BROWSER_BACK = 0xA6
Global Const $VK_BROWSER_FORWARD = 0xA7
Global Const $VK_BROWSER_REFRESH = 0xA8
Global Const $VK_BROWSER_STOP = 0xA9
Global Const $VK_BROWSER_SEARCH = 0xAA
Global Const $VK_BROWSER_FAVORITES = 0xAB
Global Const $VK_BROWSER_HOME = 0xAC
Global Const $VK_VOLUME_MUTE = 0xAD
Global Const $VK_VOLUME_DOWN = 0xAE
Global Const $VK_VOLUME_UP = 0xAF
Global Const $VK_MEDIA_NEXT_TRACK = 0xB0
Global Const $VK_MEDIA_PREV_TRACK = 0xB1
Global Const $VK_MEDIA_STOP = 0xB2
Global Const $VK_MEDIA_PLAY_PAUSE = 0xB3
Global Const $VK_LAUNCH_MAIL = 0xB4
Global Const $VK_LAUNCH_MEDIA_SELECT = 0xB5
Global Const $VK_LAUNCH_APP1 = 0xB6
Global Const $VK_LAUNCH_APP2 = 0xB7
Global Const $VK_OEM_1 = 0xBA
Global Const $VK_OEM_PLUS = 0xBB
Global Const $VK_OEM_COMMA = 0xBC
Global Const $VK_OEM_MINUS = 0xBD
Global Const $VK_OEM_PERIOD = 0xBE
Global Const $VK_OEM_2 = 0xBF
Global Const $VK_OEM_3 = 0xC0
Global Const $VK_OEM_4 = 0xDB
Global Const $VK_OEM_5 = 0xDC
Global Const $VK_OEM_6 = 0xDD
Global Const $VK_OEM_7 = 0xDE
Global Const $VK_OEM_8 = 0xDF
Global Const $VK_OEM_102 = 0xE2
Global Const $VK_PROCESSKEY = 0xE5
Global Const $VK_PACKET = 0xE7
Global Const $VK_ATTN = 0xF6
Global Const $VK_CRSEL = 0xF7
Global Const $VK_EXSEL = 0xF8
Global Const $VK_EREOF = 0xF9
Global Const $VK_PLAY = 0xFA
Global Const $VK_ZOOM = 0xFB
Global Const $VK_NONAME = 0xFC
Global Const $VK_PA1 = 0xFD
Global Const $VK_OEM_CLEAR = 0xFE
Global Const $MF_UNHILITE = 0x0
Global Const $MF_ENABLED = 0x0
Global Const $MF_UNCHECKED = 0x0
Global Const $MF_STRING = 0x0
Global Const $MF_GRAYED = 0x00000001
Global Const $MF_DISABLED = 0x00000002
Global Const $MF_BITMAP = 0x00000004
Global Const $MF_CHECKED = 0x00000008
Global Const $MF_POPUP = 0x00000010
Global Const $MF_MENUBARBREAK = 0x00000020
Global Const $MF_MENUBREAK = 0x00000040
Global Const $MF_HILITE = 0x00000080
Global Const $MF_OWNERDRAW = 0x00000100
Global Const $MF_USECHECKBITMAPS = 0x00000200
Global Const $MF_BYPOSITION = 0x00000400
Global Const $MF_SEPARATOR = 0x00000800
Global Const $MF_DEFAULT = 0x00001000
Global Const $MF_SYSMENU = 0x00002000
Global Const $MF_HELP = 0x00004000
Global Const $MF_RIGHTJUSTIFY = 0x00004000
Global Const $MF_MOUSESELECT = 0x00008000
Global Const $MFS_GRAYED = 0x00000003
Global Const $MFS_DISABLED = $MFS_GRAYED
Global Const $MFS_CHECKED = $MF_CHECKED
Global Const $MFS_HILITE = $MF_HILITE
Global Const $MFS_ENABLED = $MF_ENABLED
Global Const $MFS_UNCHECKED = $MF_UNCHECKED
Global Const $MFS_UNHILITE = $MF_UNHILITE
Global Const $MFS_DEFAULT = $MF_DEFAULT
Global Const $MFT_STRING = $MF_STRING
Global Const $MFT_BITMAP = $MF_BITMAP
Global Const $MFT_MENUBARBREAK = $MF_MENUBARBREAK
Global Const $MFT_MENUBREAK = $MF_MENUBREAK
Global Const $MFT_OWNERDRAW = $MF_OWNERDRAW
Global Const $MFT_RADIOCHECK = 0x00000200
Global Const $MFT_SEPARATOR = $MF_SEPARATOR
Global Const $MFT_RIGHTORDER = 0x00002000
Global Const $MFT_RIGHTJUSTIFY = $MF_RIGHTJUSTIFY
Global Const $MIIM_STATE = 0x00000001
Global Const $MIIM_ID = 0x00000002
Global Const $MIIM_SUBMENU = 0x00000004
Global Const $MIIM_CHECKMARKS = 0x00000008
Global Const $MIIM_TYPE = 0x00000010
Global Const $MIIM_DATA = 0x00000020
Global Const $MIIM_DATAMASK = 0x0000003F
Global Const $MIIM_STRING = 0x00000040
Global Const $MIIM_BITMAP = 0x00000080
Global Const $MIIM_FTYPE = 0x00000100
Global Const $MIM_MAXHEIGHT = 0x00000001
Global Const $MIM_BACKGROUND = 0x00000002
Global Const $MIM_HELPID = 0x00000004
Global Const $MIM_MENUDATA = 0x00000008
Global Const $MIM_STYLE = 0x00000010
Global Const $MIM_APPLYTOSUBMENUS = 0x80000000
Global Const $MNS_CHECKORBMP = 0x04000000
Global Const $MNS_NOTIFYBYPOS = 0x08000000
Global Const $MNS_AUTODISMISS = 0x10000000
Global Const $MNS_DRAGDROP = 0x20000000
Global Const $MNS_MODELESS = 0x40000000
Global Const $MNS_NOCHECK = 0x80000000
Global Const $TPM_LEFTBUTTON = 0x0
Global Const $TPM_LEFTALIGN = 0x0
Global Const $TPM_TOPALIGN = 0x0
Global Const $TPM_HORIZONTAL = 0x0
Global Const $TPM_RECURSE = 0x00000001
Global Const $TPM_RIGHTBUTTON = 0x00000002
Global Const $TPM_CENTERALIGN = 0x00000004
Global Const $TPM_RIGHTALIGN = 0x00000008
Global Const $TPM_VCENTERALIGN = 0x00000010
Global Const $TPM_BOTTOMALIGN = 0x00000020
Global Const $TPM_VERTICAL = 0x00000040
Global Const $TPM_NONOTIFY = 0x00000080
Global Const $TPM_RETURNCMD = 0x00000100
Global Const $TPM_HORPOSANIMATION = 0x00000400
Global Const $TPM_HORNEGANIMATION = 0x00000800
Global Const $TPM_VERPOSANIMATION = 0x00001000
Global Const $TPM_VERNEGANIMATION = 0x00002000
Global Const $TPM_NOANIMATION = 0x00004000
Global Const $TPM_LAYOUTRTL = 0x00008000
Global Const $TPM_WORKAREA = 0x00010000
Global Const $SC_SIZE = 0xF000
Global Const $SC_MOVE = 0xF010
Global Const $SC_MINIMIZE = 0xF020
Global Const $SC_MAXIMIZE = 0xF030
Global Const $SC_NEXTWINDOW = 0xF040
Global Const $SC_PREVWINDOW = 0xF050
Global Const $SC_CLOSE = 0xF060
Global Const $SC_VSCROLL = 0xF070
Global Const $SC_HSCROLL = 0xF080
Global Const $SC_MOUSEMENU = 0xF090
Global Const $SC_KEYMENU = 0xF100
Global Const $SC_ARRANGE = 0xF110
Global Const $SC_RESTORE = 0xF120
Global Const $SC_TASKLIST = 0xF130
Global Const $SC_SCREENSAVE = 0xF140
Global Const $SC_HOTKEY = 0xF150
Global Const $SC_DEFAULT = 0xF160
Global Const $SC_MONITORPOWER = 0xF170
Global Const $SC_CONTEXTHELP = 0xF180
Global Const $SC_SEPARATOR = 0xF00F
Global Const $OBJID_SYSMENU = 0xFFFFFFFF
Global Const $OBJID_MENU = 0xFFFFFFFD
Global Const $__MENUCONSTANT_OBJID_CLIENT = 0xFFFFFFFC
Global Const $tagMENUBARINFO = "dword Size;" & $tagRECT & ";handle hMenu;handle hWndMenu;bool Focused"
Global Const $tagMDINEXTMENU = "handle hMenuIn;handle hMenuNext;hwnd hWndNext"
Global Const $tagMENUGETOBJECTINFO = "dword Flags;uint Pos;handle hMenu;ptr RIID;ptr Obj"
Global Const $tagTPMPARAMS = "uint Size;" & $tagRECT
Func _GUICtrlMenu_AddMenuItem($hMenu, $sText, $iCmdID = 0, $hSubMenu = 0)
Local $iIndex = _GUICtrlMenu_GetItemCount($hMenu)
Local $tMenu = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tMenu, "Size", DllStructGetSize($tMenu))
DllStructSetData($tMenu, "ID", $iCmdID)
DllStructSetData($tMenu, "SubMenu", $hSubMenu)
If $sText = "" Then
DllStructSetData($tMenu, "Mask", $MIIM_FTYPE)
DllStructSetData($tMenu, "Type", $MFT_SEPARATOR)
Else
DllStructSetData($tMenu, "Mask", BitOR($MIIM_ID, $MIIM_STRING, $MIIM_SUBMENU))
DllStructSetData($tMenu, "Type", $MFT_STRING)
Local $tText = DllStructCreate("wchar Text[" & StringLen($sText) + 1 & "]")
DllStructSetData($tText, "Text", $sText)
DllStructSetData($tMenu, "TypeData", DllStructGetPtr($tText))
EndIf
Local $aCall = DllCall("user32.dll", "bool", "InsertMenuItemW", "handle", $hMenu, "uint", $iIndex, "bool", True, "struct*", $tMenu)
If @error Then Return SetError(@error, @extended, -1)
Return SetExtended($aCall[0], $iIndex)
EndFunc
Func _GUICtrlMenu_AppendMenu($hMenu, $iFlags, $iNewItem, $vNewItem)
Local $sType = "wstr"
If BitAND($iFlags, $MF_BITMAP) Then $sType = "handle"
If BitAND($iFlags, $MF_OWNERDRAW) Then $sType = "ulong_ptr"
Local $aCall = DllCall("user32.dll", "bool", "AppendMenuW", "handle", $hMenu, "uint", $iFlags, "uint_ptr", $iNewItem, $sType, $vNewItem)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, False)
_GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hMenu))
Return True
EndFunc
Func _GUICtrlMenu_CalculatePopupWindowPosition($iX, $iY, $iWidth, $iHeight, $iFlags = 0, $tExclude = 0)
Local $tAnchor = DllStructCreate($tagPOINT)
DllStructSetData($tAnchor, 1, $iX)
DllStructSetData($tAnchor, 2, $iY)
Local $tSIZE = DllStructCreate($tagSIZE)
DllStructSetData($tSIZE, 1, $iWidth)
DllStructSetData($tSIZE, 2, $iHeight)
Local $tPos = DllStructCreate($tagRECT)
Local $aCall = DllCall('user32.dll', 'bool', 'CalculatePopupWindowPosition', 'struct*', $tAnchor, 'struct*', $tSIZE,  'uint', $iFlags, 'struct*', $tExclude, 'struct*', $tPos)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPos
EndFunc
Func _GUICtrlMenu_CheckMenuItem($hMenu, $iItem, $bCheck = True, $bByPos = True)
Local $iByPos = 0
If $bCheck Then $iByPos = BitOR($iByPos, $MF_CHECKED)
If $bByPos Then $iByPos = BitOR($iByPos, $MF_BYPOSITION)
Local $aCall = DllCall("user32.dll", "dword", "CheckMenuItem", "handle", $hMenu, "uint", $iItem, "uint", $iByPos)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_CheckRadioItem($hMenu, $iFirst, $iLast, $iCheck, $bByPos = True)
Local $iByPos = 0
If $bByPos Then $iByPos = $MF_BYPOSITION
Local $aCall = DllCall("user32.dll", "bool", "CheckMenuRadioItem", "handle", $hMenu, "uint", $iFirst, "uint", $iLast, "uint", $iCheck, "uint", $iByPos)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_CreateMenu($iStyle = $MNS_CHECKORBMP)
Local $aCall = DllCall("user32.dll", "handle", "CreateMenu")
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
_GUICtrlMenu_SetMenuStyle($aCall[0], $iStyle)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_CreatePopup($iStyle = $MNS_CHECKORBMP)
Local $aCall = DllCall("user32.dll", "handle", "CreatePopupMenu")
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, 0)
_GUICtrlMenu_SetMenuStyle($aCall[0], $iStyle)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_DeleteMenu($hMenu, $iItem, $bByPos = True)
Local $iByPos = 0
If $bByPos Then $iByPos = $MF_BYPOSITION
Local $aCall = DllCall("user32.dll", "bool", "DeleteMenu", "handle", $hMenu, "uint", $iItem, "uint", $iByPos)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, False)
_GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hMenu))
Return True
EndFunc
Func _GUICtrlMenu_DestroyMenu($hMenu)
Local $aCall = DllCall("user32.dll", "bool", "DestroyMenu", "handle", $hMenu)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_DrawMenuBar($hWnd)
Local $aCall = DllCall("user32.dll", "bool", "DrawMenuBar", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_EnableMenuItem($hMenu, $iItem, $iState = 0, $bByPos = True)
Local $iByPos = $iState
If $bByPos Then $iByPos = BitOR($iByPos, $MF_BYPOSITION)
Local $aCall = DllCall("user32.dll", "bool", "EnableMenuItem", "handle", $hMenu, "uint", $iItem, "uint", $iByPos)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, False)
_GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hMenu))
Return True
EndFunc
Func _GUICtrlMenu_EndMenu()
Local $aCall = DllCall("user32.dll", "bool", "EndMenu")
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_FindItem($hMenu, $sText, $bInStr = False, $iStart = 0)
Local $sMenu
For $iI = $iStart To _GUICtrlMenu_GetItemCount($hMenu)
$sMenu = StringReplace(_GUICtrlMenu_GetItemText($hMenu, $iI), "&", "")
Switch $bInStr
Case False
If $sMenu = $sText Then Return $iI
Case True
If StringInStr($sMenu, $sText) Then Return $iI
EndSwitch
Next
Return -1
EndFunc
Func _GUICtrlMenu_FindParent($hMenu)
Local $hList = _WinAPI_EnumWindowsTop()
For $iI = 1 To $hList[0][0]
If _GUICtrlMenu_GetMenu($hList[$iI][0]) = $hMenu Then Return $hList[$iI][0]
Next
EndFunc
Func _GUICtrlMenu_GetItemBmp($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "BmpItem")
EndFunc
Func _GUICtrlMenu_GetItemBmpChecked($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "BmpChecked")
EndFunc
Func _GUICtrlMenu_GetItemBmpUnchecked($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "BmpUnchecked")
EndFunc
Func _GUICtrlMenu_GetItemChecked($hMenu, $iItem, $bByPos = True)
Return BitAND(_GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos), $MF_CHECKED) <> 0
EndFunc
Func _GUICtrlMenu_GetItemCount($hMenu)
Local $aCall = DllCall("user32.dll", "int", "GetMenuItemCount", "handle", $hMenu)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_GetItemData($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "ItemData")
EndFunc
Func _GUICtrlMenu_GetItemDefault($hMenu, $iItem, $bByPos = True)
Return BitAND(_GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos), $MF_DEFAULT) <> 0
EndFunc
Func _GUICtrlMenu_GetItemDisabled($hMenu, $iItem, $bByPos = True)
Return BitAND(_GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos), $MF_DISABLED) <> 0
EndFunc
Func _GUICtrlMenu_GetItemEnabled($hMenu, $iItem, $bByPos = True)
Return BitAND(_GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos), $MF_DISABLED) = 0
EndFunc
Func _GUICtrlMenu_GetItemGrayed($hMenu, $iItem, $bByPos = True)
Return BitAND(_GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos), $MF_GRAYED) <> 0
EndFunc
Func _GUICtrlMenu_GetItemHighlighted($hMenu, $iItem, $bByPos = True)
Return BitAND(_GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos), $MF_HILITE) <> 0
EndFunc
Func _GUICtrlMenu_GetItemID($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "ID")
EndFunc
Func _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_DATAMASK)
Local $aCall = DllCall("user32.dll", "bool", "GetMenuItemInfo", "handle", $hMenu, "uint", $iItem, "bool", $bByPos, "struct*", $tInfo)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aCall[0], $tInfo)
EndFunc
Func _GUICtrlMenu_GetItemRect($hWnd, $hMenu, $iItem)
Local $tRECT = _GUICtrlMenu_GetItemRectEx($hWnd, $hMenu, $iItem)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlMenu_GetItemRectEx($hWnd, $hMenu, $iItem)
Local $tRECT = DllStructCreate($tagRECT)
Local $aCall = DllCall("user32.dll", "bool", "GetMenuItemRect", "hwnd", $hWnd, "handle", $hMenu, "uint", $iItem, "struct*", $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aCall[0], $tRECT)
EndFunc
Func _GUICtrlMenu_GetItemState($hMenu, $iItem, $bByPos = True)
Local $iRet = 0
Local $iState = _GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos)
If BitAND($iState, $MFS_CHECKED) <> 0 Then $iRet = BitOR($iRet, 1)
If BitAND($iState, $MFS_DEFAULT) <> 0 Then $iRet = BitOR($iRet, 2)
If BitAND($iState, $MFS_DISABLED) <> 0 Then $iRet = BitOR($iRet, 4)
If BitAND($iState, $MFS_GRAYED) <> 0 Then $iRet = BitOR($iRet, 8)
If BitAND($iState, $MFS_HILITE) <> 0 Then $iRet = BitOR($iRet, 16)
Return $iRet
EndFunc
Func _GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "State")
EndFunc
Func _GUICtrlMenu_GetItemSubMenu($hMenu, $iItem)
Local $aCall = DllCall("user32.dll", "handle", "GetSubMenu", "handle", $hMenu, "int", $iItem)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_GetItemText($hMenu, $iItem, $bByPos = True)
Local $iByPos = 0
If $bByPos Then $iByPos = $MF_BYPOSITION
Local $aCall = DllCall("user32.dll", "int", "GetMenuStringW", "handle", $hMenu, "uint", $iItem, "wstr", "", "int", 4096, "uint", $iByPos)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aCall[0], $aCall[3])
EndFunc
Func _GUICtrlMenu_GetItemType($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "Type")
EndFunc
Func _GUICtrlMenu_GetMenu($hWnd)
Local $aCall = DllCall("user32.dll", "handle", "GetMenu", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_GetMenuBackground($hMenu)
Local $tInfo = _GUICtrlMenu_GetMenuInfo($hMenu)
Return DllStructGetData($tInfo, "hBack")
EndFunc
Func _GUICtrlMenu_GetMenuBarInfo($hWnd, $iItem = 0, $iObject = 1)
Local $aObject[3] = [$__MENUCONSTANT_OBJID_CLIENT, $OBJID_MENU, $OBJID_SYSMENU]
Local $tInfo = DllStructCreate($tagMENUBARINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
Local $aCall = DllCall("user32.dll", "bool", "GetMenuBarInfo", "hwnd", $hWnd, "long", $aObject[$iObject], "long", $iItem, "struct*", $tInfo)
If @error Then Return SetError(@error, @extended, 0)
Local $aInfo[8]
$aInfo[0] = DllStructGetData($tInfo, "Left")
$aInfo[1] = DllStructGetData($tInfo, "Top")
$aInfo[2] = DllStructGetData($tInfo, "Right")
$aInfo[3] = DllStructGetData($tInfo, "Bottom")
$aInfo[4] = DllStructGetData($tInfo, "hMenu")
$aInfo[5] = DllStructGetData($tInfo, "hWndMenu")
$aInfo[6] = BitAND(DllStructGetData($tInfo, "Focused"), 1) <> 0
$aInfo[7] = BitAND(DllStructGetData($tInfo, "Focused"), 2) <> 0
Return SetExtended($aCall[0], $aInfo)
EndFunc
Func _GUICtrlMenu_GetMenuContextHelpID($hMenu)
Local $tInfo = _GUICtrlMenu_GetMenuInfo($hMenu)
Return DllStructGetData($tInfo, "ContextHelpID")
EndFunc
Func _GUICtrlMenu_GetMenuData($hMenu)
Local $tInfo = _GUICtrlMenu_GetMenuInfo($hMenu)
Return DllStructGetData($tInfo, "MenuData")
EndFunc
Func _GUICtrlMenu_GetMenuDefaultItem($hMenu, $bByPos = True, $iFlags = 0)
Local $aCall = DllCall("user32.dll", "INT", "GetMenuDefaultItem", "handle", $hMenu, "uint", $bByPos, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_GetMenuHeight($hMenu)
Local $tInfo = _GUICtrlMenu_GetMenuInfo($hMenu)
Return DllStructGetData($tInfo, "YMax")
EndFunc
Func _GUICtrlMenu_GetMenuInfo($hMenu)
Local $tInfo = DllStructCreate($tagMENUINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", BitOR($MIM_BACKGROUND, $MIM_HELPID, $MIM_MAXHEIGHT, $MIM_MENUDATA, $MIM_STYLE))
Local $aCall = DllCall("user32.dll", "bool", "GetMenuInfo", "handle", $hMenu, "struct*", $tInfo)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aCall[0], $tInfo)
EndFunc
Func _GUICtrlMenu_GetMenuStyle($hMenu)
Local $tInfo = _GUICtrlMenu_GetMenuInfo($hMenu)
Return DllStructGetData($tInfo, "Style")
EndFunc
Func _GUICtrlMenu_GetSystemMenu($hWnd, $bRevert = False)
Local $aCall = DllCall("user32.dll", "hwnd", "GetSystemMenu", "hwnd", $hWnd, "int", $bRevert)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_InsertMenuItem($hMenu, $iIndex, $sText, $iCmdID = 0, $hSubMenu = 0)
Local $tMenu = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tMenu, "Size", DllStructGetSize($tMenu))
DllStructSetData($tMenu, "ID", $iCmdID)
DllStructSetData($tMenu, "SubMenu", $hSubMenu)
If $sText = "" Then
DllStructSetData($tMenu, "Mask", $MIIM_FTYPE)
DllStructSetData($tMenu, "Type", $MFT_SEPARATOR)
Else
DllStructSetData($tMenu, "Mask", BitOR($MIIM_ID, $MIIM_STRING, $MIIM_SUBMENU))
DllStructSetData($tMenu, "Type", $MFT_STRING)
Local $tText = DllStructCreate("wchar Text[" & StringLen($sText) + 1 & "]")
DllStructSetData($tText, "Text", $sText)
DllStructSetData($tMenu, "TypeData", DllStructGetPtr($tText))
EndIf
Local $aCall = DllCall("user32.dll", "bool", "InsertMenuItemW", "handle", $hMenu, "uint", $iIndex, "bool", True, "struct*", $tMenu)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_InsertMenuItemEx($hMenu, $iIndex, ByRef $tMenu, $bByPos = True)
Local $aCall = DllCall("user32.dll", "bool", "InsertMenuItemW", "handle", $hMenu, "uint", $iIndex, "bool", $bByPos, "struct*", $tMenu)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_IsMenu($hMenu)
Local $aCall = DllCall("user32.dll", "bool", "IsMenu", "handle", $hMenu)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_LoadMenu($hInst, $sMenuName)
Local $aCall = DllCall("user32.dll", "handle", "LoadMenuW", "handle", $hInst, "wstr", $sMenuName)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_MapAccelerator($hMenu, $sAccelKey)
Local $sText
Local $iCount = _GUICtrlMenu_GetItemCount($hMenu)
For $iI = 0 To $iCount - 1
$sText = _GUICtrlMenu_GetItemText($hMenu, $iI)
If StringInStr($sText, "&" & $sAccelKey) > 0 Then Return $iI
Next
Return -1
EndFunc
Func _GUICtrlMenu_MenuItemFromPoint($hWnd, $hMenu, $iX = -1, $iY = -1)
If $iX = -1 Then $iX = _WinAPI_GetMousePosX()
If $iY = -1 Then $iY = _WinAPI_GetMousePosY()
Local $aCall = DllCall("user32.dll", "int", "MenuItemFromPoint", "hwnd", $hWnd, "handle", $hMenu, "int", $iX, "int", $iY)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_RemoveMenu($hMenu, $iItem, $bByPos = True)
Local $iByPos = 0
If $bByPos Then $iByPos = $MF_BYPOSITION
Local $aCall = DllCall("user32.dll", "bool", "RemoveMenu", "handle", $hMenu, "uint", $iItem, "uint", $iByPos)
If @error Or Not $aCall[0] Then Return SetError(@error + 10, @extended, False)
_GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hMenu))
Return True
EndFunc
Func _GUICtrlMenu_SetItemBitmaps($hMenu, $iItem, $hChecked, $hUnChecked, $bByPos = True)
Local $iByPos = 0
If $bByPos Then $iByPos = $MF_BYPOSITION
Local $aCall = DllCall("user32.dll", "bool", "SetMenuItemBitmaps", "handle", $hMenu, "uint", $iItem, "uint", $iByPos, "handle", $hUnChecked, "handle", $hChecked)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_SetItemBmp($hMenu, $iItem, $hBitmap, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_BITMAP)
DllStructSetData($tInfo, "BmpItem", $hBitmap)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemBmpChecked($hMenu, $iItem, $hBitmap, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
DllStructSetData($tInfo, "Mask", $MIIM_CHECKMARKS)
DllStructSetData($tInfo, "BmpChecked", $hBitmap)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemBmpUnchecked($hMenu, $iItem, $hBitmap, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
DllStructSetData($tInfo, "Mask", $MIIM_CHECKMARKS)
DllStructSetData($tInfo, "BmpUnchecked", $hBitmap)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemChecked($hMenu, $iItem, $bState = True, $bByPos = True)
Return _GUICtrlMenu_SetItemState($hMenu, $iItem, $MFS_CHECKED, $bState, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemData($hMenu, $iItem, $iData, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_DATA)
DllStructSetData($tInfo, "ItemData", $iData)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemDefault($hMenu, $iItem, $bState = True, $bByPos = True)
Return _GUICtrlMenu_SetItemState($hMenu, $iItem, $MFS_DEFAULT, $bState, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemDisabled($hMenu, $iItem, $bState = True, $bByPos = True)
Return _GUICtrlMenu_SetItemState($hMenu, $iItem, BitOR($MFS_DISABLED, $MFS_GRAYED), $bState, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemEnabled($hMenu, $iItem, $bState = True, $bByPos = True)
Return _GUICtrlMenu_SetItemState($hMenu, $iItem, BitOR($MFS_DISABLED, $MFS_GRAYED), Not $bState, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemGrayed($hMenu, $iItem, $bState = True, $bByPos = True)
Return _GUICtrlMenu_SetItemState($hMenu, $iItem, $MFS_GRAYED, $bState, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemHighlighted($hMenu, $iItem, $bState = True, $bByPos = True)
Return _GUICtrlMenu_SetItemState($hMenu, $iItem, $MFS_HILITE, $bState, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemID($hMenu, $iItem, $iID, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_ID)
DllStructSetData($tInfo, "ID", $iID)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemInfo($hMenu, $iItem, ByRef $tInfo, $bByPos = True)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
Local $aCall = DllCall("user32.dll", "bool", "SetMenuItemInfoW", "handle", $hMenu, "uint", $iItem, "bool", $bByPos, "struct*", $tInfo)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_SetItemState($hMenu, $iItem, $iState, $bState = True, $bByPos = True)
Local $iFlag = _GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos)
If $bState Then
$iState = BitOR($iFlag, $iState)
Else
$iState = BitAND($iFlag, BitNOT($iState))
EndIf
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_STATE)
DllStructSetData($tInfo, "State", $iState)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemSubMenu($hMenu, $iItem, $hSubMenu, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_SUBMENU)
DllStructSetData($tInfo, "SubMenu", $hSubMenu)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemText($hMenu, $iItem, $sText, $bByPos = True)
Local $tBuffer = DllStructCreate("wchar Text[" & StringLen($sText) + 1 & "]")
DllStructSetData($tBuffer, "Text", $sText)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_STRING)
DllStructSetData($tInfo, "TypeData", DllStructGetPtr($tBuffer))
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemType($hMenu, $iItem, $iType, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_FTYPE)
DllStructSetData($tInfo, "Type", $iType)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetMenu($hWnd, $hMenu)
Local $aCall = DllCall("user32.dll", "bool", "SetMenu", "hwnd", $hWnd, "handle", $hMenu)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_SetMenuBackground($hMenu, $hBrush)
Local $tInfo = DllStructCreate($tagMENUINFO)
DllStructSetData($tInfo, "Mask", $MIM_BACKGROUND)
DllStructSetData($tInfo, "hBack", $hBrush)
Return _GUICtrlMenu_SetMenuInfo($hMenu, $tInfo)
EndFunc
Func _GUICtrlMenu_SetMenuContextHelpID($hMenu, $iHelpID)
Local $tInfo = DllStructCreate($tagMENUINFO)
DllStructSetData($tInfo, "Mask", $MIM_HELPID)
DllStructSetData($tInfo, "ContextHelpID", $iHelpID)
Return _GUICtrlMenu_SetMenuInfo($hMenu, $tInfo)
EndFunc
Func _GUICtrlMenu_SetMenuData($hMenu, $iData)
Local $tInfo = DllStructCreate($tagMENUINFO)
DllStructSetData($tInfo, "Mask", $MIM_MENUDATA)
DllStructSetData($tInfo, "MenuData", $iData)
Return _GUICtrlMenu_SetMenuInfo($hMenu, $tInfo)
EndFunc
Func _GUICtrlMenu_SetMenuDefaultItem($hMenu, $iItem, $bByPos = True)
Local $aCall = DllCall("user32.dll", "bool", "SetMenuDefaultItem", "handle", $hMenu, "uint", $iItem, "uint", $bByPos)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_SetMenuHeight($hMenu, $iHeight)
Local $tInfo = DllStructCreate($tagMENUINFO)
DllStructSetData($tInfo, "Mask", $MIM_MAXHEIGHT)
DllStructSetData($tInfo, "YMax", $iHeight)
Return _GUICtrlMenu_SetMenuInfo($hMenu, $tInfo)
EndFunc
Func _GUICtrlMenu_SetMenuInfo($hMenu, ByRef $tInfo)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
Local $aCall = DllCall("user32.dll", "bool", "SetMenuInfo", "handle", $hMenu, "struct*", $tInfo)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUICtrlMenu_SetMenuStyle($hMenu, $iStyle)
Local $tInfo = DllStructCreate($tagMENUINFO)
DllStructSetData($tInfo, "Mask", $MIM_STYLE)
DllStructSetData($tInfo, "Style", $iStyle)
Return _GUICtrlMenu_SetMenuInfo($hMenu, $tInfo)
EndFunc
Func _GUICtrlMenu_TrackPopupMenu($hMenu, $hWnd, $iX = -1, $iY = -1, $iAlignX = 1, $iAlignY = 1, $iNotify = 0, $iButtons = 0)
If $iX = -1 Then $iX = _WinAPI_GetMousePosX()
If $iY = -1 Then $iY = _WinAPI_GetMousePosY()
Local $iFlags = 0
Switch $iAlignX
Case 1
$iFlags = BitOR($iFlags, $TPM_LEFTALIGN)
Case 2
$iFlags = BitOR($iFlags, $TPM_RIGHTALIGN)
Case Else
$iFlags = BitOR($iFlags, $TPM_CENTERALIGN)
EndSwitch
Switch $iAlignY
Case 1
$iFlags = BitOR($iFlags, $TPM_TOPALIGN)
Case 2
$iFlags = BitOR($iFlags, $TPM_VCENTERALIGN)
Case Else
$iFlags = BitOR($iFlags, $TPM_BOTTOMALIGN)
EndSwitch
If BitAND($iNotify, 1) <> 0 Then $iFlags = BitOR($iFlags, $TPM_NONOTIFY)
If BitAND($iNotify, 2) <> 0 Then $iFlags = BitOR($iFlags, $TPM_RETURNCMD)
Switch $iButtons
Case 1
$iFlags = BitOR($iFlags, $TPM_RIGHTBUTTON)
Case Else
$iFlags = BitOR($iFlags, $TPM_LEFTBUTTON)
EndSwitch
Local $aCall = DllCall("user32.dll", "bool", "TrackPopupMenu", "handle", $hMenu, "uint", $iFlags, "int", $iX, "int", $iY, "int", 0, "hwnd", $hWnd, "ptr", 0)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Global Const $ES_LEFT = 0
Global Const $ES_CENTER = 1
Global Const $ES_RIGHT = 2
Global Const $ES_MULTILINE = 4
Global Const $ES_UPPERCASE = 8
Global Const $ES_LOWERCASE = 16
Global Const $ES_PASSWORD = 32
Global Const $ES_AUTOVSCROLL = 64
Global Const $ES_AUTOHSCROLL = 128
Global Const $ES_NOHIDESEL = 256
Global Const $ES_OEMCONVERT = 1024
Global Const $ES_READONLY = 2048
Global Const $ES_WANTRETURN = 4096
Global Const $ES_NUMBER = 8192
Global Const $EC_ERR = -1
Global Const $ECM_FIRST = 0X1500
Global Const $EM_CANUNDO = 0xC6
Global Const $EM_CHARFROMPOS = 0xD7
Global Const $EM_EMPTYUNDOBUFFER = 0xCD
Global Const $EM_FMTLINES = 0xC8
Global Const $EM_GETCUEBANNER = ($ECM_FIRST + 2)
Global Const $EM_GETFIRSTVISIBLELINE = 0xCE
Global Const $EM_GETHANDLE = 0xBD
Global Const $EM_GETIMESTATUS = 0xD9
Global Const $EM_GETLIMITTEXT = 0xD5
Global Const $EM_GETLINE = 0xC4
Global Const $EM_GETLINECOUNT = 0xBA
Global Const $EM_GETMARGINS = 0xD4
Global Const $EM_GETMODIFY = 0xB8
Global Const $EM_GETPASSWORDCHAR = 0xD2
Global Const $EM_GETRECT = 0xB2
Global Const $EM_GETSEL = 0xB0
Global Const $EM_GETTHUMB = 0xBE
Global Const $EM_GETWORDBREAKPROC = 0xD1
Global Const $EM_HIDEBALLOONTIP = ($ECM_FIRST + 4)
Global Const $EM_LIMITTEXT = 0xC5
Global Const $EM_LINEFROMCHAR = 0xC9
Global Const $EM_LINEINDEX = 0xBB
Global Const $EM_LINELENGTH = 0xC1
Global Const $EM_LINESCROLL = 0xB6
Global Const $EM_POSFROMCHAR = 0xD6
Global Const $EM_REPLACESEL = 0xC2
Global Const $EM_SCROLL = 0xB5
Global Const $EM_SCROLLCARET = 0x00B7
Global Const $EM_SETCUEBANNER = ($ECM_FIRST + 1)
Global Const $EM_SETHANDLE = 0xBC
Global Const $EM_SETIMESTATUS = 0xD8
Global Const $EM_SETLIMITTEXT = $EM_LIMITTEXT
Global Const $EM_SETMARGINS = 0xD3
Global Const $EM_SETMODIFY = 0xB9
Global Const $EM_SETPASSWORDCHAR = 0xCC
Global Const $EM_SETREADONLY = 0xCF
Global Const $EM_SETRECT = 0xB3
Global Const $EM_SETRECTNP = 0xB4
Global Const $EM_SETSEL = 0xB1
Global Const $EM_SETTABSTOPS = 0xCB
Global Const $EM_SETWORDBREAKPROC = 0xD0
Global Const $EM_SHOWBALLOONTIP = ($ECM_FIRST + 3)
Global Const $EM_UNDO = 0xC7
Global Const $EC_LEFTMARGIN = 0x1
Global Const $EC_RIGHTMARGIN = 0x2
Global Const $EC_USEFONTINFO = 0xFFFF
Global Const $EMSIS_COMPOSITIONSTRING = 0x1
Global Const $EIMES_GETCOMPSTRATONCE = 0x1
Global Const $EIMES_CANCELCOMPSTRINFOCUS = 0x2
Global Const $EIMES_COMPLETECOMPSTRKILLFOCUS = 0x4
Global Const $EN_ALIGN_LTR_EC = 0x700
Global Const $EN_ALIGN_RTL_EC = 0x701
Global Const $EN_CHANGE = 0x300
Global Const $EN_ERRSPACE = 0x500
Global Const $EN_HSCROLL = 0X601
Global Const $EN_KILLFOCUS = 0x200
Global Const $EN_MAXTEXT = 0x501
Global Const $EN_SETFOCUS = 0x100
Global Const $EN_UPDATE = 0x400
Global Const $EN_VSCROLL = 0x602
Global Const $GUI_SS_DEFAULT_EDIT = 0x003010c0
Global Const $GUI_SS_DEFAULT_INPUT = 0x00000080
Global Const $SBARS_SIZEGRIP = 0x100
Global Const $SBT_TOOLTIPS = 0x800
Global Const $SBARS_TOOLTIPS = 0x800
Global Const $SBT_SUNKEN = 0x0
Global Const $SBT_NOBORDERS = 0x100
Global Const $SBT_POPOUT = 0x200
Global Const $SBT_RTLREADING = 0x400
Global Const $SBT_NOTABPARSING = 0x800
Global Const $SBT_OWNERDRAW = 0x1000
Global Const $__STATUSBARCONSTANT_WM_USER = 0X400
Global Const $SB_GETBORDERS = ($__STATUSBARCONSTANT_WM_USER + 7)
Global Const $SB_GETICON = ($__STATUSBARCONSTANT_WM_USER + 20)
Global Const $SB_GETPARTS = ($__STATUSBARCONSTANT_WM_USER + 6)
Global Const $SB_GETRECT = ($__STATUSBARCONSTANT_WM_USER + 10)
Global Const $SB_GETTEXTA = ($__STATUSBARCONSTANT_WM_USER + 2)
Global Const $SB_GETTEXTW = ($__STATUSBARCONSTANT_WM_USER + 13)
Global Const $SB_GETTEXT = $SB_GETTEXTA
Global Const $SB_GETTEXTLENGTHA = ($__STATUSBARCONSTANT_WM_USER + 3)
Global Const $SB_GETTEXTLENGTHW = ($__STATUSBARCONSTANT_WM_USER + 12)
Global Const $SB_GETTEXTLENGTH = $SB_GETTEXTLENGTHA
Global Const $SB_GETTIPTEXTA = ($__STATUSBARCONSTANT_WM_USER + 18)
Global Const $SB_GETTIPTEXTW = ($__STATUSBARCONSTANT_WM_USER + 19)
Global Const $SB_GETUNICODEFORMAT = 0x2000 + 6
Global Const $SB_ISSIMPLE = ($__STATUSBARCONSTANT_WM_USER + 14)
Global Const $SB_SETBKCOLOR = 0x2000 + 1
Global Const $SB_SETICON = ($__STATUSBARCONSTANT_WM_USER + 15)
Global Const $SB_SETMINHEIGHT = ($__STATUSBARCONSTANT_WM_USER + 8)
Global Const $SB_SETPARTS = ($__STATUSBARCONSTANT_WM_USER + 4)
Global Const $SB_SETTEXTA = ($__STATUSBARCONSTANT_WM_USER + 1)
Global Const $SB_SETTEXTW = ($__STATUSBARCONSTANT_WM_USER + 11)
Global Const $SB_SETTEXT = $SB_SETTEXTA
Global Const $SB_SETTIPTEXTA = ($__STATUSBARCONSTANT_WM_USER + 16)
Global Const $SB_SETTIPTEXTW = ($__STATUSBARCONSTANT_WM_USER + 17)
Global Const $SB_SETUNICODEFORMAT = 0x2000 + 5
Global Const $SB_SIMPLE = ($__STATUSBARCONSTANT_WM_USER + 9)
Global Const $SB_SIMPLEID = 0xff
Global Const $SBN_FIRST = -880
Global Const $SBN_SIMPLEMODECHANGE = $SBN_FIRST - 0
Global $__g_tSBBuffer, $__g_tSBBufferANSI
Global Const $__STATUSBARCONSTANT_ClassName = "msctls_statusbar32"
Global Const $__STATUSBARCONSTANT_WM_SIZE = 0x05
Global Const $__STATUSBARCONSTANT_CLR_DEFAULT = 0xFF000000
Global Const $tagBORDERS = "int BX;int BY;int RX"
Func _GUICtrlStatusBar_Create($hWnd, $vPartEdge = -1, $vPartText = "", $iStyles = -1, $iExStyles = 0x00000000)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
Local $iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
If $iStyles = -1 Then $iStyles = 0x00000000
If $iExStyles = -1 Then $iExStyles = 0x00000000
Local $aPartWidth[1], $aPartText[1]
If @NumParams > 1 Then
If IsArray($vPartEdge) Then
$aPartWidth = $vPartEdge
Else
$aPartWidth[0] = $vPartEdge
EndIf
If @NumParams = 2 Then
ReDim $aPartText[UBound($aPartWidth)]
Else
If IsArray($vPartText) Then
$aPartText = $vPartText
Else
$aPartText[0] = $vPartText
EndIf
If UBound($aPartWidth) <> UBound($aPartText) Then
Local $iLast
If UBound($aPartWidth) > UBound($aPartText) Then
$iLast = UBound($aPartText)
ReDim $aPartText[UBound($aPartWidth)]
Else
$iLast = UBound($aPartWidth)
ReDim $aPartWidth[UBound($aPartText)]
For $x = $iLast To UBound($aPartWidth) - 1
$aPartWidth[$x] = $aPartWidth[$x - 1] + 75
Next
$aPartWidth[UBound($aPartText) - 1] = -1
EndIf
EndIf
EndIf
If Not IsHWnd($hWnd) Then $hWnd = HWnd($hWnd)
If @NumParams > 3 Then $iStyle = BitOR($iStyle, $iStyles)
EndIf
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hWndSBar = _WinAPI_CreateWindowEx($iExStyles, $__STATUSBARCONSTANT_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd, $nCtrlID)
If @error Then Return SetError(@error, @extended, 0)
If @NumParams > 1 Then
_GUICtrlStatusBar_SetParts($hWndSBar, UBound($aPartWidth), $aPartWidth)
For $x = 0 To UBound($aPartText) - 1
_GUICtrlStatusBar_SetText($hWndSBar, $aPartText[$x], $x)
Next
EndIf
Return $hWndSBar
EndFunc
Func _GUICtrlStatusBar_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__STATUSBARCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hGUICtrl_LastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlStatusBar_EmbedControl($hWnd, $iPart, $hControl, $iFit = 4)
Local $aRect = _GUICtrlStatusBar_GetRect($hWnd, $iPart)
Local $iBarX = $aRect[0]
Local $iBarY = $aRect[1]
Local $iBarW = $aRect[2] - $iBarX
Local $iBarH = $aRect[3] - $iBarY
Local $iConX = $iBarX
Local $iConY = $iBarY
Local $iConW = _WinAPI_GetWindowWidth($hControl)
Local $iConH = _WinAPI_GetWindowHeight($hControl)
If $iConW > $iBarW Then $iConW = $iBarW
If $iConH > $iBarH Then $iConH = $iBarH
Local $iPadX = ($iBarW - $iConW) / 2
Local $iPadY = ($iBarH - $iConH) / 2
If $iPadX < 0 Then $iPadX = 0
If $iPadY < 0 Then $iPadY = 0
If BitAND($iFit, 1) = 1 Then $iConX = $iBarX + $iPadX
If BitAND($iFit, 2) = 2 Then $iConY = $iBarY + $iPadY
If BitAND($iFit, 4) = 4 Then
$iPadX = _GUICtrlStatusBar_GetBordersRect($hWnd)
$iPadY = _GUICtrlStatusBar_GetBordersVert($hWnd)
$iConX = $iBarX
If _GUICtrlStatusBar_IsSimple($hWnd) Then $iConX += $iPadX
$iConY = $iBarY + $iPadY
$iConW = $iBarW - ($iPadX * 2)
$iConH = $iBarH - ($iPadY * 2)
EndIf
_WinAPI_SetParent($hControl, $hWnd)
_WinAPI_MoveWindow($hControl, $iConX, $iConY, $iConW, $iConH)
EndFunc
Func _GUICtrlStatusBar_GetBorders($hWnd)
Local $tBorders = DllStructCreate($tagBORDERS)
Local $iRet = __GUICtrl_SendMsg($hWnd, $SB_GETBORDERS, 0, $tBorders, 0, True)
Local $aBorders[3]
If $iRet = 0 Then Return SetError(-1, -1, $aBorders)
$aBorders[0] = DllStructGetData($tBorders, "BX")
$aBorders[1] = DllStructGetData($tBorders, "BY")
$aBorders[2] = DllStructGetData($tBorders, "RX")
Return $aBorders
EndFunc
Func _GUICtrlStatusBar_GetBordersHorz($hWnd)
Local $aBorders = _GUICtrlStatusBar_GetBorders($hWnd)
Return SetError(@error, @extended, $aBorders[0])
EndFunc
Func _GUICtrlStatusBar_GetBordersRect($hWnd)
Local $aBorders = _GUICtrlStatusBar_GetBorders($hWnd)
Return SetError(@error, @extended, $aBorders[2])
EndFunc
Func _GUICtrlStatusBar_GetBordersVert($hWnd)
Local $aBorders = _GUICtrlStatusBar_GetBorders($hWnd)
Return SetError(@error, @extended, $aBorders[1])
EndFunc
Func _GUICtrlStatusBar_GetCount($hWnd)
Return _SendMessage($hWnd, $SB_GETPARTS)
EndFunc
Func _GUICtrlStatusBar_GetHeight($hWnd)
Local $tRECT = _GUICtrlStatusBar_GetRectEx($hWnd, 0)
Return DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top") - (_GUICtrlStatusBar_GetBordersVert($hWnd) * 2)
EndFunc
Func _GUICtrlStatusBar_GetIcon($hWnd, $iIndex = 0)
Return _SendMessage($hWnd, $SB_GETICON, $iIndex, 0, 0, "wparam", "lparam", "handle")
EndFunc
Func _GUICtrlStatusBar_GetParts($hWnd)
Local $iCount = _GUICtrlStatusBar_GetCount($hWnd)
Local $tParts = DllStructCreate("int[" & $iCount & "]")
Local $aParts[$iCount + 1]
$aParts[0] = __GUICtrl_SendMsg($hWnd, $SB_GETPARTS, $iCount, $tParts, 0, True)
For $iI = 1 To $iCount
$aParts[$iI] = DllStructGetData($tParts, 1, $iI)
Next
Return $aParts
EndFunc
Func _GUICtrlStatusBar_GetRect($hWnd, $iPart)
Local $tRECT = _GUICtrlStatusBar_GetRectEx($hWnd, $iPart)
If @error Then Return SetError(@error, 0, 0)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlStatusBar_GetRectEx($hWnd, $iPart)
Local $tRECT = DllStructCreate($tagRECT)
Local $iRet = __GUICtrl_SendMsg($hWnd, $SB_GETRECT, $iPart, $tRECT, 0, True)
Return SetError($iRet = 0, 0, $tRECT)
EndFunc
Func _GUICtrlStatusBar_GetText($hWnd, $iPart)
Local $iBuffer = _GUICtrlStatusBar_GetTextLength($hWnd, $iPart) + 1
If $iBuffer = 1 Then Return SetError(1, 0, "")
Local $tBuffer, $iMsg
If _GUICtrlStatusBar_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tSBBuffer
$iMsg = $SB_GETTEXTW
Else
$tBuffer = $__g_tSBBufferANSI
$iMsg = $SB_GETTEXT
EndIf
__GUICtrl_SendMsg($hWnd, $iMsg, $iPart, $tBuffer, 0, True)
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlStatusBar_GetTextFlags($hWnd, $iPart)
If _GUICtrlStatusBar_GetUnicodeFormat($hWnd) Then
Return _SendMessage($hWnd, $SB_GETTEXTLENGTHW, $iPart)
Else
Return _SendMessage($hWnd, $SB_GETTEXTLENGTH, $iPart)
EndIf
EndFunc
Func _GUICtrlStatusBar_GetTextLength($hWnd, $iPart)
Return _WinAPI_LoWord(_GUICtrlStatusBar_GetTextFlags($hWnd, $iPart))
EndFunc
Func _GUICtrlStatusBar_GetTextLengthEx($hWnd, $iPart)
Return _WinAPI_HiWord(_GUICtrlStatusBar_GetTextFlags($hWnd, $iPart))
EndFunc
Func _GUICtrlStatusBar_GetTipText($hWnd, $iPart)
Local $tBuffer, $iMsg
If _GUICtrlStatusBar_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tSBBuffer
$iMsg = $SB_GETTIPTEXTW
Else
$tBuffer = $__g_tSBBufferANSI
$iMsg = $SB_GETTIPTEXTA
EndIf
__GUICtrl_SendMsg($hWnd, $iMsg, _WinAPI_MakeLong($iPart, 4096), $tBuffer, 0, True)
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
If Not IsDllStruct($__g_tSBBuffer) Then
$__g_tSBBuffer = DllStructCreate("wchar Text[4096]")
$__g_tSBBufferANSI = DllStructCreate("char Text[4096]", DllStructGetPtr($__g_tSBBuffer))
EndIf
Return _SendMessage($hWnd, $SB_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlStatusBar_GetWidth($hWnd, $iPart)
Local $tRECT = _GUICtrlStatusBar_GetRectEx($hWnd, $iPart)
Return DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left") - (_GUICtrlStatusBar_GetBordersHorz($hWnd) * 2)
EndFunc
Func _GUICtrlStatusBar_IsSimple($hWnd)
Return _SendMessage($hWnd, $SB_ISSIMPLE) <> 0
EndFunc
Func _GUICtrlStatusBar_Resize($hWnd)
_SendMessage($hWnd, $__STATUSBARCONSTANT_WM_SIZE)
EndFunc
Func _GUICtrlStatusBar_SetBkColor($hWnd, $iColor)
$iColor = _SendMessage($hWnd, $SB_SETBKCOLOR, 0, $iColor)
EndFunc
Func _GUICtrlStatusBar_SetIcon($hWnd, $iPart, $hIcon = -1, $sIconFile = "")
If $hIcon = -1 Then Return _SendMessage($hWnd, $SB_SETICON, $iPart, $hIcon, 0, "wparam", "handle") <> 0
If StringLen($sIconFile) <= 0 Then Return _SendMessage($hWnd, $SB_SETICON, $iPart, $hIcon) <> 0
Local $tIcon = DllStructCreate("handle")
Local $vResult = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sIconFile, "int", $hIcon, "ptr", 0, "struct*", $tIcon, "uint", 1)
If @error Then Return SetError(@error, @extended, False)
$vResult = $vResult[0]
If $vResult > 0 Then $vResult = _SendMessage($hWnd, $SB_SETICON, $iPart, DllStructGetData($tIcon, 1), 0, "wparam", "handle")
DllCall("user32.dll", "bool", "DestroyIcon", "handle", DllStructGetData($tIcon, 1))
Return $vResult
EndFunc
Func _GUICtrlStatusBar_SetMinHeight($hWnd, $iMinHeight)
_SendMessage($hWnd, $SB_SETMINHEIGHT, $iMinHeight)
_GUICtrlStatusBar_Resize($hWnd)
EndFunc
Func _GUICtrlStatusBar_SetParts($hWnd, $vPartEdge = -1, $vPartWidth = 25)
If IsArray($vPartEdge) And IsArray($vPartWidth) Then Return False
Local $tParts, $iParts
If IsArray($vPartEdge) Then
$vPartEdge[UBound($vPartEdge) - 1] = -1
$iParts = UBound($vPartEdge)
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 0 To $iParts - 2
DllStructSetData($tParts, 1, $vPartEdge[$x], $x + 1)
Next
DllStructSetData($tParts, 1, -1, $iParts)
Else
If $vPartEdge < -1 Then Return False
If IsArray($vPartWidth) Then
$iParts = UBound($vPartWidth)
$tParts = DllStructCreate("int[" & $iParts & "]")
Local $iPartRightEdge = 0
For $x = 0 To $iParts - 2
$iPartRightEdge += $vPartWidth[$x]
If $vPartWidth[$x] <= 0 Then Return False
DllStructSetData($tParts, 1, $iPartRightEdge, $x + 1)
Next
DllStructSetData($tParts, 1, -1, $iParts)
ElseIf $vPartEdge > 1 Then
$iParts = $vPartEdge
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 1 To $iParts - 1
DllStructSetData($tParts, 1, $vPartWidth * $x, $x)
Next
DllStructSetData($tParts, 1, -1, $iParts)
Else
$iParts = 1
$tParts = DllStructCreate("int")
DllStructSetData($tParts, 1, -1)
EndIf
EndIf
__GUICtrl_SendMsg($hWnd, $SB_SETPARTS, $iParts, $tParts)
_GUICtrlStatusBar_Resize($hWnd)
Return True
EndFunc
Func _GUICtrlStatusBar_SetSimple($hWnd, $bSimple = True)
_SendMessage($hWnd, $SB_SIMPLE, $bSimple)
EndFunc
Func _GUICtrlStatusBar_SetText($hWnd, $sText = "", $iPart = 0, $iUFlag = 0)
Local $iBuffer = StringLen($sText) + 1
Local $tText, $iMsg
If _GUICtrlStatusBar_GetUnicodeFormat($hWnd) Then
$tText = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iMsg = $SB_SETTEXTW
Else
$tText = DllStructCreate("char Text[" & $iBuffer & "]")
$iMsg = $SB_SETTEXT
EndIf
DllStructSetData($tText, "Text", $sText)
If _GUICtrlStatusBar_IsSimple($hWnd) Then $iPart = $SB_SIMPLEID
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, BitOR($iPart, $iUFlag), $tText)
Return $iRet <> 0
EndFunc
Func _GUICtrlStatusBar_SetTipText($hWnd, $iPart, $sText)
Local $iBuffer = StringLen($sText) + 1
Local $tText, $iMsg
If _GUICtrlStatusBar_GetUnicodeFormat($hWnd) Then
$tText = DllStructCreate("wchar TipText[" & $iBuffer & "]")
$iMsg = $SB_SETTIPTEXTW
Else
$tText = DllStructCreate("char TipText[" & $iBuffer & "]")
$iMsg = $SB_SETTIPTEXTA
EndIf
DllStructSetData($tText, "TipText", $sText)
__GUICtrl_SendMsg($hWnd, $iMsg, $iPart, $tText)
EndFunc
Func _GUICtrlStatusBar_SetUnicodeFormat($hWnd, $bUnicode = True)
Return _SendMessage($hWnd, $SB_SETUNICODEFORMAT, $bUnicode)
EndFunc
Func _GUICtrlStatusBar_ShowHide($hWnd, $iState)
If $iState <> @SW_HIDE And $iState <> @SW_SHOW Then Return SetError(1, 1, False)
Return _WinAPI_ShowWindow($hWnd, $iState)
EndFunc
Global Const $TTF_IDISHWND = 0x00000001
Global Const $TTF_CENTERTIP = 0x00000002
Global Const $TTF_RTLREADING = 0x00000004
Global Const $TTF_SUBCLASS = 0x00000010
Global Const $TTF_TRACK = 0x00000020
Global Const $TTF_ABSOLUTE = 0x00000080
Global Const $TTF_TRANSPARENT = 0x00000100
Global Const $TTF_PARSELINKS = 0x00001000
Global Const $TTF_DI_SETITEM = 0x00008000
Global Const $__TOOLTIPCONSTANTS_WM_USER = 0X400
Global Const $TTM_ACTIVATE = $__TOOLTIPCONSTANTS_WM_USER + 1
Global Const $TTM_SETDELAYTIME = $__TOOLTIPCONSTANTS_WM_USER + 3
Global Const $TTM_ADDTOOL = $__TOOLTIPCONSTANTS_WM_USER + 4
Global Const $TTM_DELTOOL = $__TOOLTIPCONSTANTS_WM_USER + 5
Global Const $TTM_NEWTOOLRECT = $__TOOLTIPCONSTANTS_WM_USER + 6
Global Const $TTM_GETTOOLINFO = $__TOOLTIPCONSTANTS_WM_USER + 8
Global Const $TTM_SETTOOLINFO = $__TOOLTIPCONSTANTS_WM_USER + 9
Global Const $TTM_HITTEST = $__TOOLTIPCONSTANTS_WM_USER + 10
Global Const $TTM_GETTEXT = $__TOOLTIPCONSTANTS_WM_USER + 11
Global Const $TTM_UPDATETIPTEXT = $__TOOLTIPCONSTANTS_WM_USER + 12
Global Const $TTM_GETTOOLCOUNT = $__TOOLTIPCONSTANTS_WM_USER + 13
Global Const $TTM_ENUMTOOLS = $__TOOLTIPCONSTANTS_WM_USER + 14
Global Const $TTM_GETCURRENTTOOL = $__TOOLTIPCONSTANTS_WM_USER + 15
Global Const $TTM_WINDOWFROMPOINT = $__TOOLTIPCONSTANTS_WM_USER + 16
Global Const $TTM_TRACKACTIVATE = $__TOOLTIPCONSTANTS_WM_USER + 17
Global Const $TTM_TRACKPOSITION = $__TOOLTIPCONSTANTS_WM_USER + 18
Global Const $TTM_SETTIPBKCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 19
Global Const $TTM_SETTIPTEXTCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 20
Global Const $TTM_GETDELAYTIME = $__TOOLTIPCONSTANTS_WM_USER + 21
Global Const $TTM_GETTIPBKCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 22
Global Const $TTM_GETTIPTEXTCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 23
Global Const $TTM_SETMAXTIPWIDTH = $__TOOLTIPCONSTANTS_WM_USER + 24
Global Const $TTM_GETMAXTIPWIDTH = $__TOOLTIPCONSTANTS_WM_USER + 25
Global Const $TTM_SETMARGIN = $__TOOLTIPCONSTANTS_WM_USER + 26
Global Const $TTM_GETMARGIN = $__TOOLTIPCONSTANTS_WM_USER + 27
Global Const $TTM_POP = $__TOOLTIPCONSTANTS_WM_USER + 28
Global Const $TTM_UPDATE = $__TOOLTIPCONSTANTS_WM_USER + 29
Global Const $TTM_GETBUBBLESIZE = $__TOOLTIPCONSTANTS_WM_USER + 30
Global Const $TTM_ADJUSTRECT = $__TOOLTIPCONSTANTS_WM_USER + 31
Global Const $TTM_SETTITLE = $__TOOLTIPCONSTANTS_WM_USER + 32
Global Const $TTM_SETTITLEW = $__TOOLTIPCONSTANTS_WM_USER + 33
Global Const $TTM_POPUP = $__TOOLTIPCONSTANTS_WM_USER + 34
Global Const $TTM_GETTITLE = $__TOOLTIPCONSTANTS_WM_USER + 35
Global Const $TTM_ADDTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 50
Global Const $TTM_DELTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 51
Global Const $TTM_NEWTOOLRECTW = $__TOOLTIPCONSTANTS_WM_USER + 52
Global Const $TTM_GETTOOLINFOW = $__TOOLTIPCONSTANTS_WM_USER + 53
Global Const $TTM_SETTOOLINFOW = $__TOOLTIPCONSTANTS_WM_USER + 54
Global Const $TTM_HITTESTW = $__TOOLTIPCONSTANTS_WM_USER + 55
Global Const $TTM_GETTEXTW = $__TOOLTIPCONSTANTS_WM_USER + 56
Global Const $TTM_UPDATETIPTEXTW = $__TOOLTIPCONSTANTS_WM_USER + 57
Global Const $TTM_ENUMTOOLSW = $__TOOLTIPCONSTANTS_WM_USER + 58
Global Const $TTM_GETCURRENTTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 59
Global Const $TTM_SETWINDOWTHEME = 0x2000 + 11
Global Const $TTN_FIRST = -520
Global Const $TTN_GETDISPINFO = $TTN_FIRST - 0
Global Const $TTN_SHOW = $TTN_FIRST - 1
Global Const $TTN_POP = $TTN_FIRST - 2
Global Const $TTN_LINKCLICK = $TTN_FIRST - 3
Global Const $TTN_GETDISPINFOW = $TTN_FIRST - 10
Global Const $TTS_ALWAYSTIP = 0x00000001
Global Const $TTS_NOPREFIX = 0x00000002
Global Const $TTS_NOANIMATE = 0x00000010
Global Const $TTS_NOFADE = 0x00000020
Global Const $TTS_BALLOON = 0x00000040
Global Const $TTS_CLOSE = 0x00000080
Global Const $TTS_USEVISUALSTYLE = 0x00000100
Global Const $TTDT_AUTOMATIC = 0
Global Const $TTDT_RESHOW = 1
Global Const $TTDT_AUTOPOP = 2
Global Const $TTDT_INITIAL = 3
Global Enum $TTI_NONE, $TTI_INFO, $TTI_WARNING, $TTI_ERROR, $TTI_INFO_LARGE, $TTI_WARNING_LARGE, $TTI_ERROR_LARGE
Global Const $__EDITCONSTANT_ClassName = "Edit"
Global Const $__EDITCONSTANT_GUI_CHECKED = 1
Global Const $__EDITCONSTANT_GUI_HIDE = 32
Global Const $__EDITCONSTANT_GUI_EVENT_CLOSE = -3
Global Const $__EDITCONSTANT_GUI_ENABLE = 64
Global Const $__EDITCONSTANT_GUI_DISABLE = 128
Global Const $__EDITCONSTANT_SS_CENTER = 1
Global Const $__EDITCONSTANT_WM_SETREDRAW = 0x000B
Global Const $__EDITCONSTANT_WS_CAPTION = 0x00C00000
Global Const $__EDITCONSTANT_WS_POPUP = 0x80000000
Global Const $__EDITCONSTANT_WS_SYSMENU = 0x00080000
Global Const $__EDITCONSTANT_WS_MINIMIZEBOX = 0x00020000
Global Const $__EDITCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__EDITCONSTANT_WM_SETFONT = 0x0030
Global Const $__EDITCONSTANT_WM_GETTEXTLENGTH = 0x000E
Global Const $__EDITCONSTANT_WM_GETTEXT = 0x000D
Global Const $__EDITCONSTANT_WM_SETTEXT = 0x000C
Global Const $__EDITCONSTANT_SB_LINEUP = 0
Global Const $__EDITCONSTANT_SB_LINEDOWN = 1
Global Const $__EDITCONSTANT_SB_PAGEDOWN = 3
Global Const $__EDITCONSTANT_SB_PAGEUP = 2
Global Const $__EDITCONSTANT_SB_SCROLLCARET = 4
Global Const $__tagEDITBALLOONTIP = "dword Size;ptr Title;ptr Text;int Icon"
Func _GUICtrlEdit_AppendText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLength = _GUICtrlEdit_GetTextLen($hWnd)
_GUICtrlEdit_SetSel($hWnd, $iLength, $iLength)
_SendMessage($hWnd, $EM_REPLACESEL, True, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlEdit_BeginUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__EDITCONSTANT_WM_SETREDRAW, False) = 0
EndFunc
Func _GUICtrlEdit_CanUndo($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_CANUNDO) <> 0
EndFunc
Func _GUICtrlEdit_CharFromPos($hWnd, $iX, $iY)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aRet[2]
Local $iRet = _SendMessage($hWnd, $EM_CHARFROMPOS, 0, _WinAPI_MakeLong($iX, $iY))
$aRet[0] = _WinAPI_LoWord($iRet)
$aRet[1] = _WinAPI_HiWord($iRet)
Return $aRet
EndFunc
Func _GUICtrlEdit_Create($hWnd, $sText, $iX, $iY, $iWidth = 150, $iHeight = 150, $iStyle = 0x003010C4, $iExStyle = 0x00000200)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sText) Then Return SetError(2, 0, 0)
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = 0x003010C4
If $iExStyle = -1 Then $iExStyle = 0x00000200
If BitAND($iStyle, $ES_READONLY) = $ES_READONLY Then
$iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $iStyle)
Else
$iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $__UDFGUICONSTANT_WS_TABSTOP, $iStyle)
EndIf
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hEdit = _WinAPI_CreateWindowEx($iExStyle, $__EDITCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_SendMessage($hEdit, $__EDITCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($__EDITCONSTANT_DEFAULT_GUI_FONT), True)
_GUICtrlEdit_SetText($hEdit, $sText)
_GUICtrlEdit_SetLimitText($hEdit, 0)
Return $hEdit
EndFunc
Func _GUICtrlEdit_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__EDITCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hGUICtrl_LastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlEdit_EmptyUndoBuffer($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_EMPTYUNDOBUFFER)
EndFunc
Func _GUICtrlEdit_EndUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__EDITCONSTANT_WM_SETREDRAW, True) = 0
EndFunc
Func _GUICtrlEdit_FmtLines($hWnd, $bSoftBreak = False)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_FMTLINES, $bSoftBreak)
EndFunc
Func _GUICtrlEdit_Find($hWnd, $bReplace = False)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iPos = 0, $iCase, $iOccurance = 0, $iReplacements = 0
Local $aPartsRightEdge[3] = [125, 225, -1]
Local $iOldMode = Opt("GUIOnEventMode", 0)
Local $aSel = _GUICtrlEdit_GetSel($hWnd)
Local $sText = _GUICtrlEdit_GetText($hWnd)
Local $hGuiSearch = GUICreate("Find", 349, 177, -1, -1, BitOR($__UDFGUICONSTANT_WS_CHILD, $__EDITCONSTANT_WS_MINIMIZEBOX, $__EDITCONSTANT_WS_CAPTION, $__EDITCONSTANT_WS_POPUP, $__EDITCONSTANT_WS_SYSMENU))
Local $idStatusBar1 = _GUICtrlStatusBar_Create($hGuiSearch, $aPartsRightEdge)
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: ")
GUISetIcon(@SystemDir & "\shell32.dll", 22, $hGuiSearch)
GUICtrlCreateLabel("Find what:", 9, 10, 53, 16, $__EDITCONSTANT_SS_CENTER)
Local $idInputSearch = GUICtrlCreateInput("", 80, 8, 257, 21)
Local $idLblReplace = GUICtrlCreateLabel("Replace with:", 9, 42, 69, 17, $__EDITCONSTANT_SS_CENTER)
Local $idInputReplace = GUICtrlCreateInput("", 80, 40, 257, 21)
Local $idChkWholeOnly = GUICtrlCreateCheckbox("Match whole word only", 9, 72, 145, 17)
Local $idChkMatchCase = GUICtrlCreateCheckbox("Match case", 9, 96, 145, 17)
Local $idBtnFindNext = GUICtrlCreateButton("Find Next", 168, 72, 161, 21, 0)
Local $idBtnReplace = GUICtrlCreateButton("Replace", 168, 96, 161, 21, 0)
Local $idBtnClose = GUICtrlCreateButton("Close", 104, 130, 161, 21, 0)
If (IsArray($aSel) And $aSel <> $EC_ERR) Then
GUICtrlSetData($idInputSearch, StringMid($sText, $aSel[0] + 1, $aSel[1] - $aSel[0]))
If $aSel[0] <> $aSel[1] Then
$iPos = $aSel[0]
If BitAND(GUICtrlRead($idChkMatchCase), $__EDITCONSTANT_GUI_CHECKED) = $__EDITCONSTANT_GUI_CHECKED Then $iCase = 1
$iOccurance = 1
Local $iTPose
While 1
$iTPose = StringInStr($sText, GUICtrlRead($idInputSearch), $iCase, $iOccurance)
If Not $iTPose Then
$iOccurance = 0
ExitLoop
ElseIf $iTPose = $iPos + 1 Then
ExitLoop
EndIf
$iOccurance += 1
WEnd
EndIf
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: " & GUICtrlRead($idInputSearch))
EndIf
If $bReplace = False Then
GUICtrlSetState($idLblReplace, $__EDITCONSTANT_GUI_HIDE)
GUICtrlSetState($idInputReplace, $__EDITCONSTANT_GUI_HIDE)
GUICtrlSetState($idBtnReplace, $__EDITCONSTANT_GUI_HIDE)
Else
_GUICtrlStatusBar_SetText($idStatusBar1, "Replacements: " & $iReplacements, 1)
_GUICtrlStatusBar_SetText($idStatusBar1, "With: ", 2)
EndIf
GUISetState(@SW_SHOW)
Local $iMsgFind
While 1
$iMsgFind = GUIGetMsg()
Select
Case $iMsgFind = $__EDITCONSTANT_GUI_EVENT_CLOSE Or $iMsgFind = $idBtnClose
ExitLoop
Case $iMsgFind = $idBtnFindNext
GUICtrlSetState($idBtnFindNext, $__EDITCONSTANT_GUI_DISABLE)
GUICtrlSetCursor($idBtnFindNext, 15)
Sleep(100)
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: " & GUICtrlRead($idInputSearch))
If $bReplace = True Then
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: " & GUICtrlRead($idInputSearch))
_GUICtrlStatusBar_SetText($idStatusBar1, "With: " & GUICtrlRead($idInputReplace), 2)
EndIf
__GUICtrlEdit_FindText($hWnd, $idInputSearch, $idChkMatchCase, $idChkWholeOnly, $iPos, $iOccurance, $iReplacements)
Sleep(100)
GUICtrlSetState($idBtnFindNext, $__EDITCONSTANT_GUI_ENABLE)
GUICtrlSetCursor($idBtnFindNext, 2)
Case $iMsgFind = $idBtnReplace
GUICtrlSetState($idBtnReplace, $__EDITCONSTANT_GUI_DISABLE)
GUICtrlSetCursor($idBtnReplace, 15)
Sleep(100)
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: " & GUICtrlRead($idInputSearch))
_GUICtrlStatusBar_SetText($idStatusBar1, "With: " & GUICtrlRead($idInputReplace), 2)
If $iPos Then
_GUICtrlEdit_ReplaceSel($hWnd, GUICtrlRead($idInputReplace))
$iReplacements += 1
$iOccurance -= 1
_GUICtrlStatusBar_SetText($idStatusBar1, "Replacements: " & $iReplacements, 1)
EndIf
__GUICtrlEdit_FindText($hWnd, $idInputSearch, $idChkMatchCase, $idChkWholeOnly, $iPos, $iOccurance, $iReplacements)
Sleep(100)
GUICtrlSetState($idBtnReplace, $__EDITCONSTANT_GUI_ENABLE)
GUICtrlSetCursor($idBtnReplace, 2)
EndSelect
WEnd
GUIDelete($hGuiSearch)
Opt("GUIOnEventMode", $iOldMode)
EndFunc
Func _GUICtrlEdit_GetCueBanner($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tText = DllStructCreate("wchar[4096]")
If _SendMessage($hWnd, $EM_GETCUEBANNER, $tText, 4096, 0, "struct*") <> 1 Then Return SetError(-1, 0, "")
Return DllStructGetData($tText, 1)
EndFunc
Func __GUICtrlEdit_FindText($hWnd, $idInputSearch, $idChkMatchCase, $idChkWholeOnly, ByRef $iPos, ByRef $iOccurance, ByRef $iReplacements)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iCase = 0, $iWhole = 0
Local $bExact = False
Local $sFind = GUICtrlRead($idInputSearch)
Local $sText = _GUICtrlEdit_GetText($hWnd)
If BitAND(GUICtrlRead($idChkMatchCase), $__EDITCONSTANT_GUI_CHECKED) = $__EDITCONSTANT_GUI_CHECKED Then $iCase = 1
If BitAND(GUICtrlRead($idChkWholeOnly), $__EDITCONSTANT_GUI_CHECKED) = $__EDITCONSTANT_GUI_CHECKED Then $iWhole = 1
If $sFind <> "" Then
$iOccurance += 1
$iPos = StringInStr($sText, $sFind, $iCase, $iOccurance)
If $iWhole And $iPos Then
Local $s_Compare2 = StringMid($sText, $iPos + StringLen($sFind), 1)
If $iPos = 1 Then
If ($iPos + StringLen($sFind)) - 1 = StringLen($sText) Or  ($s_Compare2 = " " Or $s_Compare2 = @LF Or $s_Compare2 = @CR Or  $s_Compare2 = @CRLF Or $s_Compare2 = @TAB) Then $bExact = True
Else
Local $s_Compare1 = StringMid($sText, $iPos - 1, 1)
If ($iPos + StringLen($sFind)) - 1 = StringLen($sText) Then
If ($s_Compare1 = " " Or $s_Compare1 = @LF Or $s_Compare1 = @CR Or  $s_Compare1 = @CRLF Or $s_Compare1 = @TAB) Then $bExact = True
Else
If ($s_Compare1 = " " Or $s_Compare1 = @LF Or $s_Compare1 = @CR Or  $s_Compare1 = @CRLF Or $s_Compare1 = @TAB) And  ($s_Compare2 = " " Or $s_Compare2 = @LF Or $s_Compare2 = @CR Or  $s_Compare2 = @CRLF Or $s_Compare2 = @TAB) Then $bExact = True
EndIf
EndIf
If $bExact = False Then
__GUICtrlEdit_FindText($hWnd, $idInputSearch, $idChkMatchCase, $idChkWholeOnly, $iPos, $iOccurance, $iReplacements)
Else
_GUICtrlEdit_SetSel($hWnd, $iPos - 1, ($iPos + StringLen($sFind)) - 1)
_GUICtrlEdit_Scroll($hWnd, $__EDITCONSTANT_SB_SCROLLCARET)
EndIf
ElseIf $iWhole And Not $iPos Then
$iOccurance = 0
MsgBox($MB_SYSTEMMODAL, "Find", "Reached End of document, Can not find the string '" & $sFind & "'")
ElseIf Not $iWhole Then
If Not $iPos Then
$iOccurance = 1
_GUICtrlEdit_SetSel($hWnd, -1, 0)
_GUICtrlEdit_Scroll($hWnd, $__EDITCONSTANT_SB_SCROLLCARET)
$iPos = StringInStr($sText, $sFind, $iCase, $iOccurance)
If Not $iPos Then
$iOccurance = 0
MsgBox($MB_SYSTEMMODAL, "Find", "Reached End of document, Can not find the string  '" & $sFind & "'")
Else
_GUICtrlEdit_SetSel($hWnd, $iPos - 1, ($iPos + StringLen($sFind)) - 1)
_GUICtrlEdit_Scroll($hWnd, $__EDITCONSTANT_SB_SCROLLCARET)
EndIf
Else
_GUICtrlEdit_SetSel($hWnd, $iPos - 1, ($iPos + StringLen($sFind)) - 1)
_GUICtrlEdit_Scroll($hWnd, $__EDITCONSTANT_SB_SCROLLCARET)
EndIf
EndIf
EndIf
EndFunc
Func _GUICtrlEdit_GetFirstVisibleLine($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETFIRSTVISIBLELINE)
EndFunc
Func _GUICtrlEdit_GetHandle($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return Ptr(_SendMessage($hWnd, $EM_GETHANDLE))
EndFunc
Func _GUICtrlEdit_GetIMEStatus($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETIMESTATUS, $EMSIS_COMPOSITIONSTRING)
EndFunc
Func _GUICtrlEdit_GetLimitText($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETLIMITTEXT)
EndFunc
Func _GUICtrlEdit_GetLine($hWnd, $iLine)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLength = _GUICtrlEdit_LineLength($hWnd, $iLine)
If $iLength = 0 Then Return ""
Local $tBuffer = DllStructCreate("short Len;wchar Text[" & $iLength & "]")
DllStructSetData($tBuffer, "Len", $iLength + 1)
Local $iRet = _SendMessage($hWnd, $EM_GETLINE, $iLine, $tBuffer, 0, "wparam", "struct*")
If $iRet = 0 Then Return SetError($EC_ERR, $EC_ERR, "")
Local $tText = DllStructCreate("wchar Text[" & $iLength & "]", DllStructGetPtr($tBuffer))
Return DllStructGetData($tText, "Text")
EndFunc
Func _GUICtrlEdit_GetLineCount($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETLINECOUNT)
EndFunc
Func _GUICtrlEdit_GetMargins($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aMargins[2]
Local $iMargins = _SendMessage($hWnd, $EM_GETMARGINS)
$aMargins[0] = _WinAPI_LoWord($iMargins)
$aMargins[1] = _WinAPI_HiWord($iMargins)
Return $aMargins
EndFunc
Func _GUICtrlEdit_GetModify($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETMODIFY) <> 0
EndFunc
Func _GUICtrlEdit_GetPasswordChar($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETPASSWORDCHAR)
EndFunc
Func _GUICtrlEdit_GetRECT($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aRect[4]
Local $tRECT = _GUICtrlEdit_GetRECTEx($hWnd)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlEdit_GetRECTEx($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
_SendMessage($hWnd, $EM_GETRECT, 0, $tRECT, 0, "wparam", "struct*")
Return $tRECT
EndFunc
Func _GUICtrlEdit_GetSel($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aSel[2]
Local $tStart = DllStructCreate("uint Start")
Local $tEnd = DllStructCreate("uint End")
_SendMessage($hWnd, $EM_GETSEL, $tStart, $tEnd, 0, "struct*", "struct*")
$aSel[0] = DllStructGetData($tStart, "Start")
$aSel[1] = DllStructGetData($tEnd, "End")
Return $aSel
EndFunc
Func _GUICtrlEdit_GetText($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iTextLen = _GUICtrlEdit_GetTextLen($hWnd) + 1
Local $tText = DllStructCreate("wchar Text[" & $iTextLen & "]")
_SendMessage($hWnd, $__EDITCONSTANT_WM_GETTEXT, $iTextLen, $tText, 0, "wparam", "struct*")
Return DllStructGetData($tText, "Text")
EndFunc
Func _GUICtrlEdit_GetTextLen($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__EDITCONSTANT_WM_GETTEXTLENGTH)
EndFunc
Func _GUICtrlEdit_GetThumb($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETTHUMB)
EndFunc
Func _GUICtrlEdit_GetWordBreakProc($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETWORDBREAKPROC)
EndFunc
Func _GUICtrlEdit_HideBalloonTip($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_HIDEBALLOONTIP) <> 0
EndFunc
Func _GUICtrlEdit_InsertText($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If $iIndex = -1 Then
_GUICtrlEdit_AppendText($hWnd, $sText)
Else
_GUICtrlEdit_SetSel($hWnd, $iIndex, $iIndex)
_SendMessage($hWnd, $EM_REPLACESEL, True, $sText, 0, "wparam", "wstr")
EndIf
EndFunc
Func _GUICtrlEdit_LineFromChar($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_LINEFROMCHAR, $iIndex)
EndFunc
Func _GUICtrlEdit_LineIndex($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_LINEINDEX, $iIndex)
EndFunc
Func _GUICtrlEdit_LineLength($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iCharIndex = _GUICtrlEdit_LineIndex($hWnd, $iIndex)
Return _SendMessage($hWnd, $EM_LINELENGTH, $iCharIndex)
EndFunc
Func _GUICtrlEdit_LineScroll($hWnd, $iHoriz, $iVert)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_LINESCROLL, $iHoriz, $iVert) <> 0
EndFunc
Func _GUICtrlEdit_PosFromChar($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aCoord[2]
Local $iRet = _SendMessage($hWnd, $EM_POSFROMCHAR, $iIndex)
$aCoord[0] = _WinAPI_LoWord($iRet)
$aCoord[1] = _WinAPI_HiWord($iRet)
Return $aCoord
EndFunc
Func _GUICtrlEdit_ReplaceSel($hWnd, $sText, $bUndo = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_REPLACESEL, $bUndo, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlEdit_Scroll($hWnd, $iDirection)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If BitAND($iDirection, $__EDITCONSTANT_SB_LINEDOWN) <> $__EDITCONSTANT_SB_LINEDOWN And  BitAND($iDirection, $__EDITCONSTANT_SB_LINEUP) <> $__EDITCONSTANT_SB_LINEUP And  BitAND($iDirection, $__EDITCONSTANT_SB_PAGEDOWN) <> $__EDITCONSTANT_SB_PAGEDOWN And  BitAND($iDirection, $__EDITCONSTANT_SB_PAGEUP) <> $__EDITCONSTANT_SB_PAGEUP And  BitAND($iDirection, $__EDITCONSTANT_SB_SCROLLCARET) <> $__EDITCONSTANT_SB_SCROLLCARET Then Return 0
If $iDirection == $__EDITCONSTANT_SB_SCROLLCARET Then
Return _SendMessage($hWnd, $EM_SCROLLCARET)
Else
Return _SendMessage($hWnd, $EM_SCROLL, $iDirection)
EndIf
EndFunc
Func _GUICtrlEdit_SetCueBanner($hWnd, $sText, $bOnFocus = False)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tText = _WinAPI_MultiByteToWideChar($sText)
Return _SendMessage($hWnd, $EM_SETCUEBANNER, $bOnFocus, $tText, 0, "wparam", "struct*") = 1
EndFunc
Func _GUICtrlEdit_SetHandle($hWnd, $hMemory)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETHANDLE, $hMemory, 0, 0, "handle")
EndFunc
Func _GUICtrlEdit_SetIMEStatus($hWnd, $iComposition)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_SETIMESTATUS, $EMSIS_COMPOSITIONSTRING, $iComposition)
EndFunc
Func _GUICtrlEdit_SetLimitText($hWnd, $iLimit)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETLIMITTEXT, $iLimit)
EndFunc
Func _GUICtrlEdit_SetMargins($hWnd, $iMargin = 0x1, $iLeft = 0xFFFF, $iRight = 0xFFFF)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETMARGINS, $iMargin, _WinAPI_MakeLong($iLeft, $iRight))
EndFunc
Func _GUICtrlEdit_SetModify($hWnd, $bModified)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETMODIFY, $bModified)
EndFunc
Func _GUICtrlEdit_SetPadding($hWnd, $iCX, $iCY)
Local $tRect = DllStructCreate($tagRECT)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_GETRECT, 0, $tRect, 0, "wparam", "struct*")
$tRect.left += $iCX
$tRect.right -= $iCX
$tRect.top += $iCY
$tRect.bottom -= $iCY
Return _SendMessage($hWnd, $EM_SETRECT, 0, $tRect, 0, "wparam", "struct*")
EndFunc
Func _GUICtrlEdit_SetPasswordChar($hWnd, $sDisplayChar = "0")
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
$sDisplayChar = StringLeft($sDisplayChar, 1)
If Asc($sDisplayChar) = 48 Then
_SendMessage($hWnd, $EM_SETPASSWORDCHAR)
Else
_SendMessage($hWnd, $EM_SETPASSWORDCHAR, Asc($sDisplayChar))
EndIf
EndFunc
Func _GUICtrlEdit_SetReadOnly($hWnd, $bReadOnly)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_SETREADONLY, $bReadOnly) <> 0
EndFunc
Func _GUICtrlEdit_SetRECT($hWnd, $aRect)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $aRect[0])
DllStructSetData($tRECT, "Top", $aRect[1])
DllStructSetData($tRECT, "Right", $aRect[2])
DllStructSetData($tRECT, "Bottom", $aRect[3])
_GUICtrlEdit_SetRECTEx($hWnd, $tRECT)
EndFunc
Func _GUICtrlEdit_SetRECTEx($hWnd, $tRECT)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETRECT, 0, $tRECT, 0, "wparam", "struct*")
EndFunc
Func _GUICtrlEdit_SetRECTNP($hWnd, $aRect)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $aRect[0])
DllStructSetData($tRECT, "Top", $aRect[1])
DllStructSetData($tRECT, "Right", $aRect[2])
DllStructSetData($tRECT, "Bottom", $aRect[3])
_GUICtrlEdit_SetRectNPEx($hWnd, $tRECT)
EndFunc
Func _GUICtrlEdit_SetRectNPEx($hWnd, $tRECT)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETRECTNP, 0, $tRECT, 0, "wparam", "struct*")
EndFunc
Func _GUICtrlEdit_SetSel($hWnd, $iStart, $iEnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETSEL, $iStart, $iEnd)
EndFunc
Func _GUICtrlEdit_SetTabStops($hWnd, $aTabStops)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If Not IsArray($aTabStops) Then Return SetError(-1, -1, False)
Local $sTabStops = ""
Local $iNumTabStops = UBound($aTabStops)
For $x = 0 To $iNumTabStops - 1
$sTabStops &= "int;"
Next
$sTabStops = StringTrimRight($sTabStops, 1)
Local $tTabStops = DllStructCreate($sTabStops)
For $x = 0 To $iNumTabStops - 1
DllStructSetData($tTabStops, $x + 1, $aTabStops[$x])
Next
Local $iRet = _SendMessage($hWnd, $EM_SETTABSTOPS, $iNumTabStops, $tTabStops, 0, "wparam", "struct*") <> 0
_WinAPI_InvalidateRect($hWnd)
Return $iRet
EndFunc
Func _GUICtrlEdit_SetText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $__EDITCONSTANT_WM_SETTEXT, 0, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlEdit_SetWordBreakProc($hWnd, $iAddressFunc)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETWORDBREAKPROC, 0, $iAddressFunc)
EndFunc
Func _GUICtrlEdit_ShowBalloonTip($hWnd, $sTitle, $sText, $iIcon)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tBuffer = DllStructCreate('wchar Title[' & StringLen($sTitle) + 1 & '];wchar Text[' & StringLen($sText) + 1 & ']')
DllStructSetData($tBuffer, 'Title', $sTitle)
DllStructSetData($tBuffer, 'Text', $sText)
Local $tTT = DllStructCreate($__tagEDITBALLOONTIP)
DllStructSetData($tTT, 'Size', DllStructGetSize($tTT))
DllStructSetData($tTT, 'Title', DllStructGetPtr($tBuffer, 'Title'))
DllStructSetData($tTT, 'Text', DllStructGetPtr($tBuffer, 'Text'))
DllStructSetData($tTT, 'Icon', $iIcon)
Return _SendMessage($hWnd, $EM_SHOWBALLOONTIP, 0, $tTT, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlEdit_Undo($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_UNDO) <> 0
EndFunc
Global Const $ILC_MASK = 0x00000001
Global Const $ILC_COLOR = 0x00000000
Global Const $ILC_COLORDDB = 0x000000FE
Global Const $ILC_COLOR4 = 0x00000004
Global Const $ILC_COLOR8 = 0x00000008
Global Const $ILC_COLOR16 = 0x00000010
Global Const $ILC_COLOR24 = 0x00000018
Global Const $ILC_COLOR32 = 0x00000020
Global Const $ILC_PALETTE = 0x00000800
Global Const $ILC_MIRROR = 0x00002000
Global Const $ILC_PERITEMMIRROR = 0x00008000
Global Const $ILCF_MOVE = 0x0
Global Const $ILCF_SWAP = 0x1
Global Const $ILD_NORMAL = 0x00000000
Global Const $ILD_TRANSPARENT = 0x00000001
Global Const $ILD_BLEND25 = 0x00000002
Global Const $ILD_BLEND50 = 0x00000004
Global Const $ILD_MASK = 0x00000010
Global Const $ILD_IMAGE = 0x00000020
Global Const $ILD_ROP = 0x00000040
Global Const $ILD_OVERLAYMASK = 0x00000F00
Global Const $ILS_NORMAL = 0x00000000
Global Const $ILS_GLOW = 0x00000001
Global Const $ILS_SHADOW = 0x00000002
Global Const $ILS_SATURATE = 0x00000004
Global Const $ILS_ALPHA = 0x00000008
Global Const $__IMAGELISTCONSTANT_IMAGE_BITMAP = 0
Func _GUIImageList_Add($hWnd, $hImage, $hMask = 0)
Local $aCall = DllCall("comctl32.dll", "int", "ImageList_Add", "handle", $hWnd, "handle", $hImage, "handle", $hMask)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _GUIImageList_AddMasked($hWnd, $hImage, $iMask = 0)
Local $aCall = DllCall("comctl32.dll", "int", "ImageList_AddMasked", "handle", $hWnd, "handle", $hImage, "dword", $iMask)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _GUIImageList_AddBitmap($hWnd, $sImage, $sMask = "")
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Local $hImage = _WinAPI_LoadImage(0, $sImage, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $aSize[0], $aSize[1], $LR_LOADFROMFILE)
If $hImage = 0 Then Return SetError(_WinAPI_GetLastError(), 1, -1)
Local $hMask = 0
If $sMask <> "" Then
$hMask = _WinAPI_LoadImage(0, $sMask, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $aSize[0], $aSize[1], $LR_LOADFROMFILE)
If $hMask = 0 Then Return SetError(_WinAPI_GetLastError(), 2, -1)
EndIf
Local $iRet = _GUIImageList_Add($hWnd, $hImage, $hMask)
_WinAPI_DeleteObject($hImage)
If $hMask <> 0 Then _WinAPI_DeleteObject($hMask)
Return $iRet
EndFunc
Func _GUIImageList_AddIcon($hWnd, $sFilePath, $iIndex = 0, $bLarge = False)
Local $iRet, $tIcon = DllStructCreate("handle Handle")
If $bLarge Then
$iRet = _WinAPI_ExtractIconEx($sFilePath, $iIndex, $tIcon, 0, 1)
Else
$iRet = _WinAPI_ExtractIconEx($sFilePath, $iIndex, 0, $tIcon, 1)
EndIf
If $iRet <= 0 Then Return SetError(-1, $iRet, -1)
Local $hIcon = DllStructGetData($tIcon, "Handle")
$iRet = _GUIImageList_ReplaceIcon($hWnd, -1, $hIcon)
_WinAPI_DestroyIcon($hIcon)
If $iRet = -1 Then Return SetError(-2, $iRet, -1)
Return $iRet
EndFunc
Func _GUIImageList_BeginDrag($hWnd, $iTrack, $iXHotSpot, $iYHotSpot)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_BeginDrag", "handle", $hWnd, "int", $iTrack, "int", $iXHotSpot, "int", $iYHotSpot)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_Copy($hWnd, $iSource, $iDestination)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_Copy", "handle", $hWnd, "int", $iDestination, "handle", $hWnd, "int", $iSource, "uint", $ILCF_MOVE)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_Create($iCX = 16, $iCY = 16, $iColor = 4, $iOptions = 0, $iInitial = 4, $iGrow = 4)
Local Const $aColor[7] = [$ILC_COLOR, $ILC_COLOR4, $ILC_COLOR8, $ILC_COLOR16, $ILC_COLOR24, $ILC_COLOR32, $ILC_COLORDDB]
Local $iFlags = 0
If BitAND($iOptions, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILC_MASK)
If BitAND($iOptions, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILC_MIRROR)
If BitAND($iOptions, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILC_PERITEMMIRROR)
$iFlags = BitOR($iFlags, $aColor[$iColor])
Local $aCall = DllCall("comctl32.dll", "handle", "ImageList_Create", "int", $iCX, "int", $iCY, "uint", $iFlags, "int", $iInitial, "int", $iGrow)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _GUIImageList_Destroy($hWnd)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_Destroy", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_DestroyIcon($hIcon)
Return _WinAPI_DestroyIcon($hIcon)
EndFunc
Func _GUIImageList_DragEnter($hWnd, $iX, $iY)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_DragEnter", "hwnd", $hWnd, "int", $iX, "int", $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_DragLeave($hWnd)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_DragLeave", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_DragMove($iX, $iY)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_DragMove", "int", $iX, "int", $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_DragShowNolock($bShow)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_DragShowNolock", "bool", $bShow)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_Draw($hWnd, $iIndex, $hDC, $iX, $iY, $iStyle = 0)
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $ILD_MASK)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_Draw", "handle", $hWnd, "int", $iIndex, "handle", $hDC, "int", $iX, "int", $iY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_DrawEx($hWnd, $iIndex, $hDC, $iX, $iY, $iDX = 0, $iDY = 0, $iRGBBk = 0xFFFFFFFF, $iRGBFg = 0xFFFFFFFF, $iStyle = 0)
If $iDX = -1 Then $iDX = 0
If $iDY = -1 Then $iDY = 0
If $iRGBBk = -1 Then $iRGBBk = 0xFFFFFFFF
If $iRGBFg = -1 Then $iRGBFg = 0xFFFFFFFF
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $ILD_MASK)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_DrawEx", "handle", $hWnd, "int", $iIndex, "handle", $hDC, "int", $iX, "int", $iY,  "int", $iDX, "int", $iDY, "dword", $iRGBBk, "dword", $iRGBFg, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_Duplicate($hWnd)
Local $aCall = DllCall("comctl32.dll", "handle", "ImageList_Duplicate", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _GUIImageList_EndDrag()
DllCall("comctl32.dll", "none", "ImageList_EndDrag")
If @error Then Return SetError(@error, @extended)
EndFunc
Func _GUIImageList_GetBkColor($hWnd)
Local $aCall = DllCall("comctl32.dll", "dword", "ImageList_GetBkColor", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _GUIImageList_GetIcon($hWnd, $iIndex, $iStyle = 0)
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $ILD_MASK)
Local $aCall = DllCall("comctl32.dll", "handle", "ImageList_GetIcon", "handle", $hWnd, "int", $iIndex, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _GUIImageList_GetIconHeight($hWnd)
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Return $aSize[1]
EndFunc
Func _GUIImageList_GetIconSize($hWnd)
Local $aSize[2]
Local $tPoint = _GUIImageList_GetIconSizeEx($hWnd)
$aSize[0] = DllStructGetData($tPoint, "X")
$aSize[1] = DllStructGetData($tPoint, "Y")
Return $aSize
EndFunc
Func _GUIImageList_GetIconSizeEx($hWnd)
Local $tPoint = DllStructCreate($tagPOINT)
Local $pPointX = DllStructGetPtr($tPoint, "X")
Local $pPointY = DllStructGetPtr($tPoint, "Y")
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_GetIconSize", "hwnd", $hWnd, "struct*", $pPointX, "struct*", $pPointY)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aCall[0], $tPoint)
EndFunc
Func _GUIImageList_GetIconWidth($hWnd)
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Return $aSize[0]
EndFunc
Func _GUIImageList_GetImageCount($hWnd)
Local $aCall = DllCall("comctl32.dll", "int", "ImageList_GetImageCount", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _GUIImageList_GetImageInfoEx($hWnd, $iIndex)
Local $tImage = DllStructCreate($tagIMAGEINFO)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_GetImageInfo", "handle", $hWnd, "int", $iIndex, "struct*", $tImage)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aCall[0], $tImage)
EndFunc
Func _GUIImageList_Merge($hWnd1, $iIndex1, $hWnd2, $iIndex2, $iDX, $iDY)
Local $aCall = DllCall("comctl32.dll", "handle", "ImageList_Merge", "handle", $hWnd1, "int", $iIndex1,  "handle", $hWnd2, "int", $iIndex2, "int", $iDX, "int", $iDY)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _GUIImageList_Remove($hWnd, $iIndex = -1)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_Remove", "handle", $hWnd, "int", $iIndex)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_Replace($hWnd, $iIndex, $hImage, $hMask = 0)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_Replace", "handle", $hWnd, "int", $iIndex, "handle", $hImage, "handle", $hMask)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_ReplaceIcon($hWnd, $iIndex, $hIcon)
Local $aCall = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hWnd, "int", $iIndex, "handle", $hIcon)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _GUIImageList_SetBkColor($hWnd, $iClrBk)
Local $aCall = DllCall("comctl32.dll", "dword", "ImageList_SetBkColor", "handle", $hWnd, "dword", $iClrBk)
If @error Then Return SetError(@error, @extended, $CLR_NONE)
Return $aCall[0]
EndFunc
Func _GUIImageList_SetDragCursorImage($hWnd, $iDrag, $iDXHotSpot, $iDYHotSpot)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_SetDragCursorImage", "handle", $hWnd, "int", $iDrag, "int", $iDXHotSpot, "int", $iDYHotSpot)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_SetIconSize($hWnd, $iCX, $iCY)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_SetIconSize", "handle", $hWnd, "int", $iCX, "int", $iCY)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_SetImageCount($hWnd, $iNewCount)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_SetImageCount", "handle", $hWnd, "uint", $iNewCount)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_SetOverlayImage($hWnd, $iImage, $iOverlay)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_SetOverlayImage", "handle", $hWnd, "int", $iImage, "int", $iOverlay)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Func _GUIImageList_Swap($hWnd, $iSource, $iDestination)
Local $aCall = DllCall("comctl32.dll", "bool", "ImageList_Copy", "handle", $hWnd, "int", $iDestination, "handle", $hWnd, "int", $iSource, "uint", $ILCF_SWAP)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0] <> 0
EndFunc
Global $__g_tTVBuffer, $__g_tTVBufferANSI
Global $__g_tTVItemEx = DllStructCreate($tagTVITEMEX)
Global Const $__TREEVIEWCONSTANT_ClassName = "SysTreeView32"
Global Const $__TREEVIEWCONSTANT_WM_SETREDRAW = 0x000B
Global Const $__TREEVIEWCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $tagTVINSERTSTRUCT = "struct; handle Parent;handle InsertAfter;" & $tagTVITEMEX & " ;endstruct"
Func _GUICtrlTreeView_Add($hWnd, $hSibling, $sText, $iImage = -1, $iSelImage = -1)
Return __GUICtrlTreeView_AddItem($hWnd, $hSibling, $sText, $TVNA_ADD, $iImage, $iSelImage)
EndFunc
Func _GUICtrlTreeView_AddChild($hWnd, $hParent, $sText, $iImage = -1, $iSelImage = -1)
Return __GUICtrlTreeView_AddItem($hWnd, $hParent, $sText, $TVNA_ADDCHILD, $iImage, $iSelImage)
EndFunc
Func _GUICtrlTreeView_AddChildFirst($hWnd, $hParent, $sText, $iImage = -1, $iSelImage = -1)
Return __GUICtrlTreeView_AddItem($hWnd, $hParent, $sText, $TVNA_ADDCHILDFIRST, $iImage, $iSelImage)
EndFunc
Func _GUICtrlTreeView_AddFirst($hWnd, $hSibling, $sText, $iImage = -1, $iSelImage = -1)
Return __GUICtrlTreeView_AddItem($hWnd, $hSibling, $sText, $TVNA_ADDFIRST, $iImage, $iSelImage)
EndFunc
Func __GUICtrlTreeView_AddItem($hWnd, $hRelative, $sText, $iMethod, $iImage = -1, $iSelImage = -1, $iParam = 0)
Local $iAddMode
Switch $iMethod
Case $TVNA_ADD, $TVNA_ADDCHILD
$iAddMode = $TVTA_ADD
Case $TVNA_ADDFIRST, $TVNA_ADDCHILDFIRST
$iAddMode = $TVTA_ADDFIRST
Case Else
$iAddMode = $TVTA_INSERT
EndSwitch
Local $hItem, $hItemID = 0
If $hRelative <> 0x00000000 Then
Switch $iMethod
Case $TVNA_ADD, $TVNA_ADDFIRST
$hItem = _GUICtrlTreeView_GetParentHandle($hWnd, $hRelative)
Case $TVNA_ADDCHILD, $TVNA_ADDCHILDFIRST
$hItem = $hRelative
Case Else
$hItem = _GUICtrlTreeView_GetParentHandle($hWnd, $hRelative)
$hItemID = _GUICtrlTreeView_GetPrevSibling($hWnd, $hRelative)
If $hItemID = 0x00000000 Then $iAddMode = $TVTA_ADDFIRST
EndSwitch
EndIf
Local $tBuffer, $iMsg
If _GUICtrlTreeView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tTVBuffer
$iMsg = $TVM_INSERTITEMW
Else
$tBuffer = $__g_tTVBufferANSI
$iMsg = $TVM_INSERTITEMA
EndIf
Local $tInsert = DllStructCreate($tagTVINSERTSTRUCT)
Switch $iAddMode
Case $TVTA_ADDFIRST
DllStructSetData($tInsert, "InsertAfter", $TVI_FIRST)
Case $TVTA_ADD
DllStructSetData($tInsert, "InsertAfter", $TVI_LAST)
Case $TVTA_INSERT
DllStructSetData($tInsert, "InsertAfter", $hItemID)
EndSwitch
Local $iMask = BitOR($TVIF_TEXT, $TVIF_PARAM)
If $iImage >= 0 Then $iMask = BitOR($iMask, $TVIF_IMAGE)
If $iSelImage >= 0 Then $iMask = BitOR($iMask, $TVIF_SELECTEDIMAGE)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tInsert, "Parent", $hItem)
DllStructSetData($tInsert, "Mask", $iMask)
DllStructSetData($tInsert, "Image", $iImage)
DllStructSetData($tInsert, "SelectedImage", $iSelImage)
DllStructSetData($tInsert, "Param", $iParam)
Local $hResult = Ptr(__GUICtrl_SendMsg($hWnd, $iMsg, 0, $tInsert, $tBuffer, False, 7))
Return $hResult
EndFunc
Func _GUICtrlTreeView_BeginUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__TREEVIEWCONSTANT_WM_SETREDRAW, False) = 0
EndFunc
Func _GUICtrlTreeView_ClickItem($hWnd, $hItem, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 0)
Local $tRECT = _GUICtrlTreeView_DisplayRectEx($hWnd, $hItem, True)
If @error Then Return SetError(@error, @error, 0)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tPoint = _WinAPI_PointFromRect($tRECT, False)
_WinAPI_ClientToScreen($hWnd, $tPoint)
Local $iX, $iY
_WinAPI_GetXYFromPoint($tPoint, $iX, $iY)
Local $iMode = Opt("MouseCoordMode", 1)
If Not $bMove Then
Local $aPos = MouseGetPos()
_WinAPI_ShowCursor(False)
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
MouseMove($aPos[0], $aPos[1], 0)
_WinAPI_ShowCursor(True)
Else
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
EndIf
Opt("MouseCoordMode", $iMode)
Return 1
EndFunc
Func _GUICtrlTreeView_Create($hWnd, $iX, $iY, $iWidth = 150, $iHeight = 150, $iStyle = 0x00000037, $iExStyle = 0x00000000)
If Not IsHWnd($hWnd) Then
Return SetError(1, 0, 0)
EndIf
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = BitOR($TVS_SHOWSELALWAYS, $TVS_DISABLEDRAGDROP, $TVS_LINESATROOT, $TVS_HASLINES, $TVS_HASBUTTONS)
If $iExStyle = -1 Then $iExStyle = 0x00000000
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hTree = _WinAPI_CreateWindowEx($iExStyle, $__TREEVIEWCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_WinAPI_SetFont($hTree, _WinAPI_GetStockObject($__TREEVIEWCONSTANT_DEFAULT_GUI_FONT))
Return $hTree
EndFunc
Func _GUICtrlTreeView_CreateDragImage($hWnd, $hItem)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_CREATEDRAGIMAGE, 0, $hItem, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlTreeView_CreateSolidBitMap($hWnd, $iColor, $iWidth, $iHeight)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _WinAPI_CreateSolidBitmap($hWnd, $iColor, $iWidth, $iHeight)
EndFunc
Func _GUICtrlTreeView_Delete($hWnd, $hItem = Null)
If IsHWnd($hWnd) Then
If $hItem = Null Then
$hItem = _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0, 0, "wparam", "handle", "handle")
If $hItem <> 0x00000000 Then Return _SendMessage($hWnd, $TVM_DELETEITEM, 0, $hItem, 0, "wparam", "handle", "hwnd") <> 0
Return False
Else
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
If GUICtrlDelete($hItem) Then Return True
Return _SendMessage($hWnd, $TVM_DELETEITEM, 0, $hItem, 0, "wparam", "handle", "hwnd") <> 0
EndIf
Else
If $hItem = Null Then
$hItem = GUICtrlSendMsg($hWnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0)
If $hItem <> 0x00000000 Then Return GUICtrlSendMsg($hWnd, $TVM_DELETEITEM, 0, $hItem) <> 0
Return False
Else
If Not IsPtr($hItem) Then
$hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Else
SetExtended(1)
EndIf
Return GUICtrlSendMsg($hWnd, $TVM_DELETEITEM, 0, $hItem) <> 0
EndIf
EndIf
EndFunc
Func _GUICtrlTreeView_DeleteAll($hWnd)
Local $iCount = 0
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TVM_DELETEITEM, 0, $TVI_ROOT)
$iCount = _GUICtrlTreeView_GetCount($hWnd)
If $iCount Then Return GUICtrlSendMsg($hWnd, $TVM_DELETEITEM, 0, $TVI_ROOT) <> 0
Return True
Else
GUICtrlSendMsg($hWnd, $TVM_DELETEITEM, 0, $TVI_ROOT)
$iCount = _GUICtrlTreeView_GetCount($hWnd)
If $iCount Then Return _SendMessage($hWnd, $TVM_DELETEITEM, 0, $TVI_ROOT) <> 0
Return True
EndIf
EndFunc
Func _GUICtrlTreeView_DeleteChildren($hWnd, $hItem)
Local $bResult
If IsHWnd($hWnd) Then
$bResult = _SendMessage($hWnd, $TVM_EXPAND, BitOR($TVE_COLLAPSE, $TVE_COLLAPSERESET), $hItem, 0, "wparam", "handle")
Else
$bResult = GUICtrlSendMsg($hWnd, $TVM_EXPAND, BitOR($TVE_COLLAPSE, $TVE_COLLAPSERESET), $hItem)
EndIf
If $bResult Then _GUICtrlTreeView_SetChildren($hWnd, $hItem, False)
Return $bResult
EndFunc
Func _GUICtrlTreeView_Destroy(ByRef $hWnd)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hGUICtrl_LastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 0, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlTreeView_DisplayRect($hWnd, $hItem, $bTextOnly = False)
Local $tRECT = _GUICtrlTreeView_DisplayRectEx($hWnd, $hItem, $bTextOnly)
If @error Then Return SetError(@error, 0, 0)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlTreeView_DisplayRectEx($hWnd, $hItem, $bTextOnly = False)
Local $tRECT = DllStructCreate($tagRECT)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tCastPtr = DllStructCreate("ptr", DllStructGetPtr($tRECT))
DllStructSetData($tCastPtr, 1, $hItem)
Local $iRet = __GUICtrl_SendMsg($hWnd, $TVM_GETITEMRECT, $bTextOnly, $tRECT, 0, True)
If Not $iRet Then DllStructSetData($tCastPtr, 1, 0)
Return SetError($iRet = 0, $iRet, $tRECT)
EndFunc
Func _GUICtrlTreeView_EditText($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_WinAPI_SetFocus($hWnd)
Local $iMsg
If _GUICtrlTreeView_GetUnicodeFormat($hWnd) Then
$iMsg = $TVM_EDITLABELW
Else
$iMsg = $TVM_EDITLABELA
EndIf
Return _SendMessage($hWnd, $iMsg, 0, $hItem, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlTreeView_EndEdit($hWnd, $bCancel = False)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_ENDEDITLABELNOW, $bCancel) <> 0
EndFunc
Func _GUICtrlTreeView_EndUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__TREEVIEWCONSTANT_WM_SETREDRAW, True) = 0
EndFunc
Func _GUICtrlTreeView_EnsureVisible($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_ENSUREVISIBLE, 0, $hItem, 0, "wparam", "handle") <> 0
EndFunc
Func _GUICtrlTreeView_Expand($hWnd, $hItem = Null, $bExpand = True)
If $hItem = Null Then
$hItem = $TVI_ROOT
Else
If Not IsHWnd($hItem) Then
Local $hItem_tmp = GUICtrlGetHandle($hItem)
If $hItem_tmp Then $hItem = $hItem_tmp
EndIf
EndIf
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If $bExpand Then
__GUICtrlTreeView_ExpandItem($hWnd, $TVE_EXPAND, $hItem)
Else
__GUICtrlTreeView_ExpandItem($hWnd, $TVE_COLLAPSE, $hItem)
EndIf
EndFunc
Func __GUICtrlTreeView_ExpandItem($hWnd, $iExpand, $hItem)
If Not IsHWnd($hWnd) Then
If $hItem = 0x00000000 Then
$hItem = $TVI_ROOT
Else
$hItem = GUICtrlGetHandle($hItem)
If $hItem = 0 Then Return
EndIf
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
_SendMessage($hWnd, $TVM_EXPAND, $iExpand, $hItem, 0, "wparam", "handle")
If $iExpand = $TVE_EXPAND And $hItem > 0 Then _SendMessage($hWnd, $TVM_ENSUREVISIBLE, 0, $hItem, 0, "wparam", "handle")
$hItem = _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_CHILD, $hItem, 0, "wparam", "handle", "handle")
Local $hChild
While $hItem <> 0x00000000
$hChild = _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_CHILD, $hItem, 0, "wparam", "handle", "handle")
If $hChild <> 0x00000000 Then __GUICtrlTreeView_ExpandItem($hWnd, $iExpand, $hItem)
$hItem = _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_NEXT, $hItem, 0, "wparam", "handle", "handle")
WEnd
EndFunc
Func _GUICtrlTreeView_ExpandedOnce($hWnd, $hItem)
Return BitAND(_GUICtrlTreeView_GetState($hWnd, $hItem), $TVIS_EXPANDEDONCE) <> 0
EndFunc
Func _GUICtrlTreeView_FindItem($hWnd, $sText, $bInStr = False, $hStart = 0)
If $hStart = 0 Then $hStart = _GUICtrlTreeView_GetFirstItem($hWnd)
While $hStart <> 0x00000000
Local $sItem = _GUICtrlTreeView_GetText($hWnd, $hStart)
Switch $bInStr
Case False
If $sItem = $sText Then ExitLoop
Case True
If StringInStr($sItem, $sText) Then ExitLoop
EndSwitch
$hStart = _GUICtrlTreeView_GetNext($hWnd, $hStart)
WEnd
Return $hStart
EndFunc
Func _GUICtrlTreeView_FindItemEx($hWnd, $sTreePath, $hStart = 0)
Local $sDelimiter = Opt("GUIDataSeparatorChar")
Local $iIndex = 1
Local $aParts = StringSplit($sTreePath, $sDelimiter)
If $hStart = 0 Then $hStart = _GUICtrlTreeView_GetFirstItem($hWnd)
While ($iIndex <= $aParts[0]) And ($hStart <> 0x00000000)
If StringStripWS(_GUICtrlTreeView_GetText($hWnd, $hStart), $STR_STRIPLEADING + $STR_STRIPTRAILING) = StringStripWS($aParts[$iIndex], $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
If $iIndex = $aParts[0] Then ExitLoop
$iIndex += 1
__GUICtrlTreeView_ExpandItem($hWnd, $TVE_EXPAND, $hStart)
$hStart = _GUICtrlTreeView_GetFirstChild($hWnd, $hStart)
Else
$hStart = _GUICtrlTreeView_GetNextSibling($hWnd, $hStart)
__GUICtrlTreeView_ExpandItem($hWnd, $TVE_COLLAPSE, $hStart)
EndIf
WEnd
Return $hStart
EndFunc
Func _GUICtrlTreeView_GetBkColor($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sHex = Hex(String(_SendMessage($hWnd, $TVM_GETBKCOLOR)), 6)
Return '0x' & StringMid($sHex, 5, 2) & StringMid($sHex, 3, 2) & StringMid($sHex, 1, 2)
EndFunc
Func _GUICtrlTreeView_GetBold($hWnd, $hItem)
Return BitAND(_GUICtrlTreeView_GetState($hWnd, $hItem), $TVIS_BOLD) <> 0
EndFunc
Func _GUICtrlTreeView_GetChecked($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", $TVIF_STATE)
DllStructSetData($tItem, "hItem", $hItem)
__GUICtrlTreeView_GetItem($hWnd, $tItem)
Return BitAND(DllStructGetData($tItem, "State"), $TVIS_CHECKED) = $TVIS_CHECKED
EndFunc
Func _GUICtrlTreeView_GetChildCount($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $iRet = 0
Local $hNext = _GUICtrlTreeView_GetFirstChild($hWnd, $hItem)
If $hNext = 0x00000000 Then Return -1
Do
$iRet += 1
$hNext = _GUICtrlTreeView_GetNextSibling($hWnd, $hNext)
Until $hNext = 0x00000000
Return $iRet
EndFunc
Func _GUICtrlTreeView_GetChildren($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", $TVIF_CHILDREN)
DllStructSetData($tItem, "hItem", $hItem)
__GUICtrlTreeView_GetItem($hWnd, $tItem)
Return DllStructGetData($tItem, "Children") <> 0
EndFunc
Func _GUICtrlTreeView_GetCount($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETCOUNT)
EndFunc
Func _GUICtrlTreeView_GetCut($hWnd, $hItem)
Return BitAND(_GUICtrlTreeView_GetState($hWnd, $hItem), $TVIS_CUT) <> 0
EndFunc
Func _GUICtrlTreeView_GetDropTarget($hWnd, $hItem)
Return BitAND(_GUICtrlTreeView_GetState($hWnd, $hItem), $TVIS_DROPHILITED) <> 0
EndFunc
Func _GUICtrlTreeView_GetEditControl($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETEDITCONTROL, 0, 0, 0, "wparam", "lparam", "handle")
EndFunc
Func _GUICtrlTreeView_GetExpanded($hWnd, $hItem)
Return BitAND(_GUICtrlTreeView_GetState($hWnd, $hItem), $TVIS_EXPANDED) <> 0
EndFunc
Func _GUICtrlTreeView_GetFirstChild($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_CHILD, $hItem, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlTreeView_GetFirstItem($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_ROOT, 0, 0, "wparam", "lparam", "handle")
EndFunc
Func _GUICtrlTreeView_GetFirstVisible($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_FIRSTVISIBLE, 0, 0, "wparam", "lparam", "handle")
EndFunc
Func _GUICtrlTreeView_GetFocused($hWnd, $hItem)
Return BitAND(_GUICtrlTreeView_GetState($hWnd, $hItem), $TVIS_FOCUSED) <> 0
EndFunc
Func _GUICtrlTreeView_GetHeight($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETITEMHEIGHT)
EndFunc
Func _GUICtrlTreeView_GetImageIndex($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", $TVIF_IMAGE)
DllStructSetData($tItem, "hItem", $hItem)
__GUICtrlTreeView_GetItem($hWnd, $tItem)
Return DllStructGetData($tItem, "Image")
EndFunc
Func _GUICtrlTreeView_GetImageListIconHandle($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $hImageList = _SendMessage($hWnd, $TVM_GETIMAGELIST, 0, 0, 0, "wparam", "lparam", "handle")
Local $hIcon = DllCall("comctl32.dll", "handle", "ImageList_GetIcon", "handle", $hImageList, "int", $iIndex, "uint", 0)
If @error Then Return SetError(@error, @extended, 0)
Return $hIcon[0]
EndFunc
Func _GUICtrlTreeView_GetIndent($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETINDENT)
EndFunc
Func _GUICtrlTreeView_GetInsertMarkColor($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETINSERTMARKCOLOR)
EndFunc
Func _GUICtrlTreeView_GetISearchString($hWnd)
Local $bUnicode = _GUICtrlTreeView_GetUnicodeFormat($hWnd)
Local $iMsg
If $bUnicode Then
$iMsg = $TVM_GETISEARCHSTRINGW
Else
$iMsg = $TVM_GETISEARCHSTRINGA
EndIf
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _SendMessage($hWnd, $iMsg) = 0 Then Return ""
Local $tBuffer
If $bUnicode Then
$tBuffer = $__g_tTVBuffer
Else
$tBuffer = $__g_tTVBufferANSI
EndIf
DllStructSetData($tBuffer, "Text", "")
__GUICtrl_SendMsg($hWnd, $iMsg, 0, $tBuffer, 0, True)
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func __GUICtrlTreeView_GetItem($hWnd, ByRef $tItem)
Local $iMsg
If _GUICtrlTreeView_GetUnicodeFormat($hWnd) Then
$iMsg = $TVM_GETITEMW
Else
$iMsg = $TVM_GETITEMA
EndIf
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, 0, $tItem, 0, True)
Return $iRet <> 0
EndFunc
Func _GUICtrlTreeView_GetItemByIndex($hWnd, $hItem, $iIndex)
Local $hResult = _GUICtrlTreeView_GetFirstChild($hWnd, $hItem)
While ($hResult <> 0x00000000) And ($iIndex > 0)
$hResult = _GUICtrlTreeView_GetNextSibling($hWnd, $hResult)
$iIndex -= 1
WEnd
Return $hResult
EndFunc
Func _GUICtrlTreeView_GetItemHandle($hWnd, $hItem = Null)
If IsHWnd($hWnd) Then
If $hItem = Null Then $hItem = _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_ROOT, 0, 0, "wparam", "lparam", "handle")
Else
If $hItem = Null Then
$hItem = Ptr(GUICtrlSendMsg($hWnd, $TVM_GETNEXTITEM, $TVGN_ROOT, 0))
Else
Local $hTempItem = GUICtrlGetHandle($hItem)
If $hTempItem And Not IsPtr($hItem) Then
$hItem = $hTempItem
Else
SetExtended(1)
EndIf
EndIf
EndIf
Return $hItem
EndFunc
Func _GUICtrlTreeView_GetItemParam($hWnd, $hItem = Null)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", $TVIF_PARAM)
DllStructSetData($tItem, "Param", 0)
Local $iMsg
If _GUICtrlTreeView_GetUnicodeFormat($hWnd) Then
$iMsg = $TVM_GETITEMW
Else
$iMsg = $TVM_GETITEMA
EndIf
If IsHWnd($hWnd) Then
If $hItem = Null Then $hItem = _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0, 0, "wparam", "lparam", "handle")
If $hItem = 0x00000000 Then Return 0
DllStructSetData($tItem, "hItem", $hItem)
If _SendMessage($hWnd, $iMsg, 0, $tItem, 0, "wparam", "struct*") = 0 Then Return 0
Else
If $hItem = Null Then
$hItem = Ptr(GUICtrlSendMsg($hWnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0))
Else
Local $hTempItem = GUICtrlGetHandle($hItem)
If $hTempItem And Not IsPtr($hItem) Then
$hItem = $hTempItem
Else
SetExtended(1)
EndIf
EndIf
If $hItem = 0x00000000 Then Return 0
DllStructSetData($tItem, "hItem", $hItem)
If GUICtrlSendMsg($hWnd, $iMsg, 0, DllStructGetPtr($tItem)) = 0 Then Return 0
EndIf
Return DllStructGetData($tItem, "Param")
EndFunc
Func _GUICtrlTreeView_GetLastChild($hWnd, $hItem)
Local $hResult = _GUICtrlTreeView_GetFirstChild($hWnd, $hItem)
If $hResult <> 0x00000000 Then
Local $hNext = $hResult
Do
$hResult = $hNext
$hNext = _GUICtrlTreeView_GetNextSibling($hWnd, $hNext)
Until $hNext = 0x00000000
EndIf
Return $hResult
EndFunc
Func _GUICtrlTreeView_GetLastItem($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_LASTVISIBLE, 0, 0, "wparam", "lparam", "handle")
EndFunc
Func _GUICtrlTreeView_GetLineColor($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sHex = Hex(String(_SendMessage($hWnd, $TVM_GETLINECOLOR)), 6)
Return '0x' & StringMid($sHex, 5, 2) & StringMid($sHex, 3, 2) & StringMid($sHex, 1, 2)
EndFunc
Func _GUICtrlTreeView_GetNext($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $hResult = 0
If $hItem <> 0x00000000 Then
Local $hNext = _GUICtrlTreeView_GetFirstChild($hWnd, $hItem)
If $hNext = 0x00000000 Then
$hNext = _GUICtrlTreeView_GetNextSibling($hWnd, $hItem)
EndIf
Local $hParent = $hItem
While ($hNext = 0x00000000) And ($hParent <> 0x00000000)
$hParent = _GUICtrlTreeView_GetParentHandle($hWnd, $hParent)
If $hParent = 0x00000000 Then
$hNext = Ptr(0)
ExitLoop
EndIf
$hNext = _GUICtrlTreeView_GetNextSibling($hWnd, $hParent)
WEnd
$hResult = $hNext
EndIf
Return $hResult
EndFunc
Func _GUICtrlTreeView_GetNextChild($hWnd, $hItem)
Return _GUICtrlTreeView_GetNextSibling($hWnd, $hItem)
EndFunc
Func _GUICtrlTreeView_GetNextSibling($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_NEXT, $hItem, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlTreeView_GetNextVisible($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_NEXTVISIBLE, $hItem, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlTreeView_GetNormalImageList($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETIMAGELIST, $TVSIL_NORMAL, 0, 0, "wparam", "lparam", "handle")
EndFunc
Func _GUICtrlTreeView_GetOverlayImageIndex($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", $TVIF_STATE)
DllStructSetData($tItem, "hItem", $hItem)
DllStructSetData($tItem, "StateMask", $TVIS_OVERLAYMASK)
__GUICtrlTreeView_GetItem($hWnd, $tItem)
Return DllStructGetData($tItem, "Image")
EndFunc
Func _GUICtrlTreeView_GetParentHandle($hWnd, $hItem = Null)
If $hItem = Null Then
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
$hItem = _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0, 0, "wparam", "handle", "handle")
If $hItem = 0x00000000 Then Return 0
Else
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
EndIf
Local $hParent = _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_PARENT, $hItem, 0, "wparam", "handle", "handle")
Return $hParent
EndFunc
Func _GUICtrlTreeView_GetParentParam($hWnd, $hItem = Null)
Local $tTVITEM = $__g_tTVItemEx
DllStructSetData($tTVITEM, "Mask", $TVIF_PARAM)
DllStructSetData($tTVITEM, "Param", 0)
Local $hParent
If IsHWnd($hWnd) Then
If $hItem = Null Then $hItem = _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0, 0, "wparam", "handle", "handle")
If $hItem = 0x00000000 Then Return 0
$hParent = _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_PARENT, $hItem, 0, "wparam", "handle", "handle")
DllStructSetData($tTVITEM, "hItem", $hParent)
If _SendMessage($hWnd, $TVM_GETITEMA, 0, $tTVITEM, 0, "wparam", "struct*") = 0 Then Return 0
Else
If $hItem = Null Then
$hItem = GUICtrlSendMsg($hWnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0)
Else
Local $hTempItem = GUICtrlGetHandle($hItem)
If $hTempItem And Not IsPtr($hItem) Then
$hItem = $hTempItem
Else
SetExtended(1)
EndIf
EndIf
If $hItem = 0x00000000 Then Return 0
$hParent = GUICtrlSendMsg($hWnd, $TVM_GETNEXTITEM, $TVGN_PARENT, $hItem)
DllStructSetData($tTVITEM, "hItem", $hParent)
If GUICtrlSendMsg($hWnd, $TVM_GETITEMA, 0, DllStructGetPtr($tTVITEM)) = 0 Then Return 0
EndIf
Return DllStructGetData($tTVITEM, "Param")
EndFunc
Func _GUICtrlTreeView_GetPrev($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $hResult = _GUICtrlTreeView_GetPrevChild($hWnd, $hItem)
If $hResult <> 0x00000000 Then
Local $hPrev = $hResult
Do
$hResult = $hPrev
$hPrev = _GUICtrlTreeView_GetLastChild($hWnd, $hPrev)
Until $hPrev = 0x00000000
Else
$hResult = _GUICtrlTreeView_GetParentHandle($hWnd, $hItem)
EndIf
Return $hResult
EndFunc
Func _GUICtrlTreeView_GetPrevChild($hWnd, $hItem)
Return _GUICtrlTreeView_GetPrevSibling($hWnd, $hItem)
EndFunc
Func _GUICtrlTreeView_GetPrevSibling($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_PREVIOUS, $hItem, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlTreeView_GetPrevVisible($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_PREVIOUSVISIBLE, $hItem, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlTreeView_GetScrollTime($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETSCROLLTIME)
EndFunc
Func _GUICtrlTreeView_GetSelected($hWnd, $hItem)
Return BitAND(_GUICtrlTreeView_GetState($hWnd, $hItem), $TVIS_SELECTED) <> 0
EndFunc
Func _GUICtrlTreeView_GetSelectedImageIndex($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", $TVIF_SELECTEDIMAGE)
DllStructSetData($tItem, "hItem", $hItem)
__GUICtrlTreeView_GetItem($hWnd, $tItem)
Return DllStructGetData($tItem, "SelectedImage")
EndFunc
Func _GUICtrlTreeView_GetSelection($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlTreeView_GetSiblingCount($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $hNext, $iRet = 0
Local $hParent = _GUICtrlTreeView_GetParentHandle($hWnd, $hItem)
If $hParent <> 0x00000000 Then
$hNext = _GUICtrlTreeView_GetFirstChild($hWnd, $hParent)
If $hNext = 0x00000000 Then Return -1
Do
$iRet += 1
$hNext = _GUICtrlTreeView_GetNextSibling($hWnd, $hNext)
Until $hNext = 0x00000000
Else
$hNext = _GUICtrlTreeView_GetFirstItem($hWnd)
If $hNext = 0x00000000 Then Return -1
Do
$iRet += 1
$hNext = _GUICtrlTreeView_GetNextSibling($hWnd, $hNext)
Until $hNext = 0x00000000
EndIf
Return $iRet
EndFunc
Func _GUICtrlTreeView_GetState($hWnd, $hItem = Null)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", $TVIF_STATE)
DllStructSetData($tItem, "hItem", $hItem)
__GUICtrl_SendMsg($hWnd, $TVM_GETITEMA, 0, $tItem)
Return DllStructGetData($tItem, "State")
EndFunc
Func _GUICtrlTreeView_GetStateImageIndex($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", $TVIF_STATE)
DllStructSetData($tItem, "hItem", $hItem)
__GUICtrlTreeView_GetItem($hWnd, $tItem)
Return BitShift(BitAND(DllStructGetData($tItem, "State"), $TVIS_STATEIMAGEMASK), 12)
EndFunc
Func _GUICtrlTreeView_GetStateImageList($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETIMAGELIST, $TVSIL_STATE, 0, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlTreeView_GetText($hWnd, $hItem = Null)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
Local $tText, $iMsg
Local $bUnicode = _GUICtrlTreeView_GetUnicodeFormat($hWnd)
If $bUnicode Then
$tText = $__g_tTVBuffer
$iMsg = $TVM_GETITEMW
Else
$tText = $__g_tTVBufferANSI
$iMsg = $TVM_GETITEMA
EndIf
DllStructSetData($tText, 1, "")
DllStructSetData($tItem, "Mask", $TVIF_TEXT)
DllStructSetData($tItem, "hItem", $hItem)
__GUICtrl_SendMsg($hWnd, $iMsg, 0, $tItem, $tText, False, 5, True)
Return DllStructGetData($tText, 1)
EndFunc
Func _GUICtrlTreeView_GetTextColor($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sHex = Hex(String(_SendMessage($hWnd, $TVM_GETTEXTCOLOR)), 6)
Return '0x' & StringMid($sHex, 5, 2) & StringMid($sHex, 3, 2) & StringMid($sHex, 1, 2)
EndFunc
Func _GUICtrlTreeView_GetToolTips($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETTOOLTIPS, 0, 0, 0, "wparam", "lparam", "hwnd")
EndFunc
Func _GUICtrlTreeView_GetTree($hWnd, $hItem = Null)
If $hItem = Null Then
$hItem = 0x00000000
Else
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
EndIf
Local $sPath = ""
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If $hItem = 0x00000000 Then $hItem = _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0, 0, "wparam", "handle", "handle")
If $hItem <> 0x00000000 Then
$sPath = _GUICtrlTreeView_GetText($hWnd, $hItem)
Local $hParent, $sSeparator = Opt("GUIDataSeparatorChar")
Do
$hParent = _SendMessage($hWnd, $TVM_GETNEXTITEM, $TVGN_PARENT, $hItem, 0, "wparam", "handle", "handle")
If $hParent <> 0x00000000 Then $sPath = _GUICtrlTreeView_GetText($hWnd, $hParent) & $sSeparator & $sPath
$hItem = $hParent
Until $hItem = 0x00000000
EndIf
Return $sPath
EndFunc
Func _GUICtrlTreeView_GetUnicodeFormat($hWnd)
If Not IsDllStruct($__g_tTVBuffer) Then
$__g_tTVBuffer = DllStructCreate("wchar Text[4096]")
$__g_tTVBufferANSI = DllStructCreate("char Text[4096]", DllStructGetPtr($__g_tTVBuffer))
EndIf
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TVM_GETUNICODEFORMAT) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TVM_GETUNICODEFORMAT, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlTreeView_GetVisible($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tRECT = DllStructCreate($tagRECT)
Local $tCastPtr = DllStructCreate("ptr", DllStructGetPtr($tRECT))
DllStructSetData($tCastPtr, 1, $hItem)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iRet = __GUICtrl_SendMsg($hWnd, $TVM_GETITEMRECT, True, $tRECT, 0, True)
If $iRet = 0 Then Return False
Local $iControlHeight = _WinAPI_GetWindowHeight($hWnd)
If DllStructGetData($tRECT, "Top") >= $iControlHeight Or  DllStructGetData($tRECT, "Bottom") <= 0 Then
Return False
Else
Return True
EndIf
EndFunc
Func _GUICtrlTreeView_GetVisibleCount($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_GETVISIBLECOUNT)
EndFunc
Func _GUICtrlTreeView_HitTest($hWnd, $iX, $iY)
Local $tHitTest = _GUICtrlTreeView_HitTestEx($hWnd, $iX, $iY)
Local $iFlags = DllStructGetData($tHitTest, "Flags")
Local $iRet = 0
If BitAND($iFlags, $TVHT_NOWHERE) <> 0 Then $iRet = BitOR($iRet, 1)
If BitAND($iFlags, $TVHT_ONITEMICON) <> 0 Then $iRet = BitOR($iRet, 2)
If BitAND($iFlags, $TVHT_ONITEMLABEL) <> 0 Then $iRet = BitOR($iRet, 4)
If BitAND($iFlags, $TVHT_ONITEMINDENT) <> 0 Then $iRet = BitOR($iRet, 8)
If BitAND($iFlags, $TVHT_ONITEMBUTTON) <> 0 Then $iRet = BitOR($iRet, 16)
If BitAND($iFlags, $TVHT_ONITEMRIGHT) <> 0 Then $iRet = BitOR($iRet, 32)
If BitAND($iFlags, $TVHT_ONITEMSTATEICON) <> 0 Then $iRet = BitOR($iRet, 64)
If BitAND($iFlags, $TVHT_ABOVE) <> 0 Then $iRet = BitOR($iRet, 128)
If BitAND($iFlags, $TVHT_BELOW) <> 0 Then $iRet = BitOR($iRet, 256)
If BitAND($iFlags, $TVHT_TORIGHT) <> 0 Then $iRet = BitOR($iRet, 512)
If BitAND($iFlags, $TVHT_TOLEFT) <> 0 Then $iRet = BitOR($iRet, 1024)
Return $iRet
EndFunc
Func _GUICtrlTreeView_HitTestEx($hWnd, $iX, $iY)
Local $tHitTest = DllStructCreate($tagTVHITTESTINFO)
DllStructSetData($tHitTest, "X", $iX)
DllStructSetData($tHitTest, "Y", $iY)
__GUICtrl_SendMsg($hWnd, $TVM_HITTEST, 0, $tHitTest, 0, True)
Return $tHitTest
EndFunc
Func _GUICtrlTreeView_HitTestItem($hWnd, $iX, $iY)
Local $tHitTest = _GUICtrlTreeView_HitTestEx($hWnd, $iX, $iY)
Return DllStructGetData($tHitTest, "Item")
EndFunc
Func _GUICtrlTreeView_Index($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $iRet = -1
Local $hParent = _GUICtrlTreeView_GetParentHandle($hWnd, $hItem)
Local $hNext
If $hParent <> 0x00000000 Then
$hNext = _GUICtrlTreeView_GetFirstChild($hWnd, $hParent)
While $hNext <> 0x00000000
$iRet += 1
If $hNext = $hItem Then ExitLoop
$hNext = _GUICtrlTreeView_GetNextSibling($hWnd, $hNext)
WEnd
Else
$hNext = _GUICtrlTreeView_GetFirstItem($hWnd)
While $hNext <> 0x00000000
$iRet += 1
If $hNext = $hItem Then ExitLoop
$hNext = _GUICtrlTreeView_GetNextSibling($hWnd, $hNext)
WEnd
EndIf
If $hNext = 0x00000000 Then $iRet = -1
Return $iRet
EndFunc
Func _GUICtrlTreeView_InsertItem($hWnd, $sItem_Text, $hItem_Parent = 0, $hItem_After = 0, $iImage = -1, $iSelImage = -1)
Local $tTVI = DllStructCreate($tagTVINSERTSTRUCT)
Local $tText, $iMsg
If _GUICtrlTreeView_GetUnicodeFormat($hWnd) Then
$tText = $__g_tTVBuffer
$iMsg = $TVM_INSERTITEMW
Else
$tText = $__g_tTVBufferANSI
$iMsg = $TVM_INSERTITEMA
EndIf
Local $iBuffer, $pBuffer
If $sItem_Text <> -1 Then
$iBuffer = StringLen($sItem_Text) + 1
DllStructSetData($tText, "Text", $sItem_Text)
$pBuffer = DllStructGetPtr($tText)
Else
$iBuffer = 0
$tText = 0
$pBuffer = -1
EndIf
Local $hItem_tmp, $iExtended = 0
If $hItem_Parent = 0 Then
$hItem_Parent = $TVI_ROOT
ElseIf Not IsHWnd($hItem_Parent) Then
$hItem_tmp = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem_Parent)
If $hItem_tmp Then
$hItem_Parent = $hItem_tmp
Else
$iExtended = 1
EndIf
EndIf
If $hItem_After = 0 Then
$hItem_After = $TVI_LAST
ElseIf ($hItem_After <> $TVI_ROOT And  $hItem_After <> $TVI_FIRST And  $hItem_After <> $TVI_LAST And  $hItem_After <> $TVI_SORT) Then
If Not IsHWnd($hItem_After) Then
$hItem_tmp = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem_After)
If Not $hItem_tmp Then
$hItem_After = $TVI_LAST
Else
$hItem_After = $hItem_tmp
EndIf
EndIf
EndIf
Local $hIcon
Local $iMask = $TVIF_TEXT
If $iImage >= 0 Then
$iMask = BitOR($iMask, $TVIF_IMAGE)
$iMask = BitOR($iMask, $TVIF_IMAGE)
DllStructSetData($tTVI, "Image", $iImage)
Else
$hIcon = _GUICtrlTreeView_GetImageListIconHandle($hWnd, 0)
If $hIcon <> 0x00000000 Then
$iMask = BitOR($iMask, $TVIF_IMAGE)
DllStructSetData($tTVI, "Image", 0)
DllCall("user32.dll", "int", "DestroyIcon", "handle", $hIcon)
EndIf
EndIf
If $iSelImage >= 0 Then
$iMask = BitOR($iMask, $TVIF_SELECTEDIMAGE)
$iMask = BitOR($iMask, $TVIF_SELECTEDIMAGE)
DllStructSetData($tTVI, "SelectedImage", $iSelImage)
Else
$hIcon = _GUICtrlTreeView_GetImageListIconHandle($hWnd, 1)
If $hIcon <> 0x00000000 Then
$iMask = BitOR($iMask, $TVIF_SELECTEDIMAGE)
DllStructSetData($tTVI, "SelectedImage", 0)
DllCall("user32.dll", "int", "DestroyIcon", "handle", $hIcon)
EndIf
EndIf
$iMask = BitOR($iMask, $TVIF_PARAM)
DllStructSetData($tTVI, "Param", 0)
DllStructSetData($tTVI, "Parent", $hItem_Parent)
DllStructSetData($tTVI, "InsertAfter", $hItem_After)
DllStructSetData($tTVI, "Mask", $iMask)
DllStructSetData($tTVI, "Text", $pBuffer)
DllStructSetData($tTVI, "TextMax", $iBuffer)
Local $hItem = Ptr(__GUICtrl_SendMsg($hWnd, $iMsg, 0, $tTVI, $tText, False, -1))
SetExtended($iExtended)
Return $hItem
EndFunc
Func _GUICtrlTreeView_IsFirstItem($hWnd, $hItem)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Return _GUICtrlTreeView_GetFirstItem($hWnd) = $hItem
EndFunc
Func _GUICtrlTreeView_IsParent($hWnd, $hParent, $hItem)
If Not IsHWnd($hParent) Then $hParent = _GUICtrlTreeView_GetItemHandle($hWnd, $hParent)
Return _GUICtrlTreeView_GetParentHandle($hWnd, $hItem) = $hParent
EndFunc
Func _GUICtrlTreeView_Level($hWnd, $hItem)
Local $iRet = 0
Local $hNext = _GUICtrlTreeView_GetParentHandle($hWnd, $hItem)
While $hNext <> 0x00000000
$iRet += 1
$hNext = _GUICtrlTreeView_GetParentHandle($hWnd, $hNext)
WEnd
Return $iRet
EndFunc
Func _GUICtrlTreeView_MapAccIDToItem($hWnd, $iID)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_MAPACCIDTOHTREEITEM, $iID, 0, 0, "wparam", "lparam", "handle")
EndFunc
Func _GUICtrlTreeView_MapItemToAccID($hWnd, $hTreeItem)
If Not IsHWnd($hTreeItem) Then $hTreeItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hTreeItem)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_MAPHTREEITEMTOACCID, $hTreeItem, 0, 0, "handle")
EndFunc
Func __GUICtrlTreeView_ReverseColorOrder($vColor)
Local $sHex = Hex(String($vColor), 6)
Return '0x' & StringMid($sHex, 5, 2) & StringMid($sHex, 3, 2) & StringMid($sHex, 1, 2)
EndFunc
Func _GUICtrlTreeView_SelectItem($hWnd, $hItem, $iFlag = 0)
If Not IsHWnd($hItem) And $hItem <> 0 Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
If $iFlag = 0 Then $iFlag = $TVGN_CARET
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_SELECTITEM, $iFlag, $hItem, 0, "wparam", "handle") <> 0
EndFunc
Func _GUICtrlTreeView_SelectItemByIndex($hWnd, $hItem, $iIndex)
Return _GUICtrlTreeView_SelectItem($hWnd, _GUICtrlTreeView_GetItemByIndex($hWnd, $hItem, $iIndex))
EndFunc
Func _GUICtrlTreeView_SetBkColor($hWnd, $vRGBColor)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return __GUICtrlTreeView_ReverseColorOrder(_SendMessage($hWnd, $TVM_SETBKCOLOR, 0, Int(__GUICtrlTreeView_ReverseColorOrder($vRGBColor))))
EndFunc
Func _GUICtrlTreeView_SetBold($hWnd, $hItem, $bFlag = True)
Return _GUICtrlTreeView_SetState($hWnd, $hItem, $TVIS_BOLD, $bFlag)
EndFunc
Func _GUICtrlTreeView_SetChecked($hWnd, $hItem, $bCheck = True)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", $TVIF_STATE)
DllStructSetData($tItem, "hItem", $hItem)
If $bCheck Then
DllStructSetData($tItem, "State", 0x2000)
Else
DllStructSetData($tItem, "State", 0x1000)
EndIf
DllStructSetData($tItem, "StateMask", 0xf000)
Return __GUICtrlTreeView_SetItem($hWnd, $tItem)
EndFunc
Func _GUICtrlTreeView_SetCheckedByIndex($hWnd, $hItem, $iIndex, $bCheck = True)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $hChild = _GUICtrlTreeView_GetItemByIndex($hWnd, $hItem, $iIndex)
Return _GUICtrlTreeView_SetChecked($hWnd, $hChild, $bCheck)
EndFunc
Func _GUICtrlTreeView_SetChildren($hWnd, $hItem, $bFlag = True)
Local $iCount = _GUICtrlTreeView_GetChildCount($hWnd, $hItem)
If $iCount = -1 And $bFlag Then Return False
If $iCount And Not $bFlag Then Return False
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", BitOR($TVIF_HANDLE, $TVIF_CHILDREN))
DllStructSetData($tItem, "hItem", $hItem)
DllStructSetData($tItem, "Children", $bFlag)
Return __GUICtrlTreeView_SetItem($hWnd, $tItem)
EndFunc
Func _GUICtrlTreeView_SetCut($hWnd, $hItem, $bFlag = True)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Return _GUICtrlTreeView_SetState($hWnd, $hItem, $TVIS_CUT, $bFlag)
EndFunc
Func _GUICtrlTreeView_SetDropTarget($hWnd, $hItem, $bFlag = True)
If $bFlag Then
Return _GUICtrlTreeView_SelectItem($hWnd, $hItem, $TVGN_DROPHILITE)
ElseIf _GUICtrlTreeView_GetDropTarget($hWnd, $hItem) Then
Return _GUICtrlTreeView_SelectItem($hWnd, 0)
EndIf
Return False
EndFunc
Func _GUICtrlTreeView_SetFocused($hWnd, $hItem, $bFlag = True)
Return _GUICtrlTreeView_SetState($hWnd, $hItem, $TVIS_FOCUSED, $bFlag)
EndFunc
Func _GUICtrlTreeView_SetHeight($hWnd, $iHeight)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_SETITEMHEIGHT, $iHeight)
EndFunc
Func _GUICtrlTreeView_SetIcon($hWnd, $hItem = Null, $sIconFile = "", $iIconID = 0, $iImageMode = 6)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
If @error Or $sIconFile = "" Then Return SetError(@error + 10, 0, False)
Local $tTVITEM = $__g_tTVItemEx
Local $tIcon = DllStructCreate("handle")
Local $aCount = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sIconFile, "int", $iIconID,  "handle", 0, "struct*", $tIcon, "uint", 1)
If @error Then Return SetError(@error + 20, @extended, False)
If $aCount[0] = 0 Then Return False
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $hImageList = _SendMessage($hWnd, $TVM_GETIMAGELIST, 0, 0, 0, "wparam", "lparam", "handle")
If $hImageList = 0x00000000 Then
$hImageList = DllCall("comctl32.dll", "handle", "ImageList_Create", "int", 16, "int", 16, "uint", 0x0021, "int", 0, "int", 1)
If @error Then Return SetError(@error + 30, @extended, False)
$hImageList = $hImageList[0]
If $hImageList = 0 Then Return SetError(2, 0, False)
_SendMessage($hWnd, $TVM_SETIMAGELIST, 0, $hImageList, 0, "wparam", "handle")
EndIf
Local $hIcon = DllStructGetData($tIcon, 1)
Local $vIcon = DllCall("comctl32.dll", "int", "ImageList_AddIcon", "handle", $hImageList, "handle", $hIcon)
$vIcon = $vIcon[0]
If @error Then
Local $iError = @error + 40, $iExtended = @extended
DllCall("user32.dll", "int", "DestroyIcon", "handle", $hIcon)
Return SetError($iError, $iExtended, False)
EndIf
DllCall("user32.dll", "int", "DestroyIcon", "handle", $hIcon)
Local $iMask = BitOR($TVIF_IMAGE, $TVIF_SELECTEDIMAGE)
If BitAND($iImageMode, 2) Then
DllStructSetData($tTVITEM, "Image", $vIcon)
If Not BitAND($iImageMode, 4) Then $iMask = $TVIF_IMAGE
EndIf
If BitAND($iImageMode, 4) Then
DllStructSetData($tTVITEM, "SelectedImage", $vIcon)
If Not BitAND($iImageMode, 2) Then
$iMask = $TVIF_SELECTEDIMAGE
Else
$iMask = BitOR($TVIF_IMAGE, $TVIF_SELECTEDIMAGE)
EndIf
EndIf
DllStructSetData($tTVITEM, "Mask", $iMask)
DllStructSetData($tTVITEM, "hItem", $hItem)
Return __GUICtrlTreeView_SetItem($hWnd, $tTVITEM)
EndFunc
Func _GUICtrlTreeView_SetImageIndex($hWnd, $hItem, $iIndex)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", BitOR($TVIF_HANDLE, $TVIF_IMAGE))
DllStructSetData($tItem, "hItem", $hItem)
DllStructSetData($tItem, "Image", $iIndex)
Return __GUICtrlTreeView_SetItem($hWnd, $tItem)
EndFunc
Func _GUICtrlTreeView_SetIndent($hWnd, $iIndent)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TVM_SETINDENT, $iIndent)
EndFunc
Func _GUICtrlTreeView_SetInsertMark($hWnd, $hItem, $bAfter = True)
If Not IsHWnd($hItem) And $hItem <> 0 Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_SETINSERTMARK, $bAfter, $hItem, 0, "wparam", "handle") <> 0
EndFunc
Func _GUICtrlTreeView_SetInsertMarkColor($hWnd, $iColor)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_SETINSERTMARKCOLOR, 0, $iColor)
EndFunc
Func __GUICtrlTreeView_SetItem($hWnd, ByRef $tItem)
Local $iMsg
If _GUICtrlTreeView_GetUnicodeFormat($hWnd) Then
$iMsg = $TVM_SETITEMW
Else
$iMsg = $TVM_SETITEMA
EndIf
Local $iRet = __GUICtrl_SendMsg($hWnd, $iMsg, 0, $tItem)
Return $iRet <> 0
EndFunc
Func _GUICtrlTreeView_SetItemHeight($hWnd, $hItem, $iIntegral)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
_GUICtrlTreeView_BeginUpdate($hWnd)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", BitOR($TVIF_HANDLE, $TVIF_INTEGRAL))
DllStructSetData($tItem, "hItem", $hItem)
DllStructSetData($tItem, "Integral", $iIntegral)
Local $bResult = __GUICtrlTreeView_SetItem($hWnd, $tItem)
_GUICtrlTreeView_EndUpdate($hWnd)
Return $bResult
EndFunc
Func _GUICtrlTreeView_SetItemParam($hWnd, $hItem, $iParam)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", BitOR($TVIF_HANDLE, $TVIF_PARAM))
DllStructSetData($tItem, "hItem", $hItem)
DllStructSetData($tItem, "Param", $iParam)
Local $bResult = __GUICtrlTreeView_SetItem($hWnd, $tItem)
Return $bResult
EndFunc
Func _GUICtrlTreeView_SetLineColor($hWnd, $vRGBColor)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return __GUICtrlTreeView_ReverseColorOrder(_SendMessage($hWnd, $TVM_SETLINECOLOR, 0, Int(__GUICtrlTreeView_ReverseColorOrder($vRGBColor))))
EndFunc
Func _GUICtrlTreeView_SetNormalImageList($hWnd, $hImageList)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_SETIMAGELIST, $TVSIL_NORMAL, $hImageList, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlTreeView_SetOverlayImageIndex($hWnd, $hItem, $iIndex)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", BitOR($TVIF_HANDLE, $TVIF_STATE))
DllStructSetData($tItem, "hItem", $hItem)
DllStructSetData($tItem, "State", BitShift($iIndex, -8))
DllStructSetData($tItem, "StateMask", $TVIS_OVERLAYMASK)
Return __GUICtrlTreeView_SetItem($hWnd, $tItem)
EndFunc
Func _GUICtrlTreeView_SetScrollTime($hWnd, $iTime)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_SETSCROLLTIME, $iTime)
EndFunc
Func _GUICtrlTreeView_SetSelected($hWnd, $hItem, $bFlag = True)
Return _GUICtrlTreeView_SetState($hWnd, $hItem, $TVIS_SELECTED, $bFlag)
EndFunc
Func _GUICtrlTreeView_SetSelectedImageIndex($hWnd, $hItem, $iIndex)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", BitOR($TVIF_HANDLE, $TVIF_SELECTEDIMAGE))
DllStructSetData($tItem, "hItem", $hItem)
DllStructSetData($tItem, "SelectedImage", $iIndex)
Return __GUICtrlTreeView_SetItem($hWnd, $tItem)
EndFunc
Func _GUICtrlTreeView_SetState($hWnd, $hItem, $iState = 0, $bSetState = True)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", $TVIF_STATE)
DllStructSetData($tItem, "hItem", $hItem)
If $bSetState Then
DllStructSetData($tItem, "State", $iState)
Else
DllStructSetData($tItem, "State", BitAND($bSetState, $iState))
EndIf
DllStructSetData($tItem, "StateMask", $iState)
If $bSetState Then DllStructSetData($tItem, "StateMask", BitOR($bSetState, $iState))
Return __GUICtrlTreeView_SetItem($hWnd, $tItem)
EndFunc
Func _GUICtrlTreeView_SetStateImageIndex($hWnd, $hItem, $iIndex)
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
If $iIndex < 0 Then
Return SetError(1, 0, False)
EndIf
Local $tItem = $__g_tTVItemEx
DllStructSetData($tItem, "Mask", $TVIF_STATE)
DllStructSetData($tItem, "hItem", $hItem)
DllStructSetData($tItem, "State", BitShift($iIndex, -12))
DllStructSetData($tItem, "StateMask", $TVIS_STATEIMAGEMASK)
Return __GUICtrlTreeView_SetItem($hWnd, $tItem)
EndFunc
Func _GUICtrlTreeView_SetStateImageList($hWnd, $hImageList)
_GUIImageList_AddIcon($hImageList, "shell32.dll", 0)
Local $iCount = _GUIImageList_GetImageCount($hImageList)
For $x = $iCount - 1 To 1 Step -1
_GUIImageList_Swap($hImageList, $x, $x - 1)
Next
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_SETIMAGELIST, $TVSIL_STATE, $hImageList, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlTreeView_SetText($hWnd, $hItem = Null, $sText = "")
If Not IsHWnd($hItem) Then $hItem = _GUICtrlTreeView_GetItemHandle($hWnd, $hItem)
If @error Or $sText = "" Then Return SetError(@error + 10, 0, False)
Local $tItem = $__g_tTVItemEx
Local $tBuffer, $iMsg
If _GUICtrlTreeView_GetUnicodeFormat($hWnd) Then
$tBuffer = $__g_tTVBuffer
$iMsg = $TVM_SETITEMW
Else
$tBuffer = $__g_tTVBufferANSI
$iMsg = $TVM_SETITEMA
EndIf
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Mask", BitOR($TVIF_HANDLE, $TVIF_TEXT))
DllStructSetData($tItem, "hItem", $hItem)
Local $bResult = __GUICtrl_SendMsg($hWnd, $iMsg, 0, $tItem, $tBuffer, False, 5)
Return $bResult <> 0
EndFunc
Func _GUICtrlTreeView_SetTextColor($hWnd, $vRGBColor)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return __GUICtrlTreeView_ReverseColorOrder(_SendMessage($hWnd, $TVM_SETTEXTCOLOR, 0, Int(__GUICtrlTreeView_ReverseColorOrder($vRGBColor))))
EndFunc
Func _GUICtrlTreeView_SetToolTips($hWnd, $hToolTip)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_SETTOOLTIPS, $hToolTip, 0, 0, "wparam", "int", "hwnd")
EndFunc
Func _GUICtrlTreeView_SetUnicodeFormat($hWnd, $bFormat = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TVM_SETUNICODEFORMAT, $bFormat)
EndFunc
Func _GUICtrlTreeView_Sort($hWnd)
Local $iItemCount = _GUICtrlTreeView_GetCount($hWnd)
If $iItemCount > 2 Then
Local $aTreeView[$iItemCount], $i = 0
Local $hHandle = _GUICtrlTreeView_GetFirstItem($hWnd)
$aTreeView[1] = $hHandle
$aTreeView[0] = 2
__GUICtrlTreeView_SortGetFirstChild($hWnd, $hHandle, $aTreeView)
ReDim $aTreeView[$aTreeView[0]]
$aTreeView[0] = 0
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
For $i = 0 To UBound($aTreeView) - 1
_SendMessage($hWnd, $TVM_SORTCHILDREN, 0, $aTreeView[$i], 0, "wparam", "handle")
Next
EndIf
EndFunc
Func __GUICtrlTreeView_SortGetFirstChild($hWnd, $hItem, ByRef $aTreeView)
Local $hChild = _GUICtrlTreeView_GetFirstChild($hWnd, $hItem)
If $hChild <> 0 Then
$aTreeView[$aTreeView[0]] = $hChild
$aTreeView[0] += 1
__GUICtrlTreeView_SortGetFirstChild($hWnd, $hChild, $aTreeView)
EndIf
Local $hNext = _GUICtrlTreeView_GetNextSibling($hWnd, $hItem)
If $hNext <> 0 Then __GUICtrlTreeView_SortGetFirstChild($hWnd, $hNext, $aTreeView)
EndFunc
Global $__BinaryCall_Kernel32dll = DllOpen('kernel32.dll')
Global $__BinaryCall_Msvcrtdll = DllOpen('msvcrt.dll')
Global $__BinaryCall_LastError = ""
Func _BinaryCall_GetProcAddress($Module, $Proc)
Local $Ret = DllCall($__BinaryCall_Kernel32dll, 'ptr', 'GetProcAddress', 'ptr', $Module, 'str', $Proc)
If @Error Or Not $Ret[0] Then Return SetError(1, @Error, 0)
Return $Ret[0]
EndFunc
Func _BinaryCall_LoadLibrary($Filename)
Local $Ret = DllCall($__BinaryCall_Kernel32dll, "handle", "LoadLibraryW", "wstr", $Filename)
If @Error Then Return SetError(1, @Error, 0)
Return $Ret[0]
EndFunc
Func _BinaryCall_lstrlenA($Ptr)
Local $Ret = DllCall($__BinaryCall_Kernel32dll, "int", "lstrlenA", "ptr", $Ptr)
If @Error Then Return SetError(1, @Error, 0)
Return $Ret[0]
EndFunc
Func _BinaryCall_Alloc($Code, $Padding = 0)
Local $Length = BinaryLen($Code) + $Padding
Local $Ret = DllCall($__BinaryCall_Kernel32dll, "ptr", "VirtualAlloc", "ptr", 0, "ulong_ptr", $Length, "dword", 0x1000, "dword", 0x40)
If @Error Or Not $Ret[0] Then Return SetError(1, @Error, 0)
If BinaryLen($Code) Then
Local $Buffer = DllStructCreate("byte[" & $Length & "]", $Ret[0])
DllStructSetData($Buffer, 1, $Code)
EndIf
Return $Ret[0]
EndFunc
Func _BinaryCall_RegionSize($Ptr)
Local $Buffer = DllStructCreate("ptr;ptr;dword;uint_ptr;dword;dword;dword")
Local $Ret = DllCall($__BinaryCall_Kernel32dll, "int", "VirtualQuery", "ptr", $Ptr, "ptr", DllStructGetPtr($Buffer), "uint_ptr", DllStructGetSize($Buffer))
If @Error Or $Ret[0] = 0 Then Return SetError(1, @Error, 0)
Return DllStructGetData($Buffer, 4)
EndFunc
Func _BinaryCall_Free($Ptr)
Local $Ret = DllCall($__BinaryCall_Kernel32dll, "bool", "VirtualFree", "ptr", $Ptr, "ulong_ptr", 0, "dword", 0x8000)
If @Error Or $Ret[0] = 0 Then
$Ret = DllCall($__BinaryCall_Kernel32dll, "bool", "GlobalFree", "ptr", $Ptr)
If @Error Or $Ret[0] <> 0 Then Return SetError(1, @Error, False)
EndIf
Return True
EndFunc
Func _BinaryCall_Release($CodeBase)
Local $Ret = _BinaryCall_Free($CodeBase)
Return SetError(@Error, @Extended, $Ret)
EndFunc
Func _BinaryCall_MemorySearch($Ptr, $Length, $Binary)
Static $CodeBase
If Not $CodeBase Then
If @AutoItX64 Then
$CodeBase = _BinaryCall_Create('0x4883EC084D85C94889C8742C4C39CA72254C29CA488D141131C9EB0848FFC14C39C97414448A1408453A140874EE48FFC04839D076E231C05AC3', '', 0, True, False)
Else
$CodeBase = _BinaryCall_Create('0x5589E58B4D14578B4508568B550C538B7D1085C9742139CA721B29CA8D341031D2EB054239CA740F8A1C17381C1074F34039F076EA31C05B5E5F5DC3', '', 0, True, False)
EndIf
If Not $CodeBase Then Return SetError(1, 0, 0)
EndIf
$Binary = Binary($Binary)
Local $Buffer = DllStructCreate("byte[" & BinaryLen($Binary) & "]")
DllStructSetData($Buffer, 1, $Binary)
Local $Ret = DllCallAddress("ptr:cdecl", $CodeBase, "ptr", $Ptr, "uint", $Length, "ptr", DllStructGetPtr($Buffer), "uint", DllStructGetSize($Buffer))
Return $Ret[0]
EndFunc
Func _BinaryCall_Base64Decode($Src)
Static $CodeBase
If Not $CodeBase Then
If @AutoItX64 Then
$CodeBase = _BinaryCall_Create('0x41544989CAB9FF000000555756E8BE000000534881EC000100004889E7F3A44C89D6E98A0000004439C87E0731C0E98D0000000FB66E01440FB626FFC00FB65E020FB62C2C460FB62424408A3C1C0FB65E034189EB41C1E4024183E3308A1C1C41C1FB044509E34080FF634189CC45881C08744C440FB6DFC1E5044489DF4088E883E73CC1FF0209C7418D44240241887C08014883C10380FB63742488D841C1E3064883C60483E03F4409D841884408FF89F389C84429D339D30F8C67FFFFFF4881C4000100005B5E5F5D415CC35EC3E8F9FFFFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000003E0000003F3435363738393A3B3C3D00000063000000000102030405060708090A0B0C0D0E0F101112131415161718190000000000001A1B1C1D1E1F202122232425262728292A2B2C2D2E2F30313233', '', 132, True, False)
Else
$CodeBase = _BinaryCall_Create('0x55B9FF00000089E531C05756E8F10000005381EC0C0100008B55088DBDF5FEFFFFF3A4E9C00000003B45140F8FC20000000FB65C0A028A9C1DF5FEFFFF889DF3FEFFFF0FB65C0A038A9C1DF5FEFFFF889DF2FEFFFF0FB65C0A018985E8FEFFFF0FB69C1DF5FEFFFF899DECFEFFFF0FB63C0A89DE83E630C1FE040FB6BC3DF5FEFFFFC1E70209FE8B7D1089F3881C074080BDF3FEFFFF63745C0FB6B5F3FEFFFF8BBDECFEFFFF8B9DE8FEFFFF89F083E03CC1E704C1F80209F88B7D1088441F0189D883C00280BDF2FEFFFF6374278A85F2FEFFFFC1E60683C10483E03F09F088441F0289D883C0033B4D0C0F8C37FFFFFFEB0231C081C40C0100005B5E5F5DC35EC3E8F9FFFFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000003E0000003F3435363738393A3B3C3D00000063000000000102030405060708090A0B0C0D0E0F101112131415161718190000000000001A1B1C1D1E1F202122232425262728292A2B2C2D2E2F30313233', '', 132, True, False)
EndIf
If Not $CodeBase Then Return SetError(1, 0, Binary(""))
EndIf
$Src = String($Src)
Local $SrcLen = StringLen($Src)
Local $SrcBuf = DllStructCreate("char[" & $SrcLen & "]")
DllStructSetData($SrcBuf, 1, $Src)
Local $DstLen = Int(($SrcLen + 2) / 4) * 3 + 1
Local $DstBuf = DllStructCreate("byte[" & $DstLen & "]")
Local $Ret = DllCallAddress("uint:cdecl", $CodeBase, "ptr", DllStructGetPtr($SrcBuf), "uint", $SrcLen, "ptr", DllStructGetPtr($DstBuf), "uint", $DstLen)
If $Ret[0] = 0 Then Return SetError(2, 0, Binary(""))
Return BinaryMid(DllStructGetData($DstBuf, 1), 1, $Ret[0])
EndFunc
Func _BinaryCall_Base64Encode($Src)
Static $CodeBase
If Not $CodeBase Then
If @AutoItX64 Then
$CodeBase = _BinaryCall_Create('AwAAAARiAQAAAAAAAAArkuFQDAlvIp0qAgbDnjr76UDZs1EPNIP2K18t9s6SNTbd43IB7HfdyPM8VfD/o36z4AmSW2m2AIsC6Af3fKNsHU4BdQKGd0PQXHxPSX0iNqp1YAKovksqQna06NeKMoOYqryTUX4WgpHjokhp6zY2sEFSIjcL7dW3FDoNVz4bGPyZHRvjFwmqvr7YGlNYKwNoh+SYCXmIgVPVZ63Vz1fbT33/QFpWmWOeBRqs4J+c8Qp6zJFsK345Pjw0I8kMSsnho4F4oNzQ2OsAbmIioaQ6Ma2ziw5NH+M+t4SpEeHDnBdUTTL20sxWZ0yKruFAsBIRoHvM7LYcid2eBV2d5roSjnkwMG0g69LNjs1fHjbI/9iU/hJwpSsgl4fltXdZG659/li13UFY89M7UfckiZ9XOeBM0zadgNsy8r8M3rEAAA==')
Else
$CodeBase = _BinaryCall_Create('AwAAAARVAQAAAAAAAAAqr7blBndrIGnmhhfXD7R1fkOTKhicg1W6MCtStbz+CsneBEg0bbHH1sqTLmLfY7A6LqZl6LYWT5ULVj6MXgugPbBn9wKsSU2ZCcBBPNkx09HVPdUaKnbqghDGj/C5SHoF+A/5g+UgE1C5zJZORjJ8ljs5lt2Y9lA4BsY7jVKX2vmDvHK1NnSR6nVwh7Pb+Po/UpNcy5sObVWDKkYSCCtCIjKIYqOe3c6k8Xsp4eritCUprXEVvCFi7K5Z6HFXdm3nZsFcE+eSJ1WkRnVQbWcmpjGMGka61C68+CI7tsQ13UnCFWNSpDrCbzUejMZh8HdPgEc5vCg3pKMKin/NavNpB6+87Y9y7HIxmKsPdjDT30u9hUKWnYiRe3nrwKyVDsiYpKU/Nse368jHag5B5or3UKA+nb2+eY8JwzgA')
EndIf
If Not $CodeBase Then Return SetError(1, 0, Binary(""))
EndIf
$Src = Binary($Src)
Local $SrcLen = BinaryLen($Src)
Local $SrcBuf = DllStructCreate("byte[" & $SrcLen & "]")
DllStructSetData($SrcBuf, 1, $Src)
Local $DstLen = Int(($SrcLen + 2) / 3) * 4 + 1
Local $DstBuf = DllStructCreate("char[" & $DstLen & "]")
Local $Ret = DllCallAddress("uint:cdecl", $CodeBase, "ptr", DllStructGetPtr($SrcBuf), "uint", $SrcLen, "ptr", DllStructGetPtr($DstBuf), "uint", $DstLen)
If $Ret[0] = 0 Then Return Binary("")
Return StringMid(DllStructGetData($DstBuf, 1), 1, $Ret[0])
EndFunc
Func _BinaryCall_LzmaDecompress($Src)
Static $CodeBase
If Not $CodeBase Then
If @AutoItX64 Then
$CodeBase = _BinaryCall_Create(_BinaryCall_Base64Decode('QVcxwEFWQVVBVFVXSInXVkiJzlMx20iB7OgAAABEiiFBgPzgdgnpyQAAAEGD7C1BiMf/wEGA/Cx38THA6wRBg+wJQYjG/8BBgPwId/GLRglEi24FQQ+2zkyJRCQoRQ+2/0HB5xBBiQFBD7bEAcG4AAMAANPgjYQAcA4AAEhjyOjIBAAATInpSInF6L0EAABIicMxwEyJ8kSI4EyLRCQoiNQl//8A/0QJ+EiF24lFAHQoTYXtdCNIjVfzSI1MJDhIg8YNTIkEJE2J6UmJ2EiJ7+g2AAAAicbrBb4BAAAASInp6IQEAACF9nQKSInZMdvodgQAAEiJ2EiBxOgAAABbXl9dQVxBXUFeQV/DVVNBV0FWQVVBVEFQTQHBQVFNicVRVkgB8lJIieX8SYn0iwdMjX8Eik8Cg8r/0+L30olV6Ijhg8r/0+L30olV5ADBiUXsuAEAAACJReCJRdyJRdhIiUXQRSnJKfaDy/8A0bgAAwAA0+BIjYg2BwAAuAAEAARMif/R6fOrvwUAAADoUAMAAP/PdfdEie9EicgrfSDB4ARBifpEI1XoRAHQTY0cR+hAAwAAD4WTAAAAik3sI33k0+eA6Qj22dPuAfe4AQAAAEiNPH++AAEAAMHnCEGD+QdNjbR/bA4AAHI0TInvSCt90A+2P9HnQYnzIf5BAfNPjRxe6O8CAACJwcHuCIPhATnOvgABAAB1DjnGd9jrDE2J8+jQAgAAOfBy9EyJ76pEiclBg/kEcg65AwAAAEGD+QpyA4PBA0EpyelDAgAAT42cT4ABAADomgIAAHUsi0XcQYP5B4lF4BnAi1XY99CLTdCD4AOJVdxBicGJTdhNjbdkBgAA6akAAABPjZxPmAEAAOhfAgAAdUZEicjB4AREAdBNjZxH4AEAAOhHAgAAdWpBg/kHuQkAAAByA4PBAkGJyUyJ70grfdBIO30gD4L9AQAAigdIA33QqumzAQAAT42cT7ABAADoCgIAAIt12HQhT42cT8gBAADo+AEAAIt13HQJi03ci3XgiU3gi03YiU3ci03QiU3YiXXQQYP5B7kIAAAAcgODwQNBiclNjbdoCgAATYnz6LsBAAB1FESJ0CnJweADvggAAABJjXxGBOs2TY1eAuicAQAAdRpEidC5CAAAAMHgA74IAAAASY28RgQBAADrEUmNvgQCAAC5EAAAAL4AAQAAiU3MuAEAAABJifvoYQEAAInCKfJy8gNVzEGD+QSJVcwPg7kAAABBg8EHuQMAAAA50XICidHB4Qa4AQAAAEmNvE9gAwAAvkAAAABJifvoHwEAAEGJwkEp8nLwQYP6BHJ4RInWRIlV0NHug2XQAf/Og03QAkGD+g5zFYnx0mXQi0XQRCnQTY20R14FAADrLIPuBOi6AAAA0evRZdBBOdhyBv9F0EEp2P/OdedNjbdEBgAAwWXQBL4EAAAAvwEAAACJ+E2J8+ioAAAAqAF0Awl90NHn/8516+sERIlV0P9F0EyJ74tNzEiJ+IPBAkgrRSBIOUXQd1RIif5IK3XQSItVGKyqSDnXcwT/yXX1SYn9D7bwTDttGA+C9fz//+gwAAAAKcBIi1UQTCtlCESJIkiLVWBMK20gRIkqSIPEKEFcQV1BXUFfW13DXli4AQAAAOvSgfsAAAABcgHDweMITDtlAHPmQcHgCEWKBCRJg8QBwynATY0cQ4H7AAAAAXMVweMITDtlAHPBQcHgCEWKBCRJg8QBidlBD7cTwekLD6/KQTnIcxOJy7kACAAAKdHB6QVmQQELAcDDKcvB6gVBKchmQSkTAcCDwAHDSLj////////////gbXN2Y3J0LmRsbHxtYWxsb2MASLj////////////gZnJlZQA='))
Else
$CodeBase = _BinaryCall_Create(_BinaryCall_Base64Decode('VYnlVzH/VlOD7EyLXQiKC4D54A+HxQAAADHA6wWD6S2I0ID5LI1QAXfziEXmMcDrBYPpCYjQgPkIjVABd/OIReWLRRSITeSLUwkPtsmLcwWJEA+2ReUBwbgAAwAA0+CNhABwDgAAiQQk6EcEAACJNCSJRdToPAQAAItV1InHi0Xkhf+JArgBAAAAdDaF9nQyi0UQg8MNiRQkiXQkFIl8JBCJRCQYjUXgiUQkDItFDIlcJASD6A2JRCQI6CkAAACLVdSJRdSJFCToAQQAAItF1IXAdAqJPCQx/+jwAwAAg8RMifhbXl9dw1dWU1WJ5YtFJAFFKFD8i3UYAXUcVot1FK2SUopO/oPI/9Pg99BQiPGDyP/T4PfQUADRifeD7AwpwEBQUFBQUFcp9laDy/+4AAMAANPgjYg2BwAAuAAEAATR6fOragVZ6MoCAADi+Yt9/ItF8Ct9JCH4iUXosADoywIAAA+FhQAAAIpN9CN97NPngOkI9tnT7lgB916NPH/B5wg8B1qNjH5sDgAAUVa+AAEAAFCwAXI0i338K33cD7Y/i23M0eeJ8SH+AfGNbE0A6JgCAACJwcHuCIPhATnOvgABAAB1DjnwctfrDIttzOh5AgAAOfBy9FqD+gSJ0XIJg/oKsQNyArEGKcpS60mwwOhJAgAAdRRYX1pZWln/NCRRUrpkBgAAsQDrb7DM6CwCAAB1LLDw6BMCAAB1U1g8B7AJcgKwC1CLdfwrddw7dSQPgs8BAACsi338qumOAQAAsNjo9wEAAIt12HQbsOTo6wEAAIt11HQJi3XQi03UiU3Qi03YiU3Ui03ciU3YiXXcWF9ZumgKAACxCAH6Ulc8B4jIcgIEA1CLbczovAEAAHUUi0Xoi33MweADKclqCF6NfEcE6zWLbcyDxQLomwEAAHUYi0Xoi33MweADaghZaghejbxHBAEAAOsQvwQCAAADfcxqEFm+AAEAAIlN5CnAQIn96GYBAACJwSnxcvMBTeSDfcQED4OwAAAAg0XEB4tN5IP5BHIDagNZi33IweEGKcBAakBejbxPYAMAAIn96CoBAACJwSnxcvOJTeiJTdyD+QRyc4nOg2XcAdHug03cAk6D+Q5zGbivAgAAKciJ8dJl3ANF3NHgA0XIiUXM6y2D7gToowAAANHr0WXcOV3gcgb/RdwpXeBOdei4RAYAAANFyIlFzMFl3ARqBF4p/0eJ+IttzOi0AAAAqAF0Awl93NHnTnXs6wD/RdyLTeSDwQKLffyJ+CtFJDlF3HdIif4rddyLVSisqjnXcwNJdfeJffwPtvA7fSgPgnH9///oKAAAACnAjWwkPItVIIt1+Ct1GIkyi1Usi338K30kiTrJW15fw15YKcBA69qB+wAAAAFyAcPB4whWi3X4O3Ucc+SLReDB4AisiUXgiXX4XsOLTcQPtsDB4QQDRegByOsGD7bAA0XEi23IjWxFACnAjWxFAIH7AAAAAXMci0wkOMFkJCAIO0wkXHOcihH/RCQ4weMIiFQkIInZD7dVAMHpCw+vyjlMJCBzF4nLuQAIAAAp0cHpBWYBTQABwI1sJEDDweoFKUwkICnLZilVAAHAg8ABjWwkQMO4///////gbXN2Y3J0LmRsbHxtYWxsb2MAuP//////4GZyZWUA'))
EndIf
If Not $CodeBase Then Return SetError(1, 0, Binary(""))
EndIf
$Src = Binary($Src)
Local $SrcLen = BinaryLen($Src)
Local $SrcBuf = DllStructCreate("byte[" & $SrcLen & "]")
DllStructSetData($SrcBuf, 1, $Src)
Local $Ret = DllCallAddress("ptr:cdecl", $CodeBase, "ptr", DllStructGetPtr($SrcBuf), "uint_ptr", $SrcLen, "uint_ptr*", 0, "uint*", 0)
If $Ret[0] Then
Local $DstBuf = DllStructCreate("byte[" & $Ret[3] & "]", $Ret[0])
Local $Output = DllStructGetData($DstBuf, 1)
DllCall($__BinaryCall_Msvcrtdll, "none:cdecl", "free", "ptr", $Ret[0])
Return $Output
EndIf
Return SetError(2, 0, Binary(""))
EndFunc
Func _BinaryCall_Relocation($Base, $Reloc)
Local $Size = Int(BinaryMid($Reloc, 1, 2))
For $i = 3 To BinaryLen($Reloc) Step $Size
Local $Offset = Int(BinaryMid($Reloc, $i, $Size))
Local $Ptr = $Base + $Offset
DllStructSetData(DllStructCreate("ptr", $Ptr), 1, DllStructGetData(DllStructCreate("ptr", $Ptr), 1) + $Base)
Next
EndFunc
Func _BinaryCall_ImportLibrary($Base, $Length)
Local $JmpBin, $JmpOff, $JmpLen, $DllName, $ProcName
If @AutoItX64 Then
$JmpBin = Binary("0x48B8FFFFFFFFFFFFFFFFFFE0")
$JmpOff = 2
Else
$JmpBin = Binary("0xB8FFFFFFFFFFE0")
$JmpOff = 1
EndIf
$JmpLen = BinaryLen($JmpBin)
Do
Local $Ptr = _BinaryCall_MemorySearch($Base, $Length, $JmpBin)
If $Ptr = 0 Then ExitLoop
Local $StringPtr = $Ptr + $JmpLen
Local $StringLen = _BinaryCall_lstrlenA($StringPtr)
Local $String = DllStructGetData(DllStructCreate("char[" & $StringLen & "]", $StringPtr), 1)
Local $Split = StringSplit($String, "|")
If $Split[0] = 1 Then
$ProcName = $Split[1]
ElseIf $Split[0] = 2 Then
If $Split[1] Then $DllName = $Split[1]
$ProcName = $Split[2]
EndIf
If $DllName And $ProcName Then
Local $Handle = _BinaryCall_LoadLibrary($DllName)
If Not $Handle Then
$__BinaryCall_LastError = "LoadLibrary fail on " & $DllName
Return SetError(1, 0, False)
EndIf
Local $Proc = _BinaryCall_GetProcAddress($Handle, $ProcName)
If Not $Proc Then
$__BinaryCall_LastError = "GetProcAddress failed on " & $ProcName
Return SetError(2, 0, False)
EndIf
DllStructSetData(DllStructCreate("ptr", $Ptr + $JmpOff), 1, $Proc)
EndIf
Local $Diff = Int($Ptr - $Base + $JmpLen + $StringLen + 1)
$Base += $Diff
$Length -= $Diff
Until $Length <= $JmpLen
Return True
EndFunc
Func _BinaryCall_CodePrepare($Code)
If Not $Code Then Return ""
If IsBinary($Code) Then Return $Code
$Code = String($Code)
If StringLeft($Code, 2) = "0x" Then Return Binary($Code)
If StringIsXDigit($Code) Then Return Binary("0x" & $Code)
Return _BinaryCall_LzmaDecompress(_BinaryCall_Base64Decode($Code))
EndFunc
Func _BinaryCall_SymbolFind($CodeBase, $Identify, $Length = Default)
$Identify = Binary($Identify)
If IsKeyword($Length) Then
$Length = _BinaryCall_RegionSize($CodeBase)
EndIf
Local $Ptr = _BinaryCall_MemorySearch($CodeBase, $Length, $Identify)
If $Ptr = 0 Then Return SetError(1, 0, 0)
Return $Ptr + BinaryLen($Identify)
EndFunc
Func _BinaryCall_SymbolList($CodeBase, $Symbol)
If Not IsArray($Symbol) Or $CodeBase = 0 Then Return SetError(1, 0, 0)
Local $Tag = ""
For $i = 0 To UBound($Symbol) - 1
$Tag &=  "ptr " & $Symbol[$i] & ";"
Next
Local $SymbolList = DllStructCreate($Tag)
If @Error Then Return SetError(1, 0, 0)
For $i = 0 To UBound($Symbol) - 1
$CodeBase = _BinaryCall_SymbolFind($CodeBase, $Symbol[$i])
DllStructSetData($SymbolList, $Symbol[$i], $CodeBase)
Next
Return $SymbolList
EndFunc
Func _BinaryCall_Create($Code, $Reloc = '', $Padding = 0, $ReleaseOnExit = True, $LibraryImport = True)
Local $BinaryCode = _BinaryCall_CodePrepare($Code)
If Not $BinaryCode Then Return SetError(1, 0, 0)
Local $BinaryCodeLen = BinaryLen($BinaryCode)
Local $TotalCodeLen = $BinaryCodeLen + $Padding
Local $CodeBase = _BinaryCall_Alloc($BinaryCode, $Padding)
If Not $CodeBase Then Return SetError(2, 0, 0)
If $Reloc Then
$Reloc = _BinaryCall_CodePrepare($Reloc)
If Not $Reloc Then Return SetError(3, 0, 0)
_BinaryCall_Relocation($CodeBase, $Reloc)
EndIf
If $LibraryImport Then
If Not _BinaryCall_ImportLibrary($CodeBase, $BinaryCodeLen) Then
_BinaryCall_Free($CodeBase)
Return SetError(4, 0, 0)
EndIf
EndIf
If $ReleaseOnExit Then
_BinaryCall_ReleaseOnExit($CodeBase)
EndIf
Return SetError(0, $TotalCodeLen, $CodeBase)
EndFunc
Func _BinaryCall_CommandLineToArgv($CommandLine, ByRef $Argc, $IsUnicode = False)
Static $SymbolList
If Not IsDllStruct($SymbolList) Then
Local $Code
If @AutoItX64 Then
$Code = 'AwAAAASuAgAAAAAAAAAkL48ClEB9jTEOeYv4yYTosNjFNgf81Ag4vS2VP4y4wxFa+4yMI7GDB7CG+xn4JE3cdEVvk8cMp4oIuS3DgTxlcKHGVIg94tvzG/256bizZfGtAETQUCPQjW5+JSx2C/Y4C0VNJMKTlSCHiV5AzXRZ5gw3WFghbtkCCFxWOX+RDSI2oH/vROEOnqc0jfKTo17EBjqX+dW3QxrUe45xsbyYTZ9ccIGySgcOAxetbRiSxQnz8BOMbJyfrbZbuVJyGpKrXFLh/5MlBZ09Cim9qgflbGzmkrGStT9QL1f+O2krzyOzgaWWqhWL6S+y0G32RWVi0uMLR/JOGLEW/+Yg/4bzkeC0lKELT+RmWAatNa38BRfaitROMN12moRDHM6LYD1lzPLnaiefSQRVti561sxni/AFkYoCb5Lkuyw4RIn/r/flRiUg5w48YkqBBd9rXkaXrEoKwPg6rmOvOCZadu//B6HN4+Ipq5aYNuZMxSJXmxwXVRSQZVpSfLS2ATZMd9/Y7kLqrKy1H4V76SgI/d9OKApfKSbQ8ZaKIHBCsoluEip3UDOB82Z21zd933UH5l0laGWLIrTz7xVGkecjo0NQzR7LyhhoV3xszlIuw2v8q0Q/S9LxB5G6tYbOXo7lLjNIZc0derZz7DNeeeJ9dQE9hp8unubaTBpulPxTNtRjog=='
Else
$Code = 'AwAAAAR6AgAAAAAAAABcQfD553vjya/3DmalU0BKqABevUb/60GZ55rMwmzpQfPSRUlIl04lEiS8RDrXpS0EoBUe+uzDgZd37nVu9wsJ4fykqYvLoMz3ApxQbTBKleOIRSla6I0V8dNP3P7rHeUfjH0jCho0RvhhVpf0o4ht/iZptauxaoy1zQ19TkPZ/vf5Im8ecY6qEdHNzjo2H60jVwiOJ+1J47TmQRwxJ+yKLakq8QNxtKkRIB9B9ugfo3NAL0QslDxbyU0dSgw2aOPxV+uttLzYNnWbLBZVQbchcKgLRjC/32U3Op576sOYFolB1Nj4/33c7MRgtGLjlZfTB/4yNvd4/E+u3U6/Q4MYApCfWF4R/d9CAdiwgIjCYUkGDExKjFtHbAWXfWh9kQ7Q/GWUjsfF9BtHO6924Cy1Ou+BUKksqsxmIKP4dBjvvmz9OHc1FdtR9I63XKyYtlUnqVRtKwlNrYAZVCSFsyAefMbteq1ihU33sCsLkAnp1LRZ2wofgT1/JtT8+GO2s/n52D18wM70RH2n5uJJv8tlxQc1lwbmo4XQvcbcE91U2j9glvt2wC1pkP0hF23Nr/iiIEZHIPAOAHvhervlHE830LSHyUx8yh5Tjojr0gdLvQ=='
EndIf
Local $CodeBase = _BinaryCall_Create($Code)
If @Error Then Return SetError(1, 0, 0)
Local $Symbol[] = ["ToArgvW","ToArgvA"]
$SymbolList = _BinaryCall_SymbolList($CodeBase, $Symbol)
If @Error Then Return SetError(1, 0, 0)
EndIf
Local $Ret
If $IsUnicode Then
$Ret = DllCallAddress("ptr:cdecl", DllStructGetData($SymbolList, "ToArgvW"), "wstr", $CommandLine, "int*", 0)
Else
$Ret = DllCallAddress("ptr:cdecl", DllStructGetData($SymbolList, "ToArgvA"), "str", $CommandLine, "int*", 0)
EndIf
If Not @Error And $Ret[0] <> 0 Then
_BinaryCall_ReleaseOnExit($Ret[0])
$Argc = $Ret[2]
Return $Ret[0]
Else
Return SetError(2, 0, 0)
EndIf
EndFunc
Func _BinaryCall_StdioRedirect($Filename = "CON", $Flag = 1 + 2 + 4)
Static $SymbolList
If Not IsDllStruct($SymbolList) Then
Local $Code, $Reloc
If @AutoItX64 Then
$Code = 'AwAAAASjAQAAAAAAAAAkL48ClEB9jTEOeYv4yYTosNjFM1rLNdMULriZUDxTj+ZdkQ01F5zKL+WDCScfQKKLn66EDmcA+gXIkPcZV4lyz8VPw8BPZlNB5KymydM15kCA+uqvmBc1V0NJfzgsF0Amhn0JhM/ZIguYCHxywMQ1SgKxUb05dxDg8WlX/2aPfSolcX47+4/72lPDNTeT7d7XRdm0ND+eCauuQcRH2YOahare9ASxuU4IMHCh2rbZYHwmTNRiQUB/8dLGtph93yhmwdHtyMPLX2x5n6sdA1mxua9htLsLTulE05LLmXbRYXylDz0A'
$Reloc = 'AwAAAAQIAAAAAAAAAAABAB7T+CzGn9ScQAC='
Else
$Code = 'AwAAAASVAQAAAAAAAABcQfD553vjya/3DmalU0BKqABaUcndypZ3mTYUkHxlLV/lKZPrXYWXgNATjyiowkUQGDVYUy5THQwK4zYdU7xuGf7qfVDELc1SNbiW3NgD4D6N6ZM7auI1jPaThsPfA/ouBcx2aVQX36fjmViTZ8ZLzafjJeR7d5OG5s9sAoIzFLTZsqrFlkIJedqDAOfhA/0mMrkavTWnsio6yTbic1dER0DcEsXpLn0vBNErKHoagLzAgofHNLeFRw5yHWz5owR5CYL7rgiv2k51neHBWGx97A=='
$Reloc = 'AwAAAAQgAAAAAAAAAAABABfyHS/VRkdjBBzbtGPD6vtmVH/IsGHYvPsTv2lGuqJxGlAA'
EndIf
Local $CodeBase = _BinaryCall_Create($Code, $Reloc)
If @Error Then Return SetError(1, 0, 0)
Local $Symbol[] = ["StdinRedirect","StdoutRedirect","StderrRedirect"]
$SymbolList = _BinaryCall_SymbolList($CodeBase, $Symbol)
If @Error Then Return SetError(1, 0, 0)
EndIf
If BitAND($Flag, 1) Then DllCallAddress("none:cdecl", DllStructGetData($SymbolList, "StdinRedirect"), "str", $Filename)
If BitAND($Flag, 2) Then DllCallAddress("none:cdecl", DllStructGetData($SymbolList, "StdoutRedirect"), "str", $Filename)
If BitAND($Flag, 4) Then DllCallAddress("none:cdecl", DllStructGetData($SymbolList, "StderrRedirect"), "str", $Filename)
EndFunc
Func _BinaryCall_StdinRedirect($Filename = "CON")
Local $Ret = _BinaryCall_StdioRedirect($Filename, 1)
Return SetError(@Error, @Extended, $Ret)
EndFunc
Func _BinaryCall_StdoutRedirect($Filename = "CON")
Local $Ret = _BinaryCall_StdioRedirect($Filename, 2)
Return SetError(@Error, @Extended, $Ret)
EndFunc
Func _BinaryCall_StderrRedirect($Filename = "CON")
Local $Ret = _BinaryCall_StdioRedirect($Filename, 4)
Return SetError(@Error, @Extended, $Ret)
EndFunc
Func _BinaryCall_ReleaseOnExit($Ptr)
OnAutoItExitRegister('__BinaryCall_DoRelease')
__BinaryCall_ReleaseOnExit_Handle($Ptr)
EndFunc
Func __BinaryCall_DoRelease()
__BinaryCall_ReleaseOnExit_Handle()
EndFunc
Func __BinaryCall_ReleaseOnExit_Handle($Ptr = Default)
Static $PtrList
If @NumParams = 0 Then
If IsArray($PtrList) Then
For $i = 1 To $PtrList[0]
_BinaryCall_Free($PtrList[$i])
Next
EndIf
Else
If Not IsArray($PtrList) Then
Local $InitArray[1] = [0]
$PtrList = $InitArray
EndIf
If IsPtr($Ptr) Then
Local $Array = $PtrList
Local $Size = UBound($Array)
ReDim $Array[$Size + 1]
$Array[$Size] = $Ptr
$Array[0] += 1
$PtrList = $Array
EndIf
EndIf
EndFunc
Global Const $JSON_UNESCAPED_UNICODE = 1
Global Const $JSON_UNESCAPED_SLASHES = 2
Global Const $JSON_HEX_TAG = 4
Global Const $JSON_HEX_AMP = 8
Global Const $JSON_HEX_APOS = 16
Global Const $JSON_HEX_QUOT = 32
Global Const $JSON_UNESCAPED_ASCII = 64
Global Const $JSON_PRETTY_PRINT = 128
Global Const $JSON_STRICT_PRINT = 256
Global Const $JSON_UNQUOTED_STRING = 512
Global Const $JSMN_ERROR_NOMEM = -1
Global Const $JSMN_ERROR_INVAL = -2
Global Const $JSMN_ERROR_PART = -3
Global $Total_JSON_DUMP_Output = ""
Func __Jsmn_RuntimeLoader($ProcName = "")
Static $SymbolList
If Not IsDllStruct($SymbolList) Then
Local $Code
If @AutoItX64 Then
$Code = 'AwAAAAQfCAAAAAAAAAA1HbEvgTNrvX54gCiWSTVmt5v7RCdoFJ/zhkKmwcm8yVqZPjJBoVhNHHAIzrHWKbZh1J0QAUaHB5zyQTilTmWa9O0OKeLrk/Jg+o7CmMzjEk74uPongdHv37nwYXvg97fiHvjP2bBzI9gxSkKq9Cqh/GxSHIlZPYyW76pXUt//25Aqs2Icfpyay/NFd50rW7eMliH5ynkrp16HM1afithVrO+LpSaz/IojowApmXnBHUncHliDqbkx6/AODUkyDm1hj+AiEZ9Me1Jy+hBQ1/wC/YnuuYSJvNAKp6XDnyc8Nwr54Uqx5SbUW2CezwQQ7aXX/HFiHSKpQcFW/gi8oSx5nsoxUXVjxeNI/L7z6GF2mfu3Tnpt7hliWEdA2r2VB+TIM7Pgwl9X3Ge0T3KJQUaRtLJZcPvVtOuKXr2Q9wy7hl80hVRrt9zYrbjBHXLrRx/HeIMkZwxhmKo/dD/vvaNgE+BdU8eeJqFBJK2alrK2rh2WkRynftyepm1WrdKrz/5KhQPp/4PqH+9IADDjoGBbfvJQXdT+yiO8DtfrVnd+JOEKsKEsdgeM3UXx5r6tEHO9rYWbzbnyEiX7WozZemry+vBZMMtHn1aA63+RcDQED73xOsnj00/9E5Z6hszM5Hi8vi6Hw3iOgf3cHwcXG44aau0JpuA2DlrUvnJOYkNnY+bECeSdAR1UQkFNyqRoH2xm4Y7gYMCPsFtPBlwwleEKI27SsUq1ZHVQvFCoef7DXgf/GwPCAvwDMIQfb3hJtIVubOkASRQZVNIJ/y4KPrn/gcASV7fvMjE34loltTVlyqprUWxpI51tN6vhTOLAp+CHseKxWaf9g1wdbVs0e/5xAiqgJbmKNi9OYbhV/blpp3SL63XKxGiHdxhK1aR+4rUY4eckNbaHfW7ob+q7aBoHSs6LVX9lWakb/xWxwQdwcX/7/C+TcQSOOg6rLoWZ8wur9qp+QwzoCbXkf04OYpvD5kqgEiwQnB90kLtcA+2XSbDRu+aq02eNNCzgkZujeL/HjVISjf2EuQKSsZkBhS15eiXoRgPaUoQ5586VS7t7rhM8ng5LiVzoUQIZ0pNKxWWqD+gXRBvOMIXY2yd0Ei4sE5KFIEhbs3u8vwP7nFLIpZ/RembPTuc0ZlguGJgJ2F5iApfia+C2tRYRNjVCqECCveWw6P2Btfaq9gw7cWWmJflIQbjxtccDqsn52cftLqXSna9zk05mYdJSV8z2W7vM1YJ5Rd82v0j3kau710A/kQrN41bdaxmKjL+gvSRlOLB1bpvkCtf9+h+eVA4XIkIXKFydr1OjMZ8wq2FIxPJXskAe4YMgwQmeWZXMK1KBbLB3yQR1YOYaaHk1fNea9KsXgs5YLbiP/noAusz76oEDo/DJh1aw7cUwdhboVPg1bNq88mRb5RGa13KDK9uEET7OA02KbSL+Q4HOtyasLUoVrZzVyd8iZPoGrV36vHnj+yvG4fq6F/fkug/sBRp186yVZQVmdAgFd+WiRLnUjxHUKJ6xBbpt4FTP42E/PzPw3JlDb0UQtXTDnIL0CWqbns2E7rZ5PBwrwQYwvBn/gaEeLVGDSh84DfW4zknIneGnYDXdVEHC+ITzejAnNxb1duB+w2aVTk64iXsKHETq53GMH6DuFi0oUeEFb/xp0HsRyNC8vBjOq3Kk7NZHxCQLh7UATFttG7sH+VIqGjjNwmraGJ0C92XhpQwSgfAb3KHucCHGTTti0sn6cgS3vb36BkjGKsRhXVuoQCFH96bvTYtl8paQQW9ufRfvxPqmU0sALdR0fIvZwd7Z8z0UoEec6b1Sul4e60REj/H4scb6N2ryHBR9ua5N1YxJu1uwgoLXUL2wT9ZPBjPjySUzeqXikUIKKYgNlWy+VlNIiWWTPtKpCTr508logA=='
Else
$Code = 'AwAAAASFBwAAAAAAAAA1HbEvgTNrvX54gCiqsa1mt5v7RCdoAFjCfVE40DZbE5UfabA9UKuHrjqOMbvjSoB2zBJTEYEQejBREnPrXL3VwpVOW+L9SSfo0rTfA8U2W+Veqo1uy0dOsPhl7vAHbBHrvJNfEUe8TT0q2eaTX2LeWpyrFEm4I3mhDJY/E9cpWf0A78e+y4c7NxewvcVvAakIHE8Xb8fgtqCTVQj3Q1eso7n1fKQj5YsQ20A86Gy9fz8dky78raeZnhYayn0b1riSUKxGVnWja2i02OvAVM3tCCvXwcbSkHTRjuIAbMu2mXF1UpKci3i/GzPmbxo9n/3aX/jpR6UvxMZuaEDEij4yzfZv7EyK9WCNBXxMmtTp3Uv6MZsK+nopXO3C0xFzZA/zQObwP3zhJ4sdatzMhFi9GAM70R4kgMzsxQDNArueXj+UFzbCCFZ89zXs22F7Ixi0FyFTk3jhH56dBaN65S+gtPztNGzEUmtk4M8IanhQSw8xCXr0x0MPDpDFDZs3aN5TtTPYmyk3psk7OrmofCQGG5cRcqEt9902qtxQDOHumfuCPMvU+oMjzLzBVEDnBbj+tY3y1jvgGbmEJguAgfB04tSeAt/2618ksnJJK+dbBkDLxjB4xrFr3uIFFadJQWUckl5vfh4MVXbsFA1hG49lqWDa7uSuPCnOhv8Yql376I4U4gfcF8LcgorkxS+64urv2nMUq6AkBEMQ8bdkI64oKLFfO7fGxh5iMNZuLoutDn2ll3nq4rPi4kOyAtfhW0UPyjvqNtXJ/h0Wik5Mi8z7BVxaURTDk81TP8y9+tzjySB/uGfHFAzjF8DUY1vqJCgn0GQ8ANtiiElX/+Wnc9HWi2bEEXItbm4yv97QrEPvJG9nPRBKWGiAQsIA5J+WryX5NrfEfRPk0QQwyl16lpHlw6l0UMuk7S21xjQgyWo0MywfzoBWW7+t4HH9sqavvP4dYAw81BxXqVHQhefUOS23en4bFUPWE98pAN6bul+kS767vDK34yTC3lA2a8wLrBEilmFhdB74fxbAl+db91PivhwF/CR4Igxr35uLdof7+jAYyACopQzmsbHpvAAwT2lapLix8H03nztAC3fBqFSPBVdIv12lsrrDw4dfhJEzq7AbL/Y7L/nIcBsQ/3UyVnZk4kZP1KzyPCBLLIQNpCVgOLJzQuyaQ6k2QCBy0eJ0ppUyfp54LjwVg0X7bwncYbAomG4ZcFwTQnC2AX3oYG5n6Bz4SLLjxrFsY+v/SVa+GqH8uePBh1TPkHVNmzjXXymEf5jROlnd+EjfQdRyitkjPrg2HiQxxDcVhCh5J2L5+6CY9eIaYgrbd8zJnzAD8KnowHwh2bi4JLgmt7ktJ1XGizox7cWf3/Dod56KAcaIrSVw9XzYybdJCf0YRA6yrwPWXbwnzc/4+UDkmegi+AoCEMoue+cC7vnYVdmlbq/YLE/DWJX383oz2Ryq8anFrZ8jYvdoh8WI+dIugYL2SwRjmBoSwn56XIaot/QpMo3pYJIa4o8aZIZrjvB7BXO5aCDeMuZdUMT6AXGAGF1AeAWxFd2XIo1coR+OplMNDuYia8YAtnSTJ9JwGYWi2dJz3xrxsTQpBONf3yn8LVf8eH+o5eXc7lzCtHlDB+YyI8V9PyMsUPOeyvpB3rr9fDfNy263Zx33zTi5jldgP2OetUqGfbwl+0+zNYnrg64bluyIN/Awt1doDCQkCKpKXxuPaem/SyCHrKjg'
EndIf
Local $Symbol[] = ["jsmn_parse", "jsmn_init", "json_string_decode", "json_string_encode"]
Local $CodeBase = _BinaryCall_Create($Code)
If @error Then Exit MsgBox(16, "Json", "Startup Failure!")
$SymbolList = _BinaryCall_SymbolList($CodeBase, $Symbol)
If @error Then Exit MsgBox(16, "Json", "Startup Failure!")
EndIf
If $ProcName Then Return DllStructGetData($SymbolList, $ProcName)
EndFunc
Func Json_StringEncode($String, $Option = 0)
Static $Json_StringEncode = __Jsmn_RuntimeLoader("json_string_encode")
Local $Length = StringLen($String) * 6 + 1
Local $Buffer = DllStructCreate("wchar[" & $Length & "]")
Local $Ret = DllCallAddress("int:cdecl", $Json_StringEncode, "wstr", $String, "ptr", DllStructGetPtr($Buffer), "uint", $Length, "int", $Option)
Return SetError($Ret[0], 0, DllStructGetData($Buffer, 1))
EndFunc
Func Json_StringDecode($String)
Static $Json_StringDecode = __Jsmn_RuntimeLoader("json_string_decode")
Local $Length = StringLen($String) + 1
Local $Buffer = DllStructCreate("wchar[" & $Length & "]")
Local $Ret = DllCallAddress("int:cdecl", $Json_StringDecode, "wstr", $String, "ptr", DllStructGetPtr($Buffer), "uint", $Length)
Return SetError($Ret[0], 0, DllStructGetData($Buffer, 1))
EndFunc
Func Json_Decode($Json, $InitTokenCount = 1000)
Static $Jsmn_Init = __Jsmn_RuntimeLoader("jsmn_init"), $Jsmn_Parse = __Jsmn_RuntimeLoader("jsmn_parse")
If $Json = "" Then $Json = '""'
Local $TokenList, $Ret
Local $Parser = DllStructCreate("uint pos;int toknext;int toksuper")
Do
DllCallAddress("none:cdecl", $Jsmn_Init, "ptr", DllStructGetPtr($Parser))
$TokenList = DllStructCreate("byte[" & ($InitTokenCount * 20) & "]")
$Ret = DllCallAddress("int:cdecl", $Jsmn_Parse, "ptr", DllStructGetPtr($Parser), "wstr", $Json, "ptr", DllStructGetPtr($TokenList), "uint", $InitTokenCount)
$InitTokenCount *= 2
Until $Ret[0] <> $JSMN_ERROR_NOMEM
Local $Next = 0
Return SetError($Ret[0], 0, _Json_Token($Json, DllStructGetPtr($TokenList), $Next))
EndFunc
Func _Json_Token(ByRef $Json, $Ptr, ByRef $Next)
If $Next = -1 Then Return Null
Local $Token = DllStructCreate("int;int;int;int", $Ptr + ($Next * 20))
Local $Type = DllStructGetData($Token, 1)
Local $Start = DllStructGetData($Token, 2)
Local $End = DllStructGetData($Token, 3)
Local $Size = DllStructGetData($Token, 4)
$Next += 1
If $Type = 0 And $Start = 0 And $End = 0 And $Size = 0 Then
$Next = -1
Return Null
EndIf
Switch $Type
Case 0
Local $Primitive = StringMid($Json, $Start + 1, $End - $Start)
Switch $Primitive
Case "true"
Return True
Case "false"
Return False
Case "null"
Return Null
Case Else
If StringRegExp($Primitive, "^[+\-0-9]") Then
Return Number($Primitive)
Else
Return Json_StringDecode($Primitive)
EndIf
EndSwitch
Case 1
Local $Object = Json_ObjCreate()
For $i = 0 To $Size - 1 Step 2
Local $Key = _Json_Token($Json, $Ptr, $Next)
Local $Value = _Json_Token($Json, $Ptr, $Next)
If Not IsString($Key) Then $Key = Json_Encode($Key)
If $Object.Exists($Key) Then $Object.Remove($Key)
$Object.Add($Key, $Value)
Next
Return $Object
Case 2
Local $Array[$Size]
For $i = 0 To $Size - 1
$Array[$i] = _Json_Token($Json, $Ptr, $Next)
Next
Return $Array
Case 3
Return Json_StringDecode(StringMid($Json, $Start + 1, $End - $Start))
EndSwitch
EndFunc
Func Json_IsObject(ByRef $Object)
Return (IsObj($Object) And ObjName($Object) = "Dictionary")
EndFunc
Func Json_IsNull(ByRef $Null)
Return IsKeyword($Null) Or (Not IsObj($Null) And VarGetType($Null) = "Object")
EndFunc
Func Json_Encode_Compact($Data, $Option = 0)
Local $Json = ""
Select
Case IsString($Data)
Return '"' & Json_StringEncode($Data, $Option) & '"'
Case IsNumber($Data)
Return $Data
Case IsArray($Data) And UBound($Data, 0) = 1
$Json = "["
For $i = 0 To UBound($Data) - 1
$Json &= Json_Encode_Compact($Data[$i], $Option) & ","
Next
If StringRight($Json, 1) = "," Then $Json = StringTrimRight($Json, 1)
Return $Json & "]"
Case Json_IsObject($Data)
$Json = "{"
Local $Keys = $Data.Keys()
For $i = 0 To UBound($Keys) - 1
$Json &= '"' & Json_StringEncode($Keys[$i], $Option) & '":' & Json_Encode_Compact($Data.Item($Keys[$i]), $Option) & ","
Next
If StringRight($Json, 1) = "," Then $Json = StringTrimRight($Json, 1)
Return $Json & "}"
Case IsBool($Data)
Return StringLower($Data)
Case IsPtr($Data)
Return Number($Data)
Case IsBinary($Data)
Return '"' & Json_StringEncode(BinaryToString($Data, 4), $Option) & '"'
Case Else
Return "null"
EndSelect
EndFunc
Func Json_Encode_Pretty($Data, $Option, $Indent, $ArraySep, $ObjectSep, $ColonSep, $ArrayCRLF = Default, $ObjectCRLF = Default, $NextIdent = "")
Local $ThisIdent = $NextIdent, $Json = "", $String = "", $Match = "", $Keys = ""
Local $Length = 0
Select
Case IsString($Data)
$String = Json_StringEncode($Data, $Option)
If BitAND($Option, $JSON_UNQUOTED_STRING) And Not BitAND($Option, $JSON_STRICT_PRINT) And Not StringRegExp($String, "[\s,:]") And Not StringRegExp($String, "^[+\-0-9]") Then
Return $String
Else
Return '"' & $String & '"'
EndIf
Case IsArray($Data) And UBound($Data, 0) = 1
If UBound($Data) = 0 Then Return "[]"
If IsKeyword($ArrayCRLF) Then
$ArrayCRLF = ""
$Match = StringRegExp($ArraySep, "[\r\n]+$", 3)
If IsArray($Match) Then $ArrayCRLF = $Match[0]
EndIf
If $ArrayCRLF Then $NextIdent &= $Indent
$Length = UBound($Data) - 1
For $i = 0 To $Length
If $ArrayCRLF Then $Json &= $NextIdent
$Json &= Json_Encode_Pretty($Data[$i], $Option, $Indent, $ArraySep, $ObjectSep, $ColonSep, $ArrayCRLF, $ObjectCRLF, $NextIdent)
If $i < $Length Then $Json &= $ArraySep
Next
If $ArrayCRLF Then Return "[" & $ArrayCRLF & $Json & $ArrayCRLF & $ThisIdent & "]"
Return "[" & $Json & "]"
Case Json_IsObject($Data)
If $Data.Count = 0 Then Return "{}"
If IsKeyword($ObjectCRLF) Then
$ObjectCRLF = ""
$Match = StringRegExp($ObjectSep, "[\r\n]+$", 3)
If IsArray($Match) Then $ObjectCRLF = $Match[0]
EndIf
If $ObjectCRLF Then $NextIdent &= $Indent
$Keys = $Data.Keys()
$Length = UBound($Keys) - 1
For $i = 0 To $Length
If $ObjectCRLF Then $Json &= $NextIdent
$Json &= Json_Encode_Pretty(String($Keys[$i]), $Option, $Indent, $ArraySep, $ObjectSep, $ColonSep) & $ColonSep  & Json_Encode_Pretty($Data.Item($Keys[$i]), $Option, $Indent, $ArraySep, $ObjectSep, $ColonSep, $ArrayCRLF, $ObjectCRLF, $NextIdent)
If $i < $Length Then $Json &= $ObjectSep
Next
If $ObjectCRLF Then Return "{" & $ObjectCRLF & $Json & $ObjectCRLF & $ThisIdent & "}"
Return "{" & $Json & "}"
Case Else
Return Json_Encode_Compact($Data, $Option)
EndSelect
EndFunc
Func Json_Encode($Data, $Option = 0, $Indent = Default, $ArraySep = Default, $ObjectSep = Default, $ColonSep = Default)
If BitAND($Option, $JSON_PRETTY_PRINT) Then
Local $Strict = BitAND($Option, $JSON_STRICT_PRINT)
If IsKeyword($Indent) Then
$Indent = @TAB
Else
$Indent = Json_StringDecode($Indent)
If StringRegExp($Indent, "[^\t ]") Then $Indent = @TAB
EndIf
If IsKeyword($ArraySep) Then
$ArraySep = "," & @CRLF
Else
$ArraySep = Json_StringDecode($ArraySep)
If $ArraySep = "" Or StringRegExp($ArraySep, "[^\s,]|,.*,") Or ($Strict And Not StringRegExp($ArraySep, ",")) Then $ArraySep = "," & @CRLF
EndIf
If IsKeyword($ObjectSep) Then
$ObjectSep = "," & @CRLF
Else
$ObjectSep = Json_StringDecode($ObjectSep)
If $ObjectSep = "" Or StringRegExp($ObjectSep, "[^\s,]|,.*,") Or ($Strict And Not StringRegExp($ObjectSep, ",")) Then $ObjectSep = "," & @CRLF
EndIf
If IsKeyword($ColonSep) Then
$ColonSep = ": "
Else
$ColonSep = Json_StringDecode($ColonSep)
If $ColonSep = "" Or StringRegExp($ColonSep, "[^\s,:]|[,:].*[,:]") Or ($Strict And (StringRegExp($ColonSep, ",") Or Not StringRegExp($ColonSep, ":"))) Then $ColonSep = ": "
EndIf
Return Json_Encode_Pretty($Data, $Option, $Indent, $ArraySep, $ObjectSep, $ColonSep)
ElseIf BitAND($Option, $JSON_UNQUOTED_STRING) Then
Return Json_Encode_Pretty($Data, $Option, "", ",", ",", ":")
Else
Return Json_Encode_Compact($Data, $Option)
EndIf
EndFunc
Func Json_ObjCreate()
Local $Object = ObjCreate('Scripting.Dictionary')
$Object.CompareMode = 0
Return $Object
EndFunc
Func Json_ObjPut(ByRef $Object, $Key, $Value)
$Key = String($Key)
If $Object.Exists($Key) Then $Object.Remove($Key)
$Object.Add($Key, $Value)
EndFunc
Func Json_ObjGet(ByRef $Object, $Key)
Local $DynObject = $Object
Local $Keys = StringSplit($Key, ".")
For $x = 1 To $Keys[0]
If $DynObject.Exists($Keys[$x]) Then
If $x = $Keys[0] Then
Return $DynObject.Item($Keys[$x])
Else
$DynObject = Json_ObjGet($DynObject, $Keys[$x])
EndIf
EndIf
Next
Return SetError(1, 0, '')
EndFunc
Func Json_ObjDelete(ByRef $Object, $Key)
$Key = String($Key)
If $Object.Exists($Key) Then $Object.Remove($Key)
EndFunc
Func Json_ObjExists(ByRef $Object, $Key)
Local $DynObject = $Object
Local $Keys = StringSplit($Key, ".")
For $x = 1 To $Keys[0]
If $DynObject.Exists($Keys[$x]) Then
If $x = $Keys[0] Then
Return True
Else
$DynObject = Json_ObjGet($DynObject, $Keys[$x])
EndIf
Else
Return False
EndIf
Next
Return False
EndFunc
Func Json_ObjGetCount(ByRef $Object)
Return $Object.Count
EndFunc
Func Json_ObjGetKeys(ByRef $Object)
Return $Object.Keys()
EndFunc
Func Json_ObjGetItems(ByRef $Object)
Return $Object.Items()
EndFunc
Func Json_ObjClear(ByRef $Object)
Return $Object.RemoveAll()
EndFunc
Func Json_Put(ByRef $Var, $Notation, $Data, $CheckExists = False)
Const $REGEX_DOT_WITH_STRING      = '^\.("[^"]+")',  $REGEX_DOT_WITH_LITERAL     = '^\.([^.[]+)',  $REGEX_BRACKET_WITH_STRING  = '^\[("[^"]+")]',  $REGEX_BRACKET_WITH_LITERAL = '^\[([^]]+)]'
Local $Ret = 0, $Item = "", $Error = 0
Local $Match = ""
Local $Regex = ""
Select
Case StringRegExp($Notation, $REGEX_DOT_WITH_STRING)
$Regex = $REGEX_DOT_WITH_STRING
Case StringRegExp($Notation, $REGEX_DOT_WITH_LITERAL)
$Regex = $REGEX_DOT_WITH_LITERAL
Case StringRegExp($Notation, $REGEX_BRACKET_WITH_STRING)
$Regex = $REGEX_BRACKET_WITH_STRING
Case StringRegExp($Notation, $REGEX_BRACKET_WITH_LITERAL)
$Regex = $REGEX_BRACKET_WITH_LITERAL
Case Else
Return SetError(2, 0, "")
EndSelect
$Match = StringRegExp($Notation, $Regex, 2)
If IsArray($Match) Then
Local $Index
If StringLeft($Match[0], 1) = "." Then
$Index = String(Json_Decode($Match[1]))
Else
$Index = Json_Decode($Match[1])
EndIf
$Notation = StringTrimLeft($Notation, StringLen($Match[0]))
If IsString($Index) Then
If $CheckExists And (Not Json_IsObject($Var) Or Not Json_ObjExists($Var, $Index)) Then
Return SetError(1, 0, False)
EndIf
If Not Json_IsObject($Var) Then $Var = Json_ObjCreate()
If $Notation Then
$Item = Json_ObjGet($Var, $Index)
$Ret = Json_Put($Item, $Notation, $Data, $CheckExists)
$Error = @error
If Not $Error Then Json_ObjPut($Var, $Index, $Item)
Return SetError($Error, 0, $Ret)
Else
Json_ObjPut($Var, $Index, $Data)
Return True
EndIf
ElseIf IsInt($Index) Then
If $Index < 0 Or ($CheckExists And (Not IsArray($Var) Or UBound($Var, 0) <> 1 Or $Index >= UBound($Var))) Then
Return SetError(1, 0, False)
EndIf
If Not IsArray($Var) Or UBound($Var, 0) <> 1 Then
Dim $Var[$Index + 1]
ElseIf $Index >= UBound($Var) Then
ReDim $Var[$Index + 1]
EndIf
If $Notation Then
$Ret = Json_Put($Var[$Index], $Notation, $Data, $CheckExists)
Return SetError(@error, 0, $Ret)
Else
$Var[$Index] = $Data
Return True
EndIf
EndIf
EndIf
Return SetError(2, 0, False)
EndFunc
Func Json_Get(ByRef $Var, $Notation)
Const $REGEX_DOT_WITH_STRING      = '^\.("[^"]+")',  $REGEX_DOT_WITH_LITERAL     = '^\.([^.[]+)',  $REGEX_BRACKET_WITH_STRING  = '^\[("[^"]+")]',  $REGEX_BRACKET_WITH_LITERAL = '^\[([^]]+)]'
Local $Regex = ""
Select
Case StringRegExp($Notation, $REGEX_DOT_WITH_STRING)
$Regex = $REGEX_DOT_WITH_STRING
Case StringRegExp($Notation, $REGEX_DOT_WITH_LITERAL)
$Regex = $REGEX_DOT_WITH_LITERAL
Case StringRegExp($Notation, $REGEX_BRACKET_WITH_STRING)
$Regex = $REGEX_BRACKET_WITH_STRING
Case StringRegExp($Notation, $REGEX_BRACKET_WITH_LITERAL)
$Regex = $REGEX_BRACKET_WITH_LITERAL
Case Else
Return SetError(2, 0, "")
EndSelect
Local $Match = StringRegExp($Notation, $Regex, 2)
If IsArray($Match) Then
Local $Index
If StringLeft($Match[0], 1) = "." Then
$Index = String(Json_Decode($Match[1]))
Else
$Index = Json_Decode($Match[1])
EndIf
$Notation = StringTrimLeft($Notation, StringLen($Match[0]))
Local $Item
If IsString($Index) And Json_IsObject($Var) And Json_ObjExists($Var, $Index) Then
$Item = Json_ObjGet($Var, $Index)
ElseIf IsInt($Index) And IsArray($Var) And UBound($Var, 0) = 1 And $Index >= 0 And $Index < UBound($Var) Then
$Item = $Var[$Index]
Else
Return SetError(1, 0, "")
EndIf
If Not $Notation Then Return $Item
Local $Ret = Json_Get($Item, $Notation)
Return SetError(@error, 0, $Ret)
EndIf
EndFunc
Func Json_Dump($Json, $InitTokenCount = 1000)
Static $Jsmn_Init = __Jsmn_RuntimeLoader("jsmn_init"), $Jsmn_Parse = __Jsmn_RuntimeLoader("jsmn_parse")
If $Json = "" Then $Json = '""'
Local $TokenList, $Ret
$Total_JSON_DUMP_Output = ""
Local $Parser = DllStructCreate("uint pos;int toknext;int toksuper")
Do
DllCallAddress("none:cdecl", $Jsmn_Init, "ptr", DllStructGetPtr($Parser))
$TokenList = DllStructCreate("byte[" & ($InitTokenCount * 20) & "]")
$Ret = DllCallAddress("int:cdecl", $Jsmn_Parse, "ptr", DllStructGetPtr($Parser), "wstr", $Json, "ptr", DllStructGetPtr($TokenList), "uint", $InitTokenCount)
$InitTokenCount *= 2
Until $Ret[0] <> $JSMN_ERROR_NOMEM
Local $Next = 0
_Json_TokenDump($Json, DllStructGetPtr($TokenList), $Next)
EndFunc
Func _Json_TokenDump(ByRef $Json, $Ptr, ByRef $Next, $ObjPath = "")
If $Next = -1 Then Return Null
Local $Token = DllStructCreate("int;int;int;int", $Ptr + ($Next * 20))
Local $Type = DllStructGetData($Token, 1)
Local $Start = DllStructGetData($Token, 2)
Local $End = DllStructGetData($Token, 3)
Local $Size = DllStructGetData($Token, 4)
Local $Value
$Next += 1
If $Type = 0 And $Start = 0 And $End = 0 And $Size = 0 Then
$Next = -1
Return Null
EndIf
Switch $Type
Case 0
Local $Primitive = StringMid($Json, $Start + 1, $End - $Start)
Switch $Primitive
Case "true"
Return "True"
Case "false"
Return "False"
Case "null"
Return "Null"
Case Else
If StringRegExp($Primitive, "^[+\-0-9]") Then
Return Number($Primitive)
Else
Return Json_StringDecode($Primitive)
EndIf
EndSwitch
Case 1
For $i = 0 To $Size - 1 Step 2
Local $Key = _Json_TokenDump($Json, $Ptr, $Next)
Local $cObjPath = $ObjPath & "." & $Key
$Value = _Json_TokenDump($Json, $Ptr, $Next, $ObjPath & "." & $Key)
If Not (IsBool($Value) And $Value = False) Then
If Not IsString($Key) Then
$Key = Json_Encode($Key)
EndIf
ConsoleWrite("+-> " & $cObjPath & '  =' & $Value & @CRLF)
$Total_JSON_DUMP_Output &= "+-> " & $cObjPath & '  =' & $Value & @CRLF
EndIf
Next
Return False
Case 2
Local $sObjPath = $ObjPath
For $i = 0 To $Size - 1
$sObjPath = $ObjPath & "[" & $i & "]"
$Value = _Json_TokenDump($Json, $Ptr, $Next, $sObjPath)
If Not (IsBool($Value) And $Value = False) Then
ConsoleWrite("+=> " & $sObjPath & "=>" & $Value & @CRLF)
$Total_JSON_DUMP_Output &= "+=> " & $sObjPath & "=>" & $Value & @CRLF
EndIf
Next
$ObjPath = $sObjPath
Return False
Case 3
Local $LastKey = Json_StringDecode(StringMid($Json, $Start + 1, $End - $Start))
Return $LastKey
EndSwitch
EndFunc
Global Const $SIF_POS = 0x04
Global Const $SIF_PAGE = 0x02
Global Const $SIF_RANGE = 0x01
Global Const $SIF_TRACKPOS = 0x10
Global Const $SIF_ALL = BitOR($SIF_RANGE, $SIF_PAGE, $SIF_POS, $SIF_TRACKPOS)
Global Const $SB_HORZ = 0
Global Const $SB_VERT = 1
Global Const $SB_CTL = 2
Global Const $SB_BOTH = 3
Global Const $SB_LINELEFT = 0
Global Const $SB_LINERIGHT = 1
Global Const $SB_PAGELEFT = 2
Global Const $SB_PAGERIGHT = 3
Global Const $SB_THUMBPOSITION = 0x4
Global Const $SB_THUMBTRACK = 0x5
Global Const $SB_LINEDOWN = 1
Global Const $SB_LINEUP = 0
Global Const $SB_PAGEDOWN = 3
Global Const $SB_PAGEUP = 2
Global Const $SB_SCROLLCARET = 4
Global Const $SB_TOP = 6
Global Const $SB_BOTTOM = 7
Global Const $ESB_DISABLE_BOTH = 0x3
Global Const $ESB_DISABLE_DOWN = 0x2
Global Const $ESB_DISABLE_LEFT = 0x1
Global Const $ESB_DISABLE_LTUP = $ESB_DISABLE_LEFT
Global Const $ESB_DISABLE_RIGHT = 0x2
Global Const $ESB_DISABLE_RTDN = $ESB_DISABLE_RIGHT
Global Const $ESB_DISABLE_UP = 0x1
Global Const $ESB_ENABLE_BOTH = 0x0
Global Const $OBJID_HSCROLL = 0xFFFFFFFA
Global Const $OBJID_VSCROLL = 0xFFFFFFFB
Global Const $OBJID_CLIENT = 0xFFFFFFFC
Global $__g_aSB_WindowInfo[1][8]
Func _GUIScrollBars_EnableScrollBar($hWnd, $iSBflags = $SB_BOTH, $iArrows = $ESB_ENABLE_BOTH)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, False)
Local $aCall = DllCall("user32.dll", "bool", "EnableScrollBar", "hwnd", $hWnd, "uint", $iSBflags, "uint", $iArrows)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUIScrollBars_GetScrollBarInfoEx($hWnd, $iObject)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, 0)
Local $tSCROLLBARINFO = DllStructCreate($tagSCROLLBARINFO)
DllStructSetData($tSCROLLBARINFO, "cbSize", DllStructGetSize($tSCROLLBARINFO))
Local $aCall = DllCall("user32.dll", "bool", "GetScrollBarInfo", "hwnd", $hWnd, "long", $iObject, "struct*", $tSCROLLBARINFO)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aCall[0], $tSCROLLBARINFO)
EndFunc
Func _GUIScrollBars_GetScrollBarRect($hWnd, $iObject)
Local $aRect[4]
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, 0)
Local $tSCROLLBARINFO = _GUIScrollBars_GetScrollBarInfoEx($hWnd, $iObject)
If @error Then Return SetError(@error, @extended, 0)
$aRect[0] = DllStructGetData($tSCROLLBARINFO, "Left")
$aRect[1] = DllStructGetData($tSCROLLBARINFO, "Top")
$aRect[2] = DllStructGetData($tSCROLLBARINFO, "Right")
$aRect[3] = DllStructGetData($tSCROLLBARINFO, "Bottom")
Return $aRect
EndFunc
Func _GUIScrollBars_GetScrollBarRGState($hWnd, $iObject)
Local $aRGState[6]
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, 0)
Local $tSCROLLBARINFO = _GUIScrollBars_GetScrollBarInfoEx($hWnd, $iObject)
If @error Then Return SetError(@error, @extended, 0)
For $x = 0 To 5
$aRGState[$x] = DllStructGetData($tSCROLLBARINFO, "rgstate", $x + 1)
Next
Return $aRGState
EndFunc
Func _GUIScrollBars_GetScrollBarXYLineButton($hWnd, $iObject)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLBARINFO = _GUIScrollBars_GetScrollBarInfoEx($hWnd, $iObject)
If @error Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSCROLLBARINFO, "dxyLineButton")
EndFunc
Func _GUIScrollBars_GetScrollBarXYThumbTop($hWnd, $iObject)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLBARINFO = _GUIScrollBars_GetScrollBarInfoEx($hWnd, $iObject)
If @error Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSCROLLBARINFO, "xyThumbTop")
EndFunc
Func _GUIScrollBars_GetScrollBarXYThumbBottom($hWnd, $iObject)
If Not IsHWnd($hWnd) Then Return SetError(-1, -1, -1)
Local $tSCROLLBARINFO = _GUIScrollBars_GetScrollBarInfoEx($hWnd, $iObject)
If @error Then Return SetError(-1, -1, -1)
Return DllStructGetData($tSCROLLBARINFO, "xyThumbBottom")
EndFunc
Func _GUIScrollBars_GetScrollInfo($hWnd, $iBar, ByRef $tSCROLLINFO)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, False)
Local $aCall = DllCall("user32.dll", "bool", "GetScrollInfo", "hwnd", $hWnd, "int", $iBar, "struct*", $tSCROLLINFO)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUIScrollBars_GetScrollInfoEx($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, 0)
Local $tSCROLLINFO = DllStructCreate($tagSCROLLINFO)
DllStructSetData($tSCROLLINFO, "cbSize", DllStructGetSize($tSCROLLINFO))
DllStructSetData($tSCROLLINFO, "fMask", $SIF_ALL)
If Not _GUIScrollBars_GetScrollInfo($hWnd, $iBar, $tSCROLLINFO) Then Return SetError(@error, @extended, 0)
Return $tSCROLLINFO
EndFunc
Func _GUIScrollBars_GetScrollInfoPage($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $iBar)
If @error Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSCROLLINFO, "nPage")
EndFunc
Func _GUIScrollBars_GetScrollInfoPos($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $iBar)
If @error Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSCROLLINFO, "nPos")
EndFunc
Func _GUIScrollBars_GetScrollInfoMin($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $iBar)
If @error Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSCROLLINFO, "nMin")
EndFunc
Func _GUIScrollBars_GetScrollInfoMax($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $iBar)
If @error Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSCROLLINFO, "nMax")
EndFunc
Func _GUIScrollBars_GetScrollInfoTrackPos($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $iBar)
If @error Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSCROLLINFO, "nTrackPos")
EndFunc
Func _GUIScrollBars_GetScrollPos($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $aCall = DllCall("user32.dll", "int", "GetScrollPos", "hwnd", $hWnd, "int", $iBar)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _GUIScrollBars_GetScrollRange($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $aCall = DllCall("user32.dll", "bool", "GetScrollRange", "hwnd", $hWnd, "int", $iBar, "int*", 0, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
Local $aMin_Max[2]
$aMin_Max[0] = $aCall[3]
$aMin_Max[1] = $aCall[4]
Return SetExtended($aCall[0], $aMin_Max)
EndFunc
Func _GUIScrollBars_Init($hWnd, $iMaxH = -1, $iMaxV = -1)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, 0)
If $__g_aSB_WindowInfo[0][0] <> 0 Then ReDim $__g_aSB_WindowInfo[UBound($__g_aSB_WindowInfo) + 1][8]
Local $tSCROLLINFO = DllStructCreate($tagSCROLLINFO)
Local $tRECT = DllStructCreate($tagRECT)
Local $iIndex = UBound($__g_aSB_WindowInfo) - 1
Local $iError, $iExtended
$__g_aSB_WindowInfo[$iIndex][0] = $hWnd
$__g_aSB_WindowInfo[$iIndex][1] = $iMaxH
$__g_aSB_WindowInfo[$iIndex][6] = $iMaxH
$__g_aSB_WindowInfo[$iIndex][7] = $iMaxV
If $iMaxV = -1 Then $__g_aSB_WindowInfo[$iIndex][7] = 27
Local $hDC = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended)
$hDC = $hDC[0]
Local $tTEXTMETRIC = DllStructCreate($tagTEXTMETRIC)
DllStructSetData($tSCROLLINFO, "cbSize", DllStructGetSize($tSCROLLINFO))
DllCall("gdi32.dll", "bool", "GetTextMetricsW", "handle", $hDC, "struct*", $tTEXTMETRIC)
If @error Then
$iError = @error
$iExtended = @extended
EndIf
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If $iError Then Return SetError($iError, $iExtended)
Local $iUpperX, $iXAmount = DllStructGetData($tTEXTMETRIC, "tmAveCharWidth")
If BitAND(DllStructGetData($tTEXTMETRIC, "tmPitchAndFamily"), 1) Then
$iUpperX = 3 * $iXAmount / 2
Else
$iUpperX = 2 * $iXAmount / 2
EndIf
Local $iYAmount = DllStructGetData($tTEXTMETRIC, "tmHeight") + DllStructGetData($tTEXTMETRIC, "tmExternalLeading")
If $iMaxH = -1 Then $__g_aSB_WindowInfo[$iIndex][1] = 48 * $iXAmount + 12 * $iUpperX
$__g_aSB_WindowInfo[$iIndex][2] = $iXAmount
$__g_aSB_WindowInfo[$iIndex][3] = $iYAmount
_GUIScrollBars_ShowScrollBar($hWnd, $SB_HORZ, False)
_GUIScrollBars_ShowScrollBar($hWnd, $SB_VERT, False)
_GUIScrollBars_ShowScrollBar($hWnd, $SB_HORZ)
_GUIScrollBars_ShowScrollBar($hWnd, $SB_VERT)
DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hWnd, "struct*", $tRECT)
If @error Then Return SetError(@error, @extended)
Local $iClientX = DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
Local $iClientY = DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top")
$__g_aSB_WindowInfo[$iIndex][4] = $iClientX
$__g_aSB_WindowInfo[$iIndex][5] = $iClientY
$tSCROLLINFO = DllStructCreate($tagSCROLLINFO)
DllStructSetData($tSCROLLINFO, "fMask", BitOR($SIF_RANGE, $SIF_PAGE))
DllStructSetData($tSCROLLINFO, "nMin", 0)
DllStructSetData($tSCROLLINFO, "nMax", $__g_aSB_WindowInfo[$iIndex][7])
DllStructSetData($tSCROLLINFO, "nPage", $iClientY / $iYAmount)
_GUIScrollBars_SetScrollInfo($hWnd, $SB_VERT, $tSCROLLINFO)
DllStructSetData($tSCROLLINFO, "fMask", BitOR($SIF_RANGE, $SIF_PAGE))
DllStructSetData($tSCROLLINFO, "nMin", 0)
DllStructSetData($tSCROLLINFO, "nMax", 2 + $__g_aSB_WindowInfo[$iIndex][1] / $iXAmount)
DllStructSetData($tSCROLLINFO, "nPage", $iClientX / $iXAmount)
_GUIScrollBars_SetScrollInfo($hWnd, $SB_HORZ, $tSCROLLINFO)
EndFunc
Func _GUIScrollBars_ScrollWindow($hWnd, $iXAmount, $iYAmount)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, False)
Local $aCall = DllCall("user32.dll", "bool", "ScrollWindow", "hwnd", $hWnd, "int", $iXAmount, "int", $iYAmount, "ptr", 0, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUIScrollBars_SetScrollInfo($hWnd, $iBar, $tSCROLLINFO, $bRedraw = True)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
DllStructSetData($tSCROLLINFO, "cbSize", DllStructGetSize($tSCROLLINFO))
Local $aCall = DllCall("user32.dll", "int", "SetScrollInfo", "hwnd", $hWnd, "int", $iBar, "struct*", $tSCROLLINFO, "bool", $bRedraw)
If @error Then Return SetError(@error, @extended, -1)
Return $aCall[0]
EndFunc
Func _GUIScrollBars_SetScrollInfoMin($hWnd, $iBar, $iMin)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, False)
Local $aRange = _GUIScrollBars_GetScrollRange($hWnd, $iBar)
_GUIScrollBars_SetScrollRange($hWnd, $iBar, $iMin, $aRange[1])
Local $aRange_check = _GUIScrollBars_GetScrollRange($hWnd, $iBar)
If $aRange[1] <> $aRange_check[1] Or $iMin <> $aRange_check[0] Then
_GUIScrollBars_SetScrollRange($hWnd, $iBar, $aRange[0], $aRange[1])
Return False
EndIf
Return True
EndFunc
Func _GUIScrollBars_SetScrollInfoMax($hWnd, $iBar, $iMax)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, False)
Local $aRange = _GUIScrollBars_GetScrollRange($hWnd, $iBar)
_GUIScrollBars_SetScrollRange($hWnd, $iBar, $aRange[0], $iMax)
Local $aRange_check = _GUIScrollBars_GetScrollRange($hWnd, $iBar)
If $aRange[0] <> $aRange_check[0] Or $iMax <> $aRange_check[1] Then
_GUIScrollBars_SetScrollRange($hWnd, $iBar, $aRange[0], $aRange[1])
Return False
EndIf
Return True
EndFunc
Func _GUIScrollBars_SetScrollInfoPage($hWnd, $iBar, $iPage)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLINFO = DllStructCreate($tagSCROLLINFO)
DllStructSetData($tSCROLLINFO, "fMask", $SIF_PAGE)
DllStructSetData($tSCROLLINFO, "nPage", $iPage)
Return _GUIScrollBars_SetScrollInfo($hWnd, $iBar, $tSCROLLINFO)
EndFunc
Func _GUIScrollBars_SetScrollInfoPos($hWnd, $iBar, $iPos)
Local $iIndex = -1, $iYAmount, $iXAmount
For $x = 0 To UBound($__g_aSB_WindowInfo) - 1
If $__g_aSB_WindowInfo[$x][0] = $hWnd Then
$iIndex = $x
$iXAmount = $__g_aSB_WindowInfo[$iIndex][2]
$iYAmount = $__g_aSB_WindowInfo[$iIndex][3]
ExitLoop
EndIf
Next
If $iIndex = -1 Then Return 0
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $iBar)
Local $iPosXY = DllStructGetData($tSCROLLINFO, "nPos")
DllStructSetData($tSCROLLINFO, "fMask", $SIF_POS)
DllStructSetData($tSCROLLINFO, "nPos", $iPos)
_GUIScrollBars_SetScrollInfo($hWnd, $iBar, $tSCROLLINFO)
_GUIScrollBars_GetScrollInfo($hWnd, $iBar, $tSCROLLINFO)
$iPos = DllStructGetData($tSCROLLINFO, "nPos")
If $iBar = $SB_HORZ Then
If ($iPos <> $iPosXY) Then _GUIScrollBars_ScrollWindow($hWnd, $iXAmount * ($iPosXY - $iPos), 0)
Else
If ($iPos <> $iPosXY) Then _GUIScrollBars_ScrollWindow($hWnd, 0, $iYAmount * ($iPosXY - $iPos))
EndIf
EndFunc
Func _GUIScrollBars_SetScrollRange($hWnd, $iBar, $iMinPos, $iMaxPos)
Local $aCall = DllCall("user32.dll", "bool", "SetScrollRange", "hwnd", $hWnd, "int", $iBar, "int", $iMinPos, "int", $iMaxPos, "bool", True)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _GUIScrollBars_ShowScrollBar($hWnd, $iBar, $bShow = True)
Local $aCall = DllCall("user32.dll", "bool", "ShowScrollBar", "hwnd", $hWnd, "int", $iBar, "bool", $bShow)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Global $__g_aSB_WindowInfo[1][10] = [[0, 0, 0, 0, -1]]
$__g_aSB_WindowInfo[0][5] = _WinAPI_GetSystemMetrics(2)
$__g_aSB_WindowInfo[0][6] = _WinAPI_GetSystemMetrics(3)
Global $__g_aSB_WindowInfoEx[1][11]
Func _GUIScrollbars_Generate($hWnd, $iH_Scroll = 0, $iV_Scroll = 0, $iH_Tight = 0, $iV_Tight = 0, $fBefore = False, $iRepeat = 0, $bRegisterMsg = True)
Local $iIndex
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
For $iIndex = 1 To $__g_aSB_WindowInfo[0][0]
If $hWnd = $__g_aSB_WindowInfo[$iIndex][0] Then
ExitLoop
EndIf
Next
If $iIndex > $__g_aSB_WindowInfo[0][0] Then
$__g_aSB_WindowInfo[0][0] += 1
ReDim $__g_aSB_WindowInfo[$iIndex + 1][UBound($__g_aSB_WindowInfo, 2)]
ReDim $__g_aSB_WindowInfoEx[$iIndex + 1][UBound($__g_aSB_WindowInfoEx, 2)]
EndIf
If $iH_Scroll = 0 And $iV_Scroll = 0 Then Return SetError(2, 0, 0)
If $iH_Tight <> 0 Then $iH_Tight = 1
If $iV_Tight <> 0 Then $iV_Tight = 1
If Not IsInt($iRepeat) Then $iRepeat = 0
Local $tTEXTMETRIC = DllStructCreate($tagTEXTMETRIC)
Local $tSCROLLINFO = DllStructCreate($tagSCROLLINFO)
DllStructSetData($tSCROLLINFO, "cbSize", DllStructGetSize($tSCROLLINFO))
Local $iError, $iExtended
$__g_aSB_WindowInfo[$iIndex][0] = $hWnd
Local $aVis[2] = [(($iH_Scroll = 0) ? (False) : (True)), (($iV_Scroll = 0) ? (False) : (True))]
$__g_aSB_WindowInfo[$iIndex][1] = $aVis
Local $hDC = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If Not @error Then
$hDC = $hDC[0]
DllCall("gdi32.dll", "bool", "GetTextMetricsW", "handle", $hDC, "ptr", DllStructGetPtr($tTEXTMETRIC))
If @error Then
$iError = @error
$iExtended = @extended
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
Return SetError($iError, $iExtended, -2)
EndIf
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
Else
Return SetError(@error, @extended, -1)
EndIf
$__g_aSB_WindowInfo[$iIndex][2] = DllStructGetData($tTEXTMETRIC, "tmAveCharWidth")
$__g_aSB_WindowInfo[$iIndex][3] = DllStructGetData($tTEXTMETRIC, "tmHeight") + DllStructGetData($tTEXTMETRIC, "tmExternalLeading")
Local $aClientSize = WinGetClientSize($hWnd)
Local $iX_Client_Full = $aClientSize[0]
Local $iY_Client_Full = $aClientSize[1]
$__g_aSB_WindowInfo[$iIndex][4] = $iX_Client_Full
$__g_aSB_WindowInfo[$iIndex][5] = $iY_Client_Full
If $iX_Client_Full > $iH_Scroll Then $iH_Scroll = 0
If $iY_Client_Full > $iV_Scroll Then $iV_Scroll = 0
_GUIScrollBars_ShowScrollBar($hWnd, $SB_BOTH, False)
If $iH_Scroll Then
_GUIScrollBars_ShowScrollBar($hWnd, $SB_HORZ)
If $bRegisterMsg Then
GUIRegisterMsg($WM_HSCROLL, "__Scrollbars_WM_HSCROLL")
GUIRegisterMsg($WM_MOUSEHWHEEL, '__Scrollbars_WM_MOUSEHWHEEL')
EndIf
EndIf
If $iV_Scroll Then
_GUIScrollBars_ShowScrollBar($hWnd, $SB_VERT)
If $bRegisterMsg Then
GUIRegisterMsg($WM_VSCROLL, "__Scrollbars_WM_VSCROLL")
GUIRegisterMsg($WM_MOUSEWHEEL, "__Scrollbars_WM_MOUSEWHEEL")
EndIf
EndIf
If $iRepeat And $bRegisterMsg Then
GUIRegisterMsg($WM_KEYUP, "__Scrollbars_WM_KEYUP")
EndIf
If $bRegisterMsg Then
GUIRegisterMsg($WM_SIZE, "__Scrollbars_WM_SIZE")
EndIf
$aClientSize = WinGetClientSize($hWnd)
Local $iX_Client_Bar = $aClientSize[0]
Local $iY_Client_Bar = $aClientSize[1]
Local $iH_FullPage
If $iH_Scroll Then
If $fBefore Then
$__g_aSB_WindowInfo[$iIndex][4] = $iX_Client_Bar
$iH_FullPage = Floor($__g_aSB_WindowInfo[$iIndex][4] / $__g_aSB_WindowInfo[$iIndex][2])
$__g_aSB_WindowInfo[$iIndex][6] = Floor($iH_Scroll / $__g_aSB_WindowInfo[$iIndex][2]) - $iH_Tight
Else
If $iV_Scroll Then $__g_aSB_WindowInfo[$iIndex][4] = $iX_Client_Bar
$iH_FullPage = Floor($__g_aSB_WindowInfo[$iIndex][4] / $__g_aSB_WindowInfo[$iIndex][2])
$__g_aSB_WindowInfo[$iIndex][6] = Floor($iH_Scroll / $__g_aSB_WindowInfo[$iIndex][2] * $__g_aSB_WindowInfo[$iIndex][4] / $iX_Client_Full) - $iH_Tight
EndIf
Else
$__g_aSB_WindowInfo[$iIndex][6] = 0
EndIf
Local $iV_FullPage
If $iV_Scroll Then
If $fBefore Then
$__g_aSB_WindowInfo[$iIndex][5] = $iY_Client_Bar
$iV_FullPage = Floor($__g_aSB_WindowInfo[$iIndex][5] / $__g_aSB_WindowInfo[$iIndex][3])
$__g_aSB_WindowInfo[$iIndex][7] = Floor($iV_Scroll / $__g_aSB_WindowInfo[$iIndex][3]) - $iV_Tight
Else
If $iH_Scroll Then $__g_aSB_WindowInfo[$iIndex][5] = $iY_Client_Bar
$iV_FullPage = Floor($__g_aSB_WindowInfo[$iIndex][5] / $__g_aSB_WindowInfo[$iIndex][3])
$__g_aSB_WindowInfo[$iIndex][7] = Floor($iV_Scroll / $__g_aSB_WindowInfo[$iIndex][3] * $__g_aSB_WindowInfo[$iIndex][5] / $iY_Client_Full) - $iV_Tight
EndIf
Else
$__g_aSB_WindowInfo[$iIndex][7] = 0
EndIf
Local $aRet[4]
If $iV_Scroll Then
$aRet[0] = $iX_Client_Bar
Else
$aRet[0] = $iX_Client_Full
EndIf
If $iH_Scroll Then
$aRet[1] = $iY_Client_Bar
Else
$aRet[1] = $iY_Client_Full
EndIf
$aRet[2] = $iX_Client_Bar / $iX_Client_Full
$aRet[3] = $iY_Client_Bar / $iY_Client_Full
$__g_aSB_WindowInfoEx[$iIndex][0] = $iH_Scroll
$__g_aSB_WindowInfoEx[$iIndex][1] = $iV_Scroll
$__g_aSB_WindowInfoEx[$iIndex][2] = $aRet[2]
$__g_aSB_WindowInfoEx[$iIndex][3] = $aRet[3]
$__g_aSB_WindowInfoEx[$iIndex][4] = $fBefore
$__g_aSB_WindowInfoEx[$iIndex][5] = $iRepeat
$__g_aSB_WindowInfoEx[$iIndex][6] = (($iRepeat) ? ($iRepeat) : (7))
Local $fSuccess = True
If _GUIScrollBars_ShowScrollBar($hWnd, $SB_BOTH, False) = False Then $fSuccess = False
If $iH_Scroll Then
If _GUIScrollBars_SetScrollInfoMax($hWnd, $SB_HORZ, $__g_aSB_WindowInfo[$iIndex][6]) = False Then $fSuccess = False
_GUIScrollBars_SetScrollInfoPage($hWnd, $SB_HORZ, $iH_FullPage)
If @error Then $fSuccess = False
If _GUIScrollBars_ShowScrollBar($hWnd, $SB_HORZ, True) = False Then $fSuccess = False
Else
If _GUIScrollBars_ShowScrollBar($hWnd, $SB_HORZ, False) = False Then $fSuccess = False
EndIf
If $iV_Scroll Then
If _GUIScrollBars_SetScrollInfoMax($hWnd, $SB_VERT, $__g_aSB_WindowInfo[$iIndex][7]) = False Then $fSuccess = False
_GUIScrollBars_SetScrollInfoPage($hWnd, $SB_VERT, $iV_FullPage)
If @error Then $fSuccess = False
If _GUIScrollBars_ShowScrollBar($hWnd, $SB_VERT, True) = False Then $fSuccess = False
Else
If _GUIScrollBars_ShowScrollBar($hWnd, $SB_VERT, False) = False Then $fSuccess = False
EndIf
If $fSuccess Then Return $aRet
Return SetError(3, 0, 0)
EndFunc
Func _GUIScrollbars_ReSizer($hWnd, $iH_Max, $iV_Max, $bFullClient = False, $bRegisterMsg = True)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
For $iIndex = 1 To $__g_aSB_WindowInfo[0][0]
If $hWnd = $__g_aSB_WindowInfo[$iIndex][0] Then
ExitLoop
EndIf
Next
If $iIndex > $__g_aSB_WindowInfo[0][0] Then Return SetError(2, 0, 0)
If Not BitAND(_WinAPI_GetWindowLong($hWnd, $GWL_STYLE), 0x00040000) Then Return SetError(3, 0, 0)
$__g_aSB_WindowInfoEx[$iIndex][7] = $iH_Max
$__g_aSB_WindowInfoEx[$iIndex][8] = $iV_Max
Local $aPos = WinGetPos($hWnd)
_GUIScrollBars_ShowScrollBar($hWnd, $SB_BOTH, False)
Local $aClientSize = WinGetClientSize($hWnd)
Local $aMaxSize[2] = [$aPos[2] + $__g_aSB_WindowInfoEx[$iIndex][7] - $aClientSize[0], $aPos[3] + $__g_aSB_WindowInfoEx[$iIndex][8] - $aClientSize[1]]
WinMove($hWnd, "", Default, Default, $aMaxSize[0], $aMaxSize[1])
If Not $bFullClient Then
$__g_aSB_WindowInfo[0][1] = 0
$__g_aSB_WindowInfo[0][2] = 0
WinMove($hWnd, "", Default, Default, $aPos[2], $aPos[3])
$__g_aSB_WindowInfo[0][3] = $hWnd
$__g_aSB_WindowInfo[0][4] = $iIndex
__Scrollbars_WM_EXITSIZEMOVE($hWnd, 0, 0, 0)
EndIf
If $bRegisterMsg Then
GUIRegisterMsg($WM_EXITSIZEMOVE, "__Scrollbars_WM_EXITSIZEMOVE")
GUIRegisterMsg($WM_ENTERSIZEMOVE, "__Scrollbars_WM_ENTERSIZEMOVE")
EndIf
Return $aMaxSize
EndFunc
Func _GUIScrollbars_Locate_Ctrl($hWnd, $iX, $iY)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
Local $iIndex = -1
For $i = 0 To UBound($__g_aSB_WindowInfo) - 1
If $hWnd = $__g_aSB_WindowInfo[$i][0] Then $iIndex = $i
Next
If $iIndex = -1 Then Return SetError(3, 0, 0)
If $iX < 0 Or $iY < 0 Then Return SetError(2, 0, 0)
If $__g_aSB_WindowInfoEx[$iIndex][0] > 0 And $iX > $__g_aSB_WindowInfoEx[$iIndex][0] Then Return SetError(2, 0, 0)
If $__g_aSB_WindowInfoEx[$iIndex][1] > 0 And $iY > $__g_aSB_WindowInfoEx[$iIndex][1] Then Return SetError(2, 0, 0)
If Not $__g_aSB_WindowInfoEx[$iIndex][4] Then
$iX *= $__g_aSB_WindowInfoEx[$iIndex][2]
$iY *= $__g_aSB_WindowInfoEx[$iIndex][3]
EndIf
$iX -= _GUIScrollBars_GetScrollInfoPos($hWnd, $SB_HORZ) * $__g_aSB_WindowInfo[$iIndex][2]
$iY -= _GUIScrollBars_GetScrollInfoPos($hWnd, $SB_VERT) * $__g_aSB_WindowInfo[$iIndex][3]
Local $aRet[2] = [$iX, $iY]
Return $aRet
EndFunc
Func _GUIScrollbars_Scroll_Page($hWnd, $iH_Scroll_Pos = 0, $iV_Scroll_Pos = 0)
Local $iPos
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not (IsInt($iH_Scroll_Pos) And IsInt($iV_Scroll_Pos)) Then Return SetError(3, 0, 0)
Local $iIndex = -1
For $i = 0 To UBound($__g_aSB_WindowInfo) - 1
If $hWnd = $__g_aSB_WindowInfo[$i][0] Then $iIndex = $i
Next
If $iIndex = -1 Then Return SetError(2, 0, 0)
Local $iH_Page = Floor($__g_aSB_WindowInfo[$iIndex][4] / $__g_aSB_WindowInfo[$iIndex][2])
Local $iV_Page = Floor($__g_aSB_WindowInfo[$iIndex][5] / $__g_aSB_WindowInfo[$iIndex][3])
If $iH_Scroll_Pos > 0 Then
$iPos = ($iH_Scroll_Pos - 1) * $iH_Page
If $iPos > $__g_aSB_WindowInfo[$iIndex][6] Then $iPos = $__g_aSB_WindowInfo[$iIndex][6]
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_HORZ, $iPos)
EndIf
If $iV_Scroll_Pos > 0 Then
$iPos = ($iV_Scroll_Pos - 1) * $iV_Page
If $iPos > $__g_aSB_WindowInfo[$iIndex][7] Then $iPos = $__g_aSB_WindowInfo[$iIndex][7]
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_VERT, $iPos)
EndIf
EndFunc
Func _GUIScrollbars_EventMonitor()
If $__g_aSB_WindowInfo[0][7] <> 0 Then
Local $hWnd = $__g_aSB_WindowInfo[0][7]
Local $iIndex = -1
For $i = 0 To UBound($__g_aSB_WindowInfo) - 1
If $hWnd = $__g_aSB_WindowInfo[$i][0] Then $iIndex = $i
Next
If $iIndex = -1 Then Return SetError(1, 0, 0)
Local $aVis = $__g_aSB_WindowInfo[$iIndex][1]
If $aVis[0] = False Then
_GUIScrollBars_ShowScrollBar($hWnd, $SB_HORZ, False)
EndIf
If $aVis[1] = False Then
_GUIScrollBars_ShowScrollBar($hWnd, $SB_VERT, False)
EndIf
If $aVis[0] = True Then
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_HORZ, $__g_aSB_WindowInfo[$iIndex][9])
EndIf
If $aVis[1] = True Then
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_VERT, $__g_aSB_WindowInfo[$iIndex][8])
EndIf
$__g_aSB_WindowInfo[0][7] = 0
Return 1
EndIf
Return 0
EndFunc
Func __Scrollbars_WM_VSCROLL($hWnd, $iMsg, $wParam, $lParam)
#forceref $iMsg, $wParam, $lParam
Local $nScrollCode = BitAND($wParam, 0x0000FFFF)
Local $iIndex = -1, $yChar, $yPos
Local $Min, $Max, $Page, $Pos, $TrackPos
For $x = 0 To UBound($__g_aSB_WindowInfo) - 1
If $__g_aSB_WindowInfo[$x][0] = $hWnd Then
$iIndex = $x
$yChar = $__g_aSB_WindowInfo[$iIndex][3]
ExitLoop
EndIf
Next
If $iIndex = -1 Then Return 0
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $SB_VERT)
$Min = DllStructGetData($tSCROLLINFO, "nMin")
$Max = DllStructGetData($tSCROLLINFO, "nMax")
$Page = DllStructGetData($tSCROLLINFO, "nPage")
$yPos = DllStructGetData($tSCROLLINFO, "nPos")
$Pos = $yPos
$TrackPos = DllStructGetData($tSCROLLINFO, "nTrackPos")
Switch $nScrollCode
Case $SB_TOP
DllStructSetData($tSCROLLINFO, "nPos", $Min)
Case $SB_BOTTOM
DllStructSetData($tSCROLLINFO, "nPos", $Max)
Case $SB_LINEUP
DllStructSetData($tSCROLLINFO, "nPos", $Pos - 1)
Case $SB_LINEDOWN
DllStructSetData($tSCROLLINFO, "nPos", $Pos + 1)
Case $SB_PAGEUP
DllStructSetData($tSCROLLINFO, "nPos", $Pos - $Page)
Case $SB_PAGEDOWN
DllStructSetData($tSCROLLINFO, "nPos", $Pos + $Page)
Case $SB_THUMBTRACK
DllStructSetData($tSCROLLINFO, "nPos", $TrackPos)
EndSwitch
DllStructSetData($tSCROLLINFO, "fMask", $SIF_POS)
_GUIScrollBars_SetScrollInfo($hWnd, $SB_VERT, $tSCROLLINFO)
_GUIScrollBars_GetScrollInfo($hWnd, $SB_VERT, $tSCROLLINFO)
$Pos = DllStructGetData($tSCROLLINFO, "nPos")
If ($Pos <> $yPos) Then
_GUIScrollBars_ScrollWindow($hWnd, 0, $yChar * ($yPos - $Pos))
$yPos = $Pos
EndIf
Return $GUI_RUNDEFMSG
EndFunc
Func __Scrollbars_WM_HSCROLL($hWnd, $iMsg, $wParam, $lParam)
#forceref $iMsg, $lParam
Local $nScrollCode = BitAND($wParam, 0x0000FFFF)
Local $iIndex = -1, $xChar, $xPos
Local $Page, $Pos, $TrackPos
For $x = 0 To UBound($__g_aSB_WindowInfo) - 1
If $__g_aSB_WindowInfo[$x][0] = $hWnd Then
$iIndex = $x
$xChar = $__g_aSB_WindowInfo[$iIndex][2]
ExitLoop
EndIf
Next
If $iIndex = -1 Then Return 0
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $SB_HORZ)
$Page = DllStructGetData($tSCROLLINFO, "nPage")
$xPos = DllStructGetData($tSCROLLINFO, "nPos")
$Pos = $xPos
$TrackPos = DllStructGetData($tSCROLLINFO, "nTrackPos")
Switch $nScrollCode
Case $SB_LINELEFT
DllStructSetData($tSCROLLINFO, "nPos", $Pos - 1)
Case $SB_LINERIGHT
DllStructSetData($tSCROLLINFO, "nPos", $Pos + 1)
Case $SB_PAGELEFT
DllStructSetData($tSCROLLINFO, "nPos", $Pos - $Page)
Case $SB_PAGERIGHT
DllStructSetData($tSCROLLINFO, "nPos", $Pos + $Page)
Case $SB_THUMBTRACK
DllStructSetData($tSCROLLINFO, "nPos", $TrackPos)
EndSwitch
DllStructSetData($tSCROLLINFO, "fMask", $SIF_POS)
_GUIScrollBars_SetScrollInfo($hWnd, $SB_HORZ, $tSCROLLINFO)
_GUIScrollBars_GetScrollInfo($hWnd, $SB_HORZ, $tSCROLLINFO)
$Pos = DllStructGetData($tSCROLLINFO, "nPos")
If ($Pos <> $xPos) Then _GUIScrollBars_ScrollWindow($hWnd, $xChar * ($xPos - $Pos), 0)
Return $GUI_RUNDEFMSG
EndFunc
Func __Scrollbars_WM_MOUSEWHEEL($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $lParam
Local $iDirn, $iDelta = BitShift($wParam, 16)
Local $iIndex = -1
For $i = 0 To UBound($__g_aSB_WindowInfo) - 1
If $hWnd = $__g_aSB_WindowInfo[$i][0] Then $iIndex = $i
Next
If $iIndex <> -1 Then
If BitAND($wParam, 0x0000FFFF) Then
$iDirn = $SB_LINERIGHT
If $iDelta > 0 Then $iDirn = $SB_LINELEFT
For $i = 1 To $__g_aSB_WindowInfoEx[$iIndex][6]
_SendMessage($hWnd, $WM_HSCROLL, $iDirn)
Next
Else
$iDirn = $SB_LINEDOWN
If $iDelta > 0 Then $iDirn = $SB_LINEUP
For $i = 1 To $__g_aSB_WindowInfoEx[$iIndex][6]
_SendMessage($hWnd, $WM_VSCROLL, $iDirn)
Next
EndIf
EndIf
Return $GUI_RUNDEFMSG
EndFunc
Func __Scrollbars_WM_MOUSEHWHEEL($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $lParam
Local $iDirn = $SB_LINERIGHT
If BitShift($wParam, 16) > 0 Then $iDirn = $SB_LINELEFT
Local $iIndex = -1
For $i = 0 To UBound($__g_aSB_WindowInfo) - 1
If $hWnd = $__g_aSB_WindowInfo[$i][0] Then $iIndex = $i
Next
If $iIndex <> -1 Then
For $i = 1 To $__g_aSB_WindowInfoEx[$iIndex][5]
_SendMessage($hWnd, $WM_HSCROLL, $iDirn)
Next
EndIf
Return $GUI_RUNDEFMSG
EndFunc
Func __Scrollbars_WM_KEYUP($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $lParam
Local $aRet_Ctrl
Local $iIndex = -1
For $i = 0 To UBound($__g_aSB_WindowInfo) - 1
If $hWnd = $__g_aSB_WindowInfo[$i][0] Then $iIndex = $i
Next
If $iIndex <> -1 Then
Local $bCtrl = False
$aRet_Ctrl = DllCall("user32.dll", "short", "GetAsyncKeyState", "int", "0x11")
If $aRet_Ctrl[0] Then $bCtrl = True
Switch $wParam
Case 0x21
If $bCtrl Then
_SendMessage($hWnd, $WM_HSCROLL, $SB_PAGELEFT)
Else
_SendMessage($hWnd, $WM_VSCROLL, $SB_PAGEUP)
EndIf
Case 0x22
If $bCtrl Then
_SendMessage($hWnd, $WM_HSCROLL, $SB_PAGERIGHT)
Else
_SendMessage($hWnd, $WM_VSCROLL, $SB_PAGEDOWN)
EndIf
Case 0x23
If $bCtrl Then
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_HORZ, $__g_aSB_WindowInfo[$iIndex][6])
Else
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_VERT, $__g_aSB_WindowInfo[$iIndex][7])
EndIf
Case 0x24
If $bCtrl Then
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_HORZ, 0)
Else
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_VERT, 0)
EndIf
Case 0x25
For $i = 1 To $__g_aSB_WindowInfoEx[$iIndex][5]
_SendMessage($hWnd, $WM_HSCROLL, $SB_LINELEFT)
Next
Case 0x26
For $i = 1 To $__g_aSB_WindowInfoEx[$iIndex][5]
_SendMessage($hWnd, $WM_VSCROLL, $SB_LINEUP)
Next
Case 0x27
For $i = 1 To $__g_aSB_WindowInfoEx[$iIndex][5]
_SendMessage($hWnd, $WM_HSCROLL, $SB_LINERIGHT)
Next
Case 0x28
For $i = 1 To $__g_aSB_WindowInfoEx[$iIndex][5]
_SendMessage($hWnd, $WM_VSCROLL, $SB_LINEDOWN)
Next
EndSwitch
EndIf
Return $GUI_RUNDEFMSG
EndFunc
Func __Scrollbars_WM_ENTERSIZEMOVE($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $wParam, $lParam
For $iIndex = 1 To $__g_aSB_WindowInfo[0][0]
If $hWnd = $__g_aSB_WindowInfo[$iIndex][0] Then
$__g_aSB_WindowInfo[0][1] = _GUIScrollBars_GetScrollInfoPos($hWnd, $SB_HORZ)
$__g_aSB_WindowInfo[0][2] = _GUIScrollBars_GetScrollInfoPos($hWnd, $SB_VERT)
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_HORZ, 0)
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_VERT, 0)
_GUIScrollBars_ShowScrollBar($hWnd, $SB_BOTH, False)
$__g_aSB_WindowInfo[0][3] = $hWnd
$__g_aSB_WindowInfo[0][4] = $iIndex
ExitLoop
EndIf
Next
EndFunc
Func __Scrollbars_WM_EXITSIZEMOVE($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $wParam, $lParam
If $hWnd = $__g_aSB_WindowInfo[0][3] And $__g_aSB_WindowInfo[0][4] <> -1 Then
Local $iIndex = $__g_aSB_WindowInfo[0][4]
Local $aClientSize = WinGetClientSize($hWnd)
Local $iH_Aperture = 0, $iV_Aperture = 0, $iH_Reduction = 0, $iV_Reduction = 0
For $i = 1 To 2
If $aClientSize[0] < $__g_aSB_WindowInfoEx[$iIndex][7] + $iH_Reduction Then
$iH_Aperture = $__g_aSB_WindowInfoEx[$iIndex][7] + $iH_Reduction
$iV_Reduction = $__g_aSB_WindowInfo[0][6]
EndIf
If $aClientSize[1] < $__g_aSB_WindowInfoEx[$iIndex][8] + $iV_Reduction Then
$iV_Aperture = $__g_aSB_WindowInfoEx[$iIndex][8] + $iV_Reduction
$iH_Reduction = $__g_aSB_WindowInfo[0][5]
EndIf
Next
_GUIScrollbars_Generate($hWnd, $iH_Aperture, $iV_Aperture)
If $iH_Aperture Then _GUIScrollBars_SetScrollInfoPos($hWnd, $SB_HORZ, $__g_aSB_WindowInfo[0][1])
If $iV_Aperture Then _GUIScrollBars_SetScrollInfoPos($hWnd, $SB_VERT, $__g_aSB_WindowInfo[0][2])
$__g_aSB_WindowInfo[0][1] = 0
$__g_aSB_WindowInfo[0][4] = -1
EndIf
EndFunc
Func __Scrollbars_WM_SIZE($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $wParam, $lParam
Local $iIndex = -1
For $i = 1 To UBound($__g_aSB_WindowInfo) - 1
If $hWnd = $__g_aSB_WindowInfo[$i][0] Then $iIndex = $i
Next
If $iIndex <> -1 Then
If $hWnd = $__g_aSB_WindowInfo[$iIndex][0] Then
If BitAND(WinGetState($hWnd), $WIN_STATE_MINIMIZED) And $__g_aSB_WindowInfoEx[$iIndex][9] = False Then
_GUIScrollBars_ShowScrollBar($hWnd, $SB_BOTH, True)
$__g_aSB_WindowInfo[$iIndex][8] = _GUIScrollBars_GetScrollPos($hWnd, $SB_VERT)
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_VERT, 0)
$__g_aSB_WindowInfo[$iIndex][9] = _GUIScrollBars_GetScrollPos($hWnd, $SB_HORZ)
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_HORZ, 0)
$__g_aSB_WindowInfoEx[$iIndex][9] = True
ElseIf Not(BitAND(WinGetState($hWnd), $WIN_STATE_MINIMIZED)) And $__g_aSB_WindowInfoEx[$iIndex][9] = True Then
$__g_aSB_WindowInfo[0][7] = $hWnd
$__g_aSB_WindowInfoEx[$iIndex][9] = False
EndIf
EndIf
EndIf
EndFunc
Func _StringSize($sText, $iSize = 8.5, $iWeight = 400, $iAttrib = 0, $sName = "", $iMaxWidth = 0, $hWnd = 0)
If $iSize = Default Then $iSize = 8.5
If $iWeight = Default Then $iWeight = 400
If $iAttrib = Default Then $iAttrib = 0
If $sName = "" Or $sName = Default Then	$sName = _StringSize_DefaultFontName()
If Not IsString($sText) Then Return SetError(1, 1, 0)
If Not IsNumber($iSize) Then Return SetError(1, 2, 0)
If Not IsInt($iWeight) Then Return SetError(1, 3, 0)
If Not IsInt($iAttrib) Then Return SetError(1, 4, 0)
If Not IsString($sName) Then Return SetError(1, 5, 0)
If Not IsNumber($iMaxWidth) Then Return SetError(1, 6, 0)
If Not IsHwnd($hWnd) And $hWnd <> 0 Then Return SetError(1, 7, 0)
Local $aRet, $hDC, $hFont, $hLabel = 0, $hLabel_Handle
Local $iExpTab = BitAnd($iAttrib, 1)
$iAttrib = BitAnd($iAttrib, BitNot(1))
If IsHWnd($hWnd) Then
$hLabel = GUICtrlCreateLabel("", -10, -10, 10, 10)
$hLabel_Handle = GUICtrlGetHandle(-1)
GUICtrlSetFont(-1, $iSize, $iWeight, $iAttrib, $sName)
$aRet = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hLabel_Handle)
If @error Or $aRet[0] = 0 Then
GUICtrlDelete($hLabel)
Return SetError(2, 1, 0)
EndIf
$hDC = $aRet[0]
$aRet = DllCall("user32.dll", "lparam", "SendMessage", "hwnd", $hLabel_Handle, "int", 0x0031, "wparam", 0, "lparam", 0)
If @error Or $aRet[0] = 0 Then
GUICtrlDelete($hLabel)
Return SetError(2, _StringSize_Error_Close(2, $hDC), 0)
EndIf
$hFont = $aRet[0]
Else
$aRet = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Or $aRet[0] = 0 Then Return SetError(2, 1, 0)
$hDC = $aRet[0]
$aRet = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", 90)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(3, $hDC), 0)
Local $iInfo = $aRet[0]
$aRet = DllCall("gdi32.dll", "handle", "CreateFontW", "int", -$iInfo * $iSize / 72, "int", 0, "int", 0, "int", 0,  "int", $iWeight, "dword", BitAND($iAttrib, 2), "dword", BitAND($iAttrib, 4), "dword", BitAND($iAttrib, 8), "dword", 0, "dword", 0,  "dword", 0, "dword", 5, "dword", 0, "wstr", $sName)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(4, $hDC), 0)
$hFont = $aRet[0]
EndIf
$aRet = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hFont)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(5, $hDC, $hFont, $hLabel), 0)
Local $hPrevFont = $aRet[0]
Local $avSize_Info[4], $iLine_Length, $iLine_Height = 0, $iLine_Count = 0, $iLine_Width = 0, $iWrap_Count, $iLast_Word, $sTest_Line
Local $tSize = DllStructCreate("int X;int Y")
DllStructSetData($tSize, "X", 0)
DllStructSetData($tSize, "Y", 0)
$sText = StringRegExpReplace($sText, "((?<!\x0d)\x0a|\x0d(?!\x0a))", @CRLF)
Local $asLines = StringSplit($sText, @CRLF, 1)
For $i = 1 To $asLines[0]
If $iExpTab Then
$asLines[$i] = StringReplace($asLines[$i], @TAB, " XXXXXXXX")
EndIf
$iLine_Length = StringLen($asLines[$i])
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $asLines[$i], "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
If DllStructGetData($tSize, "X") > $iLine_Width Then $iLine_Width = DllStructGetData($tSize, "X")
If DllStructGetData($tSize, "Y") > $iLine_Height Then $iLine_Height = DllStructGetData($tSize, "Y")
Next
If $iMaxWidth <> 0 And $iLine_Width > $iMaxWidth Then
For $j = 1 To $asLines[0]
$iLine_Length = StringLen($asLines[$j])
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $asLines[$j], "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
If DllStructGetData($tSize, "X") < $iMaxWidth - 4 Then
$iLine_Count += 1
$avSize_Info[0] &= $asLines[$j] & @CRLF
Else
$iWrap_Count = 0
While 1
$iLine_Width = 0
$iLast_Word = 0
For $i = 1 To StringLen($asLines[$j])
If StringMid($asLines[$j], $i, 1) = " " Then $iLast_Word = $i - 1
$sTest_Line = StringMid($asLines[$j], 1, $i)
$iLine_Length = StringLen($sTest_Line)
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $sTest_Line, "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
$iLine_Width = DllStructGetData($tSize, "X")
If $iLine_Width >= $iMaxWidth - 4 Then ExitLoop
Next
If $i > StringLen($asLines[$j]) Then
$iWrap_Count += 1
$avSize_Info[0] &= $sTest_Line & @CRLF
ExitLoop
Else
$iWrap_Count += 1
If $iLast_Word = 0 Then Return SetError(3, _StringSize_Error_Close(0, $hDC, $hFont, $hLabel), 0)
$avSize_Info[0] &= StringLeft($sTest_Line, $iLast_Word) & @CRLF
$asLines[$j] = StringTrimLeft($asLines[$j], $iLast_Word)
$asLines[$j] = StringStripWS($asLines[$j], 1)
EndIf
WEnd
$iLine_Count += $iWrap_Count
EndIf
Next
If $iExpTab Then
$avSize_Info[0] = StringRegExpReplace($avSize_Info[0], "\x20?XXXXXXXX", @TAB)
EndIf
$avSize_Info[1] = $iLine_Height
$avSize_Info[2] = $iMaxWidth
$avSize_Info[3] = ($iLine_Count * $iLine_Height) + 4
Else
Local $avSize_Info[4] = [$sText, $iLine_Height, $iLine_Width, ($asLines[0] * $iLine_Height) + 4]
EndIf
DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hPrevFont)
DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hFont)
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $hDC)
If $hLabel Then GUICtrlDelete($hLabel)
Return $avSize_Info
EndFunc
Func _StringSize_Error_Close($iExtCode, $hDC = 0, $hFont = 0, $hLabel = 0)
If $hFont <> 0 Then DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hFont)
If $hDC <> 0 Then DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $hDC)
If $hLabel Then GUICtrlDelete($hLabel)
Return $iExtCode
EndFunc
Func _StringSize_DefaultFontName()
Local $tNONCLIENTMETRICS = DllStructCreate("uint;int;int;int;int;int;byte[60];int;int;byte[60];int;int;byte[60];byte[60];byte[60]")
DLLStructSetData($tNONCLIENTMETRICS, 1, DllStructGetSize($tNONCLIENTMETRICS))
DLLCall("user32.dll", "int", "SystemParametersInfo", "int", 41, "int", DllStructGetSize($tNONCLIENTMETRICS), "ptr", DllStructGetPtr($tNONCLIENTMETRICS), "int", 0)
Local $tLOGFONT = DllStructCreate("long;long;long;long;long;byte;byte;byte;byte;byte;byte;byte;byte;char[32]", DLLStructGetPtr($tNONCLIENTMETRICS, 13))
If IsString(DllStructGetData($tLOGFONT, 14)) Then
Return DllStructGetData($tLOGFONT, 14)
Else
Return "Tahoma"
EndIf
EndFunc
Global Const $CF_TEXT = 1
Global Const $CF_BITMAP = 2
Global Const $CF_METAFILEPICT = 3
Global Const $CF_SYLK = 4
Global Const $CF_DIF = 5
Global Const $CF_TIFF = 6
Global Const $CF_OEMTEXT = 7
Global Const $CF_DIB = 8
Global Const $CF_PALETTE = 9
Global Const $CF_PENDATA = 10
Global Const $CF_RIFF = 11
Global Const $CF_WAVE = 12
Global Const $CF_UNICODETEXT = 13
Global Const $CF_ENHMETAFILE = 14
Global Const $CF_HDROP = 15
Global Const $CF_LOCALE = 16
Global Const $CF_DIBV5 = 17
Global Const $CF_OWNERDISPLAY = 0x0080
Global Const $CF_DSPTEXT = 0x0081
Global Const $CF_DSPBITMAP = 0x0082
Global Const $CF_DSPMETAFILEPICT = 0x0083
Global Const $CF_DSPENHMETAFILE = 0x008E
Global Const $CF_PRIVATEFIRST = 0x0200
Global Const $CF_PRIVATELAST = 0x02FF
Global Const $CF_GDIOBJFIRST = 0x0300
Global Const $CF_GDIOBJLAST = 0x03FF
Func _ClipBoard_ChangeChain($hRemove, $hNewNext)
DllCall("user32.dll", "bool", "ChangeClipboardChain", "hwnd", $hRemove, "hwnd", $hNewNext)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _ClipBoard_Close()
Local $aCall = DllCall("user32.dll", "bool", "CloseClipboard")
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _ClipBoard_CountFormats()
Local $aCall = DllCall("user32.dll", "int", "CountClipboardFormats")
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _ClipBoard_Empty()
Local $aCall = DllCall("user32.dll", "bool", "EmptyClipboard")
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _ClipBoard_EnumFormats($iFormat)
Local $aCall = DllCall("user32.dll", "uint", "EnumClipboardFormats", "uint", $iFormat)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _ClipBoard_FormatStr($iFormat)
Local $aFormat[18] = [17, "Text", "Bitmap", "Metafile Picture", "SYLK", "DIF", "TIFF", "OEM Text", "DIB", "Palette",  "Pen Data", "RIFF", "WAVE", "Unicode Text", "Enhanced Metafile", "HDROP", "Locale", "DIB V5"]
If $iFormat >= 1 And $iFormat <= 17 Then Return $aFormat[$iFormat]
Switch $iFormat
Case $CF_OWNERDISPLAY
Return "Owner Display"
Case $CF_DSPTEXT
Return "Private Text"
Case $CF_DSPBITMAP
Return "Private Bitmap"
Case $CF_DSPMETAFILEPICT
Return "Private Metafile Picture"
Case $CF_DSPENHMETAFILE
Return "Private Enhanced Metafile"
Case Else
Return _ClipBoard_GetFormatName($iFormat)
EndSwitch
EndFunc
Func _ClipBoard_GetData($iFormat = 1)
If Not _ClipBoard_IsFormatAvailable($iFormat) Then Return SetError(-1, 0, 0)
If Not _ClipBoard_Open(0) Then Return SetError(-2, 0, 0)
Local $hMemory = _ClipBoard_GetDataEx($iFormat)
If $hMemory = 0 Then
_ClipBoard_Close()
Return SetError(-3, 0, 0)
EndIf
Local $pMemoryBlock = _MemGlobalLock($hMemory)
If $pMemoryBlock = 0 Then
_ClipBoard_Close()
Return SetError(-4, 0, 0)
EndIf
Local $iDataSize = _MemGlobalSize($hMemory)
If $iDataSize = 0 Then
_MemGlobalUnlock($hMemory)
_ClipBoard_Close()
Return SetError(-5, 0, "")
EndIf
Local $tData
Switch $iFormat
Case $CF_TEXT, $CF_OEMTEXT
$tData = DllStructCreate("char[" & $iDataSize & "]", $pMemoryBlock)
Case $CF_UNICODETEXT
$iDataSize = Round($iDataSize / 2)
$tData = DllStructCreate("wchar[" & $iDataSize & "]", $pMemoryBlock)
Case Else
$tData = DllStructCreate("byte[" & $iDataSize & "]", $pMemoryBlock)
EndSwitch
Local $vReturn = DllStructGetData($tData, 1)
_MemGlobalUnlock($hMemory)
_ClipBoard_Close()
Return SetExtended($iDataSize, $vReturn)
EndFunc
Func _ClipBoard_GetDataEx($iFormat = 1)
Local $aCall = DllCall("user32.dll", "handle", "GetClipboardData", "uint", $iFormat)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _ClipBoard_GetFormatName($iFormat)
Local $aCall = DllCall("user32.dll", "int", "GetClipboardFormatNameW", "uint", $iFormat, "wstr", "", "int", 4096)
If @error Then Return SetError(@error, @extended, "")
Return $aCall[2]
EndFunc
Func _ClipBoard_GetOpenWindow()
Local $aCall = DllCall("user32.dll", "hwnd", "GetOpenClipboardWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _ClipBoard_GetOwner()
Local $aCall = DllCall("user32.dll", "hwnd", "GetClipboardOwner")
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _ClipBoard_GetPriorityFormat($aFormats)
If Not IsArray($aFormats) Then Return SetError(-1, 0, 0)
If $aFormats[0] <= 0 Then Return SetError(-2, 0, 0)
Local $tData = DllStructCreate("uint[" & $aFormats[0] & "]")
For $iI = 1 To $aFormats[0]
DllStructSetData($tData, 1, $aFormats[$iI], $iI)
Next
Local $aCall = DllCall("user32.dll", "int", "GetPriorityClipboardFormat", "struct*", $tData, "int", $aFormats[0])
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _ClipBoard_GetSequenceNumber()
Local $aCall = DllCall("user32.dll", "dword", "GetClipboardSequenceNumber")
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _ClipBoard_GetViewer()
Local $aCall = DllCall("user32.dll", "hwnd", "GetClipboardViewer")
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _ClipBoard_IsFormatAvailable($iFormat)
Local $aCall = DllCall("user32.dll", "bool", "IsClipboardFormatAvailable", "uint", $iFormat)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _ClipBoard_Open($hOwner)
Local $aCall = DllCall("user32.dll", "bool", "OpenClipboard", "hwnd", $hOwner)
If @error Then Return SetError(@error, @extended, False)
Return $aCall[0]
EndFunc
Func _ClipBoard_RegisterFormat($sFormat)
Local $aCall = DllCall("user32.dll", "uint", "RegisterClipboardFormatW", "wstr", $sFormat)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _ClipBoard_SetData($vData, $iFormat = 1)
Local $tData, $hLock, $hMemory, $iSize
If IsNumber($vData) And $vData = 0 Then
$hMemory = $vData
Else
If IsBinary($vData) Then
$iSize = BinaryLen($vData)
ElseIf IsString($vData) Then
$iSize = StringLen($vData)
Else
Return SetError(2, 0, 0)
EndIf
$iSize += 1
If $iFormat = $CF_UNICODETEXT Then
$hMemory = _MemGlobalAlloc($iSize * 2, $GHND)
Else
$hMemory = _MemGlobalAlloc($iSize, $GHND)
EndIf
If $hMemory = 0 Then Return SetError(-1, 0, 0)
$hLock = _MemGlobalLock($hMemory)
If $hLock = 0 Then Return SetError(-2, 0, 0)
Switch $iFormat
Case $CF_TEXT, $CF_OEMTEXT
$tData = DllStructCreate("char[" & $iSize & "]", $hLock)
Case $CF_UNICODETEXT
$tData = DllStructCreate("wchar[" & $iSize & "]", $hLock)
Case Else
$tData = DllStructCreate("byte[" & $iSize & "]", $hLock)
EndSwitch
DllStructSetData($tData, 1, $vData)
_MemGlobalUnlock($hMemory)
EndIf
If Not _ClipBoard_Open(0) Then Return SetError(-5, 0, 0)
If Not _ClipBoard_Empty() Then
_ClipBoard_Close()
Return SetError(-6, 0, 0)
EndIf
If Not _ClipBoard_SetDataEx($hMemory, $iFormat) Then
_ClipBoard_Close()
Return SetError(-7, 0, 0)
EndIf
_ClipBoard_Close()
Return $hMemory
EndFunc
Func _ClipBoard_SetDataEx(ByRef $hMemory, $iFormat = 1)
Local $aCall = DllCall("user32.dll", "handle", "SetClipboardData", "uint", $iFormat, "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _ClipBoard_SetViewer($hViewer)
Local $aCall = DllCall("user32.dll", "hwnd", "SetClipboardViewer", "hwnd", $hViewer)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Global Const $__RICHEDITCONSTANT_WM_USER = 0x400
Global Const $EM_AUTOURLDETECT = $__RICHEDITCONSTANT_WM_USER + 91
Global Const $EM_CANPASTE = $__RICHEDITCONSTANT_WM_USER + 50
Global Const $EM_CANREDO = $__RICHEDITCONSTANT_WM_USER + 85
Global Const $EM_DISPLAYBAND = $__RICHEDITCONSTANT_WM_USER + 51
Global Const $EM_EXGETSEL = $__RICHEDITCONSTANT_WM_USER + 52
Global Const $EM_EXLIMITTEXT = $__RICHEDITCONSTANT_WM_USER + 53
Global Const $EM_EXLINEFROMCHAR = $__RICHEDITCONSTANT_WM_USER + 54
Global Const $EM_EXSETSEL = $__RICHEDITCONSTANT_WM_USER + 55
Global Const $EM_FINDTEXT = $__RICHEDITCONSTANT_WM_USER + 56
Global Const $EM_FINDTEXTEX = $__RICHEDITCONSTANT_WM_USER + 79
Global Const $EM_FINDTEXTEXW = $__RICHEDITCONSTANT_WM_USER + 124
Global Const $EM_FINDTEXTW = $__RICHEDITCONSTANT_WM_USER + 123
Global Const $EM_FINDWORDBREAK = $__RICHEDITCONSTANT_WM_USER + 76
Global Const $EM_FORMATRANGE = $__RICHEDITCONSTANT_WM_USER + 57
Global Const $EM_GETAUTOURLDETECT = $__RICHEDITCONSTANT_WM_USER + 92
Global Const $EM_GETBIDIOPTIONS = $__RICHEDITCONSTANT_WM_USER + 201
Global Const $EM_GETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 58
Global Const $EM_GETEDITSTYLE = $__RICHEDITCONSTANT_WM_USER + 205
Global Const $EM_GETEVENTMASK = $__RICHEDITCONSTANT_WM_USER + 59
Global Const $EM_GETIMECOLOR = $__RICHEDITCONSTANT_WM_USER + 105
Global Const $EM_GETIMECOMPMODE = $__RICHEDITCONSTANT_WM_USER + 122
Global Const $EM_GETIMEMODEBIAS = $__RICHEDITCONSTANT_WM_USER + 127
Global Const $EM_GETIMEOPTIONS = $__RICHEDITCONSTANT_WM_USER + 107
Global Const $EM_GETLANGOPTIONS = $__RICHEDITCONSTANT_WM_USER + 121
Global Const $EM_GETOPTIONS = $__RICHEDITCONSTANT_WM_USER + 78
Global Const $EM_GETPARAFORMAT = $__RICHEDITCONSTANT_WM_USER + 61
Global Const $EM_GETPUNCTUATION = $__RICHEDITCONSTANT_WM_USER + 101
Global Const $EM_GETREDONAME = $__RICHEDITCONSTANT_WM_USER + 87
Global Const $EM_GETSCROLLPOS = $__RICHEDITCONSTANT_WM_USER + 221
Global Const $EM_GETTABLEPARMS = $__RICHEDITCONSTANT_WM_USER + 265
Global Const $EM_GETSELTEXT = $__RICHEDITCONSTANT_WM_USER + 62
Global Const $EM_GETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 94
Global Const $EM_GETTEXTLENGTHEX = $__RICHEDITCONSTANT_WM_USER + 95
Global Const $EM_GETTEXTMODE = $__RICHEDITCONSTANT_WM_USER + 90
Global Const $EM_GETTEXTRANGE = $__RICHEDITCONSTANT_WM_USER + 75
Global Const $EM_GETTYPOGRAPHYOPTIONS = $__RICHEDITCONSTANT_WM_USER + 203
Global Const $EM_GETUNDONAME = $__RICHEDITCONSTANT_WM_USER + 86
Global Const $EM_GETWORDBREAKPROCEX = $__RICHEDITCONSTANT_WM_USER + 80
Global Const $EM_GETWORDWRAPMODE = $__RICHEDITCONSTANT_WM_USER + 103
Global Const $EM_GETZOOM = $__RICHEDITCONSTANT_WM_USER + 224
Global Const $EM_HIDESELECTION = $__RICHEDITCONSTANT_WM_USER + 63
Global Const $EM_INSERTTABLE = $__RICHEDITCONSTANT_WM_USER + 232
Global Const $EM_PASTESPECIAL = $__RICHEDITCONSTANT_WM_USER + 64
Global Const $EM_RECONVERSION = $__RICHEDITCONSTANT_WM_USER + 125
Global Const $EM_REDO = $__RICHEDITCONSTANT_WM_USER + 84
Global Const $EM_REQUESTRESIZE = $__RICHEDITCONSTANT_WM_USER + 65
Global Const $EM_SELECTIONTYPE = $__RICHEDITCONSTANT_WM_USER + 66
Global Const $EM_SETBIDIOPTIONS = $__RICHEDITCONSTANT_WM_USER + 200
Global Const $EM_SETBKGNDCOLOR = $__RICHEDITCONSTANT_WM_USER + 67
Global Const $EM_SETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 68
Global Const $EM_SETEDITSTYLE = $__RICHEDITCONSTANT_WM_USER + 204
Global Const $EM_SETEVENTMASK = $__RICHEDITCONSTANT_WM_USER + 69
Global Const $EM_SETFONTSIZE = $__RICHEDITCONSTANT_WM_USER + 223
Global Const $EM_SETIMECOLOR = $__RICHEDITCONSTANT_WM_USER + 104
Global Const $EM_SETIMEMODEBIAS = $__RICHEDITCONSTANT_WM_USER + 126
Global Const $EM_SETIMEOPTIONS = $__RICHEDITCONSTANT_WM_USER + 106
Global Const $EM_SETLANGOPTIONS = $__RICHEDITCONSTANT_WM_USER + 120
Global Const $EM_SETOLECALLBACK = $__RICHEDITCONSTANT_WM_USER + 70
Global Const $EM_SETOPTIONS = $__RICHEDITCONSTANT_WM_USER + 77
Global Const $EM_SETPALETTE = $__RICHEDITCONSTANT_WM_USER + 93
Global Const $EM_SETPARAFORMAT = $__RICHEDITCONSTANT_WM_USER + 71
Global Const $EM_SETPUNCTUATION = $__RICHEDITCONSTANT_WM_USER + 100
Global Const $EM_SETSCROLLPOS = $__RICHEDITCONSTANT_WM_USER + 222
Global Const $EM_SETTABLEPARMS = $__RICHEDITCONSTANT_WM_USER + 307
Global Const $EM_SETTARGETDEVICE = $__RICHEDITCONSTANT_WM_USER + 72
Global Const $EM_SETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 97
Global Const $EM_SETTEXTMODE = $__RICHEDITCONSTANT_WM_USER + 89
Global Const $EM_SETTYPOGRAPHYOPTIONS = $__RICHEDITCONSTANT_WM_USER + 202
Global Const $EM_SETUNDOLIMIT = $__RICHEDITCONSTANT_WM_USER + 82
Global Const $EM_SETWORDBREAKPROCEX = $__RICHEDITCONSTANT_WM_USER + 81
Global Const $EM_SETWORDWRAPMODE = $__RICHEDITCONSTANT_WM_USER + 102
Global Const $EM_SETZOOM = $__RICHEDITCONSTANT_WM_USER + 225
Global Const $EM_SHOWSCROLLBAR = $__RICHEDITCONSTANT_WM_USER + 96
Global Const $EM_STOPGROUPTYPING = $__RICHEDITCONSTANT_WM_USER + 88
Global Const $EM_STREAMIN = $__RICHEDITCONSTANT_WM_USER + 73
Global Const $EM_STREAMOUT = $__RICHEDITCONSTANT_WM_USER + 74
Global Const $EN_ALIGNLTR = 0X710
Global Const $EN_ALIGNRTL = 0X711
Global Const $EN_CORRECTTEXT = 0X705
Global Const $EN_DRAGDROPDONE = 0X70c
Global Const $EN_DROPFILES = 0X703
Global Const $EN_IMECHANGE = 0X707
Global Const $EN_LINK = 0X70b
Global Const $EN_MSGFILTER = 0X700
Global Const $EN_OBJECTPOSITIONS = 0X70a
Global Const $EN_OLEOPFAILED = 0X709
Global Const $EN_PROTECTED = 0X704
Global Const $EN_REQUESTRESIZE = 0X701
Global Const $EN_SAVECLIPBOARD = 0X708
Global Const $EN_SELCHANGE = 0X702
Global Const $EN_STOPNOUNDO = 0X706
Global Const $ENM_NONE = 0x0
Global Const $ENM_CHANGE = 0x1
Global Const $ENM_CORRECTTEXT = 0x400000
Global Const $ENM_DRAGDROPDONE = 0x10
Global Const $ENM_DROPFILES = 0x100000
Global Const $ENM_IMECHANGE = 0x800000
Global Const $ENM_KEYEVENTS = 0x10000
Global Const $ENM_LINK = 0x4000000
Global Const $ENM_MOUSEEVENTS = 0x20000
Global Const $ENM_OBJECTPOSITIONS = 0x2000000
Global Const $ENM_PROTECTED = 0x200000
Global Const $ENM_REQUESTRESIZE = 0x40000
Global Const $ENM_SCROLL = 0x4
Global Const $ENM_SCROLLEVENTS = 0x8
Global Const $ENM_SELCHANGE = 0x80000
Global Const $ENM_UPDATE = 0x2
Global Const $BOM_DEFPARADIR = 0x1
Global Const $BOM_PLAINTEXT = 0x2
Global Const $BOM_NEUTRALOVERRIDE = 0x4
Global Const $BOM_CONTEXTREADING = 0x8
Global Const $BOM_CONTEXTALIGNMENT = 0x10
Global Const $BOM_LEGACYBIDICLASS = 0x0040
Global Const $BOE_RTLDIR = 0x1
Global Const $BOE_PLAINTEXT = 0x2
Global Const $BOE_NEUTRALOVERRIDE = 0x4
Global Const $BOE_CONTEXTREADING = 0x8
Global Const $BOE_CONTEXTALIGNMENT = 0x10
Global Const $BOE_LEGACYBIDICLASS = 0x0040
Global Const $ST_DEFAULT = 0
Global Const $ST_KEEPUNDO = 1
Global Const $ST_SELECTION = 2
Global Const $GT_DEFAULT = 0
Global Const $GT_SELECTION = 2
Global Const $GT_USECRLF = 1
Global Const $GTL_CLOSE = 4
Global Const $GTL_DEFAULT = 0
Global Const $GTL_NUMBYTES = 16
Global Const $GTL_NUMCHARS = 8
Global Const $GTL_PRECISE = 2
Global Const $GTL_USECRLF = 1
Global Const $CFU_UNDERLINENONE = 0
Global Const $CFU_UNDERLINE = 1
Global Const $CFU_UNDERLINEWORD = 2
Global Const $CFU_UNDERLINEDOUBLE = 3
Global Const $CFU_UNDERLINEDOTTED = 4
Global Const $CP_ACP = 0
Global Const $CP_UNICODE = 1200
Global Const $CFE_SUBSCRIPT = 0x00010000
Global Const $CFE_SUPERSCRIPT = 0x00020000
Global Const $CFM_ALLCAPS = 0x80
Global Const $CFM_ANIMATION = 0x40000
Global Const $CFM_BACKCOLOR = 0x4000000
Global Const $CFM_BOLD = 0x1
Global Const $CFM_CHARSET = 0x8000000
Global Const $CFM_COLOR = 0x40000000
Global Const $CFM_DISABLED = 0x2000
Global Const $CFM_EMBOSS = 0x800
Global Const $CFM_FACE = 0x20000000
Global Const $CFM_HIDDEN = 0x100
Global Const $CFM_IMPRINT = 0x1000
Global Const $CFM_ITALIC = 0x2
Global Const $CFM_KERNING = 0x100000
Global Const $CFM_LCID = 0x2000000
Global Const $CFM_LINK = 0x20
Global Const $CFM_OFFSET = 0x10000000
Global Const $CFM_OUTLINE = 0x200
Global Const $CFM_PROTECTED = 0x10
Global Const $CFM_REVAUTHOR = 0x8000
Global Const $CFM_REVISED = 0x4000
Global Const $CFM_SHADOW = 0x400
Global Const $CFM_SIZE = 0x80000000
Global Const $CFM_SMALLCAPS = 0x40
Global Const $CFM_SPACING = 0x200000
Global Const $CFM_STRIKEOUT = 0x8
Global Const $CFM_STYLE = 0x80000
Global Const $CFM_SUBSCRIPT = BitOR($CFE_SUBSCRIPT, $CFE_SUPERSCRIPT)
Global Const $CFM_SUPERSCRIPT = $CFM_SUBSCRIPT
Global Const $CFM_UNDERLINE = 0x4
Global Const $CFM_UNDERLINETYPE = 0x800000
Global Const $CFM_WEIGHT = 0x400000
Global Const $CFE_ALLCAPS = $CFM_ALLCAPS
Global Const $CFE_AUTOBACKCOLOR = $CFM_BACKCOLOR
Global Const $CFE_AUTOCOLOR = $CFM_COLOR
Global Const $CFE_BOLD = $CFM_BOLD
Global Const $CFE_DISABLED = $CFM_DISABLED
Global Const $CFE_EMBOSS = $CFM_EMBOSS
Global Const $CFE_HIDDEN = $CFM_HIDDEN
Global Const $CFE_IMPRINT = $CFM_IMPRINT
Global Const $CFE_ITALIC = $CFM_ITALIC
Global Const $CFE_LINK = $CFM_LINK
Global Const $CFE_OUTLINE = $CFM_OUTLINE
Global Const $CFE_PROTECTED = $CFM_PROTECTED
Global Const $CFE_REVISED = $CFM_REVISED
Global Const $CFE_SHADOW = $CFM_SHADOW
Global Const $CFE_SMALLCAPS = $CFM_SMALLCAPS
Global Const $CFE_STRIKEOUT = $CFM_STRIKEOUT
Global Const $CFE_UNDERLINE = $CFM_UNDERLINE
Global Const $FR_MATCHALEFHAMZA = 0x80000000
Global Const $FR_MATCHDIAC = 0x20000000
Global Const $FR_MATCHKASHIDA = 0x40000000
Global Const $SCF_DEFAULT = 0x0
Global Const $SCF_SELECTION = 0x1
Global Const $SCF_WORD = 0x2
Global Const $SCF_ALL = 0x4
Global Const $SCF_USEUIRULES = 0x8
Global Const $SCF_ASSOCIATEFONT = 0x10
Global Const $SCF_NOKBUPDATE = 0x20
Global Const $LF_FACESIZE = 32
Global Const $MAX_TAB_STOPS = 32
Global Const $PFA_LEFT = 0x1
Global Const $PFA_RIGHT = 0x2
Global Const $PFA_CENTER = 0x3
Global Const $PFA_JUSTIFY = 4
Global Const $PFA_FULL_INTERWORD = 4
Global Const $PFE_TABLE = 0x4000
Global Const $PFM_NUMBERING = 0x20
Global Const $PFM_ALIGNMENT = 0x8
Global Const $PFM_SPACEBEFORE = 0x40
Global Const $PFM_NUMBERINGSTYLE = 0x2000
Global Const $PFM_NUMBERINGSTART = 0x8000
Global Const $PFM_BORDER = 0x800
Global Const $PFM_RIGHTINDENT = 0x2
Global Const $PFM_STARTINDENT = 0x1
Global Const $PFM_OFFSET = 0x4
Global Const $PFM_LINESPACING = 0x100
Global Const $PFM_SPACEAFTER = 0x80
Global Const $PFM_NUMBERINGTAB = 0x4000
Global Const $PFM_TABLE = 0x40000000
Global Const $PFM_TABSTOPS = 0x10
Global Const $PFN_BULLET = 0x1
Global Const $PFM_RTLPARA = 0x10000
Global Const $PFM_KEEP = 0x20000
Global Const $PFM_KEEPNEXT = 0x40000
Global Const $PFM_PAGEBREAKBEFORE = 0x80000
Global Const $PFM_NOLINENUMBER = 0x100000
Global Const $PFM_NOWIDOWCONTROL = 0x200000
Global Const $PFM_DONOTHYPHEN = 0x400000
Global Const $PFM_SIDEBYSIDE = 0x800000
Global Const $PFE_RTLPARA = 0x00000001
Global Const $PFE_KEEP = 0x00000002
Global Const $PFE_KEEPNEXT = 0x00000004
Global Const $PFE_PAGEBREAKBEFORE = 0x00000008
Global Const $PFE_NOLINENUMBER = 0x00000010
Global Const $PFE_NOWIDOWCONTROL = 0x00000020
Global Const $PFE_DONOTHYPHEN = 0x00000040
Global Const $PFE_SIDEBYSIDE = 0x00000080
Global Const $PFM_SHADING = 0x1000
Global Const $WB_CLASSIFY = 3
Global Const $WB_ISDELIMITER = 2
Global Const $WB_LEFT = 0
Global Const $WB_LEFTBREAK = 6
Global Const $WB_MOVEWORDLEFT = 4
Global Const $WB_MOVEWORDNEXT = 5
Global Const $WB_MOVEWORDPREV = 4
Global Const $WB_MOVEWORDRIGHT = 5
Global Const $WB_NEXTBREAK = 7
Global Const $WB_PREVBREAK = 6
Global Const $WB_RIGHT = 1
Global Const $WB_RIGHTBREAK = 7
Global Const $WBF_ISWHITE = 0x10
Global Const $WBF_BREAKLINE = 0x20
Global Const $WBF_BREAKAFTER = 0x40
Global Const $SF_TEXT = 0x1
Global Const $SF_RTF = 0x2
Global Const $SF_RTFNOOBJS = 0x3
Global Const $SF_TEXTIZED = 0x4
Global Const $SF_UNICODE = 0x0010
Global Const $SF_USECODEPAGE = 0x20
Global Const $SFF_PLAINRTF = 0x4000
Global Const $SFF_SELECTION = 0x8000
Global $__g_sRTFClassName, $__g_sRTFVersion, $__g_iRTFTwipsPeSpaceUnit = 1440
Global $__g_sGRE_CF_RTF, $__g_sGRE_CF_RETEXTOBJ
Global $__g_pGRC_StreamFromFileCallback = DllCallbackRegister("__GCR_StreamFromFileCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamFromVarCallback = DllCallbackRegister("__GCR_StreamFromVarCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamToFileCallback = DllCallbackRegister("__GCR_StreamToFileCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamToVarCallback = DllCallbackRegister("__GCR_StreamToVarCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_sStreamVar
Global $__g_tObj_RichComObject = DllStructCreate("ptr pIntf; dword  Refcount")
Global $__g_tCall_RichCom, $__g_pObj_RichCom
Global $__g_hLib_RichCom_OLE32 = DllOpen("OLE32.DLL")
Global $__g_pRichCom_Object_QueryInterface = DllCallbackRegister("__RichCom_Object_QueryInterface", "long", "ptr;dword;dword")
Global $__g_pRichCom_Object_AddRef = DllCallbackRegister("__RichCom_Object_AddRef", "long", "ptr")
Global $__g_pRichCom_Object_Release = DllCallbackRegister("__RichCom_Object_Release", "long", "ptr")
Global $__g_pRichCom_Object_GetNewStorage = DllCallbackRegister("__RichCom_Object_GetNewStorage", "long", "ptr;ptr")
Global $__g_pRichCom_Object_GetInPlaceContext = DllCallbackRegister("__RichCom_Object_GetInPlaceContext", "long", "ptr;dword;dword;dword")
Global $__g_pRichCom_Object_ShowContainerUI = DllCallbackRegister("__RichCom_Object_ShowContainerUI", "long", "ptr;long")
Global $__g_pRichCom_Object_QueryInsertObject = DllCallbackRegister("__RichCom_Object_QueryInsertObject", "long", "ptr;dword;ptr;long")
Global $__g_pRichCom_Object_DeleteObject = DllCallbackRegister("__RichCom_Object_DeleteObject", "long", "ptr;ptr")
Global $__g_pRichCom_Object_QueryAcceptData = DllCallbackRegister("__RichCom_Object_QueryAcceptData", "long", "ptr;ptr;dword;dword;dword;ptr")
Global $__g_pRichCom_Object_ContextSensitiveHelp = DllCallbackRegister("__RichCom_Object_ContextSensitiveHelp", "long", "ptr;long")
Global $__g_pRichCom_Object_GetClipboardData = DllCallbackRegister("__RichCom_Object_GetClipboardData", "long", "ptr;ptr;dword;ptr")
Global $__g_pRichCom_Object_GetDragDropEffect = DllCallbackRegister("__RichCom_Object_GetDragDropEffect", "long", "ptr;dword;dword;dword")
Global $__g_pRichCom_Object_GetContextMenu = DllCallbackRegister("__RichCom_Object_GetContextMenu", "long", "ptr;short;ptr;ptr;ptr")
Global Const $__RICHEDITCONSTANT_SB_LINEDOWN = 1
Global Const $__RICHEDITCONSTANT_SB_LINEUP = 0
Global Const $__RICHEDITCONSTANT_SB_PAGEDOWN = 3
Global Const $__RICHEDITCONSTANT_SB_PAGEUP = 2
Global Const $__RICHEDITCONSTANT_WM_COPY = 0x00000301
Global Const $__RICHEDITCONSTANT_WM_SETFONT = 0x0030
Global Const $__RICHEDITCONSTANT_WM_CUT = 0x00000300
Global Const $__RICHEDITCONSTANT_WM_PASTE = 0x00000302
Global Const $__RICHEDITCONSTANT_WM_SETREDRAW = 0x000B
Global Const $__RICHEDITCONSTANT_COLOR_WINDOWTEXT = 8
Global Const $_GCR_S_OK = 0
Global Const $_GCR_E_NOTIMPL = 0x80004001
Global Const $_GCR_E_INVALIDARG = 0x80070057
Global Const $tagEDITSTREAM = "struct;align 4;dword_ptr dwCookie;dword dwError;ptr pfnCallback;endstruct"
Global Const $tagBIDIOPTIONS = "uint cbSize;word wMask;word wEffects"
Global Const $tagCHARFORMAT = "struct;uint cbSize;dword dwMask;dword dwEffects;long yHeight;long yOffset;INT crCharColor;" &  "byte bCharSet;byte bPitchAndFamily;wchar szFaceName[32];endstruct"
Global Const $tagCHARFORMAT2 = $tagCHARFORMAT & ";word wWeight;short sSpacing;INT crBackColor;dword lcid;dword dwReserved;" &  "short sStyle;word wKerning;byte bUnderlineType;byte bAnimation;byte bRevAuthor;byte bReserved1"
Global Const $tagCHARRANGE = "struct;long cpMin;long cpMax;endstruct"
Global Const $tagFINDTEXT = $tagCHARRANGE & ";ptr lpstrText"
Global Const $tagFINDTEXTEX = $tagCHARRANGE & ";ptr lpstrText;long cpMinRang;long cpMaxRange"
Global Const $tagGETTEXTEX = "struct;align 4;dword cb;dword flags;uint codepage;ptr lpDefaultChar;ptr lpbUsedDefChar;endstruct"
Global Const $tagGETTEXTLENGTHEX = "dword flags;uint codepage"
Global Const $tagPARAFORMAT = "uint cbSize;dword dwMask;word wNumbering;word wEffects;long dxStartIndent;"  & "long dxRightIndent;long dxOffset;word wAlignment;short cTabCount;long rgxTabs[32]"
Global Const $tagPARAFORMAT2 = $tagPARAFORMAT  & ";long dySpaceBefore;long dySpaceAfter;long dyLineSpacing;short sStyle;byte bLineSpacingRule;"  & "byte bOutlineLevel;word wShadingWeight;word wShadingStyle;word wNumberingStart;word wNumberingStyle;"  & "word wNumberingTab;word wBorderSpace;word wBorderWidth;word wBorders"
Global Const $tagSETTEXTEX = "dword flags;uint codepage"
Global Const $tagTEXTRANGE = $tagCHARRANGE & ";ptr lpstrText"
Global Const $tagMSGFILTER = "struct;" & $tagNMHDR & ";align 4;uint msg;wparam wParam;lparam lParam;endstruct"
Global Const $tagENLINK = "struct;" & $tagNMHDR & ";align 4;uint msg;wparam wParam;lparam lParam;" & $tagCHARRANGE & ";endstruct"
Func _GUICtrlRichEdit_AppendText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iLength = _GUICtrlRichEdit_GetTextLength($hWnd)
_GUICtrlRichEdit_SetSel($hWnd, $iLength, $iLength)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_SELECTION)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
DllStructSetData($tSetText, 2, $CP_ACP)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_AutoDetectURL($hWnd, $bState)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bState) Then Return SetError(102, 0, False)
If _SendMessage($hWnd, $EM_AUTOURLDETECT, $bState) Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_CanPaste($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iRet = _SendMessage($hWnd, $EM_CANPASTE, 0, 0)
Return $iRet <> 0
EndFunc
Func _GUICtrlRichEdit_CanPasteSpecial($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_CANPASTE, $__g_sGRE_CF_RTF, 0) <> 0  And _SendMessage($hWnd, $EM_CANPASTE, $__g_sGRE_CF_RETEXTOBJ, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_CanRedo($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_CANREDO, 0, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_CanUndo($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_CANUNDO, 0, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_ChangeFontSize($hWnd, $iIncrement)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iIncrement) Then SetError(102, 0, False)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then Return SetError(-1, 0, False)
Return _SendMessage($hWnd, $EM_SETFONTSIZE, $iIncrement, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_Copy($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_COPY, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_Create($hWnd, $sText, $iLeft, $iTop, $iWidth = 150, $iHeight = 150, $iStyle = -1, $iExStyle = -1)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sText) Then Return SetError(2, 0, 0)
If Not __GCR_IsNumeric($iWidth, ">0,-1") Then Return SetError(105, 0, 0)
If Not __GCR_IsNumeric($iHeight, ">0,-1") Then Return SetError(106, 0, 0)
If Not __GCR_IsNumeric($iStyle, ">=0,-1") Then Return SetError(107, 0, 0)
If Not __GCR_IsNumeric($iExStyle, ">=0,-1") Then Return SetError(108, 0, 0)
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = BitOR($ES_WANTRETURN, $ES_MULTILINE)
If BitAND($iStyle, $ES_MULTILINE) <> 0 Then $iStyle = BitOR($iStyle, $ES_WANTRETURN)
If $iExStyle = -1 Then $iExStyle = 0x200
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
If BitAND($iStyle, $ES_READONLY) = 0 Then $iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_TABSTOP)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
__GCR_Init()
Local $hRichEdit = _WinAPI_CreateWindowEx($iExStyle, $__g_sRTFClassName, "", $iStyle, $iLeft, $iTop, $iWidth,  $iHeight, $hWnd, $nCtrlID)
If $hRichEdit = 0 Then Return SetError(700, 0, False)
__GCR_SetOLECallback($hRichEdit)
_SendMessage($hRichEdit, $__RICHEDITCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($DEFAULT_GUI_FONT), True)
_GUICtrlRichEdit_AppendText($hRichEdit, $sText)
Return $hRichEdit
EndFunc
Func _GUICtrlRichEdit_Cut($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_CUT, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_Deselect($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $EM_SETSEL, -1, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hGUICtrl_LastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlRichEdit_EmptyUndoBuffer($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $EM_EMPTYUNDOBUFFER, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_FindText($hWnd, $sText, $bForward = True, $bMatchCase = False, $bWholeWord = False, $iBehavior = 0)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, -1)
If $sText = "" Then Return SetError(102, 0, -1)
If Not IsBool($bForward) Then Return SetError(103, 0, -1)
If Not IsBool($bMatchCase) Then Return SetError(104, 0, -1)
If Not IsBool($bWholeWord) Then Return SetError(105, 0, -1)
If Not __GCR_IsNumeric($iBehavior) Then Return SetError(1061, 0, -1)
If BitAND($iBehavior, BitNOT(BitOR($FR_MATCHALEFHAMZA, $FR_MATCHDIAC, $FR_MATCHKASHIDA))) <> 0 Then Return SetError(1062, 0, -1)
Local $iLen = StringLen($sText) + 3
Local $tText = DllStructCreate("wchar[" & $iLen & "]")
DllStructSetData($tText, 1, $sText)
Local $tFindtext = DllStructCreate($tagFINDTEXT)
Local $aiAnchorActive
If _GUICtrlRichEdit_IsTextSelected($hWnd) Then
$aiAnchorActive = _GUICtrlRichEdit_GetSelAA($hWnd)
Else
$aiAnchorActive = _GUICtrlRichEdit_GetSel($hWnd)
EndIf
DllStructSetData($tFindtext, 1, $aiAnchorActive[0])
DllStructSetData($tFindtext, 2, ($bForward ? -1 : 0))
DllStructSetData($tFindtext, 3, DllStructGetPtr($tText))
Local Const $FR_DOWN = 0x00000001
Local Const $FR_WHOLEWORD = 0x00000002
Local Const $FR_MATCHCASE = 0x00000004
Local $wParam = 0
If $bForward Then $wParam = $FR_DOWN
If $bWholeWord Then $wParam = BitOR($wParam, $FR_WHOLEWORD)
If $bMatchCase Then $wParam = BitOR($wParam, $FR_MATCHCASE)
$wParam = BitOR($wParam, $iBehavior)
Return _SendMessage($hWnd, $EM_FINDTEXTW, $wParam, $tFindtext, "wparam", "ptr", "struct*")
EndFunc
Func _GUICtrlRichEdit_FindTextInRange($hWnd, $sText, $iStart = 0, $iEnd = -1, $bMatchCase = False, $bWholeWord = False, $iBehavior = 0)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If $sText = "" Then Return SetError(102, 0, 0)
If Not __GCR_IsNumeric($iStart, ">=0,-1") Then Return SetError(103, 0, 0)
If Not __GCR_IsNumeric($iEnd, ">=0,-1") Then Return SetError(104, 0, 0)
If Not IsBool($bMatchCase) Then Return SetError(105, 0, 0)
If Not IsBool($bWholeWord) Then Return SetError(106, 0, 0)
If Not __GCR_IsNumeric($iBehavior) Then Return SetError(1071, 0, 0)
If BitAND($iBehavior, BitNOT(BitOR($FR_MATCHALEFHAMZA, $FR_MATCHDIAC, $FR_MATCHKASHIDA))) <> 0 Then Return SetError(1072, 0, 0)
Local $iLen = StringLen($sText) + 3
Local $tText = DllStructCreate("wchar Text[" & $iLen & "]")
DllStructSetData($tText, "Text", $sText)
Local $tFindtext = DllStructCreate($tagFINDTEXTEX)
DllStructSetData($tFindtext, "cpMin", $iStart)
DllStructSetData($tFindtext, "cpMax", $iEnd)
DllStructSetData($tFindtext, "lpstrText", DllStructGetPtr($tText))
Local Const $FR_DOWN = 0x00000001
Local Const $FR_WHOLEWORD = 0x00000002
Local Const $FR_MATCHCASE = 0x00000004
Local $wParam = 0
If $iEnd >= $iStart Or $iEnd = -1 Then
$wParam = $FR_DOWN
EndIf
If $bWholeWord Then $wParam = BitOR($wParam, $FR_WHOLEWORD)
If $bMatchCase Then $wParam = BitOR($wParam, $FR_MATCHCASE)
$wParam = BitOR($wParam, $iBehavior)
_SendMessage($hWnd, $EM_FINDTEXTEXW, $wParam, $tFindtext, "iWparam", "ptr", "struct*")
Local $aRet[2]
$aRet[0] = DllStructGetData($tFindtext, "cpMinRang")
$aRet[1] = DllStructGetData($tFindtext, "cpMaxRange")
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetCharAttributes($hWnd)
Local Const $aV[17][3] = [  ["bo", $CFM_BOLD, $CFE_BOLD], ["di", $CFM_DISABLED, $CFE_DISABLED],  ["em", $CFM_EMBOSS, $CFE_EMBOSS], ["hi", $CFM_HIDDEN, $CFE_HIDDEN],  ["im", $CFM_IMPRINT, $CFE_IMPRINT], ["it", $CFM_ITALIC, $CFE_ITALIC],  ["li", $CFM_LINK, $CFE_LINK], ["ou", $CFM_OUTLINE, $CFE_OUTLINE],  ["pr", $CFM_PROTECTED, $CFE_PROTECTED], ["re", $CFM_REVISED, $CFE_REVISED],  ["sh", $CFM_SHADOW, $CFE_SHADOW], ["sm", $CFM_SMALLCAPS, $CFE_SMALLCAPS],  ["st", $CFM_STRIKEOUT, $CFE_STRIKEOUT], ["sb", $CFM_SUBSCRIPT, $CFE_SUBSCRIPT],  ["sp", $CFM_SUPERSCRIPT, $CFE_SUPERSCRIPT], ["un", $CFM_UNDERLINE, $CFE_UNDERLINE],  ["al", $CFM_ALLCAPS, $CFE_ALLCAPS]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then Return SetError(-1, 0, "")
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
Local $iMask = _SendMessage($hWnd, $EM_GETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*")
Local $iEffects = DllStructGetData($tCharFormat, 3)
Local $sStatesAndAtts = "", $sState, $bM, $bE
For $i = 0 To UBound($aV, $UBOUND_ROWS) - 1
$bM = BitAND($iMask, $aV[$i][1]) = $aV[$i][1]
$bE = BitAND($iEffects, $aV[$i][2]) = $aV[$i][2]
If $bM Then
If $bE Then
$sState = "+"
Else
$sState = "-"
EndIf
Else
$sState = "~"
EndIf
If $sState <> "-" Then $sStatesAndAtts &= $aV[$i][0] & $sState
Next
Return $sStatesAndAtts
EndFunc
Func _GUICtrlRichEdit_GetCharBkColor($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
__GCR_SendGetCharFormatMessage($hWnd, $tCharFormat)
Local $iEffects = DllStructGetData($tCharFormat, 3)
Local $iBkColor
If BitAND($iEffects, $CFE_AUTOBACKCOLOR) = $CFE_AUTOBACKCOLOR Then
$iBkColor = _WinAPI_GetSysColor($__RICHEDITCONSTANT_COLOR_WINDOWTEXT)
Else
$iBkColor = DllStructGetData($tCharFormat, 12)
EndIf
Return SetExtended(BitAND($iEffects, $CFM_BACKCOLOR) <> 0, $iBkColor)
EndFunc
Func _GUICtrlRichEdit_GetCharColor($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
__GCR_SendGetCharFormatMessage($hWnd, $tCharFormat)
Local $iEffects = DllStructGetData($tCharFormat, 3)
Local $iColor
If BitAND($iEffects, $CFE_AUTOCOLOR) = $CFE_AUTOCOLOR Then
$iColor = _WinAPI_GetSysColor($__RICHEDITCONSTANT_COLOR_WINDOWTEXT)
Else
$iColor = DllStructGetData($tCharFormat, 6)
EndIf
Return SetExtended(BitAND($iEffects, $CFM_COLOR) <> 0, $iColor)
EndFunc
Func _GUICtrlRichEdit_GetCharPosFromXY($hWnd, $iX, $iY)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iX) Then Return SetError(102, 0, 0)
If Not __GCR_IsNumeric($iY) Then Return SetError(103, 0, 0)
Local $aiRect = _GUICtrlRichEdit_GetRECT($hWnd)
If $iX < $aiRect[0] Or $iX > $aiRect[2] Or $iY < $aiRect[1] Or $iY > $aiRect[3] Then Return -1
Local $tPointL = DllStructCreate("LONG x; LONG y;")
DllStructSetData($tPointL, 1, $iX)
DllStructSetData($tPointL, 2, $iY)
Local $iRet = _SendMessage($hWnd, $EM_CHARFROMPOS, 0, $tPointL, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(-1, 0, 0)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetCharPosOfNextWord($hWnd, $iCpStart)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iCpStart) Then Return SetError(102, 0, 0)
Return _SendMessage($hWnd, $EM_FINDWORDBREAK, $WB_MOVEWORDRIGHT, $iCpStart)
EndFunc
Func _GUICtrlRichEdit_GetCharPosOfPreviousWord($hWnd, $iCpStart)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iCpStart) Then Return SetError(102, 0, 0)
Return _SendMessage($hWnd, $EM_FINDWORDBREAK, $WB_MOVEWORDLEFT, $iCpStart)
EndFunc
Func _GUICtrlRichEdit_GetCharWordBreakInfo($hWnd, $iCp)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not __GCR_IsNumeric($iCp) Then Return SetError(102, 0, "")
Local $iRet = _SendMessage($hWnd, $EM_FINDWORDBREAK, $WB_CLASSIFY, $iCp)
Local $iClass = BitAND($iRet, 0xF0)
Local $sRet = ""
If BitAND($iClass, $WBF_BREAKAFTER) Then $sRet &= "c"
If BitAND($iClass, $WBF_BREAKLINE) Then $sRet &= "d"
If BitAND($iClass, $WBF_ISWHITE) Then $sRet &= "w"
$sRet &= ";" & BitAND($iRet, 0xF)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetBkColor($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $iBkColor = _SendMessage($hWnd, $EM_SETBKGNDCOLOR, False, 0)
_SendMessage($hWnd, $EM_SETBKGNDCOLOR, False, $iBkColor)
Return $iBkColor
EndFunc
Func _GUICtrlRichEdit_GetText($hWnd, $bCrToCrLf = False, $iCodePage = 0, $sReplChar = "")
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not IsBool($bCrToCrLf) Then Return SetError(102, 0, "")
If Not __GCR_IsNumeric($iCodePage) Then Return SetError(103, 0, "")
Local $iLen = _GUICtrlRichEdit_GetTextLength($hWnd, False, True) + 1
Local $sUni = ''
If $iCodePage = $CP_UNICODE Or Not $iCodePage Then $sUni = "w"
Local $tText = DllStructCreate($sUni & "char[" & $iLen & "]")
Local $tGetTextEx = DllStructCreate($tagGETTEXTEX)
DllStructSetData($tGetTextEx, "cb", DllStructGetSize($tText))
Local $iFlags = 0
If $bCrToCrLf Then $iFlags = $GT_USECRLF
DllStructSetData($tGetTextEx, "flags", $iFlags)
If $iCodePage = 0 Then $iCodePage = $CP_UNICODE
DllStructSetData($tGetTextEx, "codepage", $iCodePage)
Local $pUsedDefChar = 0, $pDefaultChar = 0
If $sReplChar <> "" Then
Local $tDefaultChar = DllStructCreate("char")
$pDefaultChar = DllStructGetPtr($tDefaultChar, 1)
DllStructSetData($tDefaultChar, 1, $sReplChar)
Local $tUsedDefChar = DllStructCreate("bool")
$pUsedDefChar = DllStructGetPtr($tUsedDefChar, 1)
EndIf
DllStructSetData($tGetTextEx, "lpDefaultChar", $pDefaultChar)
DllStructSetData($tGetTextEx, "lpbUsedDefChar", $pUsedDefChar)
Local $iRet = _SendMessage($hWnd, $EM_GETTEXTEX, $tGetTextEx, $tText, 0, "struct*", "struct*")
If $iRet = 0 Then Return SetError(700, 0, "")
If $sReplChar <> "" Then SetExtended(DllStructGetData($tUsedDefChar, 1) <> 0)
Return DllStructGetData($tText, 1)
EndFunc
Func _GUICtrlRichEdit_GetTextLength($hWnd, $bExact = True, $bChars = False, $iUseCrLf = 1)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not IsBool($bExact) Then Return SetError(102, 0, 0)
If Not IsBool($bChars) Then Return SetError(103, 0, 0)
Local $tGetTextLen = DllStructCreate($tagGETTEXTLENGTHEX)
Local $iFlags = BitOR($iUseCrLf * $GTL_USECRLF, ($bExact ? $GTL_PRECISE : $GTL_CLOSE))
$iFlags = BitOR($iFlags, ($bChars ? $GTL_DEFAULT : $GTL_NUMBYTES))
DllStructSetData($tGetTextLen, 1, $iFlags)
DllStructSetData($tGetTextLen, 2, ($bChars ? $CP_ACP : $CP_UNICODE))
Local $iRet = _SendMessage($hWnd, $EM_GETTEXTLENGTHEX, $tGetTextLen, 0, 0, "struct*")
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetZoom($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $wParam = 0, $lParam = 0
Local $aI = _SendMessage($hWnd, $EM_GETZOOM, $wParam, $lParam, -1, "int*", "int*")
If Not $aI[0] Then Return SetError(700, 0, 0)
Local $iRet
If $aI[3] = 0 And $aI[4] = 0 Then
$iRet = 100
Else
$iRet = $aI[3] / $aI[4] * 100
EndIf
Return StringFormat("%.2f", $iRet)
EndFunc
Func _GUICtrlRichEdit_GetFirstCharPosOnLine($hWnd, $iLine = -1)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iLine, ">0,-1") Then Return SetError(1021, 0, 0)
If $iLine <> -1 Then $iLine -= 1
Local $iRet = _SendMessage($hWnd, $EM_LINEINDEX, $iLine)
If $iRet = -1 Then Return SetError(1022, 0, 0)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetFont($hWnd)
Local $aRet[3] = [0, "", 0]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, "cbSize", DllStructGetSize($tCharFormat))
__GCR_SendGetCharFormatMessage($hWnd, $tCharFormat)
If BitAND(DllStructGetData($tCharFormat, "dwMask"), $CFM_FACE) = $CFM_FACE Then  $aRet[1] = DllStructGetData($tCharFormat, "szFaceName")
If BitAND(DllStructGetData($tCharFormat, "dwMask"), $CFM_SIZE) = $CFM_SIZE Then  $aRet[0] = DllStructGetData($tCharFormat, "yHeight") / 20
If BitAND(DllStructGetData($tCharFormat, "dwMask"), $CFM_CHARSET) = $CFM_CHARSET Then  $aRet[2] = DllStructGetData($tCharFormat, "bCharSet")
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetRECT($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tRECT = DllStructCreate($tagRECT)
_SendMessage($hWnd, $EM_GETRECT, 0, $tRECT, 0, "wparam", "struct*")
Local $aiRect[4]
$aiRect[0] = DllStructGetData($tRECT, "Left")
$aiRect[1] = DllStructGetData($tRECT, "Top")
$aiRect[2] = DllStructGetData($tRECT, "Right")
$aiRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aiRect
EndFunc
Func _GUICtrlRichEdit_GetLineCount($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Return _SendMessage($hWnd, $EM_GETLINECOUNT)
EndFunc
Func _GUICtrlRichEdit_GetLineLength($hWnd, $iLine)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iLine, ">0,-1") Then Return SetError(102, 0, 0)
Local $iCharPos = _GUICtrlRichEdit_GetFirstCharPosOnLine($hWnd, $iLine)
Local $iRet = _SendMessage($hWnd, $EM_LINELENGTH, $iCharPos)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetLineNumberFromCharPos($hWnd, $iCharPos)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iCharPos, ">=0") Then Return SetError(102, 0, 0)
Return _SendMessage($hWnd, $EM_EXLINEFROMCHAR, 0, $iCharPos) + 1
EndFunc
Func _GUICtrlRichEdit_GetNextRedo($hWnd, $bName = True)
Local Const $aS[6] = ["Unknown", "Typing", "Delete", "Drag and drop", "Cut", "Paste"]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not IsBool($bName) Then Return SetError(102, 0, "")
Local $iUid = _SendMessage($hWnd, $EM_GETREDONAME, 0, 0)
If $bName Then
Return $aS[$iUid]
Else
Return $iUid
EndIf
EndFunc
Func _GUICtrlRichEdit_GetNextUndo($hWnd, $bName = True)
Local Const $aS[6] = ["Unknown", "Typing", "Delete", "Drag and drop", "Cut", "Paste"]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not IsBool($bName) Then Return SetError(102, 0, "")
Local $iUid = _SendMessage($hWnd, $EM_GETUNDONAME, 0, 0)
If $bName Then
Return $aS[$iUid]
Else
Return $iUid
EndIf
EndFunc
Func _GUICtrlRichEdit_GetNumberOfFirstVisibleLine($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Return _SendMessage($hWnd, $EM_GETFIRSTVISIBLELINE) + 1
EndFunc
Func _GUICtrlRichEdit_GetParaAlignment($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, 2)
Local $iAlignment = DllStructGetData($tParaFormat, 8)
Local $sRet = ""
Switch ($iAlignment)
Case $PFA_LEFT
$sRet = "l"
Case $PFA_CENTER
$sRet = "c"
Case $PFA_RIGHT
$sRet = "r"
Case $PFA_JUSTIFY
$sRet = "j"
Case $PFA_FULL_INTERWORD
$sRet = "w"
EndSwitch
$sRet &= ";" & __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_ALIGNMENT)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaAttributes($hWnd)
Local Enum $eAbbrev = 0, $eEffect, $eInverted
Local Const $aV[9][3] = [  ["fpg", $PFE_PAGEBREAKBEFORE, False],  ["hyp", $PFE_DONOTHYPHEN, True],  ["kpt", $PFE_KEEP, False],  ["kpn", $PFE_KEEPNEXT, False],  ["pwo", $PFE_NOWIDOWCONTROL, False],  ["r2l", $PFE_RTLPARA, False],  ["row", $PFE_TABLE, False],  ["sbs", $PFE_SIDEBYSIDE, False],  ["sln", $PFE_NOLINENUMBER, False]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iEffects = DllStructGetData($tParaFormat, "wEffects")
Local $sStatesAndAtts = "", $sState
For $i = 0 To UBound($aV, $UBOUND_ROWS) - 1
$sStatesAndAtts &= $aV[$i][$eAbbrev]
If BitAND($iEffects, $aV[$i][$eEffect]) = $aV[$i][$eEffect] Then
$sState = ($aV[$i][$eInverted] ? "-" : "+")
Else
$sState = ($aV[$i][$eInverted] ? "+" : "-")
EndIf
$sStatesAndAtts &= $sState & ";"
Next
$sStatesAndAtts &= (_GUICtrlRichEdit_IsTextSelected($hWnd) ? "f" : "c")
Return $sStatesAndAtts
EndFunc
Func _GUICtrlRichEdit_GetParaBorder($hWnd)
Local Const $avLocs[6][2] = [["l", 1], ["r", 2], ["t", 4], ["b", 8], ["i", 16], ["o", 32]]
Local Const $avLS[12] = ["none", .75, 1.5, 2.25, 3, 4.5, 6, ".75d", "1.5d", "2.25d", ".75g", ".75gd"]
Local Const $sClrs = "blk;blu;cyn;grn;mag;red;yel;whi;dbl;dgn;dmg;drd;dyl;dgy;lgy;"
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, 2)
Local $iSpace = DllStructGetData($tParaFormat, 22)
Local $iBorders = DllStructGetData($tParaFormat, 24)
Local $sRet = ""
For $i = 0 To UBound($avLocs, $UBOUND_ROWS) - 1
If BitAND($iBorders, $avLocs[$i][1]) Then $sRet &= $avLocs[$i][0]
Next
$sRet &= ";"
$sRet &= $avLS[BitShift(BitAND($iBorders, 0xF00), 8)]
$sRet &= ";"
If BitAND($iBorders, 64) Then
$sRet &= "aut"
Else
$sRet &= StringMid($sClrs, BitShift(BitAND($iBorders, 0xF000), 12) * 4 + 1, 3)
EndIf
$sRet &= ";"
$sRet &= __GCR_ConvertTwipsToSpaceUnit($iSpace) & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_BORDER)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaIndents($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, "dwMask", BitOR($PFM_STARTINDENT, $PFM_OFFSET))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, "dwMask")
Local $iIdxSI = DllStructGetData($tParaFormat, "dxStartIndent")
Local $iIdxOfs = DllStructGetData($tParaFormat, "dxOffset")
Local $iDxRI = DllStructGetData($tParaFormat, "dxRightIndent")
Local $iLeft = __GCR_ConvertTwipsToSpaceUnit($iIdxSI + $iIdxOfs)
Local $iFirstLine = __GCR_ConvertTwipsToSpaceUnit(-$iIdxOfs)
Local $iRight = __GCR_ConvertTwipsToSpaceUnit($iDxRI)
Local $iRet = $iLeft & ";" & $iRight & ";" & $iFirstLine & ";" & __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_STARTINDENT)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetParaNumbering($hWnd)
Local Const $avRoman[7][2] = [[1000, "m"], [500, "d"], [100, "c"], [50, "l"], [10, "x"], [5, "v"], [1, "i"]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, 2, BitOR($PFM_NUMBERING, $PFM_NUMBERINGSTART, $PFM_NUMBERINGSTYLE))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, "dwMask")
Local $iChar = DllStructGetData($tParaFormat, "wNumbering")
Local $iStart = DllStructGetData($tParaFormat, "wNumberingStart")
Local $iStyle = DllStructGetData($tParaFormat, "wNumberingStyle")
Local $iTab = DllStructGetData($tParaFormat, "wNumberingTab")
Local $sRet = ""
Switch $iChar
Case 0
$sRet = ""
Case 1
$sRet = "."
Case 2
$sRet = $iStart
Case 3
$sRet = Chr(Asc("a") + $iStart - 1)
Case 4
$sRet = Chr(Asc("a") + $iStart - 1)
Case 5, 6
For $i = 0 To UBound($avRoman, $UBOUND_ROWS) - 2 Step 2
For $j = $i To $i + 1
While $iStart >= $avRoman[$j][0]
$sRet &= $avRoman[$j][1]
$iStart -= $avRoman[$j][0]
WEnd
If $iStart = $avRoman[$j][0] - 1 Then
$sRet &= $avRoman[$i + 2][1] & $avRoman[$j][1]
$iStart -= $avRoman[$j][0] - $avRoman[$i + 2][0]
EndIf
Next
Next
While $iStart > 0
$sRet &= "i"
$iStart -= 1
WEnd
If $iChar = 6 Then $sRet = StringUpper($sRet)
EndSwitch
If $iChar > 1 Then
Switch $iStyle
Case 0
$sRet &= ")"
Case 0x100
$sRet = "(" & $sRet & ")"
Case 0x200
$sRet &= "."
Case 0x300
EndSwitch
EndIf
Local $aV = _GUICtrlRichEdit_GetFont($hWnd)
Local $iPoints = $aV[0]
Local $iQspaces = Round($iTab / ($iPoints * 20), 0)
For $i = 1 To $iQspaces
$sRet &= " "
Next
$sRet &= ";"
$sRet &= (($iChar = 5 Or $iChar = 6) ? "Roman;" : ";")
$sRet &= __GCR_ConvertTwipsToSpaceUnit($iTab) & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, BitOR($PFM_NUMBERING, $PFM_NUMBERINGSTART, $PFM_NUMBERINGSTYLE))
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaShading($hWnd)
Local Const $asStyles[13] = ["non", "dhz", "dvt", "ddd", "dud", "dgr", "dtr", "lhz", "lrt", "ldd", "lud",  "lgr", "ltr"]
Local Const $asClrs[16] = ["blk", "blu", "cyn", "grn", "mag", "red", "yel", "whi", "dbl", "dgn", "dmg",  "drd", "dyl", "dgy", "lgy"]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, "dwMask")
Local $iWeight = DllStructGetData($tParaFormat, "wShadingWeight")
Local $iS = DllStructGetData($tParaFormat, "wShadingStyle")
Local $sRet = $iWeight & ";"
Local $iN = BitAND($iS, 0xF)
$sRet &= $asStyles[$iN] & ";"
$iN = BitShift(BitAND($iS, 0xF0), 4)
$sRet &= $asClrs[$iN] & ";"
$iN = BitShift(BitAND($iS, 0xF00), 8)
$sRet &= $asClrs[$iN] & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_SHADING)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaSpacing($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iInter = DllStructGetData($tParaFormat, "dyLineSpacing")
Local $iRule = DllStructGetData($tParaFormat, "bLineSpacingRule")
Local $sRet = ""
Switch $iRule
Case 0
$sRet = "1 line;"
Case 1
$sRet = "1.5 lines;"
Case 2
$sRet = "2 lines;"
Case 3, 4
$sRet = __GCR_ConvertTwipsToSpaceUnit($iInter) & ";"
Case 5
$sRet = StringFormat("%.2f", $iInter / 20) & " lines;"
EndSwitch
Local $iMask = 0
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_LINESPACING) & ";"
Local $iBefore = DllStructGetData($tParaFormat, "dySpaceBefore")
$sRet &= __GCR_ConvertTwipsToSpaceUnit($iBefore) & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_SPACEBEFORE) & ";"
Local $iAfter = DllStructGetData($tParaFormat, "dySPaceAfter")
$sRet &= __GCR_ConvertTwipsToSpaceUnit($iAfter) & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_SPACEAFTER)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaTabStops($hWnd)
Local Const $asKind[5] = ["l", "c", "r", "d", "b"], $asLeader[6] = [" ", ".", "-", "_", "t", "="]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, "dwMask")
Local $iQtabs = DllStructGetData($tParaFormat, "cTabCount")
Local $sRet = $iQtabs & ";"
Local $iN, $iM
For $i = 1 To $iQtabs
$iN = DllStructGetData($tParaFormat, "rgxTabs", $i)
$sRet &= __GCR_ConvertTwipsToSpaceUnit(BitAND($iN, 0xFFFFF))
$iM = BitAND(BitShift($iN, 24), 0xF)
$sRet &= $asKind[$iM]
$iM = BitAND(BitShift($iN, 28), 0xF)
$sRet &= $asLeader[$iM] & ";"
Next
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_TABSTOPS)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetPasswordChar($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $n = _SendMessage($hWnd, $EM_GETPASSWORDCHAR)
Return ($n = 0) ? "" : Chr($n)
EndFunc
Func _GUICtrlRichEdit_GetScrollPos($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tPoint = DllStructCreate($tagPOINT)
_SendMessage($hWnd, $EM_GETSCROLLPOS, 0, $tPoint, 0, "wparam", "struct*")
Local $aRet[2]
$aRet[0] = DllStructGetData($tPoint, "x")
$aRet[1] = DllStructGetData($tPoint, "y")
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetSel($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tCharRange = DllStructCreate($tagCHARRANGE)
_SendMessage($hWnd, $EM_EXGETSEL, 0, $tCharRange, 0, "wparam", "struct*")
Local $aRet[2]
$aRet[0] = DllStructGetData($tCharRange, 1)
$aRet[1] = DllStructGetData($tCharRange, 2)
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetSelAA($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $aiLowHigh = _GUICtrlRichEdit_GetSel($hWnd)
If $aiLowHigh[0] = $aiLowHigh[1] Then Return SetError(-1, 0, 0)
_SendMessage($hWnd, $EM_SETSEL, -1, 0)
Local $aiNoSel = _GUICtrlRichEdit_GetSel($hWnd)
Local $aRet[2]
If $aiLowHigh[0] = $aiNoSel[0] Then
$aRet[0] = $aiLowHigh[1]
$aRet[1] = $aiLowHigh[0]
Else
$aRet = $aiLowHigh
EndIf
_SendMessage($hWnd, $EM_SETSEL, $aiLowHigh[0], $aiLowHigh[1])
_WinAPI_SetFocus($hWnd)
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetSelText($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then Return SetError(-1, 0, -1)
Local $aiLowHigh = _GUICtrlRichEdit_GetSel($hWnd)
Local $tText = DllStructCreate("wchar[" & $aiLowHigh[1] - $aiLowHigh[0] + 1 & "]")
_SendMessage($hWnd, $EM_GETSELTEXT, 0, $tText, 0, "wparam", "struct*")
Return DllStructGetData($tText, 1)
EndFunc
Func _GUICtrlRichEdit_GetSpaceUnit()
Switch $__g_iRTFTwipsPeSpaceUnit
Case 1440
Return "in"
Case 567
Return "cm"
Case 56.7
Return "mm"
Case 20
Return "pt"
Case 1
Return "tw"
EndSwitch
EndFunc
Func _GUICtrlRichEdit_GetTextInLine($hWnd, $iLine)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iLine, ">0,-1") Then Return SetError(1021, 0, False)
If $iLine > _GUICtrlRichEdit_GetLineCount($hWnd) Then Return SetError(1022, 0, False)
Local $iLen = _GUICtrlRichEdit_GetLineLength($hWnd, $iLine)
If $iLen = 0 Then Return ""
Local $tBuffer = DllStructCreate("short Len;wchar Text[" & $iLen + 2 & "]")
DllStructSetData($tBuffer, "Len", $iLen + 2)
If $iLine <> -1 Then $iLine -= 1
Local $iRet = _SendMessage($hWnd, $EM_GETLINE, $iLine, $tBuffer, 10, "wparam", "struct*")
If $iRet = 0 Then Return SetError(700, 0, False)
Local $tString = DllStructCreate("wchar Text[" & $iLen + 1 & "]", DllStructGetPtr($tBuffer))
Return StringLeft(DllStructGetData($tString, "Text"), $iLen)
EndFunc
Func _GUICtrlRichEdit_GetTextInRange($hWnd, $iStart, $iEnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iStart, ">=0") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iEnd, ">=0,-1") Then Return SetError(1031, 0, False)
If Not ($iEnd > $iStart Or $iEnd = -1) Then Return SetError(1032, 0, False)
Local $iLen = _GUICtrlRichEdit_GetTextLength($hWnd)
Local $tText = DllStructCreate("wchar[" & ($iLen + 4) & "]")
Local $tTextRange = DllStructCreate($tagTEXTRANGE)
DllStructSetData($tTextRange, 1, $iStart)
DllStructSetData($tTextRange, 2, $iEnd)
DllStructSetData($tTextRange, 3, DllStructGetPtr($tText))
_SendMessage($hWnd, $EM_GETTEXTRANGE, 0, $tTextRange, 0, "wparam", "struct*")
Return DllStructGetData($tText, 1)
EndFunc
Func _GUICtrlRichEdit_GetVersion()
Return $__g_sRTFVersion
EndFunc
Func _GUICtrlRichEdit_GetXYFromCharPos($hWnd, $iCharPos)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iCharPos, ">=0") Then Return SetError(1021, 0, 0)
If $iCharPos > _GUICtrlRichEdit_GetTextLength($hWnd) Then Return SetError(1022, 0, 0)
Local $tPoint = DllStructCreate($tagPOINT)
_SendMessage($hWnd, $EM_POSFROMCHAR, $tPoint, $iCharPos, 0, "struct*", "lparam")
Local $aRet[2]
$aRet[0] = DllStructGetData($tPoint, "X")
$aRet[1] = DllStructGetData($tPoint, "Y")
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GotoCharPos($hWnd, $iCharPos)
If $iCharPos > _GUICtrlRichEdit_GetTextLength($hWnd, True, True, 0) Then Return SetError(103, 0, False)
_GUICtrlRichEdit_SetSel($hWnd, $iCharPos, $iCharPos)
If @error Then Return SetError(@error, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_HideSelection($hWnd, $bHide = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bHide) Then Return SetError(102, 0, False)
_SendMessage($hWnd, $EM_HIDESELECTION, $bHide, 0)
_WinAPI_SetFocus($hWnd)
EndFunc
Func _GUICtrlRichEdit_InsertText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If $sText = "" Then Return SetError(102, 0, False)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_SELECTION)
_GUICtrlRichEdit_Deselect($hWnd)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
DllStructSetData($tSetText, 2, $CP_ACP)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(103, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_IsModified($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_GETMODIFY) <> 0
EndFunc
Func _GUICtrlRichEdit_IsTextSelected($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tCharRange = DllStructCreate($tagCHARRANGE)
_SendMessage($hWnd, $EM_EXGETSEL, 0, $tCharRange, 0, "wparam", "struct*")
Return DllStructGetData($tCharRange, 2) <> DllStructGetData($tCharRange, 1)
EndFunc
Func _GUICtrlRichEdit_Paste($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_PASTE, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_PasteSpecial($hWnd, $bAndObjects = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iN = ($bAndObjects ? $__g_sGRE_CF_RETEXTOBJ : $__g_sGRE_CF_RTF)
_SendMessage($hWnd, $EM_PASTESPECIAL, $iN, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_PauseRedraw($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_SETREDRAW, False)
EndFunc
Func _GUICtrlRichEdit_Redo($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_REDO, 0, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_ReplaceText($hWnd, $sText, $bCanUndo = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bCanUndo) Then Return SetError(103, 0, False)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then Return SetError(-1, 0, False)
Local $tText = DllStructCreate("wchar Text[" & StringLen($sText) + 1 & "]")
DllStructSetData($tText, "Text", $sText)
__GUICtrl_SendMsg($hWnd, $EM_REPLACESEL, $bCanUndo, $tText)
Return True
EndFunc
Func _GUICtrlRichEdit_ResumeRedraw($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_SETREDRAW, True)
Return _WinAPI_InvalidateRect($hWnd)
EndFunc
Func _GUICtrlRichEdit_ScrollLineOrPage($hWnd, $sAction)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If StringLen($sAction) <> 2 Then Return SetError(1021, 0, 0)
Local $sCh = StringLeft($sAction, 1)
If Not ($sCh = "l" Or $sCh = "p") Then Return SetError(1022, 0, 0)
$sCh = StringRight($sAction, 1)
If Not ($sCh = "d" Or $sCh = "u") Then Return SetError(1023, 0, 0)
Local $wParam = 0
Switch $sAction
Case "ld"
$wParam = $__RICHEDITCONSTANT_SB_LINEDOWN
Case "lu"
$wParam = $__RICHEDITCONSTANT_SB_LINEUP
Case "pd"
$wParam = $__RICHEDITCONSTANT_SB_PAGEDOWN
Case "pu"
$wParam = $__RICHEDITCONSTANT_SB_PAGEUP
EndSwitch
Local $iRet = _SendMessage($hWnd, $EM_SCROLL, $wParam, 0)
$iRet = BitAND($iRet, 0xFFFF)
If BitAND($iRet, 0x8000) <> 0 Then $iRet = BitOR($iRet, 0xFFFF0000)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_ScrollLines($hWnd, $iQlines)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iQlines) Then SetError(102, 0, False)
Local $iRet = _SendMessage($hWnd, $EM_LINESCROLL, 0, $iQlines)
If $iRet = 0 Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_ScrollToCaret($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $EM_SCROLLCARET, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_SetCharAttributes($hWnd, $sStatesAndEffects, $bWord = False)
Local Const $aV[17][3] = [  ["bo", $CFM_BOLD, $CFE_BOLD], ["di", $CFM_DISABLED, $CFE_DISABLED],  ["em", $CFM_EMBOSS, $CFE_EMBOSS], ["hi", $CFM_HIDDEN, $CFE_HIDDEN],  ["im", $CFM_IMPRINT, $CFE_IMPRINT], ["it", $CFM_ITALIC, $CFE_ITALIC],  ["li", $CFM_LINK, $CFE_LINK], ["ou", $CFM_OUTLINE, $CFE_OUTLINE],  ["pr", $CFM_PROTECTED, $CFE_PROTECTED], ["re", $CFM_REVISED, $CFE_REVISED],  ["sh", $CFM_SHADOW, $CFE_SHADOW], ["sm", $CFM_SMALLCAPS, $CFE_SMALLCAPS],  ["st", $CFM_STRIKEOUT, $CFE_STRIKEOUT], ["sb", $CFM_SUBSCRIPT, $CFE_SUBSCRIPT],  ["sp", $CFM_SUPERSCRIPT, $CFE_SUPERSCRIPT], ["un", $CFM_UNDERLINE, $CFE_UNDERLINE],  ["al", $CFM_ALLCAPS, $CFE_ALLCAPS]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bWord) Then Return SetError(103, 0, False)
Local $iMask = 0, $iEffects = 0, $n, $s
For $i = 1 To StringLen($sStatesAndEffects) Step 3
$s = StringMid($sStatesAndEffects, $i + 1, 2)
$n = -1
For $j = 0 To UBound($aV) - 1
If $aV[$j][0] = $s Then
$n = $j
ExitLoop
EndIf
Next
If $n = -1 Then Return SetError(1023, $s, False)
$iMask = BitOR($iMask, $aV[$n][1])
$s = StringMid($sStatesAndEffects, $i, 1)
Switch $s
Case "+"
$iEffects = BitOR($iEffects, $aV[$n][2])
Case "-"
Case Else
Return SetError(1022, $s, False)
EndSwitch
Next
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
DllStructSetData($tCharFormat, 2, $iMask)
DllStructSetData($tCharFormat, 3, $iEffects)
Local $wParam = ($bWord ? BitOR($SCF_WORD, $SCF_SELECTION) : $SCF_SELECTION)
Local $iRet = _SendMessage($hWnd, $EM_SETCHARFORMAT, $wParam, $tCharFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetCharBkColor($hWnd, $iBkColor = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iBkColor = Default Then
DllStructSetData($tCharFormat, 3, $CFE_AUTOBACKCOLOR)
$iBkColor = 0
Else
If BitAND($iBkColor, 0xff000000) Then Return SetError(1022, 0, False)
EndIf
DllStructSetData($tCharFormat, 2, $CFM_BACKCOLOR)
DllStructSetData($tCharFormat, 12, $iBkColor)
Return _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetCharColor($hWnd, $iColor = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iColor = Default Then
DllStructSetData($tCharFormat, 3, $CFE_AUTOCOLOR)
$iColor = 0
Else
If BitAND($iColor, 0xff000000) Then Return SetError(1022, 0, False)
EndIf
DllStructSetData($tCharFormat, 2, $CFM_COLOR)
DllStructSetData($tCharFormat, 6, $iColor)
Return _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetBkColor($hWnd, $iBngColor = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $bSysColor = False
If $iBngColor = Default Then
$bSysColor = True
$iBngColor = 0
Else
If BitAND($iBngColor, 0xff000000) Then Return SetError(1022, 0, False)
EndIf
_SendMessage($hWnd, $EM_SETBKGNDCOLOR, $bSysColor, $iBngColor)
Return True
EndFunc
Func _GUICtrlRichEdit_SetLimitOnText($hWnd, $iNewLimit)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iNewLimit, ">=0") Then Return SetError(102, 0, False)
If $iNewLimit < 65535 Then $iNewLimit = 0
_SendMessage($hWnd, $EM_EXLIMITTEXT, 0, $iNewLimit)
Return True
EndFunc
Func _GUICtrlRichEdit_SetTabStops($hWnd, $vTabStops, $bRedraw = True)
Local Const $iTwipsPerDU = 18.75
Local $tTabStops, $tagTabStops = "", $wParam
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bRedraw) Then Return SetError(103, 0, False)
If IsString($vTabStops) Then
If $vTabStops = "" Then Return SetError(1023, 0, False)
Local $aS = StringSplit($vTabStops, ";")
Local $iNumTabStops = $aS[0]
For $i = 1 To $iNumTabStops
If Not __GCR_IsNumeric($aS[$i], ">0") Then Return SetError(1022, 0, False)
$tagTabStops &= "int;"
Next
$tagTabStops = StringTrimRight($tagTabStops, 1)
$tTabStops = DllStructCreate($tagTabStops)
For $i = 1 To $iNumTabStops
DllStructSetData($tTabStops, $i, $aS[$i] * $__g_iRTFTwipsPeSpaceUnit / $iTwipsPerDU)
Next
$wParam = $iNumTabStops
ElseIf IsNumber($vTabStops) Then
If __GCR_IsNumeric($vTabStops, ">0") Then
$tTabStops = DllStructCreate("int")
DllStructSetData($tTabStops, 1, $vTabStops * $__g_iRTFTwipsPeSpaceUnit / $iTwipsPerDU)
$wParam = 1
Else
Return SetError(1024, 9, False)
EndIf
Else
Return SetError(1021, 0, False)
EndIf
Local $bResult = _SendMessage($hWnd, $EM_SETTABSTOPS, $wParam, $tTabStops, 0, "wparam", "struct*") <> 0
If $bRedraw Then _WinAPI_InvalidateRect($hWnd)
Return $bResult
EndFunc
Func _GUICtrlRichEdit_SetZoom($hWnd, $iPercent)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iPercent, ">0") Then Return SetError(1021, 0, False)
Local $iNumerator, $iDenominator
Select
Case Not ($iPercent = 100 Or ($iPercent >= 200 And $iPercent < 6400))
Return SetError(1022, 0, False)
Case $iPercent >= 100
$iNumerator = 10000
$iDenominator = 10000 / ($iPercent / 100)
Case Else
$iNumerator = 10000 * ($iPercent / 100)
$iDenominator = 10000
EndSelect
Return _SendMessage($hWnd, $EM_SETZOOM, $iNumerator, $iDenominator) <> 0
EndFunc
Func _GUICtrlRichEdit_SetEventMask($hWnd, $iEventMask)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iEventMask) Then Return SetError(102, 0, False)
_SendMessage($hWnd, $EM_SETEVENTMASK, 0, $iEventMask)
Return True
EndFunc
Func _GUICtrlRichEdit_SetFont($hWnd, $iPoints = Default, $sName = Default, $iCharset = Default, $iLcid = Default)
Local $iDwMask = 0
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iPoints = Default Or __GCR_IsNumeric($iPoints, ">0")) Then Return SetError(102, 0, False)
If $sName <> Default Then
Local $aS = StringSplit($sName, " ")
For $i = 1 To UBound($aS) - 1
If Not StringIsAlpha($aS[$i]) Then Return SetError(103, 0, False)
Next
EndIf
If Not ($iCharset = Default Or __GCR_IsNumeric($iCharset)) Then Return SetError(104, 0, False)
If Not ($iLcid = Default Or __GCR_IsNumeric($iLcid)) Then Return SetError(105, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iPoints <> Default Then
$iDwMask = $CFM_SIZE
DllStructSetData($tCharFormat, 4, Int($iPoints * 20))
EndIf
If $sName <> Default Then
If StringLen($sName) > $LF_FACESIZE - 1 Then SetError(-1, 0, False)
$iDwMask = BitOR($iDwMask, $CFM_FACE)
DllStructSetData($tCharFormat, 9, $sName)
EndIf
If $iCharset <> Default Then
$iDwMask = BitOR($iDwMask, $CFM_CHARSET)
DllStructSetData($tCharFormat, 7, $iCharset)
EndIf
If $iLcid <> Default Then
$iDwMask = BitOR($iDwMask, $CFM_LCID)
DllStructSetData($tCharFormat, 13, $iLcid)
EndIf
DllStructSetData($tCharFormat, 2, $iDwMask)
Local $iRet = _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(@error + 200, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetRECT($hWnd, $iLeft = Default, $iTop = Default, $iRight = Default, $iBottom = Default, $bRedraw = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iLeft = Default Or __GCR_IsNumeric($iLeft, ">0")) Then Return SetError(1021, 0, False)
If Not ($iTop = Default Or __GCR_IsNumeric($iTop, ">0")) Then Return SetError(1022, 0, False)
If Not ($iRight = Default Or __GCR_IsNumeric($iRight, ">0")) Then Return SetError(1023, 0, False)
If Not ($iBottom = Default Or __GCR_IsNumeric($iBottom, ">0")) Then Return SetError(1024, 0, False)
If @NumParams = 1 Then
Local $aPos = ControlGetPos($hWnd, "", "")
$iLeft = 2
$iTop = 2
$iRight = $aPos[2]
$iBottom = $aPos[3]
_GUICtrlRichEdit_SetRECT($hWnd, $iLeft, $iTop, $iRight, $iBottom)
Return True
Else
Local $aS = _GUICtrlRichEdit_GetRECT($hWnd)
If $iLeft = Default Then
$iLeft = $aS[0]
EndIf
If $iTop = Default Then
$iTop = $aS[1]
EndIf
If $iRight = Default Then
$iRight = $aS[2]
EndIf
If $iBottom = Default Then
$iBottom = $aS[3]
EndIf
If $iLeft >= $iRight Then Return SetError(1025, 0, False)
If $iTop >= $iBottom Then Return SetError(1026, 0, False)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", Number($iLeft))
DllStructSetData($tRECT, "Top", Number($iTop))
DllStructSetData($tRECT, "Right", Number($iRight))
DllStructSetData($tRECT, "Bottom", Number($iBottom))
Local $iMsg = ($bRedraw ? $EM_SETRECT : $EM_SETRECTNP)
_SendMessage($hWnd, $iMsg, 0, $tRECT, 0, "wparam", "struct*")
EndIf
Return True
EndFunc
Func _GUICtrlRichEdit_SetModified($hWnd, $bState = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bState) Then Return SetError(102, 0, False)
_SendMessage($hWnd, $EM_SETMODIFY, $bState)
Return True
EndFunc
Func _GUICtrlRichEdit_SetParaAlignment($hWnd, $sAlignment)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iAlignment
Switch $sAlignment
Case "l"
$iAlignment = $PFA_LEFT
Case "c"
$iAlignment = $PFA_CENTER
Case "r"
$iAlignment = $PFA_RIGHT
Case "j"
$iAlignment = $PFA_JUSTIFY
Case "w"
$iAlignment = $PFA_FULL_INTERWORD
Case Else
Return SetError(102, 0, False)
EndSwitch
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, 2, $PFM_ALIGNMENT)
DllStructSetData($tParaFormat, 8, $iAlignment)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetParaAttributes($hWnd, $sStatesAndAtts)
Local Enum $eAbbrev = 0, $eMask, $eEffect, $eInverted
Local Const $aV[9][4] = [  ["fpg", $PFM_PAGEBREAKBEFORE, $PFE_PAGEBREAKBEFORE, False],  ["hyp", $PFM_DONOTHYPHEN, $PFE_DONOTHYPHEN, True],  ["kpt", $PFM_KEEP, $PFE_KEEP, False],  ["kpn", $PFM_KEEPNEXT, $PFE_KEEPNEXT, False],  ["pwo", $PFM_NOWIDOWCONTROL, $PFE_NOWIDOWCONTROL, False],  ["r2l", $PFM_RTLPARA, $PFE_RTLPARA, False],  ["row", $PFM_TABLE, $PFE_TABLE, False],  ["sbs", $PFM_SIDEBYSIDE, $PFE_SIDEBYSIDE, False],  ["sln", $PFM_NOLINENUMBER, $PFE_NOLINENUMBER, False]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Mod(StringLen($sStatesAndAtts) + 1, 5) <> 0 Then Return SetError(1023, 0, False)
Local $aS = StringSplit($sStatesAndAtts, ";")
Local $iMask = 0, $iEffects = 0, $s, $n
For $i = 1 To UBound($aS, $UBOUND_ROWS) - 1
$s = StringMid($aS[$i], 2)
$n = -1
For $j = 0 To UBound($aV, $UBOUND_ROWS) - 1
If $aV[$j][$eAbbrev] = $s Then
$n = $j
ExitLoop
EndIf
Next
If $n = -1 Then Return SetError(1022, $s, False)
$iMask = BitOR($iMask, $aV[$n][$eMask])
$s = StringLeft($aS[$i], 1)
Switch $s
Case "+"
If Not $aV[$n][$eInverted] Then
$iEffects = BitOR($iEffects, $aV[$n][$eEffect])
EndIf
Case "-"
If $aV[$n][$eInverted] Then
$iEffects = BitOR($iEffects, $aV[$n][$eEffect])
EndIf
Case Else
Return SetError(1021, $s, False)
EndSwitch
Next
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, 2, $iMask)
DllStructSetData($tParaFormat, 4, $iEffects)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetParaBorder($hWnd, $sLocation = Default, $vLineStyle = Default, $sColor = Default, $iSpace = Default)
Local $iBorders
Local Const $avLocs[6][2] = [["l", 1], ["r", 2], ["t", 4], ["b", 8], ["i", 16], ["o", 32]]
Local Const $avLS[12] = ["none", .75, 1.5, 2.25, 3, 4.5, 6, ".75d", "1.5d", "2.25d", ".75g", ".75gd"]
Local Const $sClrs = ";blk;blu;cyn;grn;mag;red;yel;whi;dbl;dgn;dmg;drd;dyl;dgy;lgy;aut;"
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iSpace = Default Or __GCR_IsNumeric($iSpace, ">=0")) Then Return SetError(105, 0, False)
If $sLocation = "" Then
$iBorders = 0
$iSpace = 0
Else
If $sLocation = Default Or $vLineStyle = Default Or $sColor = Default Or $iSpace = Default Then
Local $aS = StringSplit(_GUICtrlRichEdit_GetParaBorder($hWnd), ";")
If $sLocation = Default Then $sLocation = $aS[1]
If $vLineStyle = Default Then $vLineStyle = $aS[2]
If $sColor = Default Then $sColor = $aS[3]
If $iSpace = Default Then $iSpace = $aS[4]
EndIf
Local $iLoc = 0, $n, $s
For $i = 1 To StringLen($sLocation)
$s = StringMid($sLocation, $i, 1)
$n = -1
For $j = 0 To UBound($avLocs, $UBOUND_ROWS) - 1
If $avLocs[$j][0] = $s Then
$n = $j
ExitLoop
EndIf
Next
If $n = -1 Then Return SetError(102, $s, False)
$iLoc = BitOR($iLoc, $avLocs[$n][1])
Next
$n = -1
For $i = 0 To UBound($avLS, $UBOUND_ROWS) - 1
If $vLineStyle = $avLS[$i] Then
$n = $i
ExitLoop
EndIf
Next
If $n = -1 Then Return SetError(103, 0, False)
Local $iLineStyle = $n
$n = StringInStr($sClrs, ";" & $sColor & ";")
If $n = 0 Then Return SetError(104, 0, False)
Local $iColor = Int($n / 4)
If $iColor = 16 Then
$iLoc = BitOR($iLoc, 64)
$iColor = 0
EndIf
$iBorders = $iLoc + BitShift($iLineStyle, -8) + BitShift($iColor, -12)
EndIf
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, "wBorderSpace", $iSpace * $__g_iRTFTwipsPeSpaceUnit)
DllStructSetData($tParaFormat, "wBorders", $iBorders)
DllStructSetData($tParaFormat, "dwMask", $PFM_BORDER)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetParaIndents($hWnd, $vLeft = Default, $iRight = Default, $iFirstLine = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($vLeft = Default Or __GCR_IsNumeric($vLeft)) Then Return SetError(1021, 0, False)
If Not ($iRight = Default Or __GCR_IsNumeric($iRight, ">=0")) Then Return SetError(103, 0, False)
If Not ($iFirstLine = Default Or __GCR_IsNumeric($iFirstLine)) Then Return SetError(104, 0, False)
Local $s = _GUICtrlRichEdit_GetParaIndents($hWnd)
Local $aS = StringSplit($s, ";")
If $vLeft = Default Then $vLeft = $aS[1]
If $iRight = Default Then $iRight = $aS[2]
If $iFirstLine = Default Then $iFirstLine = $aS[3]
If $vLeft < 0 Then Return SetError(1022, 0, False)
If $vLeft + $iFirstLine < 0 Then Return SetError(200, 0, False)
If StringInStr("+-", StringLeft($vLeft, 1)) <> 0 Then $vLeft = $aS[1] + $vLeft
Local $iIdxSI = $vLeft + $iFirstLine
Local $iIdxOfs = -$iFirstLine
Local $tParaFormat = DllStructCreate($tagPARAFORMAT)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, "dxStartIndent", $iIdxSI * $__g_iRTFTwipsPeSpaceUnit)
DllStructSetData($tParaFormat, "dxOffset", $iIdxOfs * $__g_iRTFTwipsPeSpaceUnit)
DllStructSetData($tParaFormat, "dxRightIndent", $iRight * $__g_iRTFTwipsPeSpaceUnit)
DllStructSetData($tParaFormat, 2, BitOR($PFM_STARTINDENT, $PFM_OFFSET, $PFM_RIGHTINDENT))
Local $iRet = _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetParaNumbering($hWnd, $sStyle, $iTextToNbrSpace = Default, $bForceRoman = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iTextToNbrSpace = Default Or __GCR_IsNumeric($iTextToNbrSpace, ">0")) Then Return SetError(103, 0, False)
If Not IsBool($bForceRoman) Then Return SetError(104, 0, False)
Local $iPFM, $iWNumbering, $iWnumStart, $iWnumStyle, $iQspaces
__GCR_ParseParaNumberingStyle($sStyle, $bForceRoman, $iPFM, $iWNumbering, $iWnumStart, $iWnumStyle, $iQspaces)
If @error Then Return SetError(@error, 0, False)
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
If BitAND($iPFM, $PFM_NUMBERING) Then DllStructSetData($tParaFormat, 3, $iWNumbering)
If BitAND($iPFM, $PFM_NUMBERINGSTART) Then DllStructSetData($tParaFormat, 19, $iWnumStart)
If BitAND($iPFM, $PFM_NUMBERINGSTYLE) Then DllStructSetData($tParaFormat, 20, $iWnumStyle)
If BitAND($iPFM, $PFM_NUMBERINGTAB) Then
Local $iTwips
If $iTextToNbrSpace = Default Then
Local $aV = _GUICtrlRichEdit_GetFont($hWnd)
Local $iPoints = $aV[0]
$iTwips = $iQspaces * $iPoints * 20
Else
$iTwips = $iTextToNbrSpace * $__g_iRTFTwipsPeSpaceUnit
EndIf
DllStructSetData($tParaFormat, 21, $iTwips)
EndIf
DllStructSetData($tParaFormat, 2, $iPFM)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetParaShading($hWnd, $iWeight = Default, $sStyle = Default, $sForeColor = Default, $sBackColor = Default)
Local $iS = 0
Local Const $sStyles = ";non;dhz;dvt;ddd;dud;dgr;dtr;lhz;lrt;ldd;lud;lgr;ltr;"
Local Const $sClrs = ";blk;blu;cyn;grn;mag;red;yel;whi;dbl;dgn;dmg;drd;dyl;dgy;lgy;"
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iWeight = Default Or __GCR_IsNumeric($iWeight, ">=0")) Then Return SetError(1021, 0, False)
If $iWeight <> Default Or $sStyle <> Default Or $sForeColor <> Default Or $sBackColor <> Default Then
Local $aS = StringSplit(_GUICtrlRichEdit_GetParaShading($hWnd), ";")
If $iWeight = Default Then $iWeight = $aS[1]
If $sStyle = Default Then $sStyle = $aS[2]
If $sForeColor = Default Then $sForeColor = $aS[3]
If $sBackColor = Default Then $sBackColor = $aS[4]
EndIf
If $iWeight < 0 Or $iWeight > 100 Then Return SetError(1022, 0, False)
Local $iN = StringInStr($sStyles, ";" & $sStyle & ";")
If $iN = 0 Then Return SetError(103, 0, False)
Local $iStyle = Int($iN / 4)
Local $iFore = BitShift(BitAND($iS, 0xF0), 4)
$iN = StringInStr($sClrs, ";" & $sForeColor & ";")
If $iN = 0 Then Return SetError(104, 0, False)
$iFore = Int($iN / 4)
$iN = StringInStr($sClrs, ";" & $sBackColor & ";")
If $iN = 0 Then Return SetError(105, 0, False)
Local $iBack = Int($iN / 4)
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, "wShadingWeight", $iWeight)
$iN = $iStyle + BitShift($iFore, -4) + BitShift($iBack, -8)
DllStructSetData($tParaFormat, "wShadingStyle", $iN)
DllStructSetData($tParaFormat, "dwMask", $PFM_SHADING)
Local $iRet = _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetParaSpacing($hWnd, $vInter = Default, $iBefore = Default, $iAfter = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iBefore = Default Or __GCR_IsNumeric($iBefore, ">=0")) Then Return SetError(103, 0, False)
If Not ($iAfter = Default Or __GCR_IsNumeric($iAfter, ">=0")) Then Return SetError(104, 0, False)
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
Local $iMask = 0
If $vInter <> Default Then
$vInter = StringStripWS($vInter, $STR_STRIPALL)
Local $iP = StringInStr($vInter, "line", $STR_NOCASESENSEBASIC)
If $iP <> 0 Then
$vInter = StringLeft($vInter, $iP - 1)
EndIf
If Not __GCR_IsNumeric($vInter, ">=0") Then Return SetError(1021, 0, False)
Local $iRule, $iLnSp = 0
If $iP <> 0 Then
Switch $vInter
Case 1
$iRule = 0
Case 1.5
$iRule = 1
Case 2
$iRule = 2
Case Else
If $vInter < 1 Then Return SetError(1022, 0, False)
$iRule = 5
$iLnSp = $vInter * 20
EndSwitch
Else
$iRule = 4
$iLnSp = $vInter * $__g_iRTFTwipsPeSpaceUnit
EndIf
$iMask = $PFM_LINESPACING
DllStructSetData($tParaFormat, "bLineSpacingRule", $iRule)
If $iLnSp <> 0 Then DllStructSetData($tParaFormat, 13, $iLnSp)
EndIf
If $iBefore <> Default Then
$iMask = BitOR($iMask, $PFM_SPACEBEFORE)
DllStructSetData($tParaFormat, "dySpaceBefore", $iBefore * $__g_iRTFTwipsPeSpaceUnit)
EndIf
If $iAfter <> Default Then
$iMask = BitOR($iMask, $PFM_SPACEAFTER)
DllStructSetData($tParaFormat, "dySpaceAfter", $iAfter * $__g_iRTFTwipsPeSpaceUnit)
EndIf
If $iMask <> 0 Then
DllStructSetData($tParaFormat, "dwMask", $iMask)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
Else
Return True
EndIf
EndFunc
Func _GUICtrlRichEdit_SetParaTabStops($hWnd, $sTabStops)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
If $sTabStops = "" Then
DllStructSetData($tParaFormat, "cTabCount", 0)
Else
Local $asTabs = StringSplit($sTabStops, ";")
If $asTabs[0] > $MAX_TAB_STOPS Then Return SetError(1021, 0, False)
Local $asAtab, $i, $s, $iN, $iP
For $iTab = 1 To $asTabs[0]
$asAtab = StringSplit($asTabs[$iTab], "")
$i = 1
While $i <= $asAtab[0] And StringInStr("01234567890.", $asAtab[$i]) <> 0
$i += 1
WEnd
If $i = 1 Then Return SetError(1021, $iTab, False)
$s = StringLeft($asTabs[$iTab], $i - 1)
If Not __GCR_IsNumeric($s, ">=0") Then Return SetError(1021, $iTab, False)
$iN = $s * $__g_iRTFTwipsPeSpaceUnit
If $i <= $asAtab[0] Then
$iP = StringInStr("lcrdb", $asAtab[$i])
If $iP = 0 Then Return SetError(1022, $iTab, False)
$iN = BitOR($iN, BitShift($iP - 1, -24))
EndIf
$i += 1
If $i <= $asAtab[0] Then
$iP = StringInStr(" .-_t=", $asAtab[$i])
If $iP = 0 Then Return SetError(1023, $iTab, False)
$iN = BitOR($iN, BitShift($iP - 1, -28))
EndIf
DllStructSetData($tParaFormat, "rgxTabs", $iN, $iTab)
Next
DllStructSetData($tParaFormat, "cTabCount", $asTabs[0])
EndIf
DllStructSetData($tParaFormat, "dwMask", $PFM_TABSTOPS)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetPasswordChar($hWnd, $sDisplayChar = "*")
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsString($sDisplayChar) Then SetError(102, 0, False)
If $sDisplayChar = "" Then
_SendMessage($hWnd, $EM_SETPASSWORDCHAR)
Else
_SendMessage($hWnd, $EM_SETPASSWORDCHAR, Asc($sDisplayChar))
EndIf
Return True
EndFunc
Func _GUICtrlRichEdit_SetReadOnly($hWnd, $bState = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bState) Then Return SetError(102, 0, False)
Local $iRet = _SendMessage($hWnd, $EM_SETREADONLY, $bState)
If $iRet = 0 Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetScrollPos($hWnd, $iX, $iY)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iX, ">=0") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iY, ">=0") Then Return SetError(103, 0, False)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, 1, $iX)
DllStructSetData($tPoint, 2, $iY)
Return _SendMessage($hWnd, $EM_SETSCROLLPOS, 0, $tPoint, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetSel($hWnd, $iAnchor, $iActive, $bHideSel = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iAnchor, ">=0,-1") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iActive, ">=0,-1") Then Return SetError(103, 0, False)
If Not IsBool($bHideSel) Then Return SetError(104, 0, False)
_SendMessage($hWnd, $EM_SETSEL, $iAnchor, $iActive)
If $bHideSel Then _SendMessage($hWnd, $EM_HIDESELECTION, $bHideSel)
_WinAPI_SetFocus($hWnd)
Return True
EndFunc
Func _GUICtrlRichEdit_SetSpaceUnit($sUnit)
Switch StringLower($sUnit)
Case "in"
$__g_iRTFTwipsPeSpaceUnit = 1440
Case "cm"
$__g_iRTFTwipsPeSpaceUnit = 567
Case "mm"
$__g_iRTFTwipsPeSpaceUnit = 56.7
Case "pt"
$__g_iRTFTwipsPeSpaceUnit = 20
Case "tw"
$__g_iRTFTwipsPeSpaceUnit = 1
Case Else
Return SetError(1, 0, False)
EndSwitch
Return True
EndFunc
Func _GUICtrlRichEdit_SetText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_DEFAULT)
DllStructSetData($tSetText, 2, $CP_ACP)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetUndoLimit($hWnd, $iLimit)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iLimit, ">=0") Then Return SetError(102, 0, False)
Return _SendMessage($hWnd, $EM_SETUNDOLIMIT, $iLimit) <> 0 Or $iLimit = 0
EndFunc
Func _GUICtrlRichEdit_StreamFromFile($hWnd, $sFileSpec, $iFileEncoding = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tEditStream = DllStructCreate($tagEDITSTREAM)
DllStructSetData($tEditStream, "pfnCallback", DllCallbackGetPtr($__g_pGRC_StreamFromFileCallback))
If $iFileEncoding = Default Then $iFileEncoding = $FO_READ
Local $hFile = FileOpen($sFileSpec, $FO_READ + $iFileEncoding)
If $hFile = -1 Then Return SetError(1021, 0, False)
Local $sBuf = FileRead($hFile, 5)
FileClose($hFile)
$hFile = FileOpen($sFileSpec, $FO_READ + $iFileEncoding)
DllStructSetData($tEditStream, "dwCookie", $hFile)
Local $wParam = ($sBuf == "{\rtf" Or $sBuf == "{urtf") ? $SF_RTF : $SF_TEXT
$wParam = BitOR($wParam, $SFF_SELECTION)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then
_GUICtrlRichEdit_SetText($hWnd, "")
EndIf
Local $iQchs = _SendMessage($hWnd, $EM_STREAMIN, $wParam, $tEditStream, 0, "wparam", "struct*")
FileClose($hFile)
Local $iError = DllStructGetData($tEditStream, "dwError")
If $iError <> 0 Then Return SetError(700, $iError, False)
If $iQchs = 0 Then
If FileGetSize($sFileSpec) = 0 Then Return SetError(1022, 0, False)
Return SetError(700, $iError, False)
EndIf
Return True
EndFunc
Func _GUICtrlRichEdit_StreamFromVar($hWnd, $sVar)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tEditStream = DllStructCreate($tagEDITSTREAM)
DllStructSetData($tEditStream, "pfnCallback", DllCallbackGetPtr($__g_pGRC_StreamFromVarCallback))
$__g_pGRC_sStreamVar = $sVar
Local $s = StringLeft($sVar, 5)
Local $wParam = ($s == "{\rtf" Or $s == "{urtf") ? $SF_RTF : $SF_TEXT
$wParam = BitOR($wParam, $SFF_SELECTION)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then
_GUICtrlRichEdit_SetText($hWnd, "")
EndIf
_SendMessage($hWnd, $EM_STREAMIN, $wParam, $tEditStream, 0, "wparam", "struct*")
Local $iError = DllStructGetData($tEditStream, "dwError")
If $iError <> 0 Then Return SetError(700, $iError, False)
Return True
EndFunc
Func _GUICtrlRichEdit_StreamToFile($hWnd, $sFileSpec, $bIncludeCOM = True, $iOpts = 0, $iCodePage = 0, $iFileEncoding = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $wParam
If StringRight($sFileSpec, 4) = ".rtf" Then
$wParam = ($bIncludeCOM ? $SF_RTF : $SF_RTFNOOBJS)
Else
$wParam = ($bIncludeCOM ? $SF_TEXTIZED : $SF_TEXT)
If BitAND($iOpts, $SFF_PLAINRTF) Then Return SetError(1041, 0, False)
EndIf
If BitAND($iOpts, BitNOT(BitOR($SFF_PLAINRTF, $SF_UNICODE))) Then Return SetError(1042, 0, False)
If BitAND($iOpts, $SF_UNICODE) Then
If Not BitAND($wParam, $SF_TEXT) Then Return SetError(1043, 0, False)
EndIf
If _GUICtrlRichEdit_IsTextSelected($hWnd) Then $wParam = BitOR($wParam, $SFF_SELECTION)
$wParam = BitOR($wParam, $iOpts)
If $iCodePage <> 0 Then
$wParam = BitOR($wParam, $SF_USECODEPAGE, BitShift($iCodePage, -16))
EndIf
Local $tEditStream = DllStructCreate($tagEDITSTREAM)
DllStructSetData($tEditStream, "pfnCallback", DllCallbackGetPtr($__g_pGRC_StreamToFileCallback))
If $iFileEncoding = Default Then $iFileEncoding = $FO_READ
Local $hFile = FileOpen($sFileSpec, $FO_OVERWRITE + $iFileEncoding)
If $hFile = -1 Then Return SetError(102, 0, False)
DllStructSetData($tEditStream, "dwCookie", $hFile)
_SendMessage($hWnd, $EM_STREAMOUT, $wParam, $tEditStream, 0, "wparam", "struct*")
FileClose($hFile)
Local $iError = DllStructGetData($tEditStream, "dwError")
If $iError <> 0 Then Return SetError(700, $iError, False)
Return True
EndFunc
Func _GUICtrlRichEdit_StreamToVar($hWnd, $bRtf = True, $bIncludeCOM = True, $iOpts = 0, $iCodePage = 0)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $wParam
If $bRtf Then
$wParam = ($bIncludeCOM ? $SF_RTF : $SF_RTFNOOBJS)
Else
$wParam = ($bIncludeCOM ? $SF_TEXTIZED : $SF_TEXT)
If BitAND($iOpts, $SFF_PLAINRTF) Then Return SetError(1041, 0, "")
EndIf
If BitAND($iOpts, BitNOT(BitOR($SFF_PLAINRTF, $SF_UNICODE))) Then Return SetError(1042, 0, "")
If BitAND($iOpts, $SF_UNICODE) Then
If Not BitAND($wParam, $SF_TEXT) Then Return SetError(1043, 0, "")
EndIf
If _GUICtrlRichEdit_IsTextSelected($hWnd) Then $wParam = BitOR($wParam, $SFF_SELECTION)
$wParam = BitOR($wParam, $iOpts)
If $iCodePage <> 0 Then
$wParam = BitOR($wParam, $SF_USECODEPAGE, BitShift($iCodePage, -16))
EndIf
Local $tEditStream = DllStructCreate($tagEDITSTREAM)
DllStructSetData($tEditStream, "pfnCallback", DllCallbackGetPtr($__g_pGRC_StreamToVarCallback))
$__g_pGRC_sStreamVar = ""
_SendMessage($hWnd, $EM_STREAMOUT, $wParam, $tEditStream, 0, "wparam", "struct*")
Local $iError = DllStructGetData($tEditStream, "dwError")
If $iError <> 0 Then Return SetError(700, $iError, "")
Return $__g_pGRC_sStreamVar
EndFunc
Func _GUICtrlRichEdit_Undo($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_UNDO, 0, 0) <> 0
EndFunc
Func __GCR_Init()
Local $ah_GUICtrlRTF_lib = DllCall("kernel32.dll", "ptr", "LoadLibraryW", "wstr", "MSFTEDIT.DLL")
If $ah_GUICtrlRTF_lib[0] <> 0 Then
$__g_sRTFClassName = "RichEdit50W"
$__g_sRTFVersion = 4.1
Else
$ah_GUICtrlRTF_lib = DllCall("kernel32.dll", "ptr", "LoadLibraryW", "wstr", "RICHED20.DLL")
$__g_sRTFVersion = FileGetVersion(@SystemDir & "\riched20.dll", "ProductVersion")
Switch $__g_sRTFVersion
Case 3.0
$__g_sRTFClassName = "RichEdit20W"
Case 5.0
$__g_sRTFClassName = "RichEdit50W"
Case 6.0
$__g_sRTFClassName = "RichEdit60W"
EndSwitch
EndIf
$__g_sGRE_CF_RTF = _ClipBoard_RegisterFormat("Rich Text Format")
$__g_sGRE_CF_RETEXTOBJ = _ClipBoard_RegisterFormat("Rich Text Format with Objects")
EndFunc
Func __GCR_StreamFromFileCallback($hFile, $pBuf, $iBuflen, $pQbytes)
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $sBuf = FileRead($hFile, $iBuflen - 1)
If @error Then Return 1
DllStructSetData($tBuf, 1, $sBuf)
DllStructSetData($tQbytes, 1, StringLen($sBuf))
Return 0
EndFunc
Func __GCR_StreamFromVarCallback($iCookie, $pBuf, $iBuflen, $pQbytes)
#forceref $iCookie
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tCtl = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $sCtl = StringLeft($__g_pGRC_sStreamVar, $iBuflen - 1)
If $sCtl = "" Then Return 1
DllStructSetData($tCtl, 1, $sCtl)
Local $iLen = StringLen($sCtl)
DllStructSetData($tQbytes, 1, $iLen)
$__g_pGRC_sStreamVar = StringMid($__g_pGRC_sStreamVar, $iLen + 1)
Return 0
EndFunc
Func __GCR_StreamToFileCallback($hFile, $pBuf, $iBuflen, $pQbytes)
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $s = DllStructGetData($tBuf, 1)
FileWrite($hFile, $s)
DllStructSetData($tQbytes, 1, StringLen($s))
Return 0
EndFunc
Func __GCR_StreamToVarCallback($iCookie, $pBuf, $iBuflen, $pQbytes)
#forceref $iCookie
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $s = DllStructGetData($tBuf, 1)
$__g_pGRC_sStreamVar &= $s
DllStructSetData($tQbytes, 1, StringLen($s))
Return 0
EndFunc
Func __GCR_ConvertTwipsToSpaceUnit($nIn)
Local $sRet
Switch $__g_iRTFTwipsPeSpaceUnit
Case 1440, 567
$sRet = StringFormat("%.2f", $nIn / $__g_iRTFTwipsPeSpaceUnit)
If $sRet = "-0.00" Then $sRet = "0.00"
Case 56.7, 72
$sRet = StringFormat("%.1f", $nIn / $__g_iRTFTwipsPeSpaceUnit)
If $sRet = "-0.0" Then $sRet = "0.0"
Case Else
$sRet = $nIn
EndSwitch
Return $sRet
EndFunc
Func __GCR_IsNumeric($vN, $sRange = "")
If Not (IsNumber($vN) Or StringIsInt($vN) Or StringIsFloat($vN)) Then Return False
Switch $sRange
Case ">0"
If $vN <= 0 Then Return False
Case ">=0"
If $vN < 0 Then Return False
Case ">0,-1"
If Not ($vN > 0 Or $vN = -1) Then Return False
Case ">=0,-1"
If Not ($vN >= 0 Or $vN = -1) Then Return False
EndSwitch
Return True
EndFunc
Func __GCR_GetParaScopeChar($hWnd, $iMask, $iPFM)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then
Return "c"
ElseIf BitAND($iMask, $iPFM) = $iPFM Then
Return "a"
Else
Return "f"
EndIf
EndFunc
Func __GCR_ParseParaNumberingStyle($sIn, $bForceRoman, ByRef $iPFM, ByRef $iWNumbering, ByRef $iWnumStart, ByRef $iWnumStyle, ByRef $iQspaces)
Local Const $sRoman = "mdclxviMDCLXVI", $iRpar = 0, $i2par = 0x100, $iPeriod = 0x200, $iNbrOnly = 0x300
If $sIn = "" Then
$iWNumbering = 0
$iPFM = $PFM_NUMBERING
Else
Local $s = StringStripWS($sIn, $STR_STRIPTRAILING)
$iQspaces = StringLen($sIn) - StringLen($s)
$sIn = $s
$iPFM = $PFM_NUMBERINGTAB
If $sIn = "." Then
$iWNumbering = $PFN_BULLET
$iPFM = BitOR($iPFM, $PFM_NUMBERING)
ElseIf $sIn = "=" Then
$iWnumStyle = 0x400
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTYLE)
Else
Switch StringRight($sIn, 1)
Case ")"
If StringLeft($sIn, 1) = "(" Then
$iWnumStyle = $i2par
$sIn = StringTrimLeft($sIn, 1)
Else
$iWnumStyle = $iRpar
EndIf
Case "."
$iWnumStyle = $iPeriod
Case Else
$iWnumStyle = $iNbrOnly
EndSwitch
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTYLE)
If $iWnumStyle <> 0x300 Then $sIn = StringTrimRight($sIn, 1)
If StringIsDigit($sIn) Then
$iWnumStart = Number($sIn)
$iWNumbering = 2
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTART, $PFM_NUMBERING)
Else
Local $bMayBeRoman = True
For $i = 1 To StringLen($sIn)
If Not StringInStr($sRoman, StringMid($sIn, $i, 1)) Then
$bMayBeRoman = False
ExitLoop
EndIf
Next
Local $bIsRoman
If $bMayBeRoman Then
$bIsRoman = $bForceRoman
Else
$bIsRoman = False
EndIf
Switch True
Case $bIsRoman
$iWnumStart = __GCR_ConvertRomanToNumber($sIn)
If $iWnumStart = -1 Then Return SetError(102, 0, False)
$iWNumbering = (StringIsLower($sIn) ? 5 : 6)
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTART, $PFM_NUMBERING)
Case StringIsAlpha($sIn)
If StringIsLower($sIn) Then
$iWNumbering = 3
Else
$iWNumbering = 4
$sIn = StringLower($sIn)
EndIf
$iWnumStart = 0
Local $iN
For $iP = 1 To StringLen($sIn)
$iN = Asc(StringMid($sIn, $i))
If $iN >= Asc("a") And $iN <= Asc("z") Then
$iWnumStart = $iWnumStart * 26 + ($iN - Asc("a") + 1)
EndIf
Next
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTART, $PFM_NUMBERING)
Case Else
Return SetError(102, 0, False)
EndSwitch
EndIf
EndIf
EndIf
Return True
EndFunc
Func __GCR_ConvertRomanToNumber($sRnum)
Local Enum $e9, $e5, $e4, $e1, $eMult, $eHigher
Local Const $aV[3][6] = [["cm", "d", "cd", "c", 100, "m"], ["xc", "l", "xl", "x", 10, "mdc"], ["ix", "v", "iv", "i", 1, "mdclx"]]
$sRnum = StringLower($sRnum)
Local $i = 1
While StringMid($sRnum, $i, 1) = "m"
$i += 1
WEnd
Local $iDigit, $iQ1s, $iRet = ($i - 1) * 1000
For $j = 0 To 2
$iDigit = 0
If StringMid($sRnum, $i, 2) = $aV[$j][$e9] Then
$iDigit = 9
$i += 2
ElseIf StringMid($sRnum, $i, 1) = $aV[$j][$e5] Then
$iDigit = 5
$i += 1
ElseIf StringMid($sRnum, $i, 2) = $aV[$j][$e4] Then
$iDigit = 4
$i += 2
ElseIf StringInStr($aV[$j][$eHigher], StringMid($sRnum, $i, 1)) Then
Return -1
EndIf
If $iDigit = 0 Or $iDigit = 5 Then
$iQ1s = 0
While StringMid($sRnum, $i, 1) = $aV[$j][$e1]
$iQ1s += 1
If $iQ1s > 3 Then Return 0
$i += 1
WEnd
$iDigit += $iQ1s
EndIf
$iRet += $iDigit * $aV[$j][$eMult]
Next
If $i <= StringLen($sRnum) Then Return -1
Return $iRet
EndFunc
Func __GCR_SendGetCharFormatMessage($hWnd, $tCharFormat)
Return _SendMessage($hWnd, $EM_GETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*")
EndFunc
Func __GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
Local $bIsSel = _GUICtrlRichEdit_IsTextSelected($hWnd)
Local $iInsPt = 0
If Not $bIsSel Then
Local $aS = _GUICtrlRichEdit_GetSel($hWnd)
$iInsPt = $aS[0]
Local $iN = _GUICtrlRichEdit_GetFirstCharPosOnLine($hWnd)
_GUICtrlRichEdit_SetSel($hWnd, $iN, $iN + 1, True)
EndIf
_SendMessage($hWnd, $EM_GETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*")
If @error Then Return SetError(@error, @extended, False)
If Not $bIsSel Then _GUICtrlRichEdit_SetSel($hWnd, $iInsPt, $iInsPt)
Return True
EndFunc
Func __GCR_SetOLECallback($hWnd)
If Not IsHWnd($hWnd) Then Return SetError(101, 0, False)
If Not $__g_pObj_RichCom Then
$__g_tCall_RichCom = DllStructCreate("ptr[20]")
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryInterface), 1)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_AddRef), 2)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_Release), 3)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetNewStorage), 4)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetInPlaceContext), 5)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_ShowContainerUI), 6)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryInsertObject), 7)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_DeleteObject), 8)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryAcceptData), 9)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_ContextSensitiveHelp), 10)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetClipboardData), 11)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetDragDropEffect), 12)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetContextMenu), 13)
DllStructSetData($__g_tObj_RichComObject, 1, DllStructGetPtr($__g_tCall_RichCom))
DllStructSetData($__g_tObj_RichComObject, 2, 1)
$__g_pObj_RichCom = DllStructGetPtr($__g_tObj_RichComObject)
EndIf
Local Const $EM_SETOLECALLBACK = 0x400 + 70
If _SendMessage($hWnd, $EM_SETOLECALLBACK, 0, $__g_pObj_RichCom) = 0 Then Return SetError(700, 0, False)
Return True
EndFunc
Func __RichCom_Object_QueryInterface($pObject, $iREFIID, $pPvObj)
#forceref $pObject, $iREFIID, $pPvObj
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_AddRef($pObject)
Local $tData = DllStructCreate("ptr;dword", $pObject)
DllStructSetData($tData, 2, DllStructGetData($tData, 2) + 1)
Return DllStructGetData($tData, 2)
EndFunc
Func __RichCom_Object_Release($pObject)
Local $tData = DllStructCreate("ptr;dword", $pObject)
If DllStructGetData($tData, 2) > 0 Then
DllStructSetData($tData, 2, DllStructGetData($tData, 2) - 1)
Return DllStructGetData($tData, 2)
EndIf
EndFunc
Func __RichCom_Object_GetInPlaceContext($pObject, $pPFrame, $pPDoc, $pFrameInfo)
#forceref $pObject, $pPFrame, $pPDoc, $pFrameInfo
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_ShowContainerUI($pObject, $bShow)
#forceref $pObject, $bShow
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_QueryInsertObject($pObject, $pClsid, $tStg, $vCp)
#forceref $pObject, $pClsid, $tStg, $vCp
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_DeleteObject($pObject, $pOleobj)
#forceref $pObject, $pOleobj
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_QueryAcceptData($pObject, $pDataobj, $pCfFormat, $vReco, $bReally, $hMetaPict)
#forceref $pObject, $pDataobj, $pCfFormat, $vReco, $bReally, $hMetaPict
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_ContextSensitiveHelp($pObject, $bEnterMode)
#forceref $pObject, $bEnterMode
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetClipboardData($pObject, $pChrg, $vReco, $pPdataobj)
#forceref $pObject, $pChrg, $vReco, $pPdataobj
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetDragDropEffect($pObject, $bDrag, $iGrfKeyState, $piEffect)
#forceref $pObject, $bDrag, $iGrfKeyState, $piEffect
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetContextMenu($pObject, $iSeltype, $pOleobj, $pChrg, $pHmenu)
#forceref $pObject, $iSeltype, $pOleobj, $pChrg, $pHmenu
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetNewStorage($pObject, $pPstg)
#forceref $pObject
Local $aSc = DllCall($__g_hLib_RichCom_OLE32, "dword", "CreateILockBytesOnHGlobal", "hwnd", 0, "int", 1, "ptr*", 0)
Local $pLockBytes = $aSc[3]
$aSc = $aSc[0]
If $aSc Then Return $aSc
$aSc = DllCall($__g_hLib_RichCom_OLE32, "dword", "StgCreateDocfileOnILockBytes", "ptr", $pLockBytes, "dword", BitOR(0x10, 2, 0x1000), "dword", 0, "ptr*", 0)
Local $tStg = DllStructCreate("ptr", $pPstg)
DllStructSetData($tStg, 1, $aSc[4])
$aSc = $aSc[0]
If $aSc Then
Local $tObj = DllStructCreate("ptr", $pLockBytes)
Local $tUnknownFuncTable = DllStructCreate("ptr[3]", DllStructGetData($tObj, 1))
Local $pReleaseFunc = DllStructGetData($tUnknownFuncTable, 3)
DllCallAddress("long", $pReleaseFunc, "ptr", $pLockBytes)
EndIf
Return $aSc
EndFunc
Global Const $__COLORCONSTANTS_HMAX = 360
Global Const $__COLORCONSTANTS_SLMAX = 100
Global Const $__COLORCONSTANTS_RGBMAX = 255
Func _ColorConvertHSLtoRGB($aArray)
If UBound($aArray) <> 3 Or UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(1, 0, 0)
Local $nR, $nG, $nB
Local $nH = Number($aArray[0]) / $__COLORCONSTANTS_HMAX
Local $nS = Number($aArray[1]) / $__COLORCONSTANTS_SLMAX
Local $nL = Number($aArray[2]) / $__COLORCONSTANTS_SLMAX
If $nS = 0 Then
$nR = $nL
$nG = $nL
$nB = $nL
Else
Local $nValA, $nValB
If $nL <= 0.5 Then
$nValB = $nL * ($nS + 1)
Else
$nValB = ($nL + $nS) - ($nL * $nS)
EndIf
$nValA = 2 * $nL - $nValB
$nR = __ColorConvertHueToRGB($nValA, $nValB, $nH + 1 / 3)
$nG = __ColorConvertHueToRGB($nValA, $nValB, $nH)
$nB = __ColorConvertHueToRGB($nValA, $nValB, $nH - 1 / 3)
EndIf
$aArray[0] = $nR * $__COLORCONSTANTS_RGBMAX
$aArray[1] = $nG * $__COLORCONSTANTS_RGBMAX
$aArray[2] = $nB * $__COLORCONSTANTS_RGBMAX
Return $aArray
EndFunc
Func __ColorConvertHueToRGB($nA, $nB, $nH)
If $nH < 0 Then $nH += 1
If $nH > 1 Then $nH -= 1
If (6 * $nH) < 1 Then Return $nA + ($nB - $nA) * 6 * $nH
If (2 * $nH) < 1 Then Return $nB
If (3 * $nH) < 2 Then Return $nA + ($nB - $nA) * 6 * (2 / 3 - $nH)
Return $nA
EndFunc
Func _ColorConvertRGBtoHSL($aArray)
If UBound($aArray) <> 3 Or UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(1, 0, 0)
Local $nH, $nS, $nL
Local $nR = Number($aArray[0]) / $__COLORCONSTANTS_RGBMAX
Local $nG = Number($aArray[1]) / $__COLORCONSTANTS_RGBMAX
Local $nB = Number($aArray[2]) / $__COLORCONSTANTS_RGBMAX
Local $nMax = $nR
If $nMax < $nG Then $nMax = $nG
If $nMax < $nB Then $nMax = $nB
Local $nMin = $nR
If $nMin > $nG Then $nMin = $nG
If $nMin > $nB Then $nMin = $nB
Local $nMinMaxSum = ($nMax + $nMin)
Local $nMinMaxDiff = ($nMax - $nMin)
$nL = $nMinMaxSum / 2
If $nMinMaxDiff = 0 Then
$nH = 0
$nS = 0
Else
If $nL < 0.5 Then
$nS = $nMinMaxDiff / $nMinMaxSum
Else
$nS = $nMinMaxDiff / (2 - $nMinMaxSum)
EndIf
Switch $nMax
Case $nR
$nH = ($nG - $nB) / (6 * $nMinMaxDiff)
Case $nG
$nH = ($nB - $nR) / (6 * $nMinMaxDiff) + 1 / 3
Case $nB
$nH = ($nR - $nG) / (6 * $nMinMaxDiff) + 2 / 3
EndSwitch
If $nH < 0 Then $nH += 1
If $nH > 1 Then $nH -= 1
EndIf
$aArray[0] = $nH * $__COLORCONSTANTS_HMAX
$aArray[1] = $nS * $__COLORCONSTANTS_SLMAX
$aArray[2] = $nL * $__COLORCONSTANTS_SLMAX
Return $aArray
EndFunc
Func _ColorGetBlue($iColor)
Return BitAND($iColor, 0xFF)
EndFunc
Func _ColorGetGreen($iColor)
Return BitAND(BitShift($iColor, 8), 0xFF)
EndFunc
Func _ColorGetRed($iColor)
Return BitAND(BitShift($iColor, 16), 0xFF)
EndFunc
Func _ColorGetCOLORREF($iColor, Const $_iCallerExtended = @extended)
If BitAND($iColor, 0xFF000000) Then Return SetError(1, 0, 0)
Local $aColor[3]
$aColor[2] = BitAND(BitShift($iColor, 16), 0xFF)
$aColor[1] = BitAND(BitShift($iColor, 8), 0xFF)
$aColor[0] = BitAND($iColor, 0xFF)
Return SetExtended($_iCallerExtended, $aColor)
EndFunc
Func _ColorGetRGB($iColor, Const $_iCallerExtended = @extended)
If BitAND($iColor, 0xFF000000) Then Return SetError(1, 0, 0)
Local $aColor[3]
$aColor[0] = BitAND(BitShift($iColor, 16), 0xFF)
$aColor[1] = BitAND(BitShift($iColor, 8), 0xFF)
$aColor[2] = BitAND($iColor, 0xFF)
Return SetExtended($_iCallerExtended, $aColor)
EndFunc
Func _ColorSetCOLORREF($aColor, Const $_iCallerExtended = @extended)
If UBound($aColor) <> 3 Then Return SetError(1, 0, -1)
Local $iColor = 0, $iColorI
For $i = 2 To 0 Step -1
$iColor = BitShift($iColor, -8)
$iColorI = $aColor[$i]
If $iColorI < 0 Or $iColorI > 255 Then Return SetError(2, $i, -1)
$iColor += $iColorI
Next
Return SetExtended($_iCallerExtended, $iColor)
EndFunc
Func _ColorSetRGB($aColor, Const $_iCallerExtended = @extended)
If UBound($aColor) <> 3 Then Return SetError(1, 0, -1)
Local $iColor = 0, $iColorI
For $i = 0 To 2
$iColor = BitShift($iColor, -8)
$iColorI = $aColor[$i]
If $iColorI < 0 Or $iColorI > 255 Then Return SetError(2, 0, -1)
$iColor += $iColorI
Next
Return SetExtended($_iCallerExtended, $iColor)
EndFunc
Global $g_cbCheckString = DllCallbackRegister('_CheckSendKeys', 'uint', 'uint;uint')
Global $g_cbCheckUDFs = DllCallbackRegister('_CheckUDFs', 'uint', 'uint')
Global $g_pcbCheckString = DllCallbackGetPtr($g_cbCheckString)
Global $g_pcbCheckUDFs = DllCallbackGetPtr($g_cbCheckUDFs)
OnAutoItExitRegister('__RESH_Exit')
Global $g_aAutoitVersion = StringSplit(@AutoItVersion, '.', 2)
Global $g_AutoitIsBeta = $g_aAutoitVersion[2] > 8
Global $g_RESH_VIEW_TIMES = True
Global $g_iTagBegin, $g_iTagEnd, $g_iTagComment
Global $g_iTagDS, $g_iTagDE, $g_iTagSS, $g_iTagSE
Global $g_RESH_iFontSize = 18
Global $g_RESH_sFont = 'Courier New'
Global Const $g_RESH_sDefaultColorTable = '' &  '\red240\green0\blue255;' &  '\red153\green153\blue204;' &  '\red160\green15\blue240;' &  '\red0\green153\blue51;' &  '\red170\green0\blue0;' &  '\red255\green0\blue0;' &  '\red172\green0\blue169;' &  '\red0\green0\blue255;' &  '\red0\green128\blue255;' &  '\red255\green136\blue0;' &  '\red0\green0\blue144;' &  '\red240\green0\blue255;' &  '\red0\green0\blue255;'
Global $g_RESH_sColorTable = $g_RESH_sDefaultColorTable
Global Const $g_cMacro = 'cf1'
Global Const $g_cString = 'cf2'
Global Const $g_cSpecial = 'cf3'
Global Const $g_cComment = 'cf4'
Global Const $g_cVars = 'cf5'
Global Const $g_cOperators = 'cf6'
Global Const $g_cNum = 'cf7'
Global Const $g_cKeyword = 'cf8'
Global Const $g_cUDF = 'cf9'
Global Const $g_cSend = 'cf10'
Global Const $g_cFunctions = 'cf11'
Global Const $g_cPreProc = 'cf12'
Global Const $g_cComObjects = 'cf13'
_CheckUDFs(0)
Func _RESH_SyntaxHighlight($hRichEdit, $sUpdateFunction = 0, $sNewData = "")
Local $iStart = _GUICtrlRichEdit_GetFirstCharPosOnLine($hRichEdit)
Local $aScroll = _GUICtrlRichEdit_GetScrollPos($hRichEdit)
_GUICtrlRichEdit_PauseRedraw($hRichEdit)
_GUICtrlRichEdit_SetSelNoFocus($hRichEdit, 0, -1, True)
Local $sCode
If $sNewData = "" Then
_GUICtrlRichEdit_GetSelText($hRichEdit)
EndIf
$sNewData = StringReplace($sNewData, "#Region", "#region")
$sNewData = StringReplace($sNewData, "#EndRegion", "#endregion")
$sCode = _RESH_GenerateRTFCode($sNewData, $sUpdateFunction)
$sCode = StringReplace($sCode, "#region", "#Region")
$sCode = StringReplace($sCode, "#endregion", "#EndRegion")
_GUICtrlRichEdit_ReplaceText($hRichEdit, '')
_GUICtrlRichEdit_SetLimitOnText($hRichEdit, Round(StringLen($sCode) * 1.5))
_GUICtrlRichEdit_SetText($hRichEdit, $sCode)
_GUICtrlRichEdit_GotoCharPosNoFocus($hRichEdit, $iStart)
_GUICtrlRichEdit_SetScrollPos($hRichEdit, $aScroll[0], $aScroll[1])
_GUICtrlRichEdit_ResumeRedraw($hRichEdit)
Return $sCode
EndFunc
Func _GUICtrlRichEdit_SetSelNoFocus($hWnd, $iAnchor, $iActive, $bHideSel = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iAnchor, ">=0,-1") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iActive, ">=0,-1") Then Return SetError(103, 0, False)
If Not IsBool($bHideSel) Then Return SetError(104, 0, False)
_SendMessage($hWnd, $EM_SETSEL, $iAnchor, $iActive)
If $bHideSel Then _SendMessage($hWnd, $EM_HIDESELECTION, $bHideSel)
Return True
EndFunc
Func _GUICtrlRichEdit_AppendTextNoFocus($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iLength = _GUICtrlRichEdit_GetTextLength($hWnd)
_GUICtrlRichEdit_SetSelNoFocus($hWnd, $iLength, $iLength)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_SELECTION)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
DllStructSetData($tSetText, 2, $CP_ACP)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_GotoCharPosNoFocus($hWnd, $iCharPos)
If $iCharPos > _GUICtrlRichEdit_GetTextLength($hWnd, True, True, 0) Then Return SetError(103, 0, False)
_GUICtrlRichEdit_SetSelNoFocus($hWnd, $iCharPos, $iCharPos)
If @error Then Return SetError(@error, 0, False)
Return True
EndFunc
Func _RESH_SetColorTable($aColorTable)
If $aColorTable = Default Then
$g_RESH_sColorTable = $g_RESH_sDefaultColorTable
Else
If IsArray($aColorTable) And UBound($aColorTable) = 13 Then
Local $acolor, $sColorTable
For $i = 0 To 12
$acolor = __RESH_GetRGB($aColorTable[$i])
If @error Then Return SetError(1, $i, 0)
$sColorTable &= '\red' & $acolor[0] & '\green' & $acolor[1] & '\blue' & $acolor[2] & ';'
Next
$g_RESH_sColorTable = $sColorTable
Else
Return SetError(2, 0, 0)
EndIf
EndIf
Return 1
EndFunc
Func _RESH_GenerateRTFCode($sAu3Code, $sUpdateFunction = 0)
Local $sRTFCode = $sAu3Code & @CRLF
__RESH_ReplaceRichEditTags($sRTFCode)
__RESH_ASM_MC($sRTFCode)
__RESH_HeaderFooter($sRTFCode)
Return $sRTFCode
EndFunc
Func __RESH_ASM_MC(ByRef $sSource)
$timer = TimerInit()
Local Static $bOpCode, $tMem, $fStartup = True
If $fStartup Then
$bOpCode = 'j7gAyAgAAIt1CIsAfQyKHoD7AA8AhNpIAACA+yAQD4b/RQFAIg+EhIZGASAnD4SmAiAgOw+EHEcBICQPhIS0AiBAD4ScAhAQLg+E4AIQJg+EQuUCWCgPhNwCECkID4TTAhAqD4TKIQIQKw+EwQIQLQ+EhLgCCCwPhK8CCEJbBWtdD4SdAgheCA+ElAIIPA+EiyECCD0PhIICCD4PhIR5Agg/D4RwAggQOg+EZwIILw+EAl4CCCMPhTkDAAAAZoE+I2N1EICAfgJzdQq5ABAYAOl+gHKBCm9tdQAqgX4EbWVudAB1IYF+CHMtcwB0dRhmgX4MYVJygRgOdIAYD4EYCEGDGE9iZnU2gBh1IHNjYXUtgBh0bxByX3UkABhQYXIAYXUbgX4QbWWQdGV1EoAhFHKBNxoWgR5LgI+AHlRpZAR1JYAeeV9QYXUCHIAecmFtZXUTqYAedGUCFhABFh4DFghBdXQCFm9JdDMhAhZXcmFwAhZwZRuAOQQW8YB0ABZpZ25BAWAEb3JlZgJgCKR1bgFgCmMAFAsBFCLIAxRlbmSBUgRyiGVnaUIpCG9ugAhaCoEIpYMIQSkZQilPUmbBEAhmAAgJAQiEEQMIZm9yAghjZWSqZQsIYw0IcgwIQocYj0AygRhBH0CjAOkngwajACYCMARpb4EOBsEHagfBBwfDB3CAWcIHZyptwgdhxQfnRGhuQRFDaHRvSUNoU3RhIUJocnRSZUJoZ2mTQHlCaGVyRWjpQ0IPIG5vYXUrQw9pdSIiQQ8zZXjBMgxlpmPAYwAcEGWADBGBDCK2gwxpbmNBCgRsxnVAQ0AKCC1vQARACioMQQoNQQqMQwpSZTJxQgp1aYBFQQpBZFxtaUIKATlCCmJDCklF3xQ4QwpOb1QCfnKoYXlJA35jwk0KgRQ9An4PhxSBXIIUhFz0QgsmGE0D2UADgH7/XwAPhO1BAACKXgD/gOswgPsJdwgF6d3lAWGA+xlV4AHN5QFB4wG94QEeBcYFPMIPSW5pUnVCM2AMZWFkU2FuCBBlY3RpIRcMb26uTiM6IGchFxIBYRNhEA7DwhNCBwFhZW5hbdkCYWVTgDGiZmmCVwJhypaFBVdCenJpoHBBerdgBUR6A0oOIQZCemTHC3/AQyMTwEMjE8FDQBNgBQ6Loi1lBUQCW2VsZYJB9gjhJQJbF8cPQSnCD0QpTvwAIuQMAldlYQJXZGUFV9ziA0NvYJCgGwQIaW51YoIIQ2FzFWEIDGEE4nQETG9vynBlBL5iBEVuwBhhFEh3aXRCRghoZRSdXwsEgBgDBIGcAgR8AwR4XGl0ghiEC4IYYUIDVohvbGFCA3RpbOYb2kbFCkbjGyOPBiGP4hsiJuIDRGVmBHd1bNfiA6EO4gMG5QdXBH9CK6YGwRbiA+ZA4QNT4BmpojIEYyEDBiEDzCIDtlJgMSMDcuE1IgOyYwYvQBxkBqENIgOYIgNHbKRvYiMDYWwlA35jBrR0YeQMaSEYIgNkIgNsRWzgMSIDSeGZIgNKOSIDTG+gwWAWIGgKucoF4QIy4gJVbiBJ6gLCGuICRmFsc+ICYSh94gIC4gLgO+MCoRXiAuryP+ECQnkgl+EC4Q7iAmLS4gJXaGliKecIulHiAlJlROMObeUCoiviAmAsSesIinIBTmUqeBEHBBEBeBMBdWyLMQsSAWYSAVRoZdEVxRIBVBIBU3Rl4SESAe5C8wgABhUBMBMHMRMUAbIeMwJpdPEbEgEMEgHTdC4SAfo+8hF1EEkUAbLoEgFUcgAvFAHWEgHYRW510Q0SAcQTAXErrRQBshABcH9GIj8CUV5tcn+bYwHTEQLxA2IBhLVjAUGCKwIhDGIBbWMBLk5DBLEFYgFWYwFUb9UAAQIBAUUDAU9hBgIB7jQDAWIiAgEjBAERFAIBFhKECDYEASIMR1VJCEN1RfE1cmxSdV48wUjAaoFTEYJMkU0QBcBrVpFNFGlld1OtEjMY4HYQChoRChtSHYo9xgQ9' &  'wwRDdTThhsZlsC3gbQxlVBBoAGYQEGVWaQJmFHdJ6wBLQAQYQREZUg1PBEwEtkygCUEEdE8ERQQARwSaN0UELkUEQF0MZTAvmSFNEHQxKKBFFE1wJuXgAxjhA8E84QMhfTJ9nSB9dDJ9oh4xfVVuP339Nn2D0gPCB4ALwweAC8MHn4ALEwyACxMMgAsUd7ADehWxA0e/A7wDcQqxA3XtRA8UQQ+yAwu/A7wD4RfnsQPiF3oHzzu/A3wHABNpMgtoQ0JHFIE6sgOTI78DvANQcm+yA2dy2mWCRhSxdrIDV78DvANEQ2gzC2NrYgIxFAp4tQMbsgNTdHJpQbEdBG5nRnKxHQgQb21BU7EdDENJZElBsR0QcmCKUAMU+VED5ToWB1EDEgdRAxIH4VEDZVRhYlIDABaxFRVSA69eA1NSA2V0REJlUgNmQmtDUgNv9mxgMVQDeVIDciRSA3Ekt1EDciRRA1LhsFEDc3A2bVUDQx8KHApHwKhRA3D2aMJiUgMNVwMBj1IDAY9DUgMBj2VVcGQDj2/OdwKPUUECj9I5rwOrA7ZCQKiiA3QyGKcDl6IDDERsEAOhA2FsbGLhogNhY2tSowOBRKMDN2OWYQ6iA1xfB1wHU2zuaaMD876nAyGiA5IfoQMMbmfQOKEDZ0V4cKGiA1JlcGyjA2GyhuYSUVyiA+Y4VgcQPVMHrxA9UwcQPZFBbRI9EPAmKAq5EkEDsUIDT2LOakMDsgJBA2VJgJFCA7ZyUIZCA2ORBkIDfJ4GhlNDA/TADHNpegOfaBBuZ0UDR+8J7AlM29ApQgNlAThCAxJPA0wDNkRAa0IDbXEwQgPdNwljcW5NQgNpbmltIUIDaXplQUIDbGxUVW5DA2SGEKhCA1QP4TRBAxIyQQNTZXRP0UIDbkV2w4oQkBFEAwZzQgPhCQC3AHUtgX4EdHJsAEN1JIF+CHJlAGF0dRuBfgxlAElucHUSZoF+ABB1dHUKuRIAAAAA6T43AACBID5HVUlDFdBHcqpvBGhwBWgJBWhTAmgQZXRBYwJoY2VsImUCaHJhdAQ0cnMJBTTUNgE0RHJpdpEDNEdldAI0RmkENJBTeXN0AzRlbQU0bp8CNAIiATRDAJYCNHQIZU5UAjRGU0xpKQM0bmsFNGoCNFN0hHJpAhpuZ1RvAhoQQVNDSQIaSUFyUnIDGmF5BRo1AxpvJHVuAhpkUwRPV2FCdgNPVm9sdQMabQplBRoAAhpQcm9jEYNpc3NTAhpldFCycgIaaW8AQgIadIY0RMs1HblSYWQDGmlabwUalg4ahTREA09mpkOATwIab3IFGmECDQlRT1NoAg1vcnRjJU2ELFUabmSDXG9ETHVtBELGNPc0AQ1USnLAUysADUl0gHAiIwANAHlIdRkADWFuYGRsdRCAwHaADBGFgQzEggxDb25zggwQb2xlV4IMcml08mWCDEVyQJ6BDMEzggz+kYIMgiaBDEJOggxBToEMqGVJY4MMboUMXoIMTEF1wKMDJldpggxuo8F3gQxUaXQMJitOGUJTggxldE9uAyZ2nGVuggzBTIIM+DNUGQsBuVMZxYIMV2luTUeCDEAURBlsZWOCDHRvAFGCDAHDggySggyZP001BCZ1RQZfTgZlGUdyUeMycGhpQgZjRQYsh0IGgkZBBkZpbmRCBjxGaWB5AhNgA2sZ+TItHRNEAAFKBsZeBkVkmwMThiyTTgZlGUJrQgbLIGAMRmBCBkRsgAtBBhBhbGxiQgZhY2uyR6MMdFADE0YGLR4TSExpcwsT+jEmJiWjQAZgPlN1HEAGaMBrpHUTQAZOYUKGEIEF3s2CBeILgQXgC0eCBQBlbmGCBQBlhgWgggXgF1PphAV1Y4IFdKFXgQXgKnphhQVzggWCkYEFgJFXIYIFYWl0Q4IFbG86cyYLRmsWojyBBU5l7ngjC0IDhAUZggWie4EFl6J7gQWgEFOCBXRhYFXZhAXsMA0coyFloBCCBexycyKUggW/ggUQ' & _
'HAFn0YEFU2l6JguSggVAZtZXggXgGk6CBW/hz8IQtmlgtYQFZYIFwIt0ggXUcm/5LDhlFkdDJ0EVx4EFQhWBBUluZkGxggWmC30WiTLeL60hQyMLY8FJgQVlUGlBb4IFsQ2CBVOgKYIFdXNiYVuDBSULVKEzhAWEgwVohGVsggVsRXhlggVsY3VgMcECVwASxQJXo28IbAhPYmrFAirPApHMAlRhYsUC/S5EGWWmE2zCAmllkBcdHNAbwgJWJ1PxgjILdEZv6SMqZGW2IaPCAm8IZwjoQXZpxQJ2wgImKpApmlDDL3UwLxIcY29BYYXCAknCAkh0dHDFAkJVwgJzZXJBwgJne8ELxAIcmwXGL2I+zS/vQi0KDlJlY3kDDmxkZUXCAm1wgoDCAsILwgISkSqhE1NwYXV2IWKUAIsYAHagBZFGDupsEAMPEQOQEgNyZhEDhklwQBIDdE9wdBMD7xCDEQOhDhIDXjMGwSoRA9/CKhIDISUSAwNQDmEXEgM+LBIDAh1SCQEdEQNhc2xzTDQG8k8OERISA/r+LIYaMwagNhEDABI0BtNf9g5hEhIDyBIDwjkRA8I55xMDcCASA2N1EgPRoxID6pY+BlMUA0MUA7NfdwxeZBIDUqARA1CgchIDaUhtUmkTA2doewwyHxID0mIRA9Jikg9ja0btEwNyEnl3DAAVA90VoJYznw8RA84rBiIRA1Jlw6CeEQNUb0FyNAYzH/tRIhIDnBID8iczH/AnEQOlABxUEwNleHsMahID278S9xh5AnxXCTgfAxQD29C1EgNtwng3BgZfCRIDZ7A0XwkSA9Qqmg/gC0VhEgNuY29kdCXCiw46ZxUDohIDAm2SKHNzi38lWyJwEgNBZGwzH9BiVW5SEwNnMCsTNSsTHFYiPl4JTBIDb27UZ040Bm27EgwSA78SUGV0SW0UA2cbA9q+KT0GEwPygdkuthKoEgPD+TFTCWlzdFa0EnMMencVA3YSA18JPzgVA0TFPgZUEgNyZWU/BhIDohISA1RDUPLKBOKEwQDBCFNvY2sCweCU5bACDrEC5ijSN0DDsgIQS2VlcLICQWN0LQPRDKJ6sgK6sgJNb2R1c7ICZUPgG7ECY9xrRGPaERW0Ao6yAlILy7ECUAtEsgJpcyBpsgL7Un2yAmKyAjIqsQLiz7ECaHRlSYPmDILmsgI2h/MK0UKxAm5nSXOyAnBYRGlnswLCdLICCp+yAnJb8gpxW/IKZUb0CtJlNgjeJ/0KR7ICYDLuZbMCEn2yArKyAjgIYGChsQJCaW5hswJyUUG9sgKGsgK2DfI3sQJEIXW3tgASZoF+DHRldQAKuQ4AAADpWgAnAACBPkZpbABldSSBfgRTYQB2ZXUbgX4IRJBpYWx1AqxvZwWsQi4LrEdldFYCVmWocnNpBFZuBVYCAlbQTW91cwJWZQBYAlZQQ3VycwQrcgUr1kImCldPcGVuFoOqIQIrU3RyaQIrbmeEVHICK2ltTGUDKxRmdAUrfgIrQ29uQnQCK3JvbEMCK29IbW1hgxVuZIUVUiGCFVdpbk2CFWluRGltgyt6ZUGDFWwqbIUVJoUVR4NtdENCYYIVcmV0UIRXcwmFFfolgRVHVUlDIYIVdHJsU4OZdEZWb4RBhlfOjhVSgxVjVHZNgxVzhoOihRVSEYNBZ2lzghV0ZXKFjhV2ghVCaW5hg4N4eVRvwgpCUcMgxgpKEcIKVURQwyBsb3Phw4NTb2NrwwoAcsQKQh7CClRyYXnDjmVkdE/CCm5FAJHMNvIiJMoKQ3Jlw0x0ZSpNxQp1xQrGwgpEbEOAa8EKYWxsQcIKZFRkcsQKc8ZXmsMKcuRpdsuZU2XFNsCQxAqubsIKyYPFYlTEFXjGK5ZCwgrRbUTEjnRhxQqSFtUKbmTOYuojzUwiVMOkb2xUwwppcAXFCr7CClByb2N1giLBNnNzRXUZwAqAeGlzdHUQgIAVFUAKDUEKlEMKaXhlIUIKbENoZUIKY2vU' &  'c3VCCm1FCmpCCmJtISEFQ2hhbiIFZ2XcRGkiBaFyIgVAKwUAK1pBIgV0oUYhBWIlBRbLIgXgH1PjFHRPYwrAQE5uIgWhKiIF7CKid3CEbGEiBXNoSW0iBXBhZ2VPIgXhhyIFwkMiBWYKdGFydCIFR9xybyMaoSQiBZhjCqESISEFbmdDbyIFbXDcYXIiBWGdIgVuIgWnJENhRSEFQ29sb2sfRB8iBaJKIhrANCIFTGFiLmUiBWFKIgUarQ9Jc+EiBUFscGgiBaFEIgXU8CE1BU5sNMYiBSYviFdyaaMPZUxp4yndJhqcKwXAFHU0ciIFJxo7ZR8vGkgiBaKbozlQcqEiBW9jZXOrTh50ClMiAuoU9CBsH1LjU3ZbQMcrBcoiBaAPVyIFYdJpJBpjdG0KoCIFom7RIkRybESjJGzAECoFPnYiBeJ+IQXgfuNobmE0YmwrBUztFGQ0U3AUYWMrBSI0BUFTQ0pJIgVJJQX4HzMFTCxvdyMvpk7ONAVGbBRvYetopDQFRGlnK+M+JgV6LQVTMxpyadRwV5ICU5UCUD8FkgIoVXBwfAomkgJBZMJskwJiUmVnkgJgSVmcAvwe3wfUB0OSAlK9lQLSnQIUIqBCnBeokgJl2RxHcx90UFM89il+a5ICGSJTlAJUUxI2RFQ3nwI/BZICKpUCtU5Caws/RJICABMNaGVsdaoc0UZFYEcTkSx10pdyDDEC3B22DDECsAxG7zICEF8RBzICuDICUmAxAt1QYEMyAqJ5NAKUMgLSE8cxAtITMQJnRXgxDjICtnC+BnQEaZB9NAJMMgLD8kQxAlJlYWQyAoBHfbYGKDICMj7yCFE/MQJUVnlwIjQCBLUGczICbzhsZVcyApBMNgLgHO+WcDECsEv/CLwyAngNQJPZcgRtYREuMgKYMgISQxcxAhBD/xF0MgJIdHSKcLUGUHMEb3h5NQKKUHUER3MNdEhhMgKsbmTQEDQCLD4LUzICdHRhdw0IMwsxbjECczZowIUxAnhhcTQC5BvTViSzBkN18whzUrEyAhbAMgJyFiExAk1hcKR1GACCCEdCNgoBEFoLgQKXggKAC1ODAnS/ILGCAqB9gQKRJIICbo4CammDAnRiUAohDIICRV3lCUeEAmA7ggJ5jAIc/3cMgwKwd4ICYAyBAuG1ggL88xoGNoECoq2CAmCgigJeyoICEhaBAhAWSYMCY+3iNQohFIICoYICoiGBAn3gSm6DArAKgQJxFIICeC+CAnIvgQJwL0iDAmlkzcsMT4ICDxcIQYMCNgriJoICRnRwVQ8QclMPzniCAiElggL9GR8FggIuRCMcMXeCAtSCAkluV6A0gQIgNVM0Cno7CquHggICOoECUmVjeeQRXZwZgosCcqYTBW2LAlm7ggJ5FHODAvAUaiYwggJDkMFTD2h1dGRUD3dNmxkHzgwkHG5mggJveYUC3hjcI2UmwD06CrX3jwL/KIECjIICyAygG4ICWmTiZgrhZoICY4ICVBZDzwzMDDoTBWV0RXmCAnh0IK0TBSMcRiERe4ICtx5T8MHDNdKdVzjouhf9KE2kBwKOxwy/ggJdgF9ngwKQX4MCT3MUZl2FApaPAqQwnEJtgALktgCBPlRDUE51IQCBfgRhbWVUdQAYZoF+CG9JdQAQgH4KUHUKuQALAAAA6UQXAIAAgT5NZW1HAqCQZXRTdAOgYXQCoApzBVAbAlBDb25zIQJQb2xlUgNQZWElAlBkBVDyFgFQSXOERGwCKGxTdHIDKFR1YwIodAUoyQIoVyRpbgV6VGkDKHRstQIoZQUooAIoAEdpAiiQbmdMbwMod2UCKEpyBSh3DShVcAMUcLUMFE4FPVOTegY9JQ0UpE9uAxRUbwIUcAUUFPwVBBRBAhRjdGkKdpMo0wIUUHJvY1GDKHNzVwQUaQuPqhECFE1vdQO4ZUdlbYRRUAM9hsyBAhSAzHShAhRyb2xTAxRoAwqKdwUKWIMeaXhlRGargG4CCnJD' & _
'ZmgFCi/OKNJMAwppc8soBkU9VI9JRj3dFNQoZW5Lj7SrAgqIcFOEcGyMR4sCCjhGaWwDM0BHRBRpesWLHmILCkluc8Uog5mabAUKOU4UxMxpbUsUShDNKFIErmdoyyjnRhMBCkDhQ3UbwcxuUG5ldRIBCmOBCAp9gQjEgghCUIEIwByECHgthgihgggA1GWCCGNstGFygwhlQU2CCH6CCLOCLoEIRXgAaoIIdKFEFUIEW2URU0IEdGFyWnRDBHVhWEIEOKsIU6hldFBDBG+mCBVCBIhHVUmjCGV0SMQVkmymCPISQQRCbIBHYUEEa0lucAQNJhrPp0IEQluiCFdopAhlgTG1QgSsTARD4D9DJ2tFBOaJQgRoEUZvQwSATEQEUmZNBEljJBpuRQRDYUIEVHJheUIEoD5NKUMEc2dFBCBCBFN0RGRvQgR1dFLEFWEpBjD9EUQEaSM9Q2wtZBFzoUZCBNpCBFZhunImPXlDBICTRAS3qwjcblcgTMM4RgSURAQgA6lCBGdMZBFmhh5xpQgpwzhycs8VTkIEUmVEZ0WjCHVtSwQweb1FBCtCBIZB4CKOQQhCBFREaSYaU8QVesYV5VoQDQ1WZBEmPcJCBFXaRBhTn0IE4JFnIxoAkjdDBKCxRAR8QgTGFURlCwABTCdZQgRJc0tlhHUZQAR5d29ywXUaCKEiCeJfAgRCaXTSUgIEb3SjmAghCAIE9hcCBIB1RQIEoGwDBCEi+QIE9g+mMwEEojMBBMEU7QIE1QIE4CFEAgSgFEwMFrQCBMB0QQIEY2Nl7nACBKE7AgSTAgQCYyIIKERvd0sMcgwETW/6disGUQIComoiBqFqCgLOMAICshQBAkZsoAQBAivxYQICD1MMdRQEc1fTs2tHCu4OVAxMAgJwEp18EM0CAqAjoxZlbU0KSqwFAkMCAnJlvRiL3wICRgoAN0MKBgJqCwKwNN0cBEkCAqJXMgh0g3XXHBIoUwxpbRMEckRpamYCAmYFAgcCAugeTZNzEBYl5g0bBElujBJCxQICRW52VQICcApkbQ6kAgJTb3Vu0QICZFBs4pYIcToCAvKDAgJJboAkfxDybwICkEhvdEtjDnlTsxg1NghBIwZwkAXSHGhPHWwOIAICUlQBAndpdBPygvcg/wwBAk9ianvPGgMC3gICEAQPAgMCvbsFArUYTVMMMVgCApwCAkhCaW5DCnJ5rRZ7uw0CrTdaJQavNwMCOVUMSEV1EwACdmVyZAidoQEeogGyJKEBT3Bgi2WkAQOiAUlzkI+hAXJsaW4xC6IB6ECAoQFOYnWiAW1iZQGoogHNZ6IBEHazBnJysEikAbJnUwMBHaEBUmViW6IBl6GiAUZ1bmOiAU5gvRWlAXxUA3CzBnRCb2p4pQFhswZo8HehAWQ0b3fGC0YDBXUNQ2+2cHElogErogHQMUaiAVhsYXPhHqIBEKIBRGhsbEOjAW9CbqIB9cuQViJUU6IBaGliaaIB7tqiAQAFXwO/ogFmCBBLbaYBpKsB2RCJogGwVFcXlBeiXqIBbqIBSXNCommiAW5hcnYNU6IBVeBmTzKbBKPBBiERB4XxATPyAUNlaWzzAdppAqoGQR3yARPyAVAiak7zAWHCoQahB/IB83OwJNAWUmGDwuAW8gFtvfUB0/IBwhPzA1KoBuFwnfIBs/IB8Anj1QRlsjbUBnb1AZP1AUL6CVERxfIBc/MFaXJN8wGDVX33CVPyAVAT9QXyRPcDM+v1A/QJb/JnBvET8w/zA9R1bmPLBKNfBmEe8w//UBb0lPIBQN3xAbF88w/yAeviafMHVfsBs/IBYCL/BfPzD/IBRXhwEfIBUC36Db5z8gHgonPDgIv7A1PzCY5D/xX0D/IBSXNBU+vcBHLzEfcP9QlL9Bf8G+bzUADwBW9v9CP+D/IBb/ADI9WwcfsJs/IB9wtQ5nX8D/IBSXNQefMZ8wkN9gFz8gHwJU/TtAB1GGaBfgRwZQB1EIB+Bm51CoC5' &  'BwAAAOlTAChAgT5VRFBTA/hlKm4CfGQFfDMCfFdppG5NA3xvdgI+ZQU+QhMCPklzQWQDPm2SaQu+8wYBPlRDFb5C0wIfSW5ldAMfRxUDn3QFH7MCH09iajhHdRICPwEZABMA6UKZAhlSYW5kAxlvim0FGX8CGUVudg4zQmWCDE51bWKEDHJFhQxLg0NzQm+EJmyFhQwxggxDRFRygwwUYXmFDBeCDE1zZ0pChBl4hQz9BYEMU0h0cmmDDG5nhQzjoYIMSXNGdYQMY4UMesmCDFUAQIQMgZGCDK8hggxCaXROgwxPVFWFDJWFDFiEDFKFDHulhQxBgwxORIUMYUIGlUBHU01HR8QmSFdNIKItQgZBc3PEM2fBd6VCBhPEGW5hQwZyRkfU+QREIE9BdARBJsAKCADp4cIFSXNPYlXCBWrFBcnEBUlCiASLQSXCBbHCBVNsZUKGFARwxQWZwgVGbG8ub8IFQXLCBYHCBVJ1VG5BwgVzxQVpxBdQinTLC1HDKXJlYcIFymvFBTnDEW91wyPBQmXCBSHDI3FyQSjAAgA06Q9DBGXCS0IE/QNZwlh2YUGRQgTrQgRQFmlCgkIE2UIEQ2hySldFBMdDBGFsRg21UUIEQXNjxgijQwRDFm/BNUIEkUIEQmVly0FGQgR/wwhTaUFpQgRSbUIESFcnFFtjBFRqYWYESSACZsBZwikCowEFAAIA6TLDAkzDAquhF8ICG8MCU8J9AoEI1cICBMMCRGI1AmFbwgJs7QLCAkMvAkEvwgLWqcMCUnWLCL/DAkNDDssBHcICqMMCRXjCAqEdbcICkcMCw0YCgTLCAnqtwwJUojpnC2NkC2grEVJMwwJPcIsINcMCQepzyxkewwJIoxyhfsICDgekBQJb5xbwAQAAAIA+X3UygH4BAF90LIpeAYDrADCA+wl3AusfoYIBYYD7GYABEoIBIkGDAQXpjsAGgT5QXHRhYiU0ImI2XKxwYcEWIgIQwy1wgxwFphn5ABFW/1UUgwD4AHQlicHB6QAQZoP4AQ+EfENACiABAg+EhiMBAwgPhFIgAesApOkA57n//4A+AA8EhMOAB8cHXGNmADDGRwQgg8cFrOnMQAMiAjQkAqQCBUKaAAWBPiNjAK8fASG/ZW50dRaBfggIcy2AvA2AfgwgZHUHuQ3gEesCwOvN86TroWsI4BbkI2PhBAJl4AThFuAEQOnzpOl2/8QNMklEBYn6AA4idaIAdAD0iftTUv9VEFCJx+lNEgUnAgUnBQkFJAUFMWbHRwRSMkAFBvNjGNZiMzukdDegAXTt4QuFYQcAqYA+Cg+E7f4hQSI8D4RZoASk68rOQgg25RfpzsADzSJgCnX66bblAqINMWmjDemgpQI5pAVgAoxVZQI4ZwJ4ZQI3pQqKWh7mRfNhASBEBWAB5wdhAUBHYQHbgD54dJjW6TwmD2QH6w/CAYo1xQEAIApfdPqUAy1xJu4UBbEA4pgG1ulc7/3EBBYPaAMRaAMF7OnEpQISDzMRD8kCVQvHsQBSCzQG2+mLhQMVHIlRGXREEBkPhKHSF6VgGGZAAuvmYgIzdhJVcQIccgJ5dQI+cAKkBOvmMBQbt///xggHALhgGwDJwhAAAC=='
$bOpCode = _B64Decode($bOpCode)
Local $tBuffers = DllStructCreate('byte[18683];byte[18683]')
DllStructSetData($tBuffers, 2, $bOpCode)
Local $aDecompress = DllCall('ntdll.dll', 'uint', 'RtlDecompressBuffer', 'ushort', 0x0002, 'ptr', DllStructGetPtr($tBuffers, 1), 'ulong', 18683, 'ptr', DllStructGetPtr($tBuffers, 2), 'ulong', 8716, 'ulong*', 0)
If @error Or $aDecompress[0] Then Return SetError(2, 0, 0)
$bOpCode = BinaryMid(DllStructGetData($tBuffers, 1), 1, $aDecompress[6])
Local $aMemBuff = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", 0, "ulong_ptr", BinaryLen($bOpCode), "dword", 4096, "dword", 64)
$tMem = DllStructCreate('byte[' & BinaryLen($bOpCode) & ']', $aMemBuff[0])
DllStructSetData($tMem, 1, $bOpCode)
$fStartup = False
EndIf
Local $iLen = StringLen($sSource) * 5
Local $tOutput = DllStructCreate('char[' & $iLen & ']')
DllCall("kernel32.dll", "bool", "VirtualProtect", "struct*", $tOutput, "dword_ptr", DllStructGetSize($tOutput), "dword", 0x00000004, "dword*", 0)
DllCallAddress('dword', DllStructGetPtr($tMem), 'str', $sSource, 'struct*', $tOutput, 'ptr', $g_pcbCheckString, 'ptr', $g_pcbCheckUDFs)
$sSource = DllStructGetData($tOutput, 1)
EndFunc
Func _CheckSendKeys($iStartAddress, $iEndAddress)
Local $sSendKeys = 'alt|altdown|altup|appskey|asc|backspace|break|browser_back|browser_favorites|browser_forward|browser_home|' &  'browser_refresh|browser_search|browser_stop|bs|capslock|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f\d|f1[12]|' &  'home|ins|insert|lalt|launch_app1|launch_app2|launch_mail|launch_media|lctrl|left|lshift|lwin|lwindown|lwinup|media_next|' &  'media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|' &  'numpaddiv|numpaddot|numpadenter|numpadmult|numpadsub|pause|pgdn|pgup|printscreen|ralt|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|' &  'shiftdown|shiftup|sleep|space|tab|up|volume_down|volume_mute|volume_up'
Local $iLen = $iEndAddress - $iStartAddress
Local $tString = DllStructCreate('char[' & $iLen & ']', $iStartAddress)
Local $sString = DllStructGetData($tString, 1)
$sString = StringRegExpReplace($sString, '(?i)([+^!#]*?\\{)(' & $sSendKeys & ')(\\})', '\\' & $g_cSend & ' \1\2\3' & '\\' & $g_cString & ' ')
If $iLen = StringLen($sString) Then Return $iEndAddress
$iEndAddress += (StringLen($sString) - $iLen)
$tString = DllStructCreate('char[' & $iEndAddress - $iStartAddress & ']', $iStartAddress)
DllStructSetData($tString, 1, $sString)
Return $iEndAddress
EndFunc
Func _CheckUDFs($iStartAddress)
Local Static $fStartup = True, $oUdfs, $oFunctions, $oKeyWords
If $fStartup Then
$oUDFs = ObjCreate("Scripting.Dictionary")
$oFunctions = ObjCreate("Scripting.Dictionary")
$oKeywords = ObjCreate("Scripting.Dictionary")
$oUDFs.CompareMode = 1
$oFunctions.CompareMode = 1
$oKeywords.CompareMode = 1
Local $aUdfs = __GetUDFs()
$aUdfs = StringSplit($aUdfs, '|', 2)
For $i = 0 To UBound($aUdfs) - 1
If Not $oUDFs.Exists($aUdfs[$i]) Then
$oUDFs.Add($aUdfs[$i], StringLen($aUdfs[$i]))
EndIf
Next
Local $aFunctions = __Functions()
$aFunctions = StringSplit($aFunctions, '|', 2)
For $i = 0 To UBound($aFunctions) - 1
If Not $oFunctions.Exists($aFunctions[$i]) Then
$oFunctions.Add($aFunctions[$i], StringLen($aFunctions[$i]))
EndIf
Next
Local $sKeywords = 'ReDim|And|ByRef|Case|Const|ContinueCase|ContinueLoop|Default|Dim|Do|ElseIf|Else|EndFunc|EndIf|EndSelect|EndSwitch|EndWith|Enum|Exit|ExitLoop|False|For|Func|Global|If|In|Local|Next|Not|Null|Return|Select|Static|Step|Switch|Then|To|True|Until|Volatile|WEnd|While|With|Or'
$aKeywords = StringSplit($sKeywords, '|', 2)
For $i = 0 To UBound($aKeywords) - 1
If Not $oKeywords.Exists($aKeywords[$i]) Then
$oKeywords.Add($aKeywords[$i], StringLen($aKeywords[$i]))
EndIf
Next
$fStartup = False
Return
EndIf
Local $tString = DllStructCreate('char[50]', $iStartAddress)
Local $sWord = StringRegExp(DllStructGetData($tString, 1), '(\w+)\b', 3)
If @error Then Return 0
Local $oDict, $iRet = 0
If $oUDFs.Exists($sWord[0]) Then
$iRet = 1
$oDict = $oUDFs
ElseIf $oKeywords.Exists($sWord[0]) Then
$iRet = 2
$oDict = $oKeywords
ElseIf $oFunctions.Exists($sWord[0]) Then
$iRet = 3
$oDict = $oFunctions
EndIf
If $iRet Then
Local $tRet = DllStructCreate('word[2]')
DllStructSetData($tRet, 1, $iRet)
DllStructSetData($tRet, 1, $oDict.Item($sWord[0]), 2)
Local $tDwordRet = DllStructCreate('dword', DllStructGetPtr($tRet))
Return DllStructGetData($tDwordRet, 1)
EndIf
Return 0
EndFunc
Func __RESH_ReplaceRichEditTags(ByRef $sCode)
Local $time = TimerInit()
Local $aRicheditTags = StringRegExp($sCode, '\\+par|\\+tab|\\+cf\d+', 3)
If Not @error Then
$aRicheditTags = __ArrayRemoveDups($aRicheditTags)
For $i = 0 To UBound($aRicheditTags) - 1
$sCode = StringReplace($sCode, $aRicheditTags[$i], StringReplace($aRicheditTags[$i], '\', '#', 0, 1), 0, 1)
Next
EndIf
$sCode = StringRegExpReplace($sCode, '([\\{}])', '\\\1')
$sCode = StringReplace($sCode, @CR, '\par' & @CRLF, 0, 1)
$sCode = StringReplace($sCode, @TAB, '\tab ', 0, 1)
EndFunc
Func __RESH_HeaderFooter(ByRef $sCode)
#Tidy_Off
$sCode = 	"{" 													&  "\rtf1\ansi\ansicpg1252\deff0\deflang1033\deftab416" 			&  "{" 												&  "\fonttbl" 										&  "{" 											&  "\f0\fnil\fcharset0 " & $g_RESH_sFont & ";" &  "}" 											&  "}" 												&  "{" 												&  "\colortbl;" 									&  $g_RESH_sColorTable 							&  "}" 												&  "{" 												&  "\*\generator Msftedit 5.41.21.2510;" 			&  "}" 												&  "\viewkind4\uc1\pard\f0\fs" & $g_RESH_iFontSize  	&  StringStripWS($sCode, 2) 							&  '}'
#Tidy_On
EndFunc
Func __RESH_GetRGB($vColorValue)
If IsNumber($vColorValue) Then Return _ColorGetRGB($vColorValue)
If IsString($vColorValue) And StringLeft($vColorValue, 1) = '#' Then
Return _ColorGetRGB(Dec(StringTrimLeft($vColorValue, 1)))
EndIf
Return SetError(1, 0, 0)
EndFunc
Func __RESH_Exit()
DllCallbackFree($g_pcbCheckUDFs)
DllCallbackFree($g_pcbCheckString)
EndFunc
Func __ArrayRemoveDups(Const ByRef $aArray)
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
Local $oSD = ObjCreate("Scripting.Dictionary")
For $i In $aArray
$oSD.Item($i)
Next
Return $oSD.Keys()
EndFunc
Func __ArraySortbyLen(ByRef $aArray, $iDecending = 1)
Local $aArray2D[UBound($aArray)][2]
For $i = 0 To UBound($aArray) - 1
$aArray2D[$i][0] = $aArray[$i]
$aArray2D[$i][1] = StringLen($aArray[$i])
Next
_ArraySort($aArray2D, $iDecending, 0, UBound($aArray) - 1, 1)
For $i = 0 To UBound($aArray) - 1
$aArray[$i] = $aArray2d[$i][0]
Next
EndFunc
Func _Decompress($bData, $iOrigLen)
Local $tBuffers = DllStructCreate('byte[' & $iOrigLen & '];byte[' & $iOrigLen & ']')
DllStructSetData($tBuffers, 2, $bData)
Local $aDecompress = DllCall('ntdll.dll', 'uint', 'RtlDecompressBuffer', 'ushort', 0x0002, 'ptr', DllStructGetPtr($tBuffers, 1),  'ulong', $iOrigLen, 'ptr', DllStructGetPtr($tBuffers, 2), 'ulong', BinaryLen($bData), 'ulong*', 0)
If @error Or $aDecompress[0] Then Return SetError(2, 0, 0)
Return BinaryMid(DllStructGetData($tBuffers, 1), 1, $aDecompress[6])
EndFunc
Func _B64Decode($sSource)
Local Static $Opcode, $tMem, $tRevIndex, $fStartup = True
If $fStartup Then
If @AutoItX64 Then
$Opcode = '0xC800000053574D89C74C89C74889D64889CB4C89C89948C7C10400000048F7F148C7C10300000048F7E14989C242807C0EFF3D750E49FFCA42807C0EFE3D750349FFCA4C89C89948C7C10800000048F7F14889C148FFC1488B064989CD48C7C108000000D7C0C0024188C349C1E30648C1E808E2EF49C1E308490FCB4C891F4883C7064883C6084C89E9E2CB4C89D05F5BC9C3'
Else
$Opcode = '0xC8080000FF75108B7D108B5D088B750C8B4D148B06D7C0C00288C2C1E808C1E206D7C0C00288C2C1E808C1E206D7C0C00288C2C1E808C1E206D7C0C00288C2C1E808C1E2060FCA891783C70383C604E2C2807EFF3D75084F807EFE3D75014FC6070089F85B29D8C9C21000'
EndIf
Local $aMemBuff = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", 0, "ulong_ptr", BinaryLen($Opcode), "dword", 4096, "dword", 64)
$tMem = DllStructCreate('byte[' & BinaryLen($Opcode) & ']', $aMemBuff[0])
DllStructSetData($tMem, 1, $Opcode)
Local $aRevIndex[128]
Local $aTable = StringToASCIIArray('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/')
For $i = 0 To UBound($aTable) - 1
$aRevIndex[$aTable[$i]] = $i
Next
$tRevIndex = DllStructCreate('byte[' & 128 & ']')
DllStructSetData($tRevIndex, 1, StringToBinary(StringFromASCIIArray($aRevIndex)))
$fStartup = False
EndIf
Local $iLen = StringLen($sSource)
Local $tOutput = DllStructCreate('byte[' & $iLen + 8 & ']')
DllCall("kernel32.dll", "bool", "VirtualProtect", "struct*", $tOutput, "dword_ptr", DllStructGetSize($tOutput), "dword", 0x00000004, "dword*", 0)
Local $tSource = DllStructCreate('char[' & $iLen + 8 & ']')
DllStructSetData($tSource, 1, $sSource)
Local $aRet = DllCallAddress('uint', DllStructGetPtr($tMem), 'struct*', $tRevIndex, 'struct*', $tSource, 'struct*', $tOutput, 'uint', (@AutoItX64 ? $iLen : $iLen / 4))
Return BinaryMid(DllStructGetData($tOutput, 1), 1, $aRet[0])
EndFunc
Func __Functions()
Local $sFunctions = 'GUICtrlRegisterListViewSort|GUICtrlCreateListViewItem|GUICtrlCreateTreeViewItem|GUICtrlCreateContextMenu|OnAutoItExitUnRegister|GUICtrlCreateMonthCal|GUICtrlCreateProgress|GUICtrlCreateCheckbox|GUICtrlCreateListView|GUICtrlCreateMenuItem|GUICtrlCreateTreeView|OnAutoItExitRegister|GUICtrlCreateGraphic|GUICtrlSetDefBkColor|StringFromASCIIArray|GUICtrlCreateTabItem|GUICtrlCreateSlider|StringRegExpReplace|DllCallbackRegister|IniReadSectionNames|GUICtrlCreateUpdown|GUICtrlCreateButton|StringToASCIIArray|SoundSetWaveVolume|DriveGetFileSystem|FileCreateNTFSLink|ProcessSetPriority|FileCreateShortcut|GUICtrlSendToDummy|GUICtrlCreateRadio|GUICtrlSetDefColor|GUISetAccelerators|GUICtrlSetResizing|GUICtrlCreateLabel|GUICtrlCreateCombo|ObjCreateInterface|GUICtrlCreateDummy|GUICtrlCreateInput|GUICtrlCreateGroup|WinMinimizeAllUndo|TrayItemSetOnEvent|GUICtrlCreateDate|FileFindFirstFile|GUICtrlSetGraphic|GUICtrlCreateEdit|GUICtrlCreateList|DllCallbackGetPtr|GUICtrlSetBkColor|GUICtrlCreateMenu|GUICtrlCreateIcon|ConsoleWriteError|TrayItemGetHandle|AutoItWinSetTitle|WinMenuSelectItem|AutoItWinGetTitle|GUICtrlSetOnEvent|GUICtrlCreateObj|GUICtrlCreateTab|WinGetClientSize|GUICtrlCreatePic|StatusbarGetText|ShellExecuteWait|HttpSetUserAgent|TrayItemGetState|FileRecycleEmpty|FileSelectFolder|IniRenameSection|GUICtrlCreateAvi|TraySetPauseIcon|ProcessWaitClose|FileFindNextFile|TrayItemSetState|FileGetShortName|GUICtrlGetHandle|DllStructSetData|ControlGetHandle|GUIGetCursorInfo|DllStructGetData|GUICtrlSetCursor|DllStructGetSize|WinWaitNotActive|FileGetEncoding|ProcessGetStats|AdlibUnRegister|GUICtrlSetStyle|GUICtrlSetLimit|TrayItemSetText|ControlListView|GUICtrlSetState|ControlTreeView|FileGetLongName|GUICtrlSetImage|FileGetShortcut|WinGetClassList|GUICtrlGetState|ControlGetFocus|DriveSpaceTotal|AutoItSetOption|DllStructGetPtr|DllStructCreate|FileReadToArray|TrayItemGetText|GUICtrlSetColor|StringTrimRight|IniWriteSection|DllCallbackFree|GUIRegisterMsg|IniReadSection|BinaryToString|UDPCloseSocket' &  '|GUICtrlRecvMsg|WinMinimizeAll|WinGetCaretPos|GUICtrlSetFont|TraySetOnEvent|GUICtrlSetData|GUICtrlSendMsg|TraySetToolTip|ControlSetText|TrayCreateMenu|DllCallAddress|DriveGetSerial|ControlCommand|TrayCreateItem|StringIsXDigit|DriveSpaceFree|ControlDisable|TCPCloseSocket|SendKeepActive|MouseClickDrag|ControlGetText|MouseGetCursor|FileOpenDialog|StringTrimLeft|FileGetVersion|StringToBinary|TrayItemDelete|FileSaveDialog|StringIsLower|StringIsASCII|StringIsDigit|StringIsFloat|GUICtrlDelete|WinWaitActive|StringIsSpace|ControlEnable|StringStripWS|GUICtrlSetTip|ControlGetPos|GUISetBkColor|GUICtrlSetPos|AdlibRegister|StringIsUpper|StringReplace|StringStripCR|StringReverse|SplashImageOn|GUISetOnEvent|StringCompare|GUIStartGroup|PixelChecksum|ProcessExists|FileGetAttrib|FileChangeDir|PixelGetColor|DriveGetLabel|FileSetAttrib|DriveGetDrive|WinGetProcess|StringIsAlpha|DriveSetLabel|FileWriteLine|StringIsAlNum|WinWaitClose|HttpSetProxy|TraySetClick|StringFormat|SplashTextOn|GUISetCursor|WinGetHandle|TraySetState|ProcessClose|StringRegExp|ShellExecute|ControlFocus|DriveGetType|ConsoleWrite|ControlClick|FileReadLine|StringUpper|StringLower|WinGetTitle|WinActivate|WinSetOnTop|WinSetState|TCPNameToIP|ProgressSet|ProgressOff|IsDllStruct|ConsoleRead|MemGetStats|FileGetSize|StringSplit|ControlSend|StringRight|FileGetTime|FileInstall|ControlShow|MouseGetPos|ProcessWait|WinGetState|ProcessList|PixelSearch|ControlMove|ControlHide|StringInStr|TraySetIcon|DriveMapDel|FtpSetProxy|DriveMapAdd|WinSetTitle|WinSetTrans|DriveMapGet|GUICtrlRead|GUISetCoord|GUIGetStyle|StringAddCR|GUISetStyle|GUISetState|DriveStatus|SetExtended|TCPShutdown|FileSetTime|FileRecycle|InetGetSize|InetGetInfo|UDPShutdown|StringIsInt|StdinWrite|StringLeft|StderrRead|StdoutRead|StdioClose|VarGetType|RegEnumKey|UDPStartup|ProgressOn|FileDelete|FileGetPos|DirGetSize|RegEnumVal|FileExists|TCPStartup|FileSetPos|TCPConnect|WinGetText|IsDeclared|GUISetHelp|GUISetFont|GUISetIcon|TrayGetMsg|BlockInput|MouseWheel|MouseClick|SoundPl' & _
'ay|EnvUpdate|HotKeySet|InetClose|IniDelete|TimerDiff|WinGetPos|TimerInit|StringMid|BinaryMid|GUIGetMsg|GUIDelete|BinaryLen|GUISwitch|SplashOff|GUICreate|ObjCreate|TCPAccept|RegDelete|MouseMove|MouseDown|BitRotate|IsKeyword|StringLen|WinExists|DirCreate|DirRemove|FileWrite|FileClose|FileFlush|WinActive|TCPListen|RunAsWait|DllClose|BitShift|FileCopy|WinFlash|WinClose|RegWrite|IsBinary|FileMove|FileRead|IsString|IsNumber|ObjEvent|FileOpen|SetError|InputBox|Shutdown|InetRead|IniWrite|FuncName|ToolTip|WinList|ClipPut|WinKill|ClipGet|IniRead|TCPRecv|IsArray|IsAdmin|TCPSend|InetGet|WinMove|IsFloat|DllOpen|UDPSend|Execute|DllCall|UDPRecv|UDPBind|SRandom|UDPOpen|Ceiling|ObjName|TrayTip|MouseUp|WinWait|RunWait|DirMove|RegRead|DirCopy|BitXOR|BitAND|UBound|BitNOT|Assign|Binary|EnvSet|IsHWnd|IsFunc|EnvGet|Number|ObjGet|Random|MsgBox|String|IsBool|CDTray|IsPtr|RunAs|Round|Break|Floor|IsObj|BitOR|Sleep|IsInt|Beep|ACos|AscW|ATan|HWnd|ASin|Eval|Send|Sqrt|Call|ChrW|Ping|Chr|Tan|Int|Opt|Abs|Hex|Asc|Exp|Sin|Log|Mod|Dec|Cos|Run|Ptr'
Return $sFunctions
EndFunc
Func __GetUDFs()
Local $sUdfs = 'F7UAX0dVSUN0cmwAUmljaEVkaXQAX0dldE51bWIAZXJPZkZpcnMAdFZpc2libGUgTGluZXwFsENvAG1ib0JveEV4AQG4RHJvcHBlZABDb250cm9sUgBlY3RFeHxfRIBhdGVfVGltAAgAelNwZWNpZmlAY0xvY2FsASZUgG9TeXN0ZW0BFjMJKgcVVG8QNgaATGlBAZhld19TZQBsdCBlbmRlZAUTU3Q8eWwQKQCoGymJgENoAGFyUG9zT2ZQAHJldmlvdXNXOG9yZJIUgYuDl0ZyPG9thBsOlBeTABRTY8GAB2xCYXJzAROGBhBYWVRoACxCb3QIdG9thz1lYmFyIYETQmFuZAJgVmEIcmlhgNBIZWlnfGh0DBSAjx0UHXMGClQIcmVlhVJJbWFnAcCEc3RJY29uSEdAGAlSTh5HcmkAFXLgQWx3YXkPRwAeAAsiSQB+U2VsABxlZKdCF9tGwV1CdYBGbo96IFVuUmVnAANlckBTb3J0Q2GBDGN+a5hQ3idBPNInzUVKCEkHAJuDeJM7T3Zlcmy8YXlLEwmXAuDFom6K4AEGO0FwcHJveGkebcDQwQMUd5Z2RElQAGx1c19CaXRtIGFwQ3JlwAhIQuBJVE1BUOFZwwI4Ip9SGAYi4BwUInteVG9nDiBIZWFkZcJJRmlGbEA6wCFuZ2WhgW8OdQgY4gtACUhvcmkKeiAcYQAcc29sdVx0aShETXyhekJgHmtwSW5mb1KGRaEgBWsOQSAFp0MVMFdpZHRCaJuKTmV4dAqKVMhvb2xhUklzQ1rhJHFAHW1pboAKLw66W01dgB9ooAIhDmIBUuElTeBpblN0cs9CwConJpfio2dH5g1EYDh0ZcE9FnPFOZIlQ+AtbW5PgnLgNUFycmF59EaBwrllUHJpbUxAE/OOICFVaXMBlYNGIQwxCUGDVVNvbGlkwFRNg8hUaRJHcm91cME7nEJ5y3GOBIEBRW7iDh/SZ/8kgClWII+iVXNl4ENoZXZy5FMxYuEW/FRyoDtpyuUkgWvhCKVB/8F7kSmfBJAEHxd/LnsuqmHPL1XcDZ8plilheJkpyRTDEScBC0hpbGk5J/lFIEluc2Vy0B9ya62gF293BMoGaQBhcQELATQZTmFtZWRQaZxwZbIW1gBzbFN0QjcfOAJgBj8CiDn5CE5vcvhtYWxvFDpR0QMfYmwyR9WKW4qNHUN1c+CBRThyYXM/AjUCICRuc/hwYXJJK10kPwI/Ar8G4689oT1TdWKaPT8CsARcb3VgaPcxLVBIYGxs/6Fs3zgUdP8RzXi/GK8/PyYPfwT/Gn8Edm5uZGlj/mVrYo9WD0RPRjsCypc+L3VMcFbgAWlQFi9wf0hlyEZpeEAUaXoPnDcCgENoaWxkRWRpitEeP0hpZGB5dI6gOQLzvwa/Bk5v5Jg/Ar8GvwafPws/Ar8GNgKxHnVzYFgB8QZVbmljb2RlnkZxJKMYX1rSAFJHHEGBFzhBbmNob3LmLPdPDcYIUI9BMAK3GrcIcAT/vwgvKCMoM2ifIw9zb27feefH2fCXcpdUbzIC5QAvV3H6XVNwYS9g0oJgBm7wZGFyQpCQCBhIR38uA94VLgJXaW5BUEkB0QNMYXllcmVkAQABZG93QXR0cvBpYnV0mDkfWU9bKALh0Gxja2Vkb4T7apB68mkBNzMybyefHs8gmjIIQk1Qxz1HcmFwAGhpY3NEcmF3/6IKAW1TeEQP0RtPD08P4woBwSJJdD21AGVtQnlJbmRlAHh8X0dVSUN0AHJsUmViYXJfAEdldEJhbmRTAHR5bGVGaXhlEGRCTVAGiExpcyB0VmlldwGUSXQAZW1TdGF0ZUkQbWFnZRZEVGV4gHRTdHJpbmcGRPBUcmVlBUQHQQE4D0UiUx9oQ3JlABxTbwBsaWRCaXRNYQJwEkVTZWxlY3QAZWRDb2x1bW4IfF9EgBlfVGltMmWCQnlzAVWABkFkgGp1c3RtZW6HRQBNb250aENhbAOBIgAD' &  'ZW5kYXJCYG9yZGVyDxGBJWUAbFJhbmdlTWEGeIB7BhFDb21ib2BCb3hFeAEShQZJyG5mbxERRmkBwYGaEEV4YWOHRVJpYyBoRWRpdIFFUGEQcmFBdAASYnV05GVzm0VpbolFhiJBInhoYXJQEYkIDRqVTnMwRmlsZUECiQhMb8hjYWwFBlRvhwjSRQBEcm9wcGVkV/BpZHRoEj2NKwcaByJcVG9BBUECHGBDgEpyfG9skQiAGssiCBrci1QYb29sQdLACUFuYwBob3JIaWdobB/AAIcIEj3CuIdxZW51DwEHwQHBKYDRSGVscDxJREq3wBABCQJZZVAwcmltTIB7QghTY8FANmxCYXJzQmlFAx0BnEXA/Ioz4QBab24CZYEDcm1hdGlvQwBk9HlQb3NpAQRYQSAERElQbHXgC3JAYXBoaWNz4QxtEG9vdGjAVk1vZANnGQl+SVNlYXJjhmhMgolWVW5pY6AHPkZCEfMQcgiLKmWPTGX/YRksFUE4MhVpffwQPwSmjmHAJU1hcmv2b2AqRmByb21YWddv4Eduz6tMZSr2EOFJdXNgPoEI8UQhZ3RooT+1ia4MqS6DfxlhCE51bWJldjvBgKJUb2RheRd8cwhBZWpJbnNlcqAIcjhrSGlgGjHGaD9BchhyYXnyEOW4Q29186gdaRlYWUEypDNzGWEB00W9Z0xFbmExcqFhYRlibQETU2l6cExrCGm/c27n1ikVZV2Hf+IDcqcdAahhUmVwbGFjZcchG6AJeAhTdWL2Qx81P/EDHVOZPV8oux0iSExp4G5lT3JQgnx6ZD9IH/8QPUjxMlQXkH9tYXD/o4CBG5U++1TwJf9UXwa/DAcfAnkID0ZEcmF3Q4hsb3NwG3Vydp9Qa9QyoDZIwJZsX40BAk/YdXRs4BIQi29nbC6YOHBhY5Ayp0NvUEhlN8RnTAqweGxPCm4feHRhoDJlZFVJPwjgAUYIb2N1EARHcm91/4GXJAaimtABpQYUFx8EVQwBVC58X1dpbkFQIElfRXhwgBFFbvB2aXJvIknDXvccfxB/chBhaV8MIwLhrh9UUwxp4nLhBHNpYrgYRUdiqjXgsFfADGEJAr1PVGHgYlN0b3BHCiY2/5yfLgYvJz8IsJPwAFRpKAZBNghDYW5QYWCJU+BwZWNpYSg6FwSlHMeSBB8EUgxzc3ewrXFP/wYCxQFJEnE8bw5ek78YBL0DNik8CEVtcHR5VYBuZG9CdWZmGLb/GwQ/KS8G7R7pTh+XDAL/uf8uBgBbDSMvBnwQqKERQjFqmEZsYVEtYC9OZQOBiG9ubnN2UGVyslA8bmMgBnQxAAKQAGRvCHdUaLBOZFByb+BjZXNzSYAzX6FPXfdqL8NScAhni9Vz4CAKduCYSGlkoBSvN0Vu4TAfoj/xAA8Ck3YgD2NrTTxhc0eDt9vBDQImTGH+YrhpzN1PCts9vxgXJaE3+YEWSW5ydr8YfzEOAqEkwHRlcm1pbgkjCAL/vzlPCuMYuhjOGl18LQYuSC8IAg9E3aixGEK0GEG1AHxfR1VJU2NyAG9sbEJhcnNfCFNldANoSW5mbxBQYWdlAoBDdHIAbFJpY2hFZGkCdAGIUGFzc3dvgHJkQ2hhcnwAIABjdXJpdHlfXwBBZGp1c3RUbwBrZW5Qcml2aSBsZWdlcwaCU3QQYXR1cwDMX0dlBHRCAHxlcnNSZQRjdBRicmFUYWIQU3RvcAdBVHJlIGVWaWV3AUBWaQBzaWJsZUNvdWJuB0FMaXMAGAAgUgBlbW92ZUFsbBBHcm91CEFSZWIJBH9hbgC+aWxkSA0ABGwAcwB7ZWVuQ0BhcHR1cmWBQFQASUZDb21wcmUAc3Npb258X0QAYXRlX1RpbWUwX0RPUwEGgQVUbx5GgHKBBI9BgCFPdXTIbGluAFJsbwCUBBAQTWVudQEOSXRlAG1CbXBVbmNo4GVja2VkCxCAURYQ4wkxARJTZWyAowQQiOaHgCGU5pHFSG9yepYY' & _
'YFBvc2l0wkFRUlMAdHlsZUhpZGTGZQcIkRhWZXIHa0lzIlPAcmluZ0tzTW9AbnRoQ2FsAQhNAGluUmVxSGVpnGdoAAjHYoVfVG9IZQFAEERJUGx1c18AQml0bWFwQ3ICZUAGRnJvbUhCYElUTUFQhhhAeGJAb0JveEV4gIxzKGV0Q4AcZZQgUmFIbmdlwCFTdMdySAxlYcA1QQdVbmljAG9kZUZvcm1h48cPyBdJbnNAPwAPwDkn0hdAcYMYYXjHSG9vgmzFWXV0dG9uQXLSRc8HSXODB1CBq0iK6Y3USW6AaHRI1O0LAyYB8RdTaG93RHJvMHBEb3eHPO8jYXh36SNKOEADZSAKVTzmH2nv5wvlE8AX5hNN9BMEVaAc6m1ybUhgR2zhR+gj6AeDIBCBXkFycmF57xOPYAjxF6pgg0FTaXoAUPExVFN5c8AQioXmM0AIAeozTmFtZWRQaQBwZXNfRGlzY3hvbm4gfIYC8SNicEHgbHREcmHjSxGBoAEDU64gBFRleHRJbv9CMO1bwAvvW9XG6VfmC0DFfeAKRsAp4yP5B+g/7ztJDm3pmOU74QBEZWZhPHVsggT3R+xnT4xXaXhkdGjuB2ZHowj2a1MYaGFk6XvuA3BhY+PpA+13RW5hgNrnU+0D9kMowdb2b/J77kPwK7EVw0Ew/xNldEhv/wH+Kz/9D/5F0Sf4F/UH0FdwbDhhY2WxBEA2SYVMbxBva3Vw9oRWYWyKdf8zX0BHZWFtIV4P8Tb/B/8L/h9GaXJz8HRET1f1S/8z+xX/AX/7L/8B/y3+E/wh+QHRlkIOa7uEaXqQAXVtbk//gXb8SdEv/En/A/QD9S8EdNngUG93UJHyMWSQkmFsww+X5YpGb2N1+Wc5fv3ijHkRTvcf/QP2Le+Y4ZhxoA9EZXD4OfkDklll/nJ6jvsB+Q3/D/8L+wNxGK/xgXAc/xVWkEJwKGv/Az/xBVBc/R39B/k9/xFlbdnirElE/xXwAU7wW1Sx//8B9AF0lv8FAkKhifsR+3H3/zP5BbCHdv0F/QH/CfgBHGFysG/1e/QnR3JhIHBoaWNzKJxXTv/3D/0R/RX8C/hj/C0xZP8tA/oFcQBEZXRhaWzz91X6E3ViAQb6dfkB8XVz/Tv2PUlz4QGKvEK0bD5p/3f4pfll/0H7AUxp4G1pdE9ucQb/CcQL/EhpYAr5XV6++y1KvpEFsExlbmf5c/UdRJAN3HRlEtdQHv8ZeBQC/bH/pND/ffoR01EwkgAL+mX3Af//E63W/6HzEeFp46lRAnIa//8T9kUP6fgPAOkyBP8R/0V//yv/rfpD/yX/CfZh9KlftQBtZV9TeXN0ZQBtVGltZVRvRghpbGUBSHxfR1UASUN0cmxMaXMAdFZpZXdfU2UEdEkAmEdyb3VwBElEBnxSZWJhcgBfR2V0QmFuZABDaGlsZFNpegMHfAo8Qm9yZGVyCHNFeAc8aWNoRQhkaXQBIVBhcmEDAyEGHk1vbnRoQwxhbAEeAgtSYW5nAwdcCh5pblJlcVIIZWN0E3tGb3Jl8ENvbG8HXAZ7gGyhPSBEZWx0YZJcTGkAbmVMZW5ndGgBBg9Db21ib0JvAHhFeF9Jbml0YFN0b3JhiFyHPWMAcm9sbFRvQ2EccmWHXIgeAC9Ub3DwSW5kZYeaBk2AXBFNcYq5YWNri3sLLoHpVPxleNIegBcBKYoHwYNABwPBBoAVdW1uV2lkA8g9iAdBbmNob3IRTC5lbnVFHUJtcIBDaGVja2VkhgeAU3RhdHVzQkMvQYEdRmxhZ3OQB0XgbWJlZEOAPkBP0B5+bMEXworImsIeAQEBB0aAcm9tUG9pbg82D0AeUS6IB4QCSW5mb9cONsEBgVxngMluETaBbIBpbkhlaWdoyx4hAtlEcmF3wABnSX5tSYuGB0ROQbkINoYHSsB1c3RpZnnDZYyDh8Adk4NGUUhpZGVAJxlgC2lvrQcAD1VuaZBjb2Rl4GhtYTAXH0QTgSaM' &  'KqmH1QNFbnMAdXJlVmlzaWL2bPMe4o5DgCrtewQb8HvByQNJZGVhbCqTIjbDxBJQUVRvb2wkH8IKMFNjaGXIoqYmQXUgdG9EZXSgJlVSAkyxB0J1dHRvbrhTdHkIG84D4Y9tuQccYXQvF3RNpQdNYXDIQWNjADpyYaCP9HuDd4sFH0FycmF5jgtjggbAlm9tbaArzwNzDwMXYEoAPtCedHJlYRmCcFZhMDZzTUhlYQMAtCI6aXRtYXBNMGFyZ2mQC2SHSW4D4bLGA0lwQWRkcgBlc3NfQ2xlYf5yhAG2B+y5ZA8hMnIPSa7/b00JOsIH65qqByMLieRkD3JDQCZ0Za+DhQtkMVTibws6VHJlAGskdAEHwdcDRmlyc3QyfN4igXJPb2NhbGVMYFVD7wHgAUV4dGWgBWT8VUnPBTAblG65hdkDYTj/XFHpATBT3UGZC0IL20FlEYmBMmF4IR1Sb3c3FwfWA69HzQVEcm9wVK9QGQR6gwywXHOwA2FAAz8GAe0BsAPTAKFiAh1ESQhQbHWAAXJhcGjAaWNzTWVhwQfQMB5pQhXsARMfUTJIREP/jw2fSewBz0OLDS8Z3wPrff/PBXRNnAtxbMImCpneA2xPQdgiSW5zZXKAG3L+a+8BRFvcInou4QGwMA8dH9IDDB3OBV8ymAtXaW7wZG93VDoXliqvCe0BT18yDJkel+gBQmWgQVWMcGQCHYAIQVBJ0qsIcm9jsExBZmZp4bCmeU1hc1AT5AEzJPEwBHBhdBEu80evCXOJQ2Yw1ANXYWl0UFhNAHVsdGlwbGVP7GJq8BxPNF/QVCI4EkQJ0gNOZaJUUmVzb+h1cmPgFGbCXKmF1gOARGlzcGxheWWNR7QHIcGPDXxfRPAMXy9BK4rLUQFwNHyADGN1inLAAl+js2tlbroH/98D0QNRANID357/HE+P35rf2AFPLt8B3wHgVmHNWNkBMFByZXbVAcQ3RW7pQXNyc7TUbYEIvwNxP/9enqd1MQn0GL8DtM57lv0O+/9G1QFOYC0bDXgWEtC/aae6aeEFvgNSZcAKY09Uw6RIQY5yYW5zMSA/C5+Vpcq8Oc5fCZdjeHAwRuBlZE9uY9sfsQNTOv5II1Z/BxDbQKOcungHXyc/Pwu0VfQO8w8jk9HXbGkOZ5sFORqlckRJoLUAUGx1c19HcmEAcGhpY3NEcmEAd1N0cmluZ0UAeHxfR1VJQ3QAcmxMaXN0Qm8AeF9HZXRJdGUgbVJlY3QTdExvAGNhbGVMYW5nIQo6VmlldwE8SG+AdmVyVGltZRQ6gHRDdXJzb3ISHeBJbWFnZQEQDncBkgBGcm9tUG9pbgkBHURJAtFDdXN0AG9tTGluZUNhgHBEaXNwb3MDdwBTY3JvbGxCYdJyAPVldAMNUgBZh0oAUmljaEVkaXREX1OFD1Bvc5MOcEBhY2VVbmmAO04AYW1lZFBpcGUAc19UcmFuc2EMY3QGCYYdTW9udDBoQ2FsgTwAdlNlHmwAto1KhjqLSk1lbgB1X0luc2VydAcBBQF7iMJTbGlkZdJyA8JnaQDDVIDmkA4AVGh1bWJMZW4IZ3RokmhVbmRvGExpbUE0Tgd0cmWAYW1Ub0ZpbEclAUcWQ2hhbm5lbA9Bh88ORlpCUldpbkFAUElfUmVnwHBlAnKAA2Rvd01lcz5zwHjTDsdZUAcCeW91h0J/TwfAJXJDb2zBlRkAGk5lAgWAAXdvcgBrSW5mb3JtYRB0aW9uzw5SZXPAdW1lUmVkwMTSSgNIFlAHRXZlbnRNCGFza8Y7TXVsdABpQnl0ZVRvV09ATYEPSHDGDlBhAEVTAHBlY2lhbHxfIERhdGVfAc1fRAxPUwEDwQJUb0FymHJheUe7gANvdwC6H8AdgGdAlQAKz9FNYXAASW5kZXhUb0n6RFMHREADIQSvAyAL+HchoANHcm91wAtmbx+vEgAuuBKgA+EATGFyIag/VHJlZaUDVGU8eHTrLGkHqQPkDkJpIHRt' & _
'YXBDwFV0ZZ9BgypWZgdjaUAHdW2nP2GtElNtYWygMPAdV/3gR0FADKdsZhagA2NSchb/oAMvGix0bKykAyEH8HfpDv94JaADgYYiqbYD62iqAy6wg+kOYQdQYXJhbTYLg7Q/cgdDb21ib4G7MaFsdWVCIYsnGlRvEG9sYmGCJUJ1dHh0b25qjq4DQSK3A1MMaXqnEucOaG93RMByb3BEb3dnQ2UH80EW47BhcqB7NQtkYSsLxkViGkCZY29k8A6hmT5CARZAPPEOMBpmB0RlHGxlAIei968DQXV0Gm+AAXBhBKYDSGVh96ROMRhRcmxSRX8HvxI5C/8/GrkD0ji/A9MQ0APdEJgU/38WXwl/FnYW8VRAdt8Bcgf/3wEUDZBfMA2wehBc3wEzCR9/FhccsC31WXoWQ2xlbGFywEgwb0FYRdgubI+QLJwFuk6wD1RpcCdHF8sB010XZWX1KGFuZPEwFGdpbshKZBRTI5MUsx8Ybz9ybIV1cGpzQHSeZHFsP0FRe+IMZWTPAfuvDJ9XVE9bRluyZt8KIAeAdHlsZUZsYU9K+QIfeHCQEAgJYw91UyMS+Q95R2+gM0AOWaDdCipI965tfavFAU5QB5E3DQmhAXhvdGV2XnRtVbrBdEUMbGzQE08zRW5hYsZs/Rx4L0FkZAUmZIlxwAFtRGwAv+AuwBFF50B7H41QiXVzz5CmkoBD/GNlekmnDL8VMyRgFzwk438OAKNseWeoDErBoBM/NAecA3HMHRLmMPJxU2NEaGWfjHdfRsCoTgVgOmUhG1NlY3VyAGl0eV9fT3BlCG5UaOB+ZFRva7xlbrh5WWG4Mg8Jd6cMB8QB8gKRNGl4ZWxG/5KoT0HBKZ09TRDaJ0nGIDj3VMT4yZBNbgAD78kixsdgk4EksDJJRaEJRWzgEuJuMK9lY2tgCbM9Pwfz0AMCB01h1wrPAZggxgExcA5EYXlbgskBRmnAcnN0RE9X3yfAAcBNb2RpZmnRCngOP1E01QBKYgqTfUjZClRvDmQhCe8wkgNhYlN0nm+YA7tnCNov52xsBgm/md9Qh+YAb+GdAw0JUtApeE9ubGdnqQzvE5QDA7YAX1N0cmVhbVQAb1ZhcnxfR1UASUltYWdlTGlAc3RfR2V0AmBJIG5mb0V4AnBDdABybENvbWJvQgBveF9Jbml0Uxh0b3IARAY4TWVuCHVfUwBwdGVtRIBpc2FibGVkD3IBALJUb3BJbmRlAQesU3RhdHVzQgRhcgEdQm9yZGUEcnMGHFRyZWVWAGlld19Jc0ZpDHJzAl4PHEhpdFQGZRUcAJRDaGlsZIByZW58X1NjABYAbkNhcHR1cmUBAQ1KUEdRdWFsmGl0eY9WAA9FZAEtHHh0Bg4BkAIrUmVtAG92ZUdyb3VwYREOZHJhd4FHCGVvCG9sYoNyU3R5bAMCtY85QmVnaW5VEHBkYXSArVNlYwR1cgBNX19Mb28Aa3VwQWNjb3VgbnROYW0HvIFQXwBFbXB0eVVuZMBvQnVmZmWD5w2CwFNlbGVjdJTK1zkjQA5BLlRpcIcyTW9AbnRoQ2FshBVSLGFuSIKFFUUCUEN1JnJACAYHUmWBQEFkxmTBFMB8QmFuByRFSABJbnNlcnRCdSh0dG+AbESAQl9UZGltgGt5c0BUgQJU4G9BcnJhh2yDFcGPR8ATzZAIJExpbcw5UphpY2iCUECGb2yAPfxuZUcOCUEBc0oOxlaAHQEHmEdESVBsdXMBQddpbmdGb3JtRGF0wMNwb3NHSFQMYWIBDYEFbGF5UuNAZUjZSGVhQC/C4EAc4EJpdG1hB5gEB4Qj/0MXjk8BZQ6YSw6MFeYcqk8RzydFbmSFA1dpbqhBUEnhCUhALmxihf2hEWlBNi8HYSQrQWEOg4kPgT3DJXCCAAxCa0NvPGxvh1oKhuBSozJDbIBpcEJvYXJkQYXBQhFBdmFpbAGRphUD4QWABUV4dGVudIBQb2ludDMytBWwTG9jYSEHzidP' &  'gUuHpE9nDiAGUHJpb4F1H60yxURqK8UnIlpQYXIdIHp0YFahKMwKU2VxAHVlbmNlTnVtjmIpe2NIQhlkZWQCPv9uK+AtoT3rcwdMSRnNYcAD/k5AJWGKTxkoV0xwIX6BNTBTY2hliJQFElJl+nMBBG7hL3YOgKdoDuAc/+Gw8hxrZQxpiCAAAwxMiz2foQcoB6pPBky0bEZsiD1lZQ5EYA50ZWwOZ0hIMm+Af3ZpoAHtOVVu4Gljb2RlNHvgpqOi/FNlboLEGC0HwyfMCqRPUFdhaXQgAVNACmwwZU9iauIctAFVbgZoIGfAAGRvd3NIk6AA8RFOZXBSaGGRcyMgErAOaWNzcAdXcgZrdwMCLkxheWVyDGVk4wNfd3RCTVADjAryg0NoZWNrUjBhZGlvqnxnWGltwHBsZVNvcu81j0IxiCVBcHDQI2ocRFT+UCIcJmX4H6uDIAlIc8kq/5AlOgWbGCKUPwXjKP8NaGb8Q3U/BZMBEjsPfAR86VX/8Q0hCv8ND44KevZw/xR2Aw5GcB3MLTkTRm9jdf5zj4Z1YCGMHjPaUX8mciYMU3a3CPtsQWxpZ/93Z7mok24nfXgD9a5/AzEY/3gfl7FlAzcMtJGoaDcTtQHHV0T7FNx8bGFnKJaxCM+zcaEA+iKyAU1h4aDAJPxyYaC4/yIyBZJlvwGyAeBXaWR0aLIBo4/wTuZzIiPSAFBvswi4AaMAIzU9uw9CdWKAdkhlCGlnaPwUVHJhY8BrUG9wdXDhAC5NZ/NMOyF5GEVuq8R6xmUwZmF1bL4yQjJUb6NbxnkDU3ViswhXkKIgRXJyb3IzjHJE/GVSYCgQM/cUcgMUE/kG8dvSY29uvw92Az0MtQ/gUHJlc3Nlrj8hNxoBAb9kUGlwZXNf8kNA23RlBgH7BoMG9yKLdV6QZkPgNFRvTeAL+GlCedid+Uz9PjkMfVD/aHDvwXQDcQCQI0ONPxNgbCRpenJJSUXRYEVsaSCDbnQiQmxBUrKkRUJ2MAFMb2dfQHVywdQZU291cmMzDF/rn7sk+xQ7WbsBuzJTbOF5/WI9aJCXqo57AztZORN2Jp2/AW2BTTNZBMNQZVB90UCyc3RvACNkwHL/YRlxV0luM2dn0URPUz/BAHPRYFn/PrlONCFN9rUAdWx0aUJ5dGUAVG9XaWRlQ2gAYXJ8X0dVSUMAdHJsUmViYXIAX1NldEJhbmRATGVuZ3RoBmxUCG9vbAF0RmluZAMEFgY2RWRpdF9TAGhvd0JhbGxvIG9uVGlwBjZMaSBzdEJveAGqSXRAZW1EYXRhB1NyAGVlVmlld19HAGV0Q2hlY2tlYmQHi2ljaAJXABtWwGVyc2lvbgpTBTeAT3JpZ2luWRgbGlgLp0iAepBTQnV0CHRvbgJTbWFnZQMBI4ANRElQbHVzAF9HcmFwaGljAHNEcmF3QmV6jGllgX2EDVBlbgFfAHVzdG9tRW5kBENhkSlTcGxpdBBJbmZvkA1Eb25AdENsaWNrkmFCYGtDb2xvh7WJDUgCb4KpfF9XaW5BBFBJAQlMYXN0RQBycm9yTWVzcwOAY4kNRm9yZWdyEG91bmTABGRvdw/NIoAI1inABklkZWEwbFNpesAU0otQYTxyYcAizw3IU8wwQWQwZFN1YsMwz4tUb8BwSW5kZXjSPgENBEN11GhTdHJpbgJn0hRhYlN0b3ACc8lFT3ZlcmxhgHBwZWRSZXOAxwHPoEluc2VydFQEZXjHBlN0YXR1DHNCwD8BYmVpZ2j/0DfCb8I/ztFCfANJzimEN8HKykhlYWRlAhuBBvBGbGFnwDDNG4FizBsHywbLkmoYUmVjdEUPZy1pc+YGIBJlX1RpAG1lX0VuY29kcGVTeXOAEQEC8gZW4GlzaWJsaxHoGyEOAnzgEmN1cml0eQBfX0xvb2t1cIhBY2NAVHRTaWeBA2kYcF5DdXJyZW4gdFByb2OAXklEP24tYARBAcB9ZyZnO3NNYG9kaWZpaI/mDUTg' & _
'ZWxldGXqU2cmwXoYaW1w6BtpH0ZvYxx1c2gKaRHgSFJvdx9nEeYG40zkDeRaQnJ1hHNoQXNvbGlk6zd/5gaBsqEG6DdoLedoZy1PCHBlbgQmVG9rZf9hUOkNYRvvDeN9AULgfe1Fh+Va4bj0WkluaXSgb4Zy6VPrWkFsaWdoEQPjeOCWbWF0Q3Jlz6BPbzThucAUdW3nDWsKHkPBSe8Gai1uJlNlbP/rBmofbONrA+ugawrBDWhQ/+UGIUJULQBFqIvEWKheIQLBrAZNYXhpbeC0oREZTQNpbksDCAVCdWIPwDpAgZEN1DVFbnVtAERpc3BsYXlEGGV2aeAijzd0VGi5oBlkSQAFpAGjGkZwbRlwJ2lyYj5kCENvbbRib/AQRVZApgFN8ALwaENhbJQF0BIdCoANt5AAGwqzBlJRbREpUuIj4W8ZZFN0eZg6ZQhBPA+1BgQFEAHjcVBsYWOsZW3wDaYBV7AzZVQzwE1lbW9yec8LCAUP2zZTEsU23hBEZXN0jHJvAAVXA0ltcICP7G9u8A3wBGZvd28j6xVDQ3dHW0ZpbGWBAFTgb0FycmHHC4oSZy+flReQBpoXqwHDElRooBKPHwqYF/oacApwYXTBYQREQ10eVGl0bGVcQmkwB5eUGApy5TBJAEVUYWdOYW1liEFsbCEjb2xsACCDcqIlKmxvYmFskxrnc1vZEDIIcmVFEQEFkUYMRWxCH3GBYmpCefMBBqwBT3BRBiAZgi3nMM9uI2VMEnmxPGF3s0wfXANJhFkDTG9hZEZy/G9tUQpfAyE0kF3vTSaSLxxhtwYRUs+TUkANYXPHRRlaA7CtVXBkL1ihAbFwdExhYgQ7GFhD0AT6cqALdLIGXANBa7VSKQ/4U2F2ECoBD88Lo8LbXvtajAAFdIh1RGl5gx1AMagP66IKBVtgWHxQYWRk51MDxAswNW934L/BBqwcn6UBr6KpjXwNVh5IaZA+T2C9z3Y5wH+wYXeQSHY78RqvAXdVoqQBwVpGYZBtaWx54V5vcw+r9fFXZYASY+8Vo1mqwW/Y6aYBSXAgF3IgVCLj4XvjrwHhEFJhbniCqgHClflnCGFiYQZ0alOl3HcCkv5uD7yDnG0IAQWjn6BFK3v/GCUHIF+HQLG5BqsBGgqkAf/k8VoDKg8bW6cBMAWrAcELORFbaW6QABdb1hDttQBveF9GaW5kUwB0cmluZ3xfRwBVSUN0cmxUcgBlZVZpZXdfRQBuZFVwZGF0ZUEGaExpc3RCANRTCHdhcAzUU3RhdAB1c0Jhcl9HZcB0V2lkdGgKagKgAEFkZENvbHVtAm4PNENvcHlJdAhlbXMQGmxpY2vDARsHoW9vbGIAaQMZMG5kZXgOoQCEVGXweHRMZQdrBtcPUAdegFNldFBhcnQHQwGGGkRlbGV0ZUGEbGwTQ0FjY2UPDWkAJ01lAJRjByiHNUlAc1NpbXBsB69TMGxpZGUCoIEfVGnCcIcaTWVudQEMAVtAR3JheWVkEg1SMGVjdEWHhgcoUmFgbmdlTWmHhgcNUzJlwSRydI0GwC5MaeBuZVNpek4ogAZODSBDb21ib4ReTEJvAV9QDZUhgl1n1RpDDWEfxzWCPAAGUEOKIW9jYXuIV4UGRQCwww4OFMEBSBBlaWdo0DVMaW3OaQKV0FAKSkltgDIBovFCZWNvbovDDWXINYcG405DRXlTeXMALkEDjgbDEC/FoUxvYWSCJdDXB2QhyEYCCkNoZWNrByEBUm8BCkJpdG1hcnAQCm9yIgqIaKQGTQBvdmVCdXR0b9+wcsAQjRdIA6F8bpAyb5R3x0aOaMUQSCAEzBDJRkMcdXKgW0IDRAhfVHLiYUF8dGl2SQ0GFOEyx8B6MANBnmhpbONTB0OAUmVwbGFjZYFDB64Tgglqq1JpY2hFzGRp4kkgE0FBE5djU0BXaW5BUEnhAUSAZWZhdWx0UGAJGHRlcuoZoQVpcEIaa8CxbyMDy09OdW1iVImWVGFiTYzg' &  'DE4CZSEZc3RvcmVDKG9ubgADaeEZV2+gcmREb2NgYmuhKfhvbGwlA6+jgK3iOqQJAYFiZXNvdXJjZQMmA6AJRXJyb3JIAGFuZGxlclJlDmcgKOwZ4AZCdWJinmxrZuUMgDB13Elz5Qwf6jMhTmAzowlkE0NhbrtAvAcdMi0QMCrhJkiAWo5sAVsDaaQJRGlzAAwBQQlEaWFsb2cxP7EWhVQlEGYPeQakclNjAWAcbkNhcHR1cqZlgBfiAFduLVFE8BsIcm95kyhOYW1lAGRQaXBlc19QuGVla+YA/yaTGmPPOnkCNG91NB2RKBM1QRZQIHJvY2Vz/zhDdY0wJG21FjEDQ3Jl4DScU28AKfUMARBTaMAaGcAZc3MwEPEobmZv778JZVcvQSEaU7AAnwGQAWBjRnJlcXkG5xZFDG51kBvYEVdhaXQP3xF4LfVK9AxBdHRhEGNoVGhgDWRJbiRwdZABSUVZLURlG3ctNANSsAIUE01lbfhvcnm/FkFBGmkpUx9JYRVJRmlyczMD+k1Q+G9zaXY6lQHTVZAAm2/DeUe+I0NhbGzfERYIDzGn75eVG3MGU2VjdcByaXR5X1+TO1AbDFRvQABxE0Zvcm0QRWxlbQAWUmFk/GlvIFGZKNcEtC1Pebc9D3gGEgbFBrdwb250aB8ADfZ6nwFDTlI/RElQoGx1c19BkB13IDfDrrA5A1RvZGGxCTwDBwAVNQOUAUJydXNoQxgxlwFEZWNv8Ctzwzc3/4x1U3R5QpDVBIHyNFVubG9ja7AAA9A48KtwQm9hcmTXICczKBEWYdcESJAoUDIQSW5zZZN9fF9GVFRQ1AdJwWVu4yZ16bc9SXCAJnKwK1oY2ATxsStGaWyVXNoRNZ+fAf+QARtW1ATTuTudOAO1FpMBN7J04q0dnURgDUaWVGn+bf+XGRU3A+E2OQO0FrCp7HBocHRwDmzaUqiogx0/j4g/HXi+uz3YBEAXRGnPGBU4A9UEtAlFbr8j1xHBAa1Gcm9tQ5BQb7eDGAjfBENMU0lElwECRmAYRmFtaWx5w5YO3BFEcmF38QafAX+RAXoTVZDhAl8LkwE2HUVCdhBCTG9nX3YtU+uShXeVZdRaQkBYeiAWl+vAK9RFRLALX+EdCyILtQfC8Y7HtzBJc0JsYfxuaz8DWqcaCNFSugko7mc/AzMDoIpQYRAKWQtE5E9TcQBUb4BGsTCQASW2AGVfVGltZV9EAE9TRGF0ZVRvAEFycmF5fF9HAFVJQ3RybFJlAGJhcl9TZXRUgG9vbFRpcHMGZABMaXN0Qm94X0BFbmRVcGQAdHwGXwGAA5pFbmNvZGBlRmlsZQEcDmZHgGV0TG9jYWwHMgMDZwAXQmFuZFRlAHh0fF9FeGNlAGxXcml0ZVNogGVldEZyb20RmwEAM1Jvd0NvdW4DADMMZ0NsaWNrSQh0ZW0KGVZpZXcYX0ZpBWeRQFJlYw+LJoYZjiaBM0FkZFMgdHJpbmeGDElwIYAJcmVzc4GdRm8/iE2GM5KogjMAHYt0VGGCYoEYSW1hZ2WBEsEGDENvbWJvhagJDABFZGl0X0JlZzxpbgXOBSWAOgTpU3QCeYHAV2luQVBJEF9XYWkAKnJJbmBwdXRJZIhmxhhEYGVzdHJvSCWHEkMQbWRJRAYGQnV0CHRvboIYaGllbP5kzjHAUAtsAQaACwg4QCUATmV0X0Nvbm4BwGJpb25EaWFs5m8AWAUGYW6Ah4cHBgZwRGlzY0MFRQyOZEOccmWKRAQfQCVTdBQGw0ImEQZQYXJhB4SCXcFBy2FiU3RvyHZIPoePEgQGkBJDaGFyAb58UG+IEoRdQA1EcAwfUsBlYWRPbmwHagcGwGN0TlBFeAsGYAt/QQxBDbESRCKkRKAIIAFkgG93c0hvb2tBCQMEA6AFQ3VycmVueHRUaMArYD4HAwBHax+gIQMHYgwGPQEKQmtDGG9sb4APJAZGbHUEc2hhh0J1ZmZlBnIgH0cJQXN5bmMY' & _
'S2V5pBJihEhvcgRpekBsYWxBbGmMZ24gCikGU3lzwguMQnKgCgcDVUlEoR7Dw3ZIIlRyZWWCcOE7QQBJfF9GVFDCa2ECcwAoc3BvbnNlMEluZm9sDCAlTWX9gAljAzUHHCGKBRxwDGOQkFNlY3UgnXlfYhzkY2OBY1NpgChHqsYMZyOqBwOlrFRvgBlACWMBoAtuQ2FwdHVywGVfU2F2ZQROJwajAXNICUlFSAA2SeAaMHJ0RXYgOEAIaXCDhyjDZVNvbGlkhCjn4BiklwKZaXQgEOIYJAYQRW51bcREUG9wBHVwLQZEZWxheR8mwwUDwBIIA0QJRHJhtHdG4GJlQH2gj2yODyNAAWWJRElQQEdfTQJh4DB4VHJhbnMGbKJEwMBwQm9hcsJkAQZPcGVuJVEKA2GAn21hdE5ADUcJRzByYXBoYDqhEFBpOxADgC9sCgOCLaEuVG83ATNvPuFBb2KiJAZQZXtBVkJXbYAvLwbnrioGRPhhc2gFgAcD4UdICQoDHykGbAxQfMFAFwNCaXQAbWFwQ2xvbmX+QfAfHwOxF7AAjwGBAYl1T9kumw9AbpB7YXAgW3DEb3OvBF9IaaAEUm1JFANEZXGFcnPBMGnaev8Yc68EVwlOUwmvHXB3QXJjOAYAAVIcUDBvaW50eFeoBFByvGV2FwPTjlkJEwNTEDMyZYNaZWwQFoYBTWXEbnX1VVR5cBcDigHvSRSJAdNHjwFtWouCAURqH6A/FxyJAaoE5ApDbGX4YXJUhUw5BnEArwSEAfOvBFOOaWPJaxIDcHgSA+OplAFddXNCcG3ceVaR/yALcQCPAVciHwM7BlMJ4U///xhFFA8OASGBAMAJiwGTCh8XThcDEzuxAHefaWNo8YV4Wm9vVwmGAY0ztrfsQkv7Y4cBYfCaaBc3rP8dAzgGzweBAc2dGQP7q4UBHRCYVWBUjwERuUVDVPOPARADUmUZAye3fAy4Ev+qBLUrnyhILRo1qQQfNRUDD2oXGAOfu4ASbGV0ZYdBwqcEUAJoQ2Fsnij/6QpbOxUDbRe2K1AR3y7Ewf+PM4Iz0InZR8jWBHIUsgABkFVuaXYAS2Fs5G7vzwdf08IHYMlu2KuGAb/BH7bB0Nn3P6TBMQloZWMia0mUR3VpEAxvdXhyY2X/ArTBvJWQOWecTGXAdv8CoBtjdb2Y+ER1cBDh+ayxWfADoXoHoxB3AUOCSGVpZ2gfn+XuMtnjodB3BE1vZPB1bGVIcAHY1oSIfwd5gBFsabB7fAdG2OAfRH5phz2o1oN9ErFhKyABUGhyb3AwnWn4FJlOQgJtYUt1tgBVSUN0cmxTbABpZGVyX1NldABSYW5nZXxfRwEDuENvbWJvQm+AeF9DcmVhdAdcQQe8QnVkZHkGLkIgdXR0b24BLkNoCGVjaxAuRm9jdUJzBi5MaXN0AV5BYGRkRmlsB18EL0cQZXRTdAl3UmViAGFyX0lEVG9JcG5kZXgQXwsvBxdJDG1hCNcBd1ZpZXcBB9dESVBsdXNfAEJpdG1hcExvTGNrgASHU0lwgFByKGVzcwElRYc7UmlAY2hFZGl0gjxlImyGC1RhYgFeSXRAZW1SZWN0hwtyTGVlgjsADkN1hwtNgG9udGhDYWyNs+OFjwAXVGV4gReEUwJnwYAKSGVpZ2iIL4M7gFRvb2xUaXCHX0GE10NsZWFyiVNNGGVudUJHACpCbXA/zQuAEst3yDXEI8oFUm9gd0NvdW7INcEXUuBlbW92ZYECyguDBQ/LZcZHzEHGBURlbGX/yAXHZUAfxGVCFAFOQZXDcwHMBURyYWdFbnQEZXLMBUJlZ2luAwEHzxFNYXNrZWQAfF9XaW5BUEkIX0lzAAJkb3dW8GlzaWLIrcOnyxHLUyPF18RxQXJywExhcGfNO8BHAdF1csTLxB1MAG9hZFNoZWxswDMySWNvbs9HAg1B0JtFeHBhbsAvQwBsaXBCb2FyZIJfAmpGb3JtYehcPwFHIRhjOecC' &  'YlyAAk1hvnJAG+cC4jtjMuM7RKAYAF9UaW1lX0RPQlPhAFRvU3TgLEkkRUUgHXJIgBBsZRRyUgAkc+IvU2VjQHVyaXR5XyEXUPhyaXaggOEj6giBAeQIEFNRTGkgA0RpcwBwbGF5MkRSZRhzdWzoHeQXRGVzGHRyb+BW5AVMYXNAdEluc2VywRpJDkTqLGAFABhjdEFsr+Bi5w7gEcCAYeBobe4y//Jf4ALubuIjYzvqX2WG7SkB4gJMaW5lU2NyBm/hEekIQXBwZW6eZO0soDLvFOIIUmVgJAxjZel95gtMZW5nPHRo7juBGkAD7AtUafxja+t65p7lVuc44RGCC3xTaeBN6QsDMOMm5FlE4HVwbGljIAgDQ+IChE5lQhFQcm92gWb8TmHoGuYOIcPoGuNuwdEP4AjkO4Qx5TJJbmZvC++/8SxGQHtQYXJlj+gd5JvnceQCRFRQwmL/xLfqDuSw5g7oAsM+5JXlAhhOZXdBAePFSUVUvGFnQR+hDiAUgAJp4X0D5Cajj0Zyb21Qbz5p6BRiI+NE4yyBKVNoH4AZowBhV+kg6FlTaXrXcxb1CHIAbwBKYfhf9DV0SGlwHHP/BbFh8gVG84AR1Hh1c5ARUAPogGlnA9EagQ5kUGlwZXN/BCWxAE5wNXY3BzGDJgdJwkXRTEVsZW2QG7AC8FZhbHUfZFAogoOKPh9xBPMz+AxQZSAXRW51Km3gLWPgA25wWnR1F6ABdADWGFLwQ2FzZedmAcuEsUpvc+8MJSwnB/HATG91chA7kU60BZMwzmNkbmYBAwlUb/BccirwRXhjZaAj0mFxJ2cb+ekcRXiwB0cEsxazJMEoH2UBMgUAVzIGNlRRdWUAcnlTaW5nbGUXQFTXAsAdTrAmSG9vPmtJBGABkwXhC5oIQWSwanVzdHqR8ztN8IAnATxGBJE4RXigRXRhj1J2ZAExGbMFc1RvwH1jpxKjC1dpZLhNtEFo/G93swVsGBVM6iOgBOQj8QV/bnZhMHyQAnMLJQf4VUlEUTgQG4ARbFNXJTE9KExldpEfRARQYeR0aJEOT26RALMztQPwTG9IaaRvLozhEskPxFN0YKtPYmqKFQVTPlAQcHtsY3shOEkEWFl/WEVnAeMWjxWgdpYIvrtOfm8oB6Znn7vTAgp1BodvGGRpZvdHZQFSRUMOVMQm4TPQMUNvbm49Q1IyWg5DZ1MOS09QYWxkZEIbOJFo0ZlQAGn/p1bkQRIRFKMafAsKB8fqDE8CT4SzAU+0BVR3wIJQAGVyUGl4ZWxYr1plpdgoNdoCWS8HdCZcp2sBahi0BU1DUGVv4QwRtEpQZW7wCURhcz9wbPGyZwHQAmcByA9FbnhkVXARMS0HxpdFBEeAcmFwaGljcwEG7kO+c5YIYwFIQEygshZm4R3PRmxhZwd41AInB/9qARQXbbjWApcfIUXNsEQE53Rqnh8xKE5QDwpLMtkCT4jjxA8mHkUETWGQRHj/JmM1KOJFgTkBR954Tez1Fhfi3k8yQTIzRQTrtgBsSGVhZGVyXwBBZGRJdGVtfABfR1VJQ3RybAhTbGkBsFNldFAEb3MGVERUUF9HAGV0TUNGb250AQJUVG9vbFRpcAECKmFyZ2lufF8AV2luQVBJX0UAeHRyYWN0SWMQb25FeAYqRmxhxHNoABZkb3cBKgiCcEVudW0BCwBtBStvAHJtYXRNZXNzCGFnZQaDQnV0dMRvbgAuYWJsABUEKwEAf0ZpbGVTaXoOZQRXCMUAHFRpY3wAX0NvbG9yQ28AbnZlcnRIU0xgdG9SR0KLCgAIdAZvAA2JK0RldmljEGVDYXCATEV4YwBlbEh5cGVybMBpbmtJbnOAGYpiAEJpdHNUb1RUAkaJIENsaWVudBhSZWOAFYgKdXJzQG9ySW5mb4ZXUgBlYmFyX0hpdIhUZXODFU5ldIHNZQBPbgAfaW+Ar4UVaUBjaEVkaXSAX3DSeYYKSXCAFnIAmYEwA5DmgoNTUUxp' & _
'dGUAX1F1ZXJ5Rmk4bmFsQE3GCsIURm0gdExpbmVAPFNlAGN1cml0eV9fEFNpZFRAPlN0clFJBUlzVsAPZAAHfIJfAStTaGFyZUMB4ENoZWNrSgXAJYAwGERlbEYbhJ9MYXnEb3XAK0lFVIF1QUcIb2xsRTxJRUZyDGFtTQVEUlNoZWyIbEFigA9EbGfNFSBDcmVhdMA2dmkQSW50ZcGjaXZl8QBTdHJvxyBBtYBGg5vFxhVEgGByb3nDqsp4B8AKxbpEEE1lbnVfL0BSy9CAMsR5U0E8RXYBAIFMb2dfX09wAGVuQmFja3VwL8Z4wjbHeMYgZsMfUHJ+b8BtRAUDNYEEwFNGEFUGcwE2TRBBdHRhY3JoAAZzb0HLSDHAqFT+b4Gr7SCoe2tHohhqEEFaBFJn4SBESVBsdSBzX1BlbgAFRW4+ZMBlrFrkKawCQAVEcp5h5zakDeU25QpJbUCAQERpc3Bvc2d+TABvYWRMaWJyYXxyeWh+YjFBAwEBp0Rl4nQjKUxvbqANp3CjAodjcyAIAg1MaXN07hVHJ2tgCS8IVGV4ZyZUAHJlZVZpZXdffFNv5IPnCiGtYKJnG00AYXRyaXhSb3S3Ix4tl+KvRkAzAD5n4Q/gRG93bmzgGy0IbSbgQnJ1c2hmJiopAaIDQHmgGG9yZERvY/8sayoIZgUuE+JBaF3gImVdAaQjUG9pbnRGchxvbeYrJz/gIEJhbiOgGGUFcmltIDlMYfhuZ0loGyBKQA0lSq0uP6M56ismSi0/KjSmp1JlNmTor6UCVQAGpgJBVoJJwJxQbGF5aaQNP+jQpi5pEOATYzznFUxhwHN0RXJyb4CnwMHAcEJvYXJk4QLBRAZlgALqB1JlbW92H4g2gyAC1eu0oAJSRUOEVHwgBnBsYWOBs3lgFEluYeEuBSG6CttsCmcCW0SNBldpZHR+aOwaeA42BSYyJ16BB0M6bFk6V3BikUkDSFRp0m3AI0tpIFtsYEjAAIsxZvNoVCAwbENoACAfgWeJBjAcYw7HC01vdRRzZbAxWU8Bb3NYgTljT2JqQnlOsABhmQJTdGRI0CchCUmaRYARay0wSx5saZFsPxlGgVICRnwKVCaaOVNj/mHoGOIDwQrjA5QCMVfHOo+LGzMFxAsAK3Jhd2VpA8RfwZNSZXNvdXL+Y+cDF4KhdYg64gyAAFIST1Bvj3WEM7A0T2a/JEO8YW4DMpcsw3OygUkACchFeHCwKmVyQDtqmvlRZHlzgix3nldYoWQ3BeHAAkRhdGHYoxABeDTvhaaSoHh6mKpSwSQcNzUF9xo36C0FckHBgkIBKgkIO+OBBtEDQm94lF53CjEbBwQ75axwB2xBcHBF7Hhpe6AgsXPzKe1jMFLxlgJVcGTACGYOZCOBVR5GxQv8l0EhjYtUaXT36BiDA0CAbeh6ZICkExYN/+EhoDRFrESL6Bg7gLsPRlj/1cR4dtAs4hjqAyRI7QMSIgNEooJFVG9BcnJhwyBIFpNsZXRldgrjbT+RmQRSvUozEiAhkAREYQB5T2ZXZWVrSfxTT84Uohg8AYKsdJiRevhyaW9BsRcfcBwEigkfdEFuAAN0mSFH0VgtdT5tIwGBMnMMoAaQx3R5fwyIoWZjxJ9QOk+UN483RM5DPgbiw3QCSXM4KjQBvzGsKajiJIFfZVUmgHMn3HF6OE93bnE0Zk2w4nP4RW1w+BMInm256nX0BfhCZWUngqMtMrd3AkER/3O4IJXQHyIk8YlEJOLdAMUnMBrGP8AqU2PgwmxCNGFy4JNuwTvhmERp6HJQdUG7dOAEQS2IXN+vmICU0BHxd6mcVVBSgpw5WEdkZKEAqFn4a0lFOEltZ87R4WsiXUJ58EluZGVr9cbkOAFwKwEzBkdVSLcASVRvb2xUaXAAX0Rlc3Ryb3kQfF9HVQaYR2V0EFRleHQCTEN0chBsVGFiAUxJdGVSbQpMSGkATnMLTlNhEE5GaW5kAA4GJk3AZW51X0lzAQYG' &  'EwBMaXN0Qm94XzhEaXIKOwmfARNFZERpdAFkU2VsBhNCAHV0dG9uX1NoRG93BhNBVkkIO0QASVBsdXNfUGUAbkRpc3Bvc2URBidEVFCUMWNybz5shzGCCQCCiTuCCUNyCGVhdIAnRnRwXwEBYlRvQXJyYXkcMkQACYAtgX1GaWwwZUZpcoGUCQlDbIECRFdpbkFQSYFpwEJrQ29sb4B/gRIBiCVFeHxfVGltxGVygsJkbGUBBgYcJwNAASgNCW9ugDhDcoB5cHRfRW5jgQOhihJNb3ZlgAJkQU0BBQ5vbWJpbmVSBGduRwlBS0VMQQhOR0kANENsaXAgQm9hcmQBIkRhDHRhilZFQlNRTGkAdGVfRmV0Y2hgTmFtZXPHOEBoQxh1cnPBOMhpT3BlDm7BOIgEzBJRdWVy4HlSZXNlADSEBMBLGYFBb3WABIdQQ2FwGHR1cgcOgbJhYmwIZTJkhgRMaWJWYGVyc2lvwDhGL2HAcmFtSW5pw7LFwThVcGQCIYQXwTxsZ59Dt0FogKqABMAzcmUBWgBFeGNlbFNoZZxldAE9QAbFXkRlwl6fw0sEDoEqBQ6EF0luwHvwRmxvYQEOBloACgRagFVJSW1hZ2XBhY3AaXCDq4cERHJhwHEnCyEAD4QEV3KAPkZvEHJtdWzNElN3YR5wTBXKRMFVzERMb2GAZFN0cmluZ+xLR0MVpAQhEkljb0I7TkJlAA1oYXJlAEVyDm1gB+QSAF51bW5EGGVsZQEtSAJJbnMEZXKlF051bWJlnnLBF4Ej5RJBJVRvwCaHijYlR0gVQml0bWEcA8iKpgRvcmREb2NAQWRkUGljI0dEAGVidWdCdWdSAGVwb3J0RW52AHxfSUVMaW5rIYAyY2tCeUOjTWUAbVZpcnR1YWzgQWxsb2NhHKAEgA38V2Ggog1T4F5FKOiOhRABgnxCaW5hcnlTYGVhcmNoRAKjcWG+dEBVZ2iDBsBtJgJSoCfgYXNlREMiAiEtIotYRW51BFUFjk4iF0UCdqBOTG9nX19OcG90aWbgSGU/oqBL8mUgAklFgS1iRKIeZg3P40jCQ2VnYEZvZABqy6LDYQ5niGFrZVFBLWsEPlUgIiibAgHBjGcrRnI8ZWVBK8daRUVnck9imGplY+pvoDlOZadVAEluUHJvY2Vz/yMUB1/ABOkIbFwgAqCCAnS5hDFuYwAvwDErgkmgS28gC6cq40YIUGPjGGkETwxsZAXn5VZQb3BVY2BUJwtCa03gKkNUX/EklkluZiAmSFuiGUdi+aCYZVKiIaUzAHOlM2mdH2kfUEKVDqlbujxTdWLgTGFuZ0laA69ckyeL8SNjKkVwO2RkZcdXOWMARXh8b5QO1zJFcgZykQUXE0JhY2t1wzE8VAxTaHV04BpXMP+BUrQYvDnhCDA+E0XTO1MxImxRWlNpepVHQm/Ab2tBdHRhATjGTzxsbAMVZwZCCVpORWTjQRjHCkNvdRkCIivkOQ+JUQoBgwmlOHJpdmW/kjh8bCoDQEn0IQAucMAN/+BD15iVdRsCcmkBARIWFUDHN2KyLjoEU2Vl8D/REpkCAlRvYwcYAlBsIQOHEQJIiwMBUmVhZAYBcFBhdGjwB/BKME12H7MM4Uryf9JKZhhTYXYEZUGIg2V0Rm9jAnWzHUdsb2JhbPxVbqAdh0lwBRQCqQsToZklI3RhQCE3NklzJT+h+CFIVE1MNUlLwB8bkgDLkEMxSgQBUHRJxm7zIQUuYWZl2iyhegfDHhUClitJRUJvZD55UhVjBzykEQJhgXJvmGR1Y1FgClVMb+F3A1A6IBlEYXlPZlcfghqng7Q4EQLwAXNJbs5NAKGgLQkSdG/wEIgrwyMDNwRFbXB0cAiWZh5hgmQrAyBrUQZ5VmEcbHWyCBFSUQBJc0wwZWFwWfIBxA9DaANQRBGhdmlHcGli+EJ1c1ydNhqGeaF3KQn/My2SIvEIlhKxFAEBoxTzAfxvd3qE8AD1YxMeRKQht88B' & _
'uWE70S0bq01zcBb3BXODOhczQ2VhwgRaIHtw97BUVISjYFbxD3YrJEnXan8BH3QcoAhFjvcBYbqFQUj8YXN0WfcA1HiaZIszsUifJHBgMoGh8Qyjc0J58wD38wS3KflsYfBbkCg6aJY69yQj9BtQRUPSLxVW+HqhPn1AB1UAGT1+8SCgCsBXcphpYnWioPYHRnXxFf31BFIQePEKdi9SJ7p18iEfIj2pNXO3JZflFlNwbOdBv9QBzIVMbzOLthujCrk1OHNnAOvHAnAjVMd5f1Eb4QB1C2QSpgRjZ8UCdfhsRGlwptYBQIOhTTMwz7VQ0AFRBWAAb3IQL4IvgE1heEluZGVnCMxIaTML0gFUb1W6cwAYUmV2MBzRFlm0AGlFeGVjQ29tAG1hbmR8X1N0AHJpbmdFbmNyCHlwdAZweHBsbwBkZXxfV2VlawBOdW1iZXJJUwBPfF9FeGNlbABCb29rT3BlbgB8X0RhdGVEYYh5T2YBTHxfQwGEQQCCYXJ0dXAAdmkAbkFQSV9CaXQEQmwAskRlYnVnAFJlcG9ydEV4AHxfSUVFcnJvgHJOb3RpZnkADgBOZXRHZXRTbwh1cmMAd0FycmEAeU1pbkluZGUBAixEb2NSZWFkEEhUTUwApFFMaQB0ZV9Fc2NhcIMALAOzQmV0d2UBlRkFHW5jAsIFDnJyTcRzZwjCU2F2gA4CByGBLENlbGwAYW9sJG9ygENHcgIlSUUAUHJvcGVydHkbgAkJB1MBBwJSUmV2CGVycwVZRmluZAJBASRTZW5kTWVAc3NhZ2VBhA1EIGlzcGxhgHVXb/RyZIBnUIBagCIEkwAwzERDhWUAk2VhgQ2DFBhDbG+BMIRkUXVlHnKAIoQGhA2BFE1hY/Byb1J1AYGCIgNWhQYYSW5zgFwHcUJsdQHADUZUUF9GaWwGZYFAxClQZXJtdSZ0wQbABVdyABlMbzEJTk5ld4FCgBBPYhBqQnlJwA1JRUYAb3JtU3VibWkDgUnAclNtdHBNYQJpQEJNYXRoQ2hAZWNrRGl2QQpJQHNGcmFtZUJQdgJpgAFUaW1lb3XHQAPFIgOXQ2hvQDZCKwB8X05vd0NhbIZjAZzAM291bmSAmQh0dXMEA1Jlc3XCbcVgVW5pcYU2hrlhAwNubmVji6LAGWxgaXBQdXQBHkO0VMBvTW9udGjKcIQW4FNlYXJjQAYCAwVUYUIgTGVuZ8EMQgZUPm8BFYVFACfBOoEWSXMQVmFsaQVaRGVsxmXBM0VkUkdChnzDQIBUaWNrc1RvQUidAQNtwCaCBAfXZWXAGeBIZXhUb0N5R1FCrP9EE8O6RQagHYQOoC+CDmRJz4MOgm2jO2VHVG9ADCAQgENQSXBUb07ANz2oFmWhiIRsIIsBCE5h2HZpZ2I1ozhGACrhAjEABGFtcAEtBBNBZMOAB2EBQXR0YSErYQEMQ3KAXwQecl9EaeRmZmUBSW7hSwIu5F5H4RnlBeICUGF14QJJgEVMb2FkV2HhBSfCPUAdgZJ2aUF0R3CkaWJiUW1nIDVjYJeJI191c0U4U3dhoAUHQwHCRAM7cmltfF+iUCBaU3BsRhFQonrbo1ICoVNAJkA7byFxoQK/4ypCL2N+olGEeoNZb8FFmHNQcsBN4SlNb6AYPFRyYRBhBQUzpSRUZZxtcANWYW3jbElF5SBx4ARjdGmhD4IWZixR3nWiIYG2YiriIk+BQaMf22EQA69hgD1DG29gTeEdjEZ1oZohAU1hawi0f0Jz41MAAeRzY3oCASMCdp5ppB3BAeIRBHp8X+CV2ERPU4EWwxNBACDhLSBSYWRpYWHMZWeHYLFBCIMgdmlHVEDA6QBPSVCgBmngGMUQYY0AeE=='
$sUdfs = BinaryToString(_Decompress(_B64Decode($sUdfs), 50865))
$sUdfs &= '|_WinAPI_GetProcAddress|_WinAPI_ShellAboutDlg'
Return $sUdfs
EndFunc
Func _objOptions()
Local $oObject = _AutoItObject_Create()
Local $oDict = ObjCreate("Scripting.Dictionary")
_AutoItObject_AddProperty($oObject, "snapGrid", $ELSCOPE_PUBLIC, True)
_AutoItObject_AddProperty($oObject, "pasteAtMouse", $ELSCOPE_PUBLIC, True)
_AutoItObject_AddProperty($oObject, "guiInFunction", $ELSCOPE_PUBLIC, True)
_AutoItObject_AddProperty($oObject, "eventMode", $ELSCOPE_PUBLIC, False)
_AutoItObject_AddProperty($oObject, "gridSize", $ELSCOPE_PUBLIC, 10)
_AutoItObject_AddProperty($oObject, "showGrid", $ELSCOPE_PUBLIC, True)
_AutoItObject_AddProperty($oObject, "showCodeViewer", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "showObjectExplorer", $ELSCOPE_PUBLIC, False)
Return $oObject
EndFunc
Func _objCtrls($isSelection = False)
Local $oObject = _AutoItObject_Create()
Local $oDict = ObjCreate("Scripting.Dictionary")
_AutoItObject_AddProperty($oObject, "mode", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "resizeStartLeft", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "resizeStartTop", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "CurrentType", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "menuCount", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "hasMenu", $ELSCOPE_PUBLIC, False)
_AutoItObject_AddProperty($oObject, "IPCount", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "hasIP", $ELSCOPE_PUBLIC, False)
_AutoItObject_AddProperty($oObject, "hasTab", $ELSCOPE_PUBLIC, False)
_AutoItObject_AddProperty($oObject, "isSelection", $ELSCOPE_PUBLIC, $isSelection)
_AutoItObject_AddProperty($oObject, "drawHwnd", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "clickedCtrl", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "styleList", $ELSCOPE_PUBLIC, _Styles_Main)
_AutoItObject_AddProperty($oObject, "ctrls", $ELSCOPE_PUBLIC, $oDict)
Local $oTypeCountList = ObjCreate("Scripting.Dictionary")
$oTypeCountList.Add("Button", 0)
$oTypeCountList.Add("Group", 0)
$oTypeCountList.Add("Checkbox", 0)
$oTypeCountList.Add("Radio", 0)
$oTypeCountList.Add("Edit", 0)
$oTypeCountList.Add("Input", 0)
$oTypeCountList.Add("Label", 0)
$oTypeCountList.Add("List", 0)
$oTypeCountList.Add("Combo", 0)
$oTypeCountList.Add("Date", 0)
$oTypeCountList.Add("Slider", 0)
$oTypeCountList.Add("Tab", 0)
$oTypeCountList.Add("Menu", 0)
$oTypeCountList.Add("TreeView", 0)
$oTypeCountList.Add("Updown", 0)
$oTypeCountList.Add("Progress", 0)
$oTypeCountList.Add("Pic", 0)
$oTypeCountList.Add("Avi", 0)
$oTypeCountList.Add("Icon", 0)
$oTypeCountList.Add("IP", 0)
$oTypeCountList.Add("ListView", 0)
$oTypeCountList.Add("Rect", 0)
$oTypeCountList.Add("Ellipse", 0)
$oTypeCountList.Add("Line", 0)
_AutoItObject_AddProperty($oObject, "typeCounts", $ELSCOPE_PUBLIC, $oTypeCountList)
_AutoItObject_AddMethod($oObject, "createNew", "_objCtrls_createNew")
_AutoItObject_AddMethod($oObject, "count", "_objCtrls_count")
_AutoItObject_AddMethod($oObject, "add", "_objCtrls_add")
_AutoItObject_AddMethod($oObject, "remove", "_objCtrls_remove")
_AutoItObject_AddMethod($oObject, "removeAll", "_objCtrls_removeAll")
_AutoItObject_AddMethod($oObject, "get", "_objCtrls_get")
_AutoItObject_AddMethod($oObject, "getFirst", "_objCtrls_getFist")
_AutoItObject_AddMethod($oObject, "getLast", "_objCtrls_getLast")
_AutoItObject_AddMethod($oObject, "getCopy", "_objCtrls_getCopy")
_AutoItObject_AddMethod($oObject, "exists", "_objCtrls_exists")
_AutoItObject_AddMethod($oObject, "incTypeCount", "_objCtrls_incTypeCount")
_AutoItObject_AddMethod($oObject, "decTypeCount", "_objCtrls_decTypeCount")
_AutoItObject_AddMethod($oObject, "getTypeCount", "_objCtrls_getTypeCount")
_AutoItObject_AddMethod($oObject, "moveUp", "_objCtrls_moveUp")
_AutoItObject_AddMethod($oObject, "moveDown", "_objCtrls_moveDown")
_AutoItObject_AddMethod($oObject, "startResizing", "_objCtrls_startResizing")
Return $oObject
EndFunc
Func _objCtrls_createNew($oSelf)
#forceref $oSelf
Local $oObject = _objCtrl($oSelf)
Return $oObject
EndFunc
Func _objCtrls_count($oSelf)
Return $oSelf.ctrls.Count
EndFunc
Func _objCtrls_add($oSelf, $objCtrl, $hParent = -1)
#forceref $oSelf
If $oSelf.isSelection Then
_AutoItObject_AddProperty($objCtrl, "grippies", $ELSCOPE_PUBLIC, _objGrippies($objCtrl, $oSelf))
EndIf
Switch $objCtrl.Type
Case "Tab"
$objCtrl.styles = _Styles_Tab()
Case "Group"
$objCtrl.styles = _Styles_Group()
Case "Button"
$objCtrl.styles = _Styles_Button()
Case "Checkbox"
$objCtrl.styles = _Styles_Checkbox()
Case "Radio"
$objCtrl.styles = _Styles_Radio()
Case "Edit"
$objCtrl.styles = _Styles_Edit()
Case "Input"
$objCtrl.styles = _Styles_Input()
Case "Label"
$objCtrl.styles = _Styles_Label()
$objCtrl.styles.Item("SS_CENTER") = True
Case "Updown"
$objCtrl.styles = _Styles_UpDown()
Case "List"
$objCtrl.styles = _Styles_List()
Case "Combo"
$objCtrl.styles = _Styles_Combo()
Case "Date"
$objCtrl.styles = _Styles_Date()
Case "TreeView"
$objCtrl.styles = _Styles_TreeView()
Case "Progress"
$objCtrl.styles = _Styles_Progress()
Case "Avi"
$objCtrl.styles = _Styles_Avi()
Case "Icon"
$objCtrl.styles = _Styles_Icon()
Case "Pic"
$objCtrl.styles = _Styles_Pic()
Case "Slider"
$objCtrl.styles = _Styles_Slider()
Case "IP"
$objCtrl.styles = _Styles_IP()
Case "ListView"
$objCtrl.styles = _Styles_ListView()
Case "Rect", "Ellipse", "Line"
$objCtrl.styles = _Styles_Label()
EndSwitch
$oSelf.ctrls.Add($objCtrl.Hwnd, $objCtrl)
If $objCtrl.Type = "Menu" Then
$oSelf.menuCount = $oSelf.menuCount + 1
$oSelf.hasMenu = True
EndIf
If $objCtrl.Type = "IP" Then
$oSelf.IPCount = $oSelf.IPCount + 1
$oSelf.hasIP = True
EndIf
If $objCtrl.Type = "Tab" Then
$oSelf.hasTab = True
EndIf
If $hParent <> -1 Then
For $oThisCtrl In $oSelf.ctrls.Items()
If $oThisCtrl.Hwnd = $hParent Then
Switch $oThisCtrl.Type
Case "Tab"
Local $iTabFocus = _GUICtrlTab_GetCurSel($oThisCtrl.Hwnd)
If $iTabFocus >= 0 Then
Local $tabID = $oThisCtrl.Tabs.at($iTabFocus)
$oTabItem = $oCtrls.get($tabID)
$oTabItem.ctrls.Add($objCtrl.Hwnd, $objCtrl)
$objCtrl.CtrlParent = $oTabItem.Hwnd
$oTabItem.CtrlParent = $oThisCtrl.Hwnd
EndIf
Case "Group"
$oThisCtrl.ctrls.Add($objCtrl.Hwnd, $objCtrl)
$objCtrl.CtrlParent = $oThisCtrl.Hwnd
EndSwitch
EndIf
Next
EndIf
$oSelf.incTypeCount($objCtrl.Type)
Return $oSelf.count
EndFunc
Func _objCtrls_remove($oSelf, $Hwnd)
#forceref $oSelf
Local $bFoundItem = $oSelf.ctrls.Exists($Hwnd)
Local $type
If $bFoundItem Then
Local $thisCtrl = $oSelf.ctrls.Item($Hwnd)
If Not $oSelf.isSelection Then
If $thisCtrl.CtrlParent <> 0 Then
Local $oTabItem = $oCtrls.get($thisCtrl.CtrlParent)
If IsObj($oTabItem) Then
$oTabItem.ctrls.Remove($thisCtrl.Hwnd)
EndIf
EndIf
EndIf
If $thisCtrl.Type = "Menu" Then
$oSelf.menuCount = $oSelf.menuCount - 1
If $oSelf.menuCount >= 1 Then
$oSelf.hasMenu = True
Else
$oSelf.hasMenu = False
EndIf
ElseIf $thisCtrl.Type = "IP" Then
$oSelf.IPCount = $oSelf.IPCount - 1
If $oSelf.IPCount >= 1 Then
$oSelf.hasIP = True
Else
$oSelf.hasIP = False
EndIf
ElseIf $thisCtrl.Type = "Tab" Then
$oSelf.hasTab = False
EndIf
If $oSelf.isSelection Then
$thisCtrl.grippies.delete()
EndIf
$type = $thisCtrl.Type
$oSelf.ctrls.Remove($Hwnd)
EndIf
If Not @error Then
$oSelf.decTypeCount($type)
Return $oSelf.count
Else
Return -1
EndIf
EndFunc
Func _objCtrls_removeAll($oSelf)
#forceref $oSelf
For $oItem In $oSelf.ctrls.Items()
If $oSelf.isSelection Then
$oItem.grippies.delete()
EndIf
Next
$oSelf.ctrls = 0
$oSelf.ctrls = ObjCreate("Scripting.Dictionary")
$oSelf.menuCount = 0
$oSelf.hasMenu = False
$oSelf.hasTab = False
EndFunc
Func _objCtrls_get($oSelf, $Hwnd)
#forceref $oSelf
If $oSelf.ctrls.Exists($Hwnd) Then
Return $oSelf.ctrls.Item($Hwnd)
Else
Return -1
EndIf
EndFunc
Func _objCtrls_getFist($oSelf)
#forceref $oSelf
Local $aItems = $oSelf.ctrls.Items()
If IsArray($aItems) And UBound($aItems) > 0 Then
Return $aItems[0]
Else
Return -1
EndIf
EndFunc
Func _objCtrls_getLast($oSelf)
#forceref $oSelf
Local $aItems = $oSelf.ctrls.Items()
If IsArray($aItems) And UBound($aItems) > 0 Then
Return $aItems[$oSelf.ctrls.Count - 1]
Else
Return -1
EndIf
EndFunc
Func _objCtrls_getCopy($oSelf, $Hwnd)
#forceref $oSelf
Local $oCtrl = $oSelf.get($Hwnd)
If IsObj($oCtrl) Then
Return _AutoItObject_Create($oCtrl)
Else
Return -1
EndIf
EndFunc
Func _objCtrls_exists($oSelf, $Hwnd)
#forceref $oSelf
If $oSelf.ctrls.Exists($Hwnd) Then
Return True
Else
Return False
EndIf
EndFunc
Func _objCtrls_incTypeCount($oSelf, $sType)
#forceref $oSelf
Local $value = $oSelf.typeCounts.Item($sType)
$oSelf.typeCounts.Item($sType) = $value + 1
Return $oSelf.typeCounts.Item($sType)
EndFunc
Func _objCtrls_decTypeCount($oSelf, $sType)
#forceref $oSelf
Local $value = $oSelf.typeCounts.Item($sType)
$oSelf.typeCounts.Item($sType) = $value - 1
Return $oSelf.typeCounts.Item($sType)
EndFunc
Func _objCtrls_getTypeCount($oSelf, $sType)
#forceref $oSelf
Return $oSelf.typeCounts.Item($sType)
EndFunc
Func _objCtrls_moveUp($oSelf, $oCtrlStart)
#forceref $oSelf
Local $iStart = -1, $iEnd = -1
Local $i = 0
If $oCtrlStart.CtrlParent = 0 Then
For $oCtrl In $oSelf.ctrls.Items()
If $oCtrl.Hwnd <> $oCtrlStart.Hwnd Then
If $oCtrl.CtrlParent = 0 Then
$iEnd = $i
EndIf
Else
$iStart = $i
ExitLoop
EndIf
$i += 1
Next
If $iStart = -1 Or $iEnd > $oSelf.count - 1 Or $iEnd < 0 Then Return 1
Local $oCtrlsTemp = ObjCreate("Scripting.Dictionary")
$i = 0
For $oCtrl In $oSelf.ctrls.Items()
If $i <> $iStart Then
If $i = $iEnd Then
$oCtrlsTemp.Add($oCtrlStart.Hwnd, $oCtrlStart)
EndIf
$oCtrlsTemp.Add($oCtrl.Hwnd, $oCtrl)
EndIf
$i += 1
Next
$oSelf.ctrls = 0
$oSelf.ctrls = $oCtrlsTemp
Else
Local $oParent = $oSelf.get($oCtrlStart.CtrlParent)
Switch $oCtrlStart.Type
Case "TabItem"
Case Else
For $oCtrl In $oParent.ctrls.Items()
If $oCtrl.Hwnd <> $oCtrlStart.Hwnd Then
If $oCtrl.CtrlParent = $oCtrlStart.CtrlParent Then
$iEnd = $i
EndIf
Else
$iStart = $i
ExitLoop
EndIf
$i += 1
Next
If $iStart = -1 Or $iEnd > $oParent.ctrls.Count - 1 Or $iEnd < 0 Then Return 1
Local $oCtrlsTemp = ObjCreate("Scripting.Dictionary")
$i = 0
For $oCtrl In $oParent.ctrls.Items()
If $i <> $iStart Then
If $i = $iEnd Then
$oCtrlsTemp.Add($oCtrlStart.Hwnd, $oCtrlStart)
EndIf
$oCtrlsTemp.Add($oCtrl.Hwnd, $oCtrl)
EndIf
$i += 1
Next
$oParent.ctrls = 0
$oParent.ctrls = $oCtrlsTemp
EndSwitch
EndIf
Return $oCtrlStart
EndFunc
Func _objCtrls_moveDown($oSelf, $oCtrlStart)
#forceref $oSelf
Local $iStart = -1, $iEnd = -1
Local $i = 0
If $oCtrlStart.CtrlParent = 0 Then
For $oCtrl In $oSelf.ctrls.Items()
If $oCtrl.Hwnd = $oCtrlStart.Hwnd Then
$iStart = $i
Else
If $iStart <> -1 And $oCtrl.CtrlParent = 0 Then
$iEnd = $i
ExitLoop
EndIf
EndIf
$i += 1
Next
If $iStart = -1 Or $iEnd > $oSelf.count - 1 Or $iEnd < 0 Then Return 1
Local $oCtrlsTemp = ObjCreate("Scripting.Dictionary")
$i = 0
For $oCtrl In $oSelf.ctrls.Items()
If $i <> $iStart Then
$oCtrlsTemp.Add($oCtrl.Hwnd, $oCtrl)
If $i = $iEnd Then
$oCtrlsTemp.Add($oCtrlStart.Hwnd, $oCtrlStart)
EndIf
EndIf
$i += 1
Next
$oSelf.ctrls = 0
$oSelf.ctrls = $oCtrlsTemp
Else
Local $oParent = $oSelf.get($oCtrlStart.CtrlParent)
Switch $oCtrlStart.Type
Case "TabItem"
Case Else
For $oCtrl In $oParent.ctrls.Items()
If $oCtrl.Hwnd = $oCtrlStart.Hwnd Then
$iStart = $i
Else
If $iStart <> -1 And $oCtrl.CtrlParent = $oCtrlStart.CtrlParent Then
$iEnd = $i
ExitLoop
EndIf
EndIf
$i += 1
Next
If $iStart = -1 Or $iEnd > $oParent.ctrls.Count - 1 Or $iEnd < 0 Then Return 1
Local $oCtrlsTemp = ObjCreate("Scripting.Dictionary")
$i = 0
For $oCtrl In $oParent.ctrls.Items()
If $i <> $iStart Then
$oCtrlsTemp.Add($oCtrl.Hwnd, $oCtrl)
If $i = $iEnd Then
$oCtrlsTemp.Add($oCtrlStart.Hwnd, $oCtrlStart)
EndIf
EndIf
$i += 1
Next
$oParent.ctrls = 0
$oParent.ctrls = $oCtrlsTemp
EndSwitch
EndIf
Return $oCtrlStart
EndFunc
Func _objCtrls_startResizing($oSelf)
#forceref $oSelf
Local $mouse_pos = _mouse_snap_pos()
For $oCtrl In $oSelf.ctrls.Items()
$oCtrl.resizePrevLeft = $mouse_pos[0]
$oCtrl.resizePrevTop = $mouse_pos[1]
$oCtrl.resizeStartLeft = $mouse_pos[0]
$oCtrl.resizeStarTop = $mouse_pos[1]
$oCtrl.PrevWidth = $oCtrl.Width
$oCtrl.PrevHeight = $oCtrl.Height
$oCtrl.PrevLeft = $oCtrl.Left
$oCtrl.PrevTop = $oCtrl.Top
Next
EndFunc
Func _objCtrl($oParent)
Local $oObject = _AutoItObject_Create()
_AutoItObject_AddProperty($oObject, "parent", $ELSCOPE_PUBLIC, $oParent)
_AutoItObject_AddProperty($oObject, "isResizeMaster", $ELSCOPE_PUBLIC, False)
_AutoItObject_AddProperty($oObject, "resizePrevLeft", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "resizePrevTop", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "resizeStartLeft", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "resizeStartTop", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "Hwnd", $ELSCOPE_PUBLIC)
_AutoItObject_AddProperty($oObject, "Hwnd", $ELSCOPE_PUBLIC)
_AutoItObject_AddProperty($oObject, "Hwnd1", $ELSCOPE_PUBLIC)
_AutoItObject_AddProperty($oObject, "Hwnd2", $ELSCOPE_PUBLIC)
_AutoItObject_AddProperty($oObject, "Name", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "Text", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "HwndCount", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "Type", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "Left", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "Top", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "Width", $ELSCOPE_PUBLIC, 1)
_AutoItObject_AddProperty($oObject, "Height", $ELSCOPE_PUBLIC, 1)
_AutoItObject_AddProperty($oObject, "PrevWidth", $ELSCOPE_PUBLIC, 1)
_AutoItObject_AddProperty($oObject, "PrevHeight", $ELSCOPE_PUBLIC, 1)
_AutoItObject_AddProperty($oObject, "PrevLeft", $ELSCOPE_PUBLIC, 1)
_AutoItObject_AddProperty($oObject, "PrevTop", $ELSCOPE_PUBLIC, 1)
_AutoItObject_AddProperty($oObject, "Visible", $ELSCOPE_PUBLIC, True)
_AutoItObject_AddProperty($oObject, "Enabled", $ELSCOPE_PUBLIC, True)
_AutoItObject_AddProperty($oObject, "Focus", $ELSCOPE_PUBLIC, False)
_AutoItObject_AddProperty($oObject, "OnTop", $ELSCOPE_PUBLIC, False)
_AutoItObject_AddProperty($oObject, "DropAccepted", $ELSCOPE_PUBLIC, False)
_AutoItObject_AddProperty($oObject, "DefButton", $ELSCOPE_PUBLIC, False)
_AutoItObject_AddProperty($oObject, "Color", $ELSCOPE_PUBLIC, -1)
_AutoItObject_AddProperty($oObject, "FontSize", $ELSCOPE_PUBLIC, -1)
_AutoItObject_AddProperty($oObject, "FontName", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "FontWeight", $ELSCOPE_PUBLIC, 400)
_AutoItObject_AddProperty($oObject, "Background", $ELSCOPE_PUBLIC, -1)
_AutoItObject_AddProperty($oObject, "Global", $ELSCOPE_PUBLIC, True)
_AutoItObject_AddProperty($oObject, "TabCount", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "Tabs", $ELSCOPE_PUBLIC, LinkedList())
_AutoItObject_AddProperty($oObject, "MenuItems", $ELSCOPE_PUBLIC, LinkedList())
_AutoItObject_AddProperty($oObject, "ctrls", $ELSCOPE_PUBLIC, ObjCreate("Scripting.Dictionary"))
_AutoItObject_AddProperty($oObject, "Dirty", $ELSCOPE_PUBLIC, False)
_AutoItObject_AddProperty($oObject, "CtrlParent", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "Locked", $ELSCOPE_PUBLIC, False)
_AutoItObject_AddProperty($oObject, "styleString", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "styles", $ELSCOPE_PUBLIC, ObjCreate("Scripting.Dictionary"))
_AutoItObject_AddProperty($oObject, "CodeString", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "BorderColor", $ELSCOPE_PUBLIC, '0x000000')
_AutoItObject_AddProperty($oObject, "BorderSize", $ELSCOPE_PUBLIC, 1)
Local $aCoord1[2] = [0, 0]
Local $aCoord2[2] = [1, 1]
_AutoItObject_AddProperty($oObject, "Coord1", $ELSCOPE_PUBLIC, $aCoord1)
_AutoItObject_AddProperty($oObject, "Coord2", $ELSCOPE_PUBLIC, $aCoord2)
_AutoItObject_AddProperty($oObject, "Items", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "Img", $ELSCOPE_PUBLIC, "")
Return $oObject
EndFunc
Func _objGroup($oParent)
Local $oObject = _objCtrl($oParent)
_AutoItObject_AddProperty($oObject, "ctrls", $ELSCOPE_PUBLIC, ObjCreate("Scripting.Dictionary"))
Return $oObject
EndFunc
Func _objCreateRect()
Local $oSelf = _AutoItObject_Create()
_AutoItObject_AddProperty($oSelf, "Left", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oSelf, "Top", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oSelf, "Width", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oSelf, "Height", $ELSCOPE_PUBLIC, 0)
Return $oSelf
EndFunc
Func _CreateListItem($name, $value)
Local $oSelf = _AutoItObject_Create()
_AutoItObject_AddProperty($oSelf, "Name", $ELSCOPE_PUBLIC, $name)
_AutoItObject_AddProperty($oSelf, "Value", $ELSCOPE_PUBLIC, $value)
Return $oSelf
EndFunc
Func _objMain()
Local $oObject = _AutoItObject_Create()
_AutoItObject_AddProperty($oObject, "Hwnd", $ELSCOPE_PUBLIC)
_AutoItObject_AddProperty($oObject, "Title", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "Name", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "Text", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "Left", $ELSCOPE_PUBLIC, -1)
_AutoItObject_AddProperty($oObject, "Top", $ELSCOPE_PUBLIC, -1)
_AutoItObject_AddProperty($oObject, "Width", $ELSCOPE_PUBLIC, -1)
_AutoItObject_AddProperty($oObject, "Height", $ELSCOPE_PUBLIC, -1)
_AutoItObject_AddProperty($oObject, "Background", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "AppName", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "AppVersion", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "DefaultCursor", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "hasChanged", $ELSCOPE_PUBLIC, False)
_AutoItObject_AddProperty($oObject, "styles", $ELSCOPE_PUBLIC, _Styles_Main())
_AutoItObject_AddProperty($oObject, "styleString", $ELSCOPE_PUBLIC, "")
Return $oObject
EndFunc
Func _objGrippies($oParent, $oGrandParent)
Local $oObject = _AutoItObject_Create()
_AutoItObject_AddProperty($oObject, "parent", $ELSCOPE_PUBLIC, $oParent)
Local $grippy_size = 5
Local $NW = GUICtrlCreateLabel("", -$grippy_size, -$grippy_size, $grippy_size, $grippy_size, -1, $WS_EX_TOPMOST)
Local $N = GUICtrlCreateLabel("", -$grippy_size, -$grippy_size, $grippy_size, $grippy_size, -1, $WS_EX_TOPMOST)
Local $NE = GUICtrlCreateLabel("", -$grippy_size, -$grippy_size, $grippy_size, $grippy_size, -1, $WS_EX_TOPMOST)
Local $W = GUICtrlCreateLabel("", -$grippy_size, -$grippy_size, $grippy_size, $grippy_size, -1, $WS_EX_TOPMOST)
Local $East = GUICtrlCreateLabel("", -$grippy_size, -$grippy_size, $grippy_size, $grippy_size, -1, $WS_EX_TOPMOST)
Local $SW = GUICtrlCreateLabel("", -$grippy_size, -$grippy_size, $grippy_size, $grippy_size, -1, $WS_EX_TOPMOST)
Local $S = GUICtrlCreateLabel("", -$grippy_size, -$grippy_size, $grippy_size, $grippy_size, -1, $WS_EX_TOPMOST)
Local $SE = GUICtrlCreateLabel("", -$grippy_size, -$grippy_size, $grippy_size, $grippy_size, -1, $WS_EX_TOPMOST)
GUICtrlSetCursor($NW, $SIZENWSE)
GUICtrlSetCursor($N, $SIZENS)
GUICtrlSetCursor($NE, $SIZENESW)
GUICtrlSetCursor($East, $SIZEWS)
GUICtrlSetCursor($SE, $SIZENWSE)
GUICtrlSetCursor($S, $SIZENS)
GUICtrlSetCursor($SW, $SIZENESW)
GUICtrlSetCursor($W, $SIZEWS)
GUICtrlSetOnEvent($NW, "_objGrippies_mouseClickEvent")
GUICtrlSetOnEvent($N, "_objGrippies_mouseClickEvent")
GUICtrlSetOnEvent($NE, "_objGrippies_mouseClickEvent")
GUICtrlSetOnEvent($SW, "_objGrippies_mouseClickEvent")
GUICtrlSetOnEvent($S, "_objGrippies_mouseClickEvent")
GUICtrlSetOnEvent($SE, "_objGrippies_mouseClickEvent")
GUICtrlSetOnEvent($W, "_objGrippies_mouseClickEvent")
GUICtrlSetOnEvent($East, "_objGrippies_mouseClickEvent")
_AutoItObject_AddProperty($oObject, "size", $ELSCOPE_PUBLIC, $grippy_size)
_AutoItObject_AddProperty($oObject, "NW", $ELSCOPE_PUBLIC, $NW)
_AutoItObject_AddProperty($oObject, "N", $ELSCOPE_PUBLIC, $N)
_AutoItObject_AddProperty($oObject, "NE", $ELSCOPE_PUBLIC, $NE)
_AutoItObject_AddProperty($oObject, "SW", $ELSCOPE_PUBLIC, $SW)
_AutoItObject_AddProperty($oObject, "S", $ELSCOPE_PUBLIC, $S)
_AutoItObject_AddProperty($oObject, "SE", $ELSCOPE_PUBLIC, $SE)
_AutoItObject_AddProperty($oObject, "W", $ELSCOPE_PUBLIC, $W)
_AutoItObject_AddProperty($oObject, "East", $ELSCOPE_PUBLIC, $East)
_AutoItObject_AddMethod($oObject, "mouseClick", "_objGrippies_mouseClick")
_AutoItObject_AddMethod($oObject, "show", "_objGrippies_show")
_AutoItObject_AddMethod($oObject, "hide", "_objGrippies_hide")
_AutoItObject_AddMethod($oObject, "delete", "_objGrippies_delete")
_AutoItObject_AddMethod($oObject, "resizing", "_objGrippies_resizing")
_objGrippies_mouseClickEvent($oGrandParent)
Return $oObject
EndFunc
Func _objGrippies_mouseClickEvent($oObject = 0)
Static $oParentObject
Local $isEvent = IsDeclared("oObject") = $DECLARED_LOCAL
If $isEvent Then
$oParentObject = $oObject
Else
If IsObj($oParentObject) Then
For $oCtrl In $oParentObject.ctrls.Items()
Switch @GUI_CtrlId
Case $oCtrl.grippies.NW, $oCtrl.grippies.N, $oCtrl.grippies.NE, $oCtrl.grippies.SE, $oCtrl.grippies.S, $oCtrl.grippies.SW, $oCtrl.grippies.W, $oCtrl.grippies.East
$oCtrl.grippies.mouseClick(@GUI_CtrlId)
EndSwitch
Next
Else
Return -1
EndIf
EndIf
EndFunc
Func _objGrippies_mouseClick($oSelf, $CtrlID)
If $oSelf.parent.Locked Then Return
Switch $CtrlID
Case $oSelf.NW
$oSelf.parent.parent.mode = $resize_nw
Case $oSelf.N
$oSelf.parent.parent.mode = $resize_n
Case $oSelf.NE
$oSelf.parent.parent.mode = $resize_ne
Case $oSelf.East
$oSelf.parent.parent.mode = $resize_e
Case $oSelf.SE
$oSelf.parent.parent.mode = $resize_se
Case $oSelf.S
$oSelf.parent.parent.mode = $resize_s
Case $oSelf.SW
$oSelf.parent.parent.mode = $resize_sw
Case $oSelf.W
$oSelf.parent.parent.mode = $resize_w
EndSwitch
$oSelf.parent.isResizeMaster = True
$oSelf.parent.parent.StartResizing()
$initResize = True
EndFunc
Func _objGrippies_resizing($oSelf, $mode)
Local $oCtrl = $oSelf.parent
Local $left, $top, $right, $bottom
Switch $mode
Case $resize_nw
$left = $oCtrl.Left + ($oMouse.X - $oCtrl.resizePrevLeft)
$top = $oCtrl.Top + ($oMouse.Y - $oCtrl.resizePrevTop)
$right = $oCtrl.Width + ($oCtrl.resizePrevLeft - $oMouse.X)
$bottom = $oCtrl.Height + ($oCtrl.resizePrevTop - $oMouse.Y)
Case $resize_n
$left = $oCtrl.Left
$top = $oCtrl.Top + ($oMouse.Y - $oCtrl.resizePrevTop)
$right = $oCtrl.Width
$bottom = $oCtrl.Height + ($oCtrl.resizePrevTop - $oMouse.Y)
Case $resize_ne
$left = $oCtrl.Left
$top = $oCtrl.Top + ($oMouse.Y - $oCtrl.resizePrevTop)
$right = $oCtrl.Width + ($oMouse.X - $oCtrl.resizePrevLeft)
$bottom = $oCtrl.Height + ($oCtrl.resizePrevTop - $oMouse.Y)
Case $resize_w
$left = $oCtrl.Left + ($oMouse.X - $oCtrl.resizePrevLeft)
$top = $oCtrl.Top
$right = $oCtrl.Width + ($oCtrl.resizePrevLeft - $oMouse.X)
$bottom = $oCtrl.Height
Case $resize_e
$left = $oCtrl.Left
$top = $oCtrl.Top
$right = $oCtrl.Width + ($oMouse.X - $oCtrl.resizePrevLeft)
$bottom = $oCtrl.Height
Case $resize_sw
$left = $oCtrl.Left + ($oMouse.X - $oCtrl.resizePrevLeft)
$top = $oCtrl.Top
$right = $oCtrl.Width + ($oCtrl.resizePrevLeft - $oMouse.X)
$bottom = $oCtrl.Height + ($oMouse.Y - $oCtrl.resizePrevTop)
Case $resize_s
$left = $oCtrl.Left
$top = $oCtrl.Top
$right = $oCtrl.Width
$bottom = $oCtrl.Height + ($oMouse.Y - $oCtrl.resizePrevTop)
Case $resize_se
$left = $oCtrl.Left
$top = $oCtrl.Top
$right = $oCtrl.Width + ($oMouse.X - $oCtrl.resizePrevLeft)
$bottom = $oCtrl.Height + ($oMouse.Y - $oCtrl.resizePrevTop)
EndSwitch
$oCtrl.resizePrevLeft = $oMouse.X
$oCtrl.resizePrevTop = $oMouse.Y
_set_current_mouse_pos()
Switch $oCtrl.Type
Case "Slider"
GUICtrlSendMsg($oCtrl.Hwnd, 27 + 0x0400, $oCtrl.Height - 20, 0)
EndSwitch
_change_ctrl_size_pos($oCtrl, $left, $top, $right, $bottom)
EndFunc
Func _objGrippies_show($oSelf)
Local $lockColor = 0xFF0000
Local $unlockColor = 0x333333
If $oSelf.parent.Locked Then
GUICtrlSetBkColor($oSelf.NW, $lockColor)
GUICtrlSetBkColor($oSelf.N, $lockColor)
GUICtrlSetBkColor($oSelf.NE, $lockColor)
GUICtrlSetBkColor($oSelf.East, $lockColor)
GUICtrlSetBkColor($oSelf.SE, $lockColor)
GUICtrlSetBkColor($oSelf.S, $lockColor)
GUICtrlSetBkColor($oSelf.SW, $lockColor)
GUICtrlSetBkColor($oSelf.W, $lockColor)
GUICtrlSetCursor($oSelf.NW, -1)
GUICtrlSetCursor($oSelf.N, -1)
GUICtrlSetCursor($oSelf.NE, -1)
GUICtrlSetCursor($oSelf.East, -1)
GUICtrlSetCursor($oSelf.SE, -1)
GUICtrlSetCursor($oSelf.S, -1)
GUICtrlSetCursor($oSelf.SW, -1)
GUICtrlSetCursor($oSelf.W, -1)
Else
GUICtrlSetBkColor($oSelf.NW, $unlockColor)
GUICtrlSetBkColor($oSelf.N, $unlockColor)
GUICtrlSetBkColor($oSelf.NE, $unlockColor)
GUICtrlSetBkColor($oSelf.East, $unlockColor)
GUICtrlSetBkColor($oSelf.SE, $unlockColor)
GUICtrlSetBkColor($oSelf.S, $unlockColor)
GUICtrlSetBkColor($oSelf.SW, $unlockColor)
GUICtrlSetBkColor($oSelf.W, $unlockColor)
GUICtrlSetCursor($oSelf.NW, $SIZENWSE)
GUICtrlSetCursor($oSelf.N, $SIZENS)
GUICtrlSetCursor($oSelf.NE, $SIZENESW)
GUICtrlSetCursor($oSelf.East, $SIZEWS)
GUICtrlSetCursor($oSelf.SE, $SIZENWSE)
GUICtrlSetCursor($oSelf.S, $SIZENS)
GUICtrlSetCursor($oSelf.SW, $SIZENESW)
GUICtrlSetCursor($oSelf.W, $SIZEWS)
EndIf
GUICtrlSetState($oSelf.NW, $GUI_SHOW)
GUICtrlSetState($oSelf.N, $GUI_SHOW)
GUICtrlSetState($oSelf.NE, $GUI_SHOW)
GUICtrlSetState($oSelf.East, $GUI_SHOW)
GUICtrlSetState($oSelf.SE, $GUI_SHOW)
GUICtrlSetState($oSelf.S, $GUI_SHOW)
GUICtrlSetState($oSelf.SW, $GUI_SHOW)
GUICtrlSetState($oSelf.W, $GUI_SHOW)
_WinAPI_SetWindowPos(GUICtrlGetHandle($oSelf.NW), $HWND_TOP, 0, 0, 0, 0, $SWP_NOMOVE + $SWP_NOSIZE + $SWP_NOCOPYBITS)
_WinAPI_SetWindowPos(GUICtrlGetHandle($oSelf.N), $HWND_TOP, 0, 0, 0, 0, $SWP_NOMOVE + $SWP_NOSIZE + $SWP_NOCOPYBITS)
_WinAPI_SetWindowPos(GUICtrlGetHandle($oSelf.NE), $HWND_TOP, 0, 0, 0, 0, $SWP_NOMOVE + $SWP_NOSIZE + $SWP_NOCOPYBITS)
_WinAPI_SetWindowPos(GUICtrlGetHandle($oSelf.W), $HWND_TOP, 0, 0, 0, 0, $SWP_NOMOVE + $SWP_NOSIZE + $SWP_NOCOPYBITS)
_WinAPI_SetWindowPos(GUICtrlGetHandle($oSelf.East), $HWND_TOP, 0, 0, 0, 0, $SWP_NOMOVE + $SWP_NOSIZE + $SWP_NOCOPYBITS)
_WinAPI_SetWindowPos(GUICtrlGetHandle($oSelf.SW), $HWND_TOP, 0, 0, 0, 0, $SWP_NOMOVE + $SWP_NOSIZE + $SWP_NOCOPYBITS)
_WinAPI_SetWindowPos(GUICtrlGetHandle($oSelf.S), $HWND_TOP, 0, 0, 0, 0, $SWP_NOMOVE + $SWP_NOSIZE + $SWP_NOCOPYBITS)
_WinAPI_SetWindowPos(GUICtrlGetHandle($oSelf.SE), $HWND_TOP, 0, 0, 0, 0, $SWP_NOMOVE + $SWP_NOSIZE + $SWP_NOCOPYBITS)
Local Const $grippy_size = $oSelf.size
Local Const $l = $oSelf.parent.Left
Local Const $t = $oSelf.parent.Top
Local Const $W = $oSelf.parent.Width
Local Const $h = $oSelf.parent.Height
Local $offsetX = 0, $offsetY = 0
If $W < 0 Then $offsetX = $grippy_size
If $h < 0 Then $offsetY = $grippy_size
Local Const $nw_left = $l - $grippy_size + $offsetX
Local Const $nw_top = $t - $grippy_size + $offsetY
Local Const $n_left = $l + ($W - $grippy_size) / 2
Local Const $n_top = $nw_top
Local Const $ne_left = $l + $W - $offsetX
Local Const $ne_top = $nw_top
Local Const $e_left = $ne_left
Local Const $e_top = $t + ($h - $grippy_size) / 2
Local Const $se_left = $ne_left
Local Const $se_top = $t + $h - $offsetY
Local Const $s_left = $n_left
Local Const $s_top = $se_top
Local Const $sw_left = $nw_left
Local Const $sw_top = $se_top
Local Const $w_left = $nw_left
Local Const $w_top = $e_top
Switch $oSelf.parent.Type
Case "Combo", "Checkbox", "Radio"
GUICtrlSetPos($oSelf.East, $e_left, $e_top, Default, Default)
GUICtrlSetPos($oSelf.W, $w_left, $w_top, Default, Default)
Case Else
GUICtrlSetPos($oSelf.NW, $nw_left, $nw_top, Default, Default)
GUICtrlSetPos($oSelf.N, $n_left, $n_top, Default, Default)
GUICtrlSetPos($oSelf.NE, $ne_left, $ne_top, Default, Default)
GUICtrlSetPos($oSelf.East, $e_left, $e_top, Default, Default)
GUICtrlSetPos($oSelf.SE, $se_left, $se_top, Default, Default)
GUICtrlSetPos($oSelf.S, $s_left, $s_top, Default, Default)
GUICtrlSetPos($oSelf.SW, $sw_left, $sw_top, Default, Default)
GUICtrlSetPos($oSelf.W, $w_left, $w_top, Default, Default)
EndSwitch
EndFunc
Func _objGrippies_hide($oSelf)
GUICtrlSetState($oSelf.NW, $GUI_HIDE)
GUICtrlSetState($oSelf.N, $GUI_HIDE)
GUICtrlSetState($oSelf.NE, $GUI_HIDE)
GUICtrlSetState($oSelf.East, $GUI_HIDE)
GUICtrlSetState($oSelf.SE, $GUI_HIDE)
GUICtrlSetState($oSelf.S, $GUI_HIDE)
GUICtrlSetState($oSelf.SW, $GUI_HIDE)
GUICtrlSetState($oSelf.W, $GUI_HIDE)
EndFunc
Func _objGrippies_delete($oSelf)
GUICtrlDelete($oSelf.NW)
GUICtrlDelete($oSelf.N)
GUICtrlDelete($oSelf.NE)
GUICtrlDelete($oSelf.East)
GUICtrlDelete($oSelf.SW)
GUICtrlDelete($oSelf.S)
GUICtrlDelete($oSelf.SE)
GUICtrlDelete($oSelf.W)
EndFunc
Func _Styles_Main()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_GUI", False)
$oDict.Add("WS_BORDER", False)
$oDict.Add("WS_POPUP", False)
$oDict.Add("WS_CAPTION", False)
$oDict.Add("WS_CLIPCHILDREN", False)
$oDict.Add("WS_CLIPSIBLINGS", False)
$oDict.Add("WS_DISABLED", False)
$oDict.Add("WS_DLGFRAME", False)
$oDict.Add("WS_HSCROLL", False)
$oDict.Add("WS_MAXIMIZE", False)
$oDict.Add("WS_MAXIMIZEBOX", False)
$oDict.Add("WS_MINIMIZE", False)
$oDict.Add("WS_MINIMIZEBOX", False)
$oDict.Add("WS_OVERLAPPED", False)
$oDict.Add("WS_OVERLAPPEDWINDOW", False)
$oDict.Add("WS_POPUPWINDOW", False)
$oDict.Add("WS_SIZEBOX", False)
$oDict.Add("WS_SYSMENU", False)
$oDict.Add("WS_THICKFRAME", False)
$oDict.Add("WS_VSCROLL", False)
$oDict.Add("WS_VISIBLE", False)
$oDict.Add("WS_CHILD", False)
$oDict.Add("WS_GROUP", False)
$oDict.Add("WS_TABSTOP", False)
$oDict.Add("DS_MODALFRAME", False)
$oDict.Add("DS_SETFOREGROUND", False)
$oDict.Add("DS_CONTEXTHELP", False)
Return $oDict
EndFunc
Func _Styles_Tab()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_TAB", False)
$oDict.Add("TCS_SCROLLOPPOSITE", False)
$oDict.Add("TCS_BOTTOM", False)
$oDict.Add("TCS_RIGHT", False)
$oDict.Add("TCS_MULTISELECT", False)
$oDict.Add("TCS_FLATBUTTONS", False)
$oDict.Add("TCS_FORCEICONLEFT", False)
$oDict.Add("TCS_FORCELABELLEFT", False)
$oDict.Add("TCS_HOTTRACK", False)
$oDict.Add("TCS_VERTICAL", False)
$oDict.Add("TCS_TABS", False)
$oDict.Add("TCS_BUTTONS", False)
$oDict.Add("TCS_SINGLELINE", False)
$oDict.Add("TCS_MULTILINE", False)
$oDict.Add("TCS_RIGHTJUSTIFY", False)
$oDict.Add("TCS_FIXEDWIDTH", False)
$oDict.Add("TCS_RAGGEDRIGHT", False)
$oDict.Add("TCS_FOCUSONBUTTONDOWN", False)
$oDict.Add("TCS_OWNERDRAWFIXED", False)
$oDict.Add("TCS_TOOLTIPS", False)
$oDict.Add("TCS_FOCUSNEVER", False)
Return $oDict
EndFunc
Func _Styles_Group()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("WS_BORDER", False)
$oDict.Add("WS_POPUP", False)
$oDict.Add("WS_CAPTION", False)
$oDict.Add("WS_CLIPCHILDREN", False)
$oDict.Add("WS_CLIPSIBLINGS", False)
$oDict.Add("WS_DISABLED", False)
$oDict.Add("WS_DLGFRAME", False)
$oDict.Add("WS_HSCROLL", False)
$oDict.Add("WS_MAXIMIZE", False)
$oDict.Add("WS_MAXIMIZEBOX", False)
$oDict.Add("WS_MINIMIZE", False)
$oDict.Add("WS_MINIMIZEBOX", False)
$oDict.Add("WS_OVERLAPPED", False)
$oDict.Add("WS_OVERLAPPEDWINDOW", False)
$oDict.Add("WS_POPUPWINDOW", False)
$oDict.Add("WS_SIZEBOX", False)
$oDict.Add("WS_SYSMENU", False)
$oDict.Add("WS_THICKFRAME", False)
$oDict.Add("WS_VSCROLL", False)
$oDict.Add("WS_VISIBLE", False)
$oDict.Add("WS_CHILD", False)
$oDict.Add("WS_GROUP", False)
$oDict.Add("WS_TABSTOP", False)
$oDict.Add("DS_MODALFRAME", False)
$oDict.Add("DS_SETFOREGROUND", False)
$oDict.Add("DS_CONTEXTHELP", False)
Return $oDict
EndFunc
Func _Styles_Button()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_BUTTON", False)
$oDict.Add("BS_LEFT", False)
$oDict.Add("BS_CENTER", False)
$oDict.Add("BS_RIGHT", False)
$oDict.Add("BS_BOTTOM", False)
$oDict.Add("BS_VCENTER", False)
$oDict.Add("BS_TOP", False)
$oDict.Add("BS_DEFPUSHBUTTON", False)
$oDict.Add("BS_MULTILINE", False)
$oDict.Add("BS_ICON", False)
$oDict.Add("BS_BITMAP", False)
$oDict.Add("BS_FLAT", False)
$oDict.Add("BS_NOTIFY", False)
Return $oDict
EndFunc
Func _Styles_Checkbox()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_CHECKBOX", False)
$oDict.Add("BS_3STATE", False)
$oDict.Add("BS_AUTO3STATE", False)
$oDict.Add("BS_AUTOCHECKBOX", False)
$oDict.Add("BS_CHECKBOX", False)
$oDict.Add("BS_LEFT", False)
$oDict.Add("BS_PUSHLIKE", False)
$oDict.Add("BS_RIGHT", False)
$oDict.Add("BS_RIGHTBUTTON", False)
$oDict.Add("BS_GROUPBOX", False)
$oDict.Add("BS_AUTORADIOBUTTON", False)
Return $oDict
EndFunc
Func _Styles_Radio()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_RADIO", False)
$oDict.Add("BS_BOTTOM", False)
$oDict.Add("BS_CENTER", False)
$oDict.Add("BS_DEFPUSHBUTTON", False)
$oDict.Add("BS_MULTILINE", False)
$oDict.Add("BS_TOP", False)
$oDict.Add("BS_VCENTER", False)
$oDict.Add("BS_ICON", False)
$oDict.Add("BS_BITMAP", False)
$oDict.Add("BS_FLAT", False)
$oDict.Add("BS_NOTIFY", False)
Return $oDict
EndFunc
Func _Styles_Edit()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_EDIT", False)
$oDict.Add("ES_AUTOHSCROLL", False)
$oDict.Add("ES_AUTOVSCROLL", False)
$oDict.Add("ES_CENTER", False)
$oDict.Add("ES_LOWERCASE", False)
$oDict.Add("ES_NOHIDESEL", False)
$oDict.Add("ES_NUMBER", False)
$oDict.Add("ES_OEMCONVERT", False)
$oDict.Add("ES_MULTILINE", False)
$oDict.Add("ES_PASSWORD", False)
$oDict.Add("ES_READONLY", False)
$oDict.Add("ES_RIGHT", False)
$oDict.Add("ES_UPPERCASE", False)
$oDict.Add("ES_WANTRETURN", False)
Return $oDict
EndFunc
Func _Styles_Input()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("ES_AUTOHSCROLL", False)
$oDict.Add("ES_AUTOVSCROLL", False)
$oDict.Add("ES_CENTER", False)
$oDict.Add("ES_LOWERCASE", False)
$oDict.Add("ES_NOHIDESEL", False)
$oDict.Add("ES_NUMBER", False)
$oDict.Add("ES_OEMCONVERT", False)
$oDict.Add("ES_MULTILINE", False)
$oDict.Add("ES_PASSWORD", False)
$oDict.Add("ES_READONLY", False)
$oDict.Add("ES_RIGHT", False)
$oDict.Add("ES_UPPERCASE", False)
$oDict.Add("ES_WANTRETURN", False)
Return $oDict
EndFunc
Func _Styles_Label()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_LABEL", False)
$oDict.Add("SS_BLACKFRAME", False)
$oDict.Add("SS_BLACKRECT", False)
$oDict.Add("SS_CENTER", False)
$oDict.Add("SS_CENTERIMAGE", False)
$oDict.Add("SS_ETCHEDFRAME", False)
$oDict.Add("SS_ETCHEDHORZ", False)
$oDict.Add("SS_ETCHEDVERT", False)
$oDict.Add("SS_GRAYFRAME", False)
$oDict.Add("SS_GRAYRECT", False)
$oDict.Add("SS_LEFT", False)
$oDict.Add("SS_LEFTNOWORDWRAP", False)
$oDict.Add("SS_NOPREFIX", False)
$oDict.Add("SS_NOTIFY", False)
$oDict.Add("SS_RIGHT", False)
$oDict.Add("SS_RIGHTJUST", False)
$oDict.Add("SS_SIMPLE", False)
$oDict.Add("SS_SUNKEN", False)
$oDict.Add("SS_WHITEFRAME", False)
$oDict.Add("SS_WHITERECT", False)
Return $oDict
EndFunc
Func _Styles_UpDown()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("UDS_ALIGNLEFT", False)
$oDict.Add("UDS_ALIGNRIGHT", False)
$oDict.Add("UDS_ARROWKEYS", False)
$oDict.Add("UDS_HORZ", False)
$oDict.Add("UDS_NOTHOUSANDS", False)
$oDict.Add("UDS_WRAP", False)
Return $oDict
EndFunc
Func _Styles_List()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_LIST", False)
$oDict.Add("LBS_DISABLENOSCROLL", False)
$oDict.Add("LBS_NOINTEGRALHEIGHT", False)
$oDict.Add("LBS_NOSEL", False)
$oDict.Add("LBS_NOTIFY", False)
$oDict.Add("LBS_SORT", False)
$oDict.Add("LBS_STANDARD", False)
$oDict.Add("LBS_USETABSTOPS", False)
Return $oDict
EndFunc
Func _Styles_Combo()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_COMBO", False)
$oDict.Add("CBS_AUTOHSCROLL", False)
$oDict.Add("CBS_DISABLENOSCROLL", False)
$oDict.Add("CBS_DROPDOWN", False)
$oDict.Add("CBS_DROPDOWNLIST", False)
$oDict.Add("CBS_LOWERCASE", False)
$oDict.Add("CBS_NOINTEGRALHEIGHT", False)
$oDict.Add("CBS_OEMCONVERT", False)
$oDict.Add("CBS_SIMPLE", False)
$oDict.Add("CBS_SORT", False)
$oDict.Add("CBS_UPPERCASE", False)
Return $oDict
EndFunc
Func _Styles_Date()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_DATE", False)
$oDict.Add("DTS_UPDOWN", False)
$oDict.Add("DTS_SHOWNONE", False)
$oDict.Add("DTS_LONGDATEFORMAT", False)
$oDict.Add("DTS_TIMEFORMAT", False)
$oDict.Add("DTS_RIGHTALIGN", False)
$oDict.Add("DTS_SHORTDATEFORMAT", False)
Return $oDict
EndFunc
Func _Styles_TreeView()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_TREEVIEW", False)
$oDict.Add("TVS_HASBUTTONS", False)
$oDict.Add("TVS_HASLINES", False)
$oDict.Add("TVS_LINESATROOT", False)
$oDict.Add("TVS_DISABLEDRAGDROP", False)
$oDict.Add("TVS_SHOWSELALWAYS", False)
$oDict.Add("TVS_RTLREADING", False)
$oDict.Add("TVS_NOTOOLTIPS", False)
$oDict.Add("TVS_CHECKBOXES", False)
$oDict.Add("TVS_TRACKSELECT", False)
$oDict.Add("TVS_SINGLEEXPAND", False)
$oDict.Add("TVS_FULLROWSELECT", False)
$oDict.Add("TVS_NOSCROLL", False)
$oDict.Add("TVS_NONEVENHEIGHT", False)
Return $oDict
EndFunc
Func _Styles_Progress()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_PROGRESS", False)
$oDict.Add("PBS_MARQUEE", False)
$oDict.Add("PBS_SMOOTH", False)
$oDict.Add("PBS_SMOOTHREVERSE", False)
$oDict.Add("PBS_VERTICAL", False)
Return $oDict
EndFunc
Func _Styles_Avi()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_AVI", False)
$oDict.Add("ACS_AUTOPLAY", False)
$oDict.Add("ACS_CENTER", False)
$oDict.Add("ACS_TRANSPARENT", False)
$oDict.Add("ACS_NONTRANSPARENT", False)
Return $oDict
EndFunc
Func _Styles_Icon()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_ICON", False)
$oDict.Add("SS_BLACKFRAME", False)
$oDict.Add("SS_BLACKRECT", False)
$oDict.Add("SS_CENTER", False)
$oDict.Add("SS_CENTERIMAGE", False)
$oDict.Add("SS_ETCHEDFRAME", False)
$oDict.Add("SS_ETCHEDHORZ", False)
$oDict.Add("SS_ETCHEDVERT", False)
$oDict.Add("SS_GRAYFRAME", False)
$oDict.Add("SS_GRAYRECT", False)
$oDict.Add("SS_LEFT", False)
$oDict.Add("SS_LEFTNOWORDWRAP", False)
$oDict.Add("SS_NOPREFIX", False)
$oDict.Add("SS_NOTIFY", False)
$oDict.Add("SS_RIGHT", False)
$oDict.Add("SS_RIGHTJUST", False)
$oDict.Add("SS_SIMPLE", False)
$oDict.Add("SS_SUNKEN", False)
$oDict.Add("SS_WHITEFRAME", False)
$oDict.Add("SS_WHITERECT", False)
Return $oDict
EndFunc
Func _Styles_Pic()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_PIC", False)
$oDict.Add("SS_BLACKFRAME", False)
$oDict.Add("SS_BLACKRECT", False)
$oDict.Add("SS_CENTER", False)
$oDict.Add("SS_CENTERIMAGE", False)
$oDict.Add("SS_ETCHEDFRAME", False)
$oDict.Add("SS_ETCHEDHORZ", False)
$oDict.Add("SS_ETCHEDVERT", False)
$oDict.Add("SS_GRAYFRAME", False)
$oDict.Add("SS_GRAYRECT", False)
$oDict.Add("SS_LEFT", False)
$oDict.Add("SS_LEFTNOWORDWRAP", False)
$oDict.Add("SS_NOPREFIX", False)
$oDict.Add("SS_NOTIFY", False)
$oDict.Add("SS_RIGHT", False)
$oDict.Add("SS_RIGHTJUST", False)
$oDict.Add("SS_SIMPLE", False)
$oDict.Add("SS_SUNKEN", False)
$oDict.Add("SS_WHITEFRAME", False)
$oDict.Add("SS_WHITERECT", False)
Return $oDict
EndFunc
Func _Styles_Slider()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_SLIDER", False)
$oDict.Add("TBS_AUTOTICKS", False)
$oDict.Add("TBS_BOTH", False)
$oDict.Add("TBS_BOTTOM", False)
$oDict.Add("TBS_HORZ", False)
$oDict.Add("TBS_VERT", False)
$oDict.Add("TBS_NOTHUMB", False)
$oDict.Add("TBS_NOTICKS", False)
$oDict.Add("TBS_LEFT", False)
$oDict.Add("TBS_RIGHT", False)
$oDict.Add("TBS_TOP", False)
Return $oDict
EndFunc
Func _Styles_IP()
Local $oDict = ObjCreate("Scripting.Dictionary")
Return $oDict
EndFunc
Func _Styles_ListView()
Local $oDict = ObjCreate("Scripting.Dictionary")
$oDict.Add("GUI_SS_DEFAULT_LISTVIEW", False)
$oDict.Add("LVS_ICON", False)
$oDict.Add("LVS_REPORT", False)
$oDict.Add("LVS_SMALLICON", False)
$oDict.Add("LVS_LIST", False)
$oDict.Add("LVS_EDITLABELS", False)
$oDict.Add("LVS_NOCOLUMNHEADER", False)
$oDict.Add("LVS_NOSORTHEADER", False)
$oDict.Add("LVS_SINGLESEL", False)
$oDict.Add("LVS_SHOWSELALWAYS", False)
$oDict.Add("LVS_SORTASCENDING", False)
$oDict.Add("LVS_SORTDESCENDING", False)
$oDict.Add("LVS_NOLABELWRAP", False)
Return $oDict
EndFunc
Func _objAction()
Local $oObject = _AutoItObject_Create()
Local $aTemp[0]
_AutoItObject_AddProperty($oObject, "action", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oObject, "ctrls", $ELSCOPE_PUBLIC, $aTemp)
_AutoItObject_AddProperty($oObject, "parameters", $ELSCOPE_PUBLIC, $aTemp)
Return $oObject
EndFunc
Func _objProperties()
Local $oObject = _AutoItObject_Create()
_AutoItObject_AddProperty($oObject, "properties", $ELSCOPE_PUBLIC, _objPropertiesProps())
_AutoItObject_AddProperty($oObject, "styles", $ELSCOPE_PUBLIC, ObjCreate("Scripting.Dictionary"))
Return $oObject
EndFunc
Func _objPropertiesProps()
Local $oObject = _AutoItObject_Create()
_AutoItObject_AddProperty($oObject, "Hwnd", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "Title", $ELSCOPE_PUBLIC, _objProperty("Title"))
_AutoItObject_AddProperty($oObject, "Text", $ELSCOPE_PUBLIC, _objProperty("Text"))
_AutoItObject_AddProperty($oObject, "Name", $ELSCOPE_PUBLIC, _objProperty("Name"))
_AutoItObject_AddProperty($oObject, "Left", $ELSCOPE_PUBLIC, _objProperty("Left"))
_AutoItObject_AddProperty($oObject, "Top", $ELSCOPE_PUBLIC, _objProperty("Top"))
_AutoItObject_AddProperty($oObject, "Width", $ELSCOPE_PUBLIC, _objProperty("Width"))
_AutoItObject_AddProperty($oObject, "Height", $ELSCOPE_PUBLIC, _objProperty("Height"))
_AutoItObject_AddProperty($oObject, "Color", $ELSCOPE_PUBLIC, _objProperty("Color"))
_AutoItObject_AddProperty($oObject, "FontName", $ELSCOPE_PUBLIC, _objProperty("FontName"))
_AutoItObject_AddProperty($oObject, "FontSize", $ELSCOPE_PUBLIC, _objProperty("FontSize"))
_AutoItObject_AddProperty($oObject, "FontWeight", $ELSCOPE_PUBLIC, _objProperty("FontWeight"))
_AutoItObject_AddProperty($oObject, "Background", $ELSCOPE_PUBLIC, _objProperty("Background"))
_AutoItObject_AddProperty($oObject, "Global", $ELSCOPE_PUBLIC, _objProperty("Global", "Checkbox"))
_AutoItObject_AddProperty($oObject, "BorderColor", $ELSCOPE_PUBLIC, _objProperty("BorderColor"))
_AutoItObject_AddProperty($oObject, "BorderSize", $ELSCOPE_PUBLIC, _objProperty("BorderSize"))
_AutoItObject_AddProperty($oObject, "Items", $ELSCOPE_PUBLIC, _objProperty("Items"))
_AutoItObject_AddProperty($oObject, "Img", $ELSCOPE_PUBLIC, _objProperty("Img"))
Return $oObject
EndFunc
Func _objProperty($name, $type = "")
Local $oSelf = _AutoItObject_Create()
_AutoItObject_AddProperty($oSelf, "name", $ELSCOPE_PUBLIC, $name)
_AutoItObject_AddProperty($oSelf, "type", $ELSCOPE_PUBLIC, $type)
_AutoItObject_AddProperty($oSelf, "Hwnd", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddMethod($oSelf, "value", "_objProperty_value")
Return $oSelf
EndFunc
Func _objProperty_value($oSelf, $vNewValue = "")
If @NumParams = 2 Then
Switch $oSelf.type
Case "Checkbox"
Switch $vNewValue
Case $GUI_CHECKED
GUICtrlSetState($oSelf.Hwnd, $GUI_CHECKED)
Case $GUI_UNCHECKED
GUICtrlSetState($oSelf.Hwnd, $GUI_UNCHECKED)
Case Else
GUICtrlSetState($oSelf.Hwnd, $GUI_INDETERMINATE)
EndSwitch
Case Else
GUICtrlSetData($oSelf.Hwnd, $vNewValue)
EndSwitch
Else
Switch $oSelf.type
Case "Checkbox"
Return GUICtrlRead($oSelf.Hwnd)
Case Else
Return GUICtrlRead($oSelf.Hwnd)
EndSwitch
EndIf
EndFunc
Func _create_ctrl($oCtrl = 0, $bUseName = False, $startX = -1, $startY = -1, $hParent = -1, $bDuplicate = False)
If $oCtrls.CurrentType = "Tab" Then
If $oCtrls.getTypeCount("Tab") > 0 Then
Return 0
EndIf
EndIf
Local $oNewControl
Local $isPaste = False
Local $cursor_pos = _mouse_snap_pos()
Switch IsObj($oCtrl)
Case True
$isPaste = True
$oNewControl = $oCtrl
Case False
If $startX <> -1 Then $cursor_pos[0] = $startX
If $startY <> -1 Then $cursor_pos[1] = $startY
If $oOptions.pasteAtMouse Or $oCtrls.mode = $mode_drawing Then
If _cursor_out_of_bounds($cursor_pos) Then
ContinueCase
EndIf
Else
$cursor_pos[0] = 0
$cursor_pos[1] = 0
EndIf
$oNewControl = $oCtrls.createNew()
$oNewControl.HwndCount = 1
$oNewControl.Type = $oCtrls.CurrentType
$oNewControl.Left = $cursor_pos[0]
$oNewControl.Top = $cursor_pos[1]
$oNewControl.Global = $GUI_CHECKED
$oNewControl.FontSize = 8.5
EndSwitch
GUICtrlSetState($menu_wipe, $GUI_ENABLE)
Local Const $count = $oCtrls.count
Local $name
Local $found = True
Local $j = 0
While $found
$found = False
$j += 1
$name = $oNewControl.Type & "_" & $j
If $count >= 1 Then
For $oCtrl In $oCtrls.ctrls.Items()
If $oCtrl.Name = $name Then
$found = True
ExitLoop
EndIf
Next
Else
$found = False
EndIf
WEnd
If Not $bUseName Then
$oNewControl.Name = $name
EndIf
Switch $oNewControl.Type
Case "Updown"
$oNewControl.Text = "0"
Case Else
If Not $isPaste Then
$oNewControl.Text = $oNewControl.Type & " " & $j
EndIf
EndSwitch
$oNewControl.CtrlParent = 0
If $isPaste Then
For $oThisCtrl In $oSelected.ctrls.Items()
Switch $oThisCtrl.Type
Case "Tab"
$hParent = $oThisCtrl.Hwnd
ExitLoop
Case "Group"
$hParent = $oThisCtrl.Hwnd
ExitLoop
EndSwitch
Next
EndIf
Local $tabChild = False
If $hParent <> -1 Then
For $oThisCtrl In $oCtrls.ctrls.Items()
If $oThisCtrl.Hwnd = $hParent Then
Switch $oThisCtrl.Type
Case "Tab"
Local $iTabFocus = _GUICtrlTab_GetCurSel($oThisCtrl.Hwnd)
If $iTabFocus >= 0 Then
Local $tabID = $oThisCtrl.Tabs.at($iTabFocus)
GUISwitch($hGUI, $tabID)
$tabChild = True
EndIf
ExitLoop
EndSwitch
EndIf
Next
EndIf
Switch $oNewControl.Type
Case "Button"
$oNewControl.Hwnd = GUICtrlCreateButton($oNewControl.Text, $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
$oCtrls.add($oNewControl, $hParent)
$bStatusNewMessage = True
_GUICtrlStatusBar_SetText($hStatusbar, "new button")
Case "Group"
$oNewControl.Hwnd = GUICtrlCreateGroup($oNewControl.Text, $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
$oCtrls.add($oNewControl, $hParent)
Case "Checkbox"
$oNewControl.Height = 20
$oNewControl.Hwnd = GUICtrlCreateCheckbox($oNewControl.Text, $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
If $isPaste Then
If $oNewControl.Background <> -1 Then
GUICtrlSetBkColor($oNewControl.Hwnd, $oNewControl.Background)
EndIf
EndIf
$oCtrls.add($oNewControl, $hParent)
Case "Radio"
$oNewControl.Height = 20
$oNewControl.Hwnd = GUICtrlCreateRadio($oNewControl.Text, $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
If $isPaste Then
If $oNewControl.Background <> -1 Then
GUICtrlSetBkColor($oNewControl.Hwnd, $oNewControl.Background)
EndIf
EndIf
$oCtrls.add($oNewControl, $hParent)
Case "Edit"
$oNewControl.Hwnd = GUICtrlCreateEdit('', $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
$oCtrls.add($oNewControl, $hParent)
GUICtrlSetResizing($oNewControl.Hwnd, $GUI_DOCKALL)
Case "Input"
$oNewControl.Hwnd = GUICtrlCreateInput($oNewControl.Text, $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
$oCtrls.add($oNewControl, $hParent)
Case "Label"
$oNewControl.Hwnd = GUICtrlCreateLabel($oNewControl.Text, $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
If $isPaste Then
If $oNewControl.Background <> -1 Then
GUICtrlSetBkColor($oNewControl.Hwnd, $oNewControl.Background)
EndIf
If $oNewControl.Color <> -1 Then
GUICtrlSetColor($oNewControl.Hwnd, $oNewControl.Color)
EndIf
EndIf
$oCtrls.add($oNewControl, $hParent)
Case "List"
$oNewControl.Hwnd = GUICtrlCreateList($oNewControl.Text, $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
$oCtrls.add($oNewControl, $hParent)
Case "Combo"
$oNewControl.Height = 20
$oNewControl.Hwnd = GUICtrlCreateCombo('', $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
$oCtrls.add($oNewControl, $hParent)
Case "Date"
$oNewControl.Hwnd = GUICtrlCreateDate('', $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
$oCtrls.add($oNewControl, $hParent)
GUICtrlSetResizing($oNewControl.Hwnd, $GUI_DOCKALL)
Case "Slider"
$oNewControl.Hwnd = _GuiCtrlCreateSlider($oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height, $oNewControl.Height)
$oCtrls.add($oNewControl, $hParent)
GUICtrlSetResizing($oNewControl.Hwnd, $GUI_DOCKALL)
Case "Tab"
$oNewControl.Hwnd = GUICtrlCreateTab($oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
GUICtrlSetOnEvent(-1, "_onCtrlTabSwitch")
$oCtrls.add($oNewControl, $hParent)
GUISwitch($hGUI)
_hide_grid($background)
If BitAND(GUICtrlRead($menu_show_grid), $GUI_CHECKED) = $GUI_CHECKED Then
_show_grid($background, $oMain.Width, $oMain.Height)
EndIf
Case "TreeView"
$oNewControl.Hwnd = GUICtrlCreateTreeView($oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
GUICtrlCreateTreeViewItem($oNewControl.Text, $oNewControl.Hwnd)
$oCtrls.add($oNewControl, $hParent)
Case "Updown"
$oNewControl.HwndCount = 2
$oNewControl.Height = 20
$oNewControl.Hwnd1 = GUICtrlCreateInput($oNewControl.Text, $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
$oNewControl.Hwnd = $oNewControl.Hwnd1
$oNewControl.Hwnd2 = GUICtrlCreateUpdown($oNewControl.Hwnd1)
$oCtrls.add($oNewControl, $hParent)
Case "Progress"
$oNewControl.Hwnd = GUICtrlCreateProgress($oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
GUICtrlSetData($oNewControl.Hwnd, 100)
$oCtrls.add($oNewControl, $hParent)
GUICtrlSetResizing($oNewControl.Hwnd, $GUI_DOCKALL)
Case "Pic"
If $oNewControl.Img = "" Then
$oNewControl.Img = $samplebmp
EndIf
$oNewControl.Hwnd = GUICtrlCreatePic($oNewControl.Img, $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
$oCtrls.add($oNewControl, $hParent)
GUICtrlSetResizing($oNewControl.Hwnd, $GUI_DOCKALL)
Case "Avi"
If $oNewControl.Img = "" Then
$oNewControl.Img = $sampleavi
EndIf
$oNewControl.Hwnd = GUICtrlCreateAvi($oNewControl.Img, 0, $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
$oCtrls.add($oNewControl, $hParent)
GUICtrlSetResizing($oNewControl.Hwnd, $GUI_DOCKALL)
Case "Icon"
If $oNewControl.Img = "" Then
$oNewControl.Img = $sampleicon
EndIf
$oNewControl.Hwnd = GUICtrlCreateIcon($oNewControl.Img, -1, $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
$oCtrls.add($oNewControl, $hParent)
Case "Menu"
$oNewControl.Hwnd = GUICtrlCreateMenu("Menu 1")
$oNewControl.Left = -1
$oNewControl.Top = -1
$oNewControl.Width = 0
$oNewControl.Height = 0
$oCtrls.add($oNewControl, $hParent)
Local $cmenu = GUICtrlCreateContextMenu($oNewControl.Hwnd)
GUICtrlCreateMenuItem("test Item", $cmenu)
Local $aWinPos = WinGetClientSize($hGUI)
$oMain.Height = $aWinPos[1]
Case "IP"
$oNewControl.Text = ""
$oNewControl.Hwnd = _GUICtrlIpAddress_Create($hGUI, $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
$oCtrls.add($oNewControl)
_GUICtrlIpAddress_Set($oNewControl.Hwnd, $oNewControl.Text)
Case "ListView"
$oNewControl.Hwnd = GUICtrlCreateListView($oNewControl.Text, $oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
$oCtrls.add($oNewControl, $hParent)
Case "Rect"
$oNewControl.Hwnd = GUICtrlCreateGraphic($oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
GUICtrlSetGraphic($oNewControl.Hwnd, $GUI_GR_RECT, 0, 0, $oNewControl.Width, $oNewControl.Height)
GUICtrlSetGraphic($oNewControl.Hwnd, $GUI_GR_REFRESH)
_updateGraphic($oNewControl)
$oCtrls.add($oNewControl, $hParent)
Case "Ellipse"
$oNewControl.Hwnd = GUICtrlCreateGraphic($oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
GUICtrlSetGraphic($oNewControl.Hwnd, $GUI_GR_ELLIPSE, 0, 0, $oNewControl.Width, $oNewControl.Height)
GUICtrlSetGraphic($oNewControl.Hwnd, $GUI_GR_REFRESH)
_updateGraphic($oNewControl)
$oCtrls.add($oNewControl, $hParent)
Case "Line"
$oNewControl.Hwnd = GUICtrlCreateGraphic($oNewControl.Left, $oNewControl.Top, $oNewControl.Width, $oNewControl.Height)
GUICtrlSetGraphic($oNewControl.Hwnd, $GUI_GR_MOVE, $oNewControl.Coord1[0], $oNewControl.Coord1[1])
GUICtrlSetGraphic($oNewControl.Hwnd, $GUI_GR_LINE, $oNewControl.Coord2[0], $oNewControl.Coord2[1])
GUICtrlSetGraphic($oNewControl.Hwnd, $GUI_GR_REFRESH)
_updateGraphic($oNewControl)
$oCtrls.add($oNewControl, $hParent)
EndSwitch
$oMain.hasChanged = True
If $tabChild Then
GUICtrlCreateTabItem('')
GUISwitch($hGUI)
EndIf
Switch IsObj($oCtrl)
Case True
Switch $oNewControl.Type
Case "Rect", "Ellipse", "Line"
Case Else
GUICtrlSetData($oNewControl.Hwnd, $oNewControl.Text)
EndSwitch
Case False
$oNewControl.Text = $oNewControl.Text
EndSwitch
GUICtrlSetResizing($oNewControl.Hwnd, $GUI_DOCKALL)
GuiCtrlSetOnTop($oNewControl.Hwnd)
Return $oNewControl
EndFunc
Func _GuiCtrlCreateSlider(Const $left, Const $top, Const $width, Const $height, $style)
Local Const $ref = GUICtrlCreateSlider($left, $top, $width, $height)
If $style <= 0 Then
$style = 0x50020001
EndIf
GUICtrlSetStyle($ref, BitOR($style, 0x040))
Local $size = $height - 20
If $width - 20 < $size Then
$size = $width - 20
EndIf
GUICtrlSendMsg($ref, 27 + 0x0400, $size, 0)
Return $ref
EndFunc
Func _onNewTab()
_new_tab()
EndFunc
Func _new_tab($loadGUI = False)
Local $oCtrl
For $oCtrl In $oCtrls.ctrls.Items()
If $oCtrl.Type = "Tab" Then
ExitLoop
EndIf
Next
$oCtrl.TabCount = $oCtrl.TabCount + 1
Local $tab = _objCtrl($oCtrls)
$tab.Hwnd = GUICtrlCreateTabItem("Tab" & $oCtrl.TabCount)
GUICtrlCreateTabItem("")
$tab.Text = "Tab" & $oCtrl.TabCount
$tab.Name = "TabItem_" & $oCtrl.TabCount
$tab.Type = "TabItem"
$oCtrls.add($tab)
$oCtrl.Tabs.add($tab.Hwnd)
_GUICtrlTab_SetCurSel($oCtrl.Hwnd, $oCtrl.TabCount - 1)
If Not $loadGUI Then
_refreshGenerateCode()
_formObjectExplorer_updateList()
EndIf
Return $oCtrl.TabCount
EndFunc
Func _onCtrlTabSwitch()
_tabClearInactiveSelection(@GUI_CtrlId)
EndFunc
Func _tabClearInactiveSelection($Hwnd)
Local $oCtrl = $oCtrls.get($Hwnd)
Local $oTab
Local $iTabFocus = _GUICtrlTab_GetCurSel($Hwnd)
Local $tabFocusID = $oCtrl.Tabs.at($iTabFocus)
For $hTab In $oCtrl.Tabs
If $hTab = $tabFocusID Then ContinueLoop
$oTab = $oCtrls.get($hTab)
For $oTabCtrl In $oTab.ctrls.Items()
_remove_from_selected($oTabCtrl)
Next
Next
GUISwitch($hGUI)
EndFunc
Func _onDeleteTab()
_delete_tab()
EndFunc
Func _delete_tab()
Local $oCtrl
For $oCtrl In $oCtrls.ctrls.Items()
If $oCtrl.Type = "Tab" Then
ExitLoop
EndIf
Next
Local $iTabFocus = _GUICtrlTab_GetCurSel($oCtrl.Hwnd)
If $iTabFocus >= 0 Then
$tabID = $oCtrl.Tabs.at($iTabFocus)
$oTabItem = $oCtrls.get($tabID)
For $oTabCtrl In $oTabItem.ctrls.Items()
_delete_ctrl($oTabCtrl)
Next
_GUICtrlTab_DeleteItem($oCtrl.Hwnd, $iTabFocus)
$oCtrls.ctrls.remove($oTabItem.Hwnd)
$oCtrl.Tabs.remove($iTabFocus)
$oCtrl.TabCount = $oCtrl.TabCount - 1
_GUICtrlTab_SetCurSel($oCtrl.Hwnd, 0)
Else
_delete_selected_controls()
EndIf
GUISwitch($hGUI)
_refreshGenerateCode()
_formObjectExplorer_updateList()
EndFunc
Func _updateIP($oCtrl)
Local $prevKey = $oCtrl.Hwnd
_GUICtrlIpAddress_Destroy(HWnd($oCtrl.Hwnd))
$oCtrl.Hwnd = _GUICtrlIpAddress_Create($hGUI, $oCtrl.Left, $oCtrl.Top, $oCtrl.Width, $oCtrl.Height)
_GUICtrlIpAddress_Set($oCtrl.Hwnd, $oCtrl.Text)
$oCtrl.parent.ctrls.Key($prevKey) = $oCtrl.Hwnd
EndFunc
Func _new_menuItem()
_new_menuItemCreate()
EndFunc
Func _new_menuItemCreate($oParent = 0, $loadGUI = False)
Local $oCtrl, $hSelected
If Not IsObj($oParent) Then
$hSelected = _getLvSelectedHwnd()
$oCtrl = $oCtrls.get($hSelected)
If Not IsObj($oCtrl) Then Return -1
Else
$oCtrl = $oParent
$hSelected = $oParent.Hwnd
EndIf
Local $newCount = $oCtrl.MenuItems.count + 1
Local $MenuItem = _objCtrl($oCtrl)
$MenuItem.Hwnd = GUICtrlCreateMenuItem("MenuItem" & $newCount, $hSelected)
$MenuItem.Text = "MenuItem" & $newCount
$MenuItem.Name = "MenuItem_" & $newCount
$oCtrl.MenuItems.add($MenuItem)
_GUICtrlTab_SetCurSel($oCtrl.Hwnd, $newCount - 1)
If Not $loadGUI Then
_refreshGenerateCode()
_formObjectExplorer_updateList()
EndIf
EndFunc
Func _delete_menuItem()
Local $hSelected = _getLvSelectedHwnd()
Local $oCtrl = $oCtrls.get($hSelected)
If Not IsObj($oCtrl) Then Return -1
Local $oParent
For $oCtrl In $oCtrls.ctrls.Items()
If $oCtrl.Type = "Menu" Then
For $oMenuItem In $oCtrl.MenuItems
If $oMenuItem.Hwnd = $hSelected Then
$oParent = $oCtrl
ExitLoop 2
EndIf
Next
EndIf
Next
If Not IsObj($oParent) Then Return -1
Local $i = 0
For $oMenuItem In $oParent.MenuItems
If $oMenuItem.Hwnd = $hSelected Then
$oParent.MenuItems.remove($i)
_GUICtrlTab_SetCurSel($oParent.Hwnd, 0)
ExitLoop
EndIf
$i += 1
Next
GUICtrlDelete($hSelected)
_refreshGenerateCode()
_formObjectExplorer_updateList()
EndFunc
Func _control_type()
$oCtrls.CurrentType = GUICtrlRead(@GUI_CtrlId, 1)
$oCtrls.mode = $mode_draw
EndFunc
Func _delete_ctrl(Const $oCtrl, $clear = False)
If $oCtrl.Locked And Not $clear Then Return
GUISwitch($hGUI)
Switch $oCtrl.Type
Case "Updown"
GUICtrlDelete($oCtrl.Hwnd1)
GUICtrlDelete($oCtrl.Hwnd2)
Case "IP"
_GUICtrlIpAddress_Destroy(HWnd($oCtrl.Hwnd))
Case "Tab"
For $hTabItem In $oCtrl.Tabs
_delete_tab()
Next
GUICtrlDelete($oCtrl.Hwnd)
Case "Group"
For $oThisCtrl In $oCtrl.ctrls.Items()
_delete_ctrl($oThisCtrl)
Next
GUICtrlDelete($oCtrl.Hwnd)
Case Else
GUICtrlDelete($oCtrl.Hwnd)
EndSwitch
GUISwitch($hGUI)
$oCtrls.remove($oCtrl.Hwnd)
$oSelected.remove($oCtrl.Hwnd)
$oMain.hasChanged = True
EndFunc
Func _vector_magnitude(Const $x1, Const $x2, Const $y1, Const $y2)
Return Sqrt((($x1 - $y1) ^ 2) + (($x2 - $y2) ^ 2))
EndFunc
Func _left_top_union_rect($oObjCtrls = 0)
If Not IsObj($oObjCtrls) Then
$oObjCtrls = $oSelected
EndIf
Local $sel_ctrl
Local $smallest = _objCreateRect()
$smallest.Left = $oObjCtrls.getFirst().Left
$smallest.Top = $oObjCtrls.getFirst().Top
For $oCtrl In $oObjCtrls.ctrls.Items()
If Int($oCtrl.Left) < Int($smallest.Left) Then
$smallest.Left = $oCtrl.Left
EndIf
If Int($oCtrl.Top) < Int($smallest.Top) Then
$smallest.Top = $oCtrl.Top
EndIf
Next
For $oCtrl In $oObjCtrls.ctrls.Items()
If Int(($oCtrl.Left - $smallest.Left) + $oCtrl.Width) > Int($smallest.Width) Then
$smallest.Width = Int(($oCtrl.Left - $smallest.Left) + $oCtrl.Width)
EndIf
If Int(($oCtrl.Top - $smallest.Top) + $oCtrl.Height) > Int($smallest.Height) Then
$smallest.Height = Int(($oCtrl.Top - $smallest.Top) + $oCtrl.Height)
EndIf
Next
Return $smallest
EndFunc
Func _copy_selected()
Local Const $sel_count = $oSelected.count
GUICtrlSetState($oMain.DefaultCursor, $GUI_CHECKED)
$oCtrls.mode = $mode_default
Switch $sel_count >= 1
Case True
$oClipboard.removeAll()
Local Const $smallest = _left_top_union_rect()
Local Const $selected = _selected_to_array($sel_count, $smallest)
_selected_to_clipboard($selected, $sel_count)
EndSwitch
EndFunc
Func _cut_selected()
_copy_selected()
_delete_selected_controls()
EndFunc
Func _selected_to_array(Const $sel_count, Const $smallest)
Local $selected[$sel_count][2]
Local $i = 0
For $oCtrl In $oSelected.ctrls.Items()
$selected[$i][0] = $oCtrl
$selected[$i][1] = _vector_magnitude($smallest.Left, $smallest.Top, $oCtrl.Left, $oCtrl.Top)
$i += 1
Next
Return $selected
EndFunc
Func _selected_to_clipboard(Const $selected, Const $sel_count)
$oClipboard.removeAll()
Local $i = 0
For $oCtrl In $oSelected.ctrls.Items()
$oClipboard.add($oSelected.getCopy($oCtrl.Hwnd))
$i += 1
Next
EndFunc
Func _PasteSelected($bDuplicate = False, $bAtMouse = False)
GUICtrlSetState($oMain.DefaultCursor, $GUI_CHECKED)
Local Const $clipboard_count = $oClipboard.count
Local $aNewCtrls[$clipboard_count]
Local $topLeftRect = _left_top_union_rect($oClipboard)
_SendMessage($hGUI, $WM_SETREDRAW, False)
Switch $clipboard_count >= 1
Case True
Local $oNewCtrl, $i = 0
Local $iPosX = -1, $iPosY = -1
For $oCtrl In $oClipboard.ctrls.Items()
$oNewCtrl = $oClipboard.getCopy($oCtrl.Hwnd)
If Not $oOptions.pasteAtMouse And Not $bDuplicate Then
$oNewCtrl.Left = 0
$oNewCtrl.Top = 0
ElseIf $bDuplicate Then
$oNewCtrl.Left += 20
$oNewCtrl.Top += 20
ElseIf $bAtMouse Then
$oNewCtrl.Left = $oMouse.StartX
$oNewCtrl.Top = $oMouse.StartY
Else
Local $mouse_pos = _mouse_snap_pos()
$oNewCtrl.Left = ($mouse_pos[0] - $topLeftRect.Left) + $oNewCtrl.Left
$oNewCtrl.Top = ($mouse_pos[1] - $topLeftRect.Height) + ($oNewCtrl.Top - $topLeftRect.Top)
EndIf
$aNewCtrls[$i] = _create_ctrl($oNewCtrl, 0, $iPosX, $iPosY, -1, $bDuplicate)
$i += 1
Next
$i = 0
For $oCtrl In $aNewCtrls
If $i = 0 Then
_add_to_selected($aNewCtrls[$i], True, True)
Else
_add_to_selected($aNewCtrls[$i], False, False)
EndIf
$i += 1
Next
EndSwitch
Local $oAction = _objAction()
$oAction.action = $action_pasteCtrl
$oAction.ctrls = $aNewCtrls
_updateActionStacks($oAction)
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_refreshGenerateCode()
_formObjectExplorer_updateList()
EndFunc
Func _DuplicateSelected()
If $oSelected.count < 1 Then Return
_copy_selected()
_PasteSelected(True)
EndFunc
Func _display_selected_tooltip()
Local $tooltip
Local Const $count = $oSelected.count
If $oSelected.count < 5 Then
For $oCtrl In $oSelected.ctrls.Items()
$tooltip &= $oCtrl.Name & ": X:" & $oCtrl.Left & ", Y:" & $oCtrl.Top & ", W:" & $oCtrl.Width & ", H:" & $oCtrl.Height & @CRLF
Next
ToolTip(StringTrimRight($tooltip, 2))
Else
ToolTip("")
EndIf
EndFunc
Func _control_intersection(Const $oCtrl, Const $oRect)
If $oCtrl.Type = "TabItem" Then Return False
Local $aMousePos = MouseGetPos()
Local $returnVal
If $aMousePos[0] < $oMouse.StartX Then
$returnVal = _CtrlCrossRect($oCtrl.Left, $oCtrl.Top, $oCtrl.Width, $oCtrl.Height, $oRect.Left, $oRect.Top, $oRect.Width, $oRect.Height)
Else
$returnVal = _CtrlInRect($oCtrl.Left, $oCtrl.Top, $oCtrl.Width, $oCtrl.Height, $oRect.Left, $oRect.Top, $oRect.Width, $oRect.Height)
EndIf
If $oCtrl.CtrlParent <> 0 Then
If $oCtrls.get($oCtrl.CtrlParent).Type = "TabItem" Then
Local $TabHwnd = $oCtrls.get($oCtrl.CtrlParent).CtrlParent
Local $iTabFocus = _GUICtrlTab_GetCurSel($TabHwnd)
If $iTabFocus >= 0 Then
Local $oTabCtrl = $oCtrls.get($TabHwnd)
Local $iTabFocusID = $oTabCtrl.Tabs.at($iTabFocus)
If $iTabFocusID <> $oCtrl.CtrlParent Then
Return False
EndIf
EndIf
EndIf
EndIf
Return $returnVal
EndFunc
Func _group_select(Const $oCtrl)
If $oCtrl.Type = "Group" Then
_select_control_group($oCtrl)
_set_current_mouse_pos()
$oCtrls.mode = $mode_init_move
Return True
EndIf
Return False
EndFunc
Func _select_control_group(Const $oGroup)
Local $oGroupRect = _objCreateRect()
$oGroupRect.Left = $oGroup.Left
$oGroupRect.Top = $oGroup.Top
$oGroupRect.Width = $oGroup.Width
$oGroupRect.Height = $oGroup.Height
Local Const $count = $oCtrls.count
For $oCtrl In $oCtrls.ctrls.Items()
If _control_intersection($oCtrl, $oGroupRect) Then
_add_to_selected($oCtrl, False)
EndIf
Next
EndFunc
Func _add_to_selected(Const $oCtrl, Const $overwrite = True, Const $updateProps = True)
If Not IsObj($oCtrl) Then
Return
EndIf
Switch $overwrite
Case True
_remove_all_from_selected()
Case False
Switch $oSelected.exists($oCtrl.Hwnd)
Case True
Return SetError(1, 0, False)
EndSwitch
EndSwitch
$oSelected.add($oCtrl)
If $updateProps Then
_showProperties($props_Ctrls)
_populate_control_properties_gui($oCtrl)
EndIf
$oCtrl.grippies.show()
Return True
EndFunc
Func _selectAll()
Local $first = True
_remove_all_from_selected()
_SendMessage($hGUI, $WM_SETREDRAW, False)
For $oCtrl In $oCtrls.ctrls.Items()
$oSelected.add($oCtrl)
$oCtrl.grippies.show()
Next
_showProperties($props_Ctrls)
_populate_control_properties_gui($oCtrl)
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
$oCtrls.mode = $mode_default
EndFunc
Func _add_remove_selected_control(Const $oRect)
For $oCtrl In $oCtrls.ctrls.Items()
Switch _control_intersection($oCtrl, $oRect)
Case True
Switch _add_to_selected($oCtrl, False, False)
Case True
_display_selected_tooltip()
EndSwitch
Case False
Switch _remove_from_selected($oCtrl, False)
Case True
Local $sel_count = $oSelected.count
Switch $sel_count >= 1
Case True
EndSwitch
_display_selected_tooltip()
EndSwitch
EndSwitch
Next
EndFunc
Func _remove_all_from_selected()
_SendMessage($hGUI, $WM_SETREDRAW, False)
$oSelected.removeAll()
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
Return True
EndFunc
Func _delete_selected_controls()
_deleteCtrls()
EndFunc
Func _deleteCtrls($aCtrlsIn = 0)
GUICtrlSetState($oMain.DefaultCursor, $GUI_CHECKED)
$oCtrls.mode = $mode_default
Local $undo
If IsArray($aCtrlsIn) Then
$undo = True
Else
$aCtrlsIn = $oSelected.ctrls.Items()
EndIf
Local $count = UBound($aCtrlsIn)
Switch $count >= 1
Case True
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $oAction = _objAction()
$oAction.action = $action_deleteCtrl
Local $aCtrls[UBound($aCtrlsIn)]
Local $i
For $oCtrl In $aCtrlsIn
If Not $undo Then
$aCtrls[$i] = $oSelected.getCopy($oCtrl.Hwnd)
EndIf
_delete_ctrl($oCtrl)
$i += 1
Next
_formObjectExplorer_updateList()
_recall_overlay()
_set_default_mode()
_refreshGenerateCode()
If $count > 0 Then
_populate_control_properties_gui($oSelected.getFirst())
_showProperties($props_Ctrls)
Else
_showProperties($props_Main)
EndIf
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
If Not $undo Then
$oAction.ctrls = $aCtrls
_updateActionStacks($oAction)
EndIf
Return True
Case False
_showProperties($props_Main)
EndSwitch
EndFunc
Func _remove_from_selected(Const $oCtrl, $updateProps = True)
If Not IsObj($oCtrl) Then
Return
EndIf
Switch $oSelected.exists($oCtrl.Hwnd)
Case False
Return SetError(1, 0, False)
EndSwitch
For $oThisCtrl In $oSelected.ctrls.Items()
Switch $oCtrl.Hwnd
Case $oThisCtrl.Hwnd
$oSelected.remove($oThisCtrl.Hwnd)
ExitLoop
EndSwitch
Next
$oCtrl.grippies.hide()
If $updateProps Then
If $oSelected.count > 0 Then
_showProperties($props_Ctrls)
Else
_showProperties($props_Main)
EndIf
EndIf
Return True
EndFunc
Func _change_ctrl_size_pos(ByRef $oCtrl, $left, $top, $width, $height, $tabChild = False)
If $oCtrl.Locked Then Return
Switch $oCtrl.Type
Case "Rect", "Ellipse", "Line"
Case Else
If $width < 1 Or $height < 1 Then
Return
EndIf
EndSwitch
If $left <> Default Then $oCtrl.Left = $left
If $top <> Default Then $oCtrl.Top = $top
If $width <> Default Then $oCtrl.Width = $width
If $height <> Default Then $oCtrl.Height = $height
Switch $oCtrl.Type
Case "Updown"
GUICtrlSetPos($oCtrl.Hwnd, $left, $top, $oCtrl.Width, $oCtrl.Height)
Case "IP"
_updateIP($oCtrl)
Case "Rect", "Ellipse", "Line"
_updateGraphic($oCtrl)
Case Else
GUICtrlSetPos($oCtrl.Hwnd, $left, $top, $width, $height)
If $oCtrl.Type = "Icon" Then
GUICtrlSetImage($oCtrl.Hwnd, $oCtrl.Img, -1)
EndIf
If $oCtrl.Type = "Pic" Then
GUICtrlSetImage($oCtrl.Hwnd, $oCtrl.Img, -1)
EndIf
EndSwitch
If Not $tabChild Then
$oCtrl.grippies.show()
EndIf
$oMain.hasChanged = True
EndFunc
Func _updateGraphic($oCtrl)
Local $prevKey = $oCtrl.Hwnd
GUICtrlDelete($oCtrl.Hwnd)
$oCtrl.Hwnd = GUICtrlCreateGraphic($oCtrl.left, $oCtrl.top, $oCtrl.Width, $oCtrl.Height)
If $oCtrl.BorderSize > 1 Then
GUICtrlSetGraphic($oCtrl.Hwnd, $GUI_GR_PENSIZE, $oCtrl.BorderSize)
EndIf
Switch $oCtrl.Type
Case "Rect", "Ellipse"
If $oCtrl.BorderColor <> -1 And $oCtrl.background <> -1 Then
GUICtrlSetGraphic($oCtrl.Hwnd, $GUI_GR_COLOR, $oCtrl.BorderColor, $oCtrl.background)
ElseIf $oCtrl.BorderColor = -1 And $oCtrl.background <> -1 Then
GUICtrlSetGraphic($oCtrl.Hwnd, $GUI_GR_COLOR, 0x000000, $oCtrl.background)
ElseIf $oCtrl.BorderColor <> -1 And $oCtrl.background = -1 Then
GUICtrlSetGraphic($oCtrl.Hwnd, $GUI_GR_COLOR, $oCtrl.BorderColor)
EndIf
Switch $oCtrl.Type
Case "Rect"
GUICtrlSetGraphic($oCtrl.Hwnd, $GUI_GR_RECT, 0, 0, $oCtrl.Width, $oCtrl.Height)
Case "Ellipse"
GUICtrlSetGraphic($oCtrl.Hwnd, $GUI_GR_ELLIPSE, 0, 0, $oCtrl.Width, $oCtrl.Height)
EndSwitch
Case "Line"
Local $aCoord1 = [$oCtrl.coord1[0], $oCtrl.coord1[1]]
Local $aCoord2 = [$oCtrl.coord2[0], $oCtrl.coord2[1]]
Switch $oCtrls.mode
Case $resize_nw
$aCoord2[0] = $oCtrl.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
EndIf
Case $resize_n
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
EndIf
Case $resize_w
$aCoord2[0] = $oCtrl.width
Case $resize_e
$aCoord2[0] = $oCtrl.width
Case $resize_s
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
EndIf
Case $resize_se
$aCoord2[0] = $oCtrl.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
EndIf
Case $resize_ne
$aCoord2[0] = $oCtrl.width
$aCoord2[0] = $oCtrl.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
EndIf
Case $resize_sw
$aCoord2[0] = $oCtrl.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
EndIf
Case Else
$aCoord2[0] = $oCtrl.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
EndIf
EndSwitch
GUICtrlSetGraphic($oCtrl.Hwnd, $GUI_GR_MOVE, $aCoord1[0], $aCoord1[1])
GUICtrlSetGraphic($oCtrl.Hwnd, $GUI_GR_PENSIZE, $oCtrl.BorderSize)
If $oCtrl.BorderColor <> -1 Then
GUICtrlSetGraphic($oCtrl.Hwnd, $GUI_GR_COLOR, $oCtrl.BorderColor)
EndIf
GUICtrlSetGraphic($oCtrl.Hwnd, $GUI_GR_LINE, $aCoord2[0], $aCoord2[1])
GUICtrlSetGraphic($oCtrl.Hwnd, $GUI_GR_REFRESH)
EndSwitch
GUICtrlSetGraphic($oCtrl.Hwnd, $GUI_GR_REFRESH)
$oCtrl.parent.ctrls.Key($prevKey) = $oCtrl.Hwnd
EndFunc
Func _moveTabCtrls($oCtrl, $delta_x, $delta_y, $width, $height)
If $oCtrl.Locked Then Return
Local $oTab, $left, $top
For $hTab In $oCtrl.Tabs
$oTab = $oCtrls.get($hTab)
For $oTabCtrl In $oTab.ctrls.Items()
If $oSelected.exists($oTabCtrl.Hwnd) Then ContinueLoop
If $delta_x = Default Then
$left = Default
Else
$left = $oTabCtrl.Left - $delta_x
EndIf
If $delta_y = Default Then
$top = Default
Else
$top = $oTabCtrl.Top - $delta_y
EndIf
_change_ctrl_size_pos($oTabCtrl, $left, $top, $width, $height, True)
Next
Next
GUISwitch($hGUI)
EndFunc
Func _moveGroupCtrls($oCtrl, $delta_x, $delta_y, $width, $height)
If $oCtrl.Locked Then Return
Local $left, $top
For $oThisCtrl In $oCtrl.ctrls.Items()
If $oSelected.exists($oThisCtrl.Hwnd) Then ContinueLoop
If $delta_x = Default Then
$left = Default
Else
$left = $oThisCtrl.Left - $delta_x
EndIf
If $delta_y = Default Then
$top = Default
Else
$top = $oThisCtrl.Top - $delta_y
EndIf
_change_ctrl_size_pos($oThisCtrl, $left, $top, $width, $height, True)
Next
GUISwitch($hGUI)
EndFunc
Func _move_mouse_to_grippy(Const $x, Const $y)
Local Const $mouse_coord_mode = Opt("MouseCoordMode", 2)
MouseMove(Int($x + ($grippy_size / 2)), Int($y + ($grippy_size / 2)), 0)
Opt("MouseCoordMode", $mouse_coord_mode)
EndFunc
Func _updateActionStacks($oActionObject = 0)
Local $aTemp[0]
If Not IsObj($oActionObject) Then
$aStackUndo = $aTemp
$aStackRedo = $aTemp
Return
EndIf
_ArrayAdd($aStackUndo, $oActionObject)
$aStackRedo = $aTemp
EndFunc
Func GuiCtrlSetOnTop($iCtrlID, $hAfter = $HWND_TOP)
Local $hWnd = $iCtrlID
Local $hAfterNew = $hAfter
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($iCtrlID)
If $hAfter <> $HWND_TOP And $hAfter <> $HWND_BOTTOM Then
If Not IsHWnd($hAfter) Then $hAfterNew = GUICtrlGetHandle($hAfter)
EndIf
Return _WinAPI_SetWindowPos($hWnd, $hAfterNew, 0, 0, 0, 0, $SWP_NOMOVE + $SWP_NOSIZE + $SWP_NOCOPYBITS)
EndFunc
Func _undo()
ConsoleWrite("Undo" & @CRLF)
Local $size = UBound($aStackUndo)
If $size > 0 Then
Local $oAction = $aStackUndo[$size - 1]
Switch $oAction.action
Case $action_changeText
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $aParams
For $i = 0 To UBound($aActionCtrls) - 1
$aParams = $aActionParams[$i]
GUICtrlSetData($aActionCtrls[$i].Hwnd, $aParams[0])
$aActionCtrls[$i].Text = $aParams[0]
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_populate_control_properties_gui($oSelected.getFirst())
_refreshGenerateCode()
Case $action_renameCtrl
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
$aActionCtrls[0].Name = $aActionParams[0]
_populate_control_properties_gui($oSelected.getFirst())
_formObjectExplorer_updateList()
_refreshGenerateCode()
Case $action_nudgeCtrl
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_nudgeSelected(-1 * $aActionParams[0], -1 * $aActionParams[1], $aActionCtrls)
Case $action_moveCtrl
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_nudgeSelected(-1 * $aActionParams[0], -1 * $aActionParams[1], $aActionCtrls)
Case $action_resizeCtrl
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $aParams
For $i = 0 To UBound($aActionCtrls) - 1
$aParams = $aActionParams[$i]
_change_ctrl_size_pos($aActionCtrls[$i], $aParams[4], $aParams[5], $aParams[0], $aParams[1])
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_populate_control_properties_gui($oSelected.getFirst())
_refreshGenerateCode()
Case $action_drawCtrl
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_deleteCtrls($aActionCtrls)
Case $action_deleteCtrl
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $prevHwnd, $oNewCtrl
For $i = 0 To UBound($aActionCtrls) - 1
$prevHwnd = $aActionCtrls[$i].Hwnd
$oNewCtrl = _create_ctrl($aActionCtrls[$i])
_remove_all_from_selected()
Switch $aActionCtrls[$i].Type
Case "Rect", "Ellipse", "Line"
_updateGraphic($aActionCtrls[$i])
EndSwitch
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_formObjectExplorer_updateList()
_refreshGenerateCode()
Case $action_pasteCtrl
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_deleteCtrls($aActionCtrls)
Case $action_changeBkColor
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $aParams
For $i = 0 To UBound($aActionCtrls) - 1
$aParams = $aActionParams[$i]
Local $newColor = $aParams[0]
Switch $aActionCtrls[$i].Type
Case "Label", "Checkbox", "Radio", "Input", "Edit"
If $newColor <> -1 Then
GUICtrlSetBkColor($aActionCtrls[$i].Hwnd, $newColor)
$aActionCtrls[$i].Background = $newColor
Else
GUICtrlSetBkColor($aActionCtrls[$i].Hwnd, $defaultGuiBkColor)
$aActionCtrls[$i].Background = -1
EndIf
Case "Rect", "Ellipse"
$aActionCtrls[$i].Background = $newColor
_updateGraphic($aActionCtrls[$i])
EndSwitch
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_populate_control_properties_gui($oSelected.getFirst())
_refreshGenerateCode()
Case $action_changeColor
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $aParams
For $i = 0 To UBound($aActionCtrls) - 1
$aParams = $aActionParams[$i]
Local $newColor = $aParams[0]
Switch $aActionCtrls[$i].Type
Case "Label", "Edit", "Input"
If $newColor <> -1 Then
GUICtrlSetColor($aActionCtrls[$i].Hwnd, $newColor)
Else
GUICtrlDelete($aActionCtrls[$i].Hwnd)
$aActionCtrls[$i].Hwnd = GUICtrlCreateLabel($aActionCtrls[$i].Text, $aActionCtrls[$i].Left, $aActionCtrls[$i].Top, $aActionCtrls[$i].Width, $aActionCtrls[$i].Height)
$aActionCtrls[$i].Color = -1
If $aActionCtrls[$i].Background <> -1 Then
GUICtrlSetBkColor($aActionCtrls[$i].Hwnd, $aActionCtrls[$i].Background)
EndIf
EndIf
$aActionCtrls[$i].Color = $newColor
EndSwitch
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_populate_control_properties_gui($oSelected.getFirst())
_refreshGenerateCode()
Case $action_changeBorderColor
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $aParams
For $i = 0 To UBound($aActionCtrls) - 1
$aParams = $aActionParams[$i]
Local $newColor = $aParams[0]
Switch $aActionCtrls[$i].Type
Case "Rect", "Ellipse", "Line"
$aActionCtrls[$i].BorderColor = $newColor
_updateGraphic($aActionCtrls[$i])
EndSwitch
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_populate_control_properties_gui($oSelected.getFirst())
_refreshGenerateCode()
Case $action_changeBorderSize
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $aParams
For $i = 0 To UBound($aActionCtrls) - 1
$aParams = $aActionParams[$i]
Local $newData = $aParams[0]
Switch $aActionCtrls[$i].Type
Case "Rect", "Ellipse", "Line"
$aActionCtrls[$i].BorderSize = $newData
_updateGraphic($aActionCtrls[$i])
EndSwitch
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_populate_control_properties_gui($oSelected.getFirst())
_refreshGenerateCode()
Case $action_changeCode
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
Local $aParams
For $i = 0 To UBound($aActionCtrls) - 1
$aParams = $aActionParams[$i]
$aActionCtrls[$i].CodeString = $aParams[0]
Next
_refreshGenerateCode()
EndSwitch
_ArrayAdd($aStackRedo, $aStackUndo[$size - 1])
_ArrayDelete($aStackUndo, $size - 1)
EndIf
EndFunc
Func _redo()
ConsoleWrite("Redo" & @CRLF)
Local $size = UBound($aStackRedo)
If $size > 0 Then
Local $oAction = $aStackRedo[$size - 1]
Switch $oAction.action
Case $action_changeText
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $aParams
For $i = 0 To UBound($aActionCtrls) - 1
$aParams = $aActionParams[$i]
GUICtrlSetData($aActionCtrls[$i].Hwnd, $aParams[1])
$aActionCtrls[$i].Text = $aParams[1]
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_populate_control_properties_gui($oSelected.getFirst())
_refreshGenerateCode()
Case $action_renameCtrl
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
$aActionCtrls[0].Name = $aActionParams[1]
_populate_control_properties_gui($oSelected.getFirst())
_formObjectExplorer_updateList()
_refreshGenerateCode()
Case $action_nudgeCtrl
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_nudgeSelected($aActionParams[0], $aActionParams[1], $aActionCtrls)
Case $action_moveCtrl
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_nudgeSelected($aActionParams[0], $aActionParams[1], $aActionCtrls)
Case $action_resizeCtrl
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $aParams
For $i = 0 To UBound($aActionCtrls) - 1
$aParams = $aActionParams[$i]
_change_ctrl_size_pos($aActionCtrls[$i], $aParams[6], $aParams[7], $aParams[2], $aParams[3])
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_populate_control_properties_gui($oSelected.getFirst())
_refreshGenerateCode()
Case $action_drawCtrl
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $prevHwnd, $oNewCtrl
For $i = 0 To UBound($aActionCtrls) - 1
$prevHwnd = $aActionCtrls[$i].Hwnd
$oNewCtrl = _create_ctrl($aActionCtrls[$i])
_remove_all_from_selected()
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_formObjectExplorer_updateList()
_refreshGenerateCode()
Case $action_deleteCtrl
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_deleteCtrls($aActionCtrls)
Case $action_pasteCtrl
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $prevHwnd, $oNewCtrl
For $i = 0 To UBound($aActionCtrls) - 1
$prevHwnd = $aActionCtrls[$i].Hwnd
$oNewCtrl = _create_ctrl($aActionCtrls[$i])
_remove_all_from_selected()
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_formObjectExplorer_updateList()
_refreshGenerateCode()
Case $action_changeBkColor
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $aParams
For $i = 0 To UBound($aActionCtrls) - 1
$aParams = $aActionParams[$i]
Local $newColor = $aParams[1]
Switch $aActionCtrls[$i].Type
Case "Label", "Checkbox", "Radio", "Input", "Edit"
If $newColor <> -1 Then
GUICtrlSetBkColor($aActionCtrls[$i].Hwnd, $newColor)
$aActionCtrls[$i].Background = $newColor
Else
GUICtrlSetBkColor($aActionCtrls[$i].Hwnd, $defaultGuiBkColor)
$aActionCtrls[$i].Background = -1
EndIf
Case "Rect", "Ellipse"
$aActionCtrls[$i].Background = $newColor
_updateGraphic($aActionCtrls[$i])
EndSwitch
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_populate_control_properties_gui($oSelected.getFirst())
_refreshGenerateCode()
Case $action_changeColor
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $aParams
For $i = 0 To UBound($aActionCtrls) - 1
$aParams = $aActionParams[$i]
Local $newColor = $aParams[1]
Switch $aActionCtrls[$i].Type
Case "Label", "Edit", "Input"
If $newColor <> -1 Then
GUICtrlSetColor($aActionCtrls[$i].Hwnd, $newColor)
Else
GUICtrlDelete($aActionCtrls[$i].Hwnd)
$aActionCtrls[$i].Hwnd = GUICtrlCreateLabel($aActionCtrls[$i].Text, $aActionCtrls[$i].Left, $aActionCtrls[$i].Top, $aActionCtrls[$i].Width, $aActionCtrls[$i].Height)
$aActionCtrls[$i].Color = -1
If $aActionCtrls[$i].Background <> -1 Then
GUICtrlSetBkColor($aActionCtrls[$i].Hwnd, $aActionCtrls[$i].Background)
EndIf
EndIf
$aActionCtrls[$i].Color = $newColor
EndSwitch
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_populate_control_properties_gui($oSelected.getFirst())
_refreshGenerateCode()
Case $action_changeBorderColor
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $aParams
For $i = 0 To UBound($aActionCtrls) - 1
$aParams = $aActionParams[$i]
Local $newColor = $aParams[1]
Switch $aActionCtrls[$i].Type
Case "Rect", "Ellipse", "Line"
$aActionCtrls[$i].BorderColor = $newColor
_updateGraphic($aActionCtrls[$i])
EndSwitch
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_populate_control_properties_gui($oSelected.getFirst())
_refreshGenerateCode()
Case $action_changeBorderSize
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $aParams
For $i = 0 To UBound($aActionCtrls) - 1
$aParams = $aActionParams[$i]
Local $newData = $aParams[1]
Switch $aActionCtrls[$i].Type
Case "Rect", "Ellipse", "Line"
$aActionCtrls[$i].BorderSize = $newData
_updateGraphic($aActionCtrls[$i])
EndSwitch
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_populate_control_properties_gui($oSelected.getFirst())
_refreshGenerateCode()
Case $action_changeCode
Local $aActionCtrls = $oAction.ctrls
Local $aActionParams = $oAction.parameters
Local $aParams
For $i = 0 To UBound($aActionCtrls) - 1
$aParams = $aActionParams[$i]
$aActionCtrls[$i].CodeString = $aParams[1]
Next
_refreshGenerateCode()
EndSwitch
_ArrayAdd($aStackUndo, $aStackRedo[$size - 1])
_ArrayDelete($aStackRedo, $size - 1)
EndIf
EndFunc
Func _onSaveGui()
_save_gui_definition()
EndFunc
Func _onSaveAsGui()
_save_gui_definition(True)
EndFunc
Func _save_gui_definition($saveAs = False)
Local $objOutput
If $AgdOutFile = "" Or $saveAs Then
If $lfld = "" Then
$lfld = IniRead($sIniPath, "Save Folder", "Last", "")
EndIf
If Not FileExists($lfld) Then
$lfld = ""
EndIf
If $lfld = "" Then
$lfld = @MyDocumentsDir
EndIf
Local $gdtitle = _get_script_title()
Local $OutFile = FileSaveDialog("Save GUI Definition to file?", $lfld, "AutoIt Gui Definitions (*.agd)", BitOR($FD_PATHMUSTEXIST, $FD_PROMPTOVERWRITE), StringReplace($gdtitle, '"', ""))
If @error = 1 Or $OutFile = "" Then
$bStatusNewMessage = True
_GUICtrlStatusBar_SetText($hStatusbar, "Error saving definition file!")
Return -1
Else
$AgdOutFile = $OutFile
$lfld = StringInStr($AgdOutFile, "\", 0, -1)
$lfld = StringLeft($AgdOutFile, $lfld - 1)
IniWrite($sIniPath, "Save Folder", "Last", $lfld)
If StringRight($AgdOutFile, 4) <> ".agd" Then
$AgdOutFile = $AgdOutFile & ".agd"
EndIf
$mygui = StringReplace($AgdOutFile, $lfld & "\", "")
$mygui = StringReplace($mygui, ".agd", "")
$mygui = $mygui & ".au3"
_addToRecentFiles($AgdOutFile)
EndIf
EndIf
FileDelete($AgdOutFile)
If @error Then
$bStatusNewMessage = True
_GUICtrlStatusBar_SetText($hStatusbar, "Error saving definition file!")
Return -2
EndIf
Local $mainHeight = $oMain.Height
If $oCtrls.hasMenu Then
$mainHeight += _WinAPI_GetSystemMetrics($SM_CYMENU)
EndIf
Local Const $ctrl_count = $oCtrls.count
Json_Put($objOutput, ".Main.Left", $oMain.Left)
Json_Put($objOutput, ".Main.Top", $oMain.Top)
Json_Put($objOutput, ".Main.Width", $oMain.Width)
Json_Put($objOutput, ".Main.Height", $mainHeight)
Json_Put($objOutput, ".Main.Name", $oMain.Name)
Json_Put($objOutput, ".Main.Title", $oMain.Title)
Json_Put($objOutput, ".Main.Background", $oMain.Background)
Json_Put($objOutput, ".Main.numctrls", $ctrl_count)
Json_Put($objOutput, ".Main.styleString", $oMain.styleString)
$i = 0
For $oCtrl In $oCtrls.ctrls.Items()
If $oCtrl.Type = "TabItem" Then ContinueLoop
If $oCtrl.CtrlParent <> 0 Then ContinueLoop
Local $handle = $oCtrl.Hwnd
Json_Put($objOutput, ".Controls[" & $i & "].Type", $oCtrl.Type)
Json_Put($objOutput, ".Controls[" & $i & "].Name", $oCtrl.Name)
Json_Put($objOutput, ".Controls[" & $i & "].Text", $oCtrl.Text)
Json_Put($objOutput, ".Controls[" & $i & "].Visible", $oCtrl.Visible)
Json_Put($objOutput, ".Controls[" & $i & "].OnTop", $oCtrl.OnTop)
Json_Put($objOutput, ".Controls[" & $i & "].DropAccepted", $oCtrl.DropAccepted)
Json_Put($objOutput, ".Controls[" & $i & "].Left", $oCtrl.Left)
Json_Put($objOutput, ".Controls[" & $i & "].Top", $oCtrl.Top)
Json_Put($objOutput, ".Controls[" & $i & "].Width", $oCtrl.Width)
Json_Put($objOutput, ".Controls[" & $i & "].Height", $oCtrl.Height)
Json_Put($objOutput, ".Controls[" & $i & "].Global", $oCtrl.Global)
Json_Put($objOutput, ".Controls[" & $i & "].Locked", $oCtrl.Locked)
Json_Put($objOutput, ".Controls[" & $i & "].styleString", $oCtrl.styleString)
Json_Put($objOutput, ".Controls[" & $i & "].FontSize", $oCtrl.FontSize)
Json_Put($objOutput, ".Controls[" & $i & "].FontWeight", $oCtrl.FontWeight)
Json_Put($objOutput, ".Controls[" & $i & "].FontName", $oCtrl.FontName)
If $oCtrl.Color = -1 Then
Json_Put($objOutput, ".Controls[" & $i & "].Color", -1)
Else
Json_Put($objOutput, ".Controls[" & $i & "].Color", "0x" & Hex($oCtrl.Color, 6))
EndIf
If $oCtrl.Background = -1 Then
Json_Put($objOutput, ".Controls[" & $i & "].Background", -1)
Else
Json_Put($objOutput, ".Controls[" & $i & "].Background", "0x" & Hex($oCtrl.Background, 6))
EndIf
Json_Put($objOutput, ".Controls[" & $i & "].CodeString", $oCtrl.CodeString)
If $oCtrl.BorderColor = -1 Then
Json_Put($objOutput, ".Controls[" & $i & "].BorderColor", "0x000000")
Else
Json_Put($objOutput, ".Controls[" & $i & "].BorderColor", "0x" & Hex($oCtrl.BorderColor, 6))
EndIf
Json_Put($objOutput, ".Controls[" & $i & "].BorderSize", $oCtrl.BorderSize)
If $oCtrl.Type = "Line" Then
Json_Put($objOutput, ".Controls[" & $i & "].Coords.Coord1_X", $oCtrl.Coord1[0])
Json_Put($objOutput, ".Controls[" & $i & "].Coords.Coord1_Y", $oCtrl.Coord1[1])
Json_Put($objOutput, ".Controls[" & $i & "].Coords.Coord2_X", $oCtrl.Coord2[0])
Json_Put($objOutput, ".Controls[" & $i & "].Coords.Coord2_Y", $oCtrl.Coord2[1])
EndIf
Json_Put($objOutput, ".Controls[" & $i & "].Items", $oCtrl.Items)
Json_Put($objOutput, ".Controls[" & $i & "].Img", $oCtrl.Img)
Switch $oCtrl.Type
Case "Tab"
Json_Put($objOutput, ".Controls[" & $i & "].TabCount", $oCtrl.TabCount)
If $oCtrl.TabCount > 0 Then
Local $j = 0, $oTab
For $hTab In $oCtrl.Tabs
$oTab = $oCtrls.get($hTab)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Type", $oTab.Type)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Name", $oTab.Name)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Text", $oTab.Text)
Local $k = 0
For $oTabCtrl In $oTab.ctrls.Items()
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Type", $oTabCtrl.Type)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Name", $oTabCtrl.Name)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Text", $oTabCtrl.Text)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Visible", $oTabCtrl.Visible)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].OnTop", $oTabCtrl.OnTop)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].DropAccepted", $oTabCtrl.DropAccepted)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Left", $oTabCtrl.Left)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Top", $oTabCtrl.Top)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Width", $oTabCtrl.Width)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Height", $oTabCtrl.Height)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Global", $oTabCtrl.Global)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Locked", $oTabCtrl.Locked)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].styleString", $oTabCtrl.styleString)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].FontSize", $oTabCtrl.FontSize)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].FontWeight", $oTabCtrl.FontWeight)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].FontName", $oTabCtrl.FontName)
If $oTabCtrl.Color = -1 Then
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Color", -1)
Else
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Color", "0x" & Hex($oTabCtrl.Color, 6))
EndIf
If $oTabCtrl.Background = -1 Then
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Background", -1)
Else
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Background", "0x" & Hex($oTabCtrl.Background, 6))
EndIf
If $oTabCtrl.BorderColor = -1 Then
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].BorderColor", "0x000000")
Else
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].BorderColor", "0x" & Hex($oTabCtrl.BorderColor, 6))
EndIf
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].BorderSize", $oTabCtrl.BorderSize)
If $oTabCtrl.Type = "Line" Then
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Coords.Coord1_X", $oTabCtrl.Coord1[0])
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Coords.Coord1_Y", $oTabCtrl.Coord1[1])
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Coords.Coord2_X", $oTabCtrl.Coord2[0])
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Coords.Coord2_Y", $oTabCtrl.Coord2[1])
EndIf
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].CodeString", $oTabCtrl.CodeString)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Items", $oTabCtrl.Items)
Json_Put($objOutput, ".Controls[" & $i & "].Tabs[" & $j & "].Controls[" & $k & "].Img", $oTabCtrl.Img)
$k += 1
Next
$j += 1
Next
EndIf
Case "Group"
If $oCtrl.ctrls.Count > 0 Then
Local $k = 0, $oThisCtrl
For $oThisCtrl In $oCtrl.ctrls.Items()
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Type", $oThisCtrl.Type)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Name", $oThisCtrl.Name)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Text", $oThisCtrl.Text)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Visible", $oThisCtrl.Visible)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].OnTop", $oThisCtrl.OnTop)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].DropAccepted", $oThisCtrl.DropAccepted)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Left", $oThisCtrl.Left)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Top", $oThisCtrl.Top)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Width", $oThisCtrl.Width)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Height", $oThisCtrl.Height)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Global", $oThisCtrl.Global)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Locked", $oThisCtrl.Locked)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].styleString", $oThisCtrl.styleString)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].FontSize", $oThisCtrl.FontSize)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].FontWeight", $oThisCtrl.FontWeight)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].FontName", $oThisCtrl.FontName)
If $oThisCtrl.Color = -1 Then
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Color", -1)
Else
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Color", "0x" & Hex($oThisCtrl.Color, 6))
EndIf
If $oThisCtrl.Background = -1 Then
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Background", -1)
Else
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Background", "0x" & Hex($oThisCtrl.Background, 6))
EndIf
If $oThisCtrl.BorderColor = -1 Then
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].BorderColor", "0x000000")
Else
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].BorderColor", "0x" & Hex($oThisCtrl.BorderColor, 6))
EndIf
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].BorderSize", $oThisCtrl.BorderSize)
If $oThisCtrl.Type = "Line" Then
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Coords.Coord1_X", $oThisCtrl.Coord1[0])
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Coords.Coord1_Y", $oThisCtrl.Coord1[1])
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Coords.Coord2_X", $oThisCtrl.Coord2[0])
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Coords.Coord2_Y", $oThisCtrl.Coord2[1])
EndIf
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].CodeString", $oThisCtrl.CodeString)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Items", $oThisCtrl.Items)
Json_Put($objOutput, ".Controls[" & $i & "].Controls[" & $k & "].Img", $oThisCtrl.Img)
$k += 1
Next
EndIf
EndSwitch
If $oCtrl.Type = "Menu" Then
Json_Put($objOutput, ".Controls[" & $i & "].MenuItemCount", $oCtrl.Menuitems.count)
Local $menuCount = $oCtrl.Menuitems.count
If $menuCount > 0 Then
Local $j = 0
For $oMenuItem In $oCtrl.MenuItems
Json_Put($objOutput, ".Controls[" & $i & "].MenuItems[" & $j & "].Name", $oMenuItem.Name)
Json_Put($objOutput, ".Controls[" & $i & "].MenuItems[" & $j & "].Text", $oMenuItem.Text)
$j += 1
Next
EndIf
EndIf
$i += 1
Next
Local $Json = Json_Encode($objOutput, $Json_PRETTY_PRINT)
Local $hFile = FileOpen($AgdOutFile, $FO_OVERWRITE)
FileWrite($hFile, $Json)
FileClose($hFile)
$bStatusNewMessage = True
_GUICtrlStatusBar_SetText($hStatusbar, "Definition saved to file")
$oMain.hasChanged = False
EndFunc
Func _onload_gui_definition()
_load_gui_definition()
EndFunc
Func _load_gui_definition($AgdInfile = '', $oImportData = -1)
Static $firstLoad = True
Local $objInput
If Not IsObj($oImportData) Then
If $oCtrls.count > 0 Then
Switch MsgBox($MB_ICONWARNING + $MB_YESNO, "Load Gui Definition from file", "Loading a Gui Definition will clear existing controls." & @CRLF & "Are you sure?" & @CRLF)
Case $IDNO
Return
EndSwitch
EndIf
Switch $AgdInfile
Case ''
$lfld = IniRead($sIniPath, "Save Folder", "Last", "")
If $lfld = "" Then
$lfld = @MyDocumentsDir
EndIf
If Not $CmdLine[0] Then
$AgdInfile = FileOpenDialog("Load GUI Definition from file?", $lfld, "AutoIt Gui Definitions (*.agd)", $FD_FILEMUSTEXIST)
If @error Then
Return
EndIf
EndIf
Case Else
If Not FileExists($AgdInfile) Then
MsgBox($MB_ICONERROR, "File Error", "Error loading the GUI definition file." & @CRLF & "File not found." & @CRLF)
Return
EndIf
EndSwitch
$AgdOutFile = $AgdInfile
_addToRecentFiles($AgdInfile)
_SendMessage($hGUI, $WM_SETREDRAW, False)
Local $sData = FileRead($AgdInfile)
If StringLeft($sData, 1) = "[" Then
_load_gui_definition_ini($AgdInfile)
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
_addToRecentFiles($AgdInfile)
Return
EndIf
$objInput = Json_Decode($sData)
Else
$objInput = $oImportData
EndIf
If Not $firstLoad Or Not $CmdLine[0] Then
_wipe_current_gui()
EndIf
If $firstLoad Then $firstLoad = False
$oMain.Name = _Json_Get($objInput, ".Main.Name", "hGUI")
$oMain.Title = _Json_Get($objInput, ".Main.Title", StringTrimRight(StringTrimLeft(_get_script_title(), 1), 1))
$oMain.Left = _Json_Get($objInput, ".Main.Left", -1)
$oMain.Top = _Json_Get($objInput, ".Main.Top", -1)
$oMain.Width = _Json_Get($objInput, ".Main.Width", 400)
$oMain.Height = _Json_Get($objInput, ".Main.Height", 350)
If IsHWnd($hGUI) Then
Local $newLeft = $oMain.Left, $newTop = $oMain.Top
If $oMain.Left = -1 Then
$newLeft = Default
EndIf
If $oMain.Top = -1 Then
$newTop = Default
EndIf
WinMove($hGUI, "", $newLeft, $newTop, $oMain.Width + $iGuiFrameW, $oMain.Height + $iGuiFrameH)
WinSetTitle($hGUI, "", $oMain.AppName & " - Form (" & $oMain.Width & ", " & $oMain.Height & ")")
If $oOptions.showGrid Then
_display_grid($background, $oMain.Width, $oMain.Height)
EndIf
EndIf
$oMain.Background = _Json_Get($objInput, ".Main.Background", -1)
$oProperties_Main.Background.value = $oMain.Background
If $oMain.Background <> -1 And $oMain.Background <> "" Then
$oMain.Background = Dec(StringReplace($oMain.Background, "0x", ""))
GUISetBkColor($oMain.Background, $hGUI)
Else
GUISetBkColor($defaultGuiBkColor, $hGUI)
EndIf
$oMain.styleString = _Json_Get($objInput, ".Main.styleString", "")
$oProperties_Main.Title.value = $oMain.Title
$oProperties_Main.Name.value = $oMain.Name
$oProperties_Main.Left.value = $oMain.Left
$oProperties_Main.Top.value = $oMain.Top
$oProperties_Main.Width.value = $oMain.Width
$oProperties_Main.Height.value = $oMain.Height
Local Const $numCtrls = _Json_Get($objInput, ".Main.numctrls", -1)
Local $oCtrl, $Key, $oNewCtrl
Local $aControls = Json_Get($objInput, ".Controls")
If @error Then
ConsoleWrite("No controls found" & @CRLF)
EndIf
If IsArray($aControls) Then
For $oThisCtrl In $aControls
$oCtrl = $oCtrls.createNew()
$oCtrl.HwndCount = 1
$oCtrl.Type = _Json_Get($oThisCtrl, ".Type", -1)
$oCtrl.Name = _Json_Get($oThisCtrl, ".Name", -1)
$oCtrl.Text = _Json_Get($oThisCtrl, ".Text", -1)
$oCtrl.Visible = _Json_Get($oThisCtrl, ".Visible", 1)
$oCtrl.OnTop = _Json_Get($oThisCtrl, ".OnTop", 0)
$oCtrl.Left = _Json_Get($oThisCtrl, ".Left", -1)
$oCtrl.Top = _Json_Get($oThisCtrl, ".Top", -1)
$oCtrl.Width = _Json_Get($oThisCtrl, ".Width", -1)
$oCtrl.Height = _Json_Get($oThisCtrl, ".Height", -1)
$oCtrl.Global = _Json_Get($oThisCtrl, ".Global", $GUI_CHECKED)
$oCtrl.Locked = _Json_Get($oThisCtrl, ".Locked", $GUI_UNCHECKED)
$oCtrl.styleString = _Json_Get($oThisCtrl, ".styleString", "")
$oCtrl.Color = _Json_Get($oThisCtrl, ".Color", -1)
If $oCtrl.Color <> -1 Then
$oCtrl.Color = Dec(StringReplace($oCtrl.Color, "0x", ""))
EndIf
$oCtrl.Background = _Json_Get($oThisCtrl, ".Background", -1)
If $oCtrl.Background <> -1 Then
$oCtrl.Background = Dec(StringReplace($oCtrl.Background, "0x", ""))
EndIf
$oCtrl.FontSize = _Json_Get($oThisCtrl, ".FontSize", 8.5)
$oCtrl.FontWeight = _Json_Get($oThisCtrl, ".FontWeight", 400)
$oCtrl.FontName = _Json_Get($oThisCtrl, ".FontName", "")
$oCtrl.BorderColor = _Json_Get($oThisCtrl, ".BorderColor", '0x000000')
If $oCtrl.BorderColor <> -1 Then
$oCtrl.BorderColor = Dec(StringReplace($oCtrl.BorderColor, "0x", ""))
EndIf
$oCtrl.BorderSize = _Json_Get($oThisCtrl, ".BorderSize", 1)
Local $aCoords[2]
$aCoords[0] = _Json_Get($oThisCtrl, ".Coords.Coord1_X", 0)
$aCoords[1] = _Json_Get($oThisCtrl, ".Coords.Coord1_Y", 0)
$oCtrl.Coord1 = $aCoords
$aCoords[0] = _Json_Get($oThisCtrl, ".Coords.Coord2_X", 0)
$aCoords[1] = _Json_Get($oThisCtrl, ".Coords.Coord2_Y", 0)
$oCtrl.Coord2 = $aCoords
$oCtrl.CodeString = _Json_Get($oThisCtrl, ".CodeString", "")
$oCtrl.Items = _Json_Get($oThisCtrl, ".Items", "")
$oCtrl.Img = _Json_Get($oThisCtrl, ".Img", "")
$oNewCtrl = _create_ctrl($oCtrl, True)
Local $aStyles = StringSplit($oNewCtrl.styleString, ", ", $STR_ENTIRESPLIT + $STR_NOCOUNT)
Local $iOldStyle
For $sStyle In $aStyles
$iOldStyle = _WinAPI_GetWindowLong(GUICtrlGetHandle($oNewCtrl.Hwnd), $GWL_STYLE)
GUICtrlSetStyle($oNewCtrl.Hwnd, BitOR($iOldStyle, Execute($sStyle)))
Next
If $oCtrl.FontSize <> 8.5 Then
If $oCtrl.Type = "IP" Then
_GUICtrlIpAddress_SetFont($oCtrl.Hwnd, "Arial", $oCtrl.FontSize)
Else
GUICtrlSetFont($oCtrl.Hwnd, $oCtrl.FontSize)
EndIf
EndIf
If $oCtrl.FontWeight <> 400 Then
If $oCtrl.Type = "IP" Then
_GUICtrlIpAddress_SetFont($oCtrl.Hwnd, "Arial", $oCtrl.FontSize, $oCtrl.FontWeight)
Else
GUICtrlSetFont($oCtrl.Hwnd, $oCtrl.FontSize, $oCtrl.FontWeight)
EndIf
EndIf
If $oCtrl.FontName <> "" Then
If $oCtrl.Type = "IP" Then
_GUICtrlIpAddress_SetFont($oCtrl.Hwnd, $oCtrl.FontName, $oCtrl.FontSize, $oCtrl.FontWeight)
Else
GUICtrlSetFont($oCtrl.Hwnd, $oCtrl.FontSize, $oCtrl.FontWeight, 0, $oCtrl.FontName)
EndIf
EndIf
$oCtrl = $oCtrls.get($oNewCtrl.Hwnd)
Local $j, $oCtrl2
Switch $oCtrl.Type
Case "Tab"
Local $tabCount = _Json_Get($oThisCtrl, ".TabCount", 0)
If $tabCount > 0 Then
Local $aTabs = Json_Get($oThisCtrl, ".Tabs")
$j = 1
Local $oTab
For $oThisTab In $aTabs
_new_tab(True)
$oTab = $oCtrls.getLast()
$oTab.Name = _Json_Get($oThisTab, ".Name", "tempName")
$oTab.Text = _Json_Get($oThisTab, ".Text", "tempText")
_GUICtrlTab_SetItemText($oCtrl.Hwnd, $j - 1, $oTab.Text)
Local $aTabCtrls = Json_Get($oThisTab, ".Controls")
If Not IsArray($aTabCtrls) Then ContinueLoop
GUISwitch($hGUI, $oTab.Hwnd)
For $oTabCtrl In $aTabCtrls
$oCtrl2 = $oCtrls.createNew()
$oCtrl2.HwndCount = 1
$oCtrl2.Type = _Json_Get($oTabCtrl, ".Type", -1)
$oCtrl2.Name = _Json_Get($oTabCtrl, ".Name", -1)
$oCtrl2.Text = _Json_Get($oTabCtrl, ".Text", -1)
$oCtrl2.Visible = _Json_Get($oTabCtrl, ".Visible", 1)
$oCtrl2.OnTop = _Json_Get($oTabCtrl, ".OnTop", 0)
$oCtrl2.Left = _Json_Get($oTabCtrl, ".Left", -1)
$oCtrl2.Top = _Json_Get($oTabCtrl, ".Top", -1)
$oCtrl2.Width = _Json_Get($oTabCtrl, ".Width", -1)
$oCtrl2.Height = _Json_Get($oTabCtrl, ".Height", -1)
$oCtrl2.Global = _Json_Get($oTabCtrl, ".Global", $GUI_CHECKED)
$oCtrl2.Locked = _Json_Get($oTabCtrl, ".Locked", $GUI_UNCHECKED)
$oCtrl2.styleString = _Json_Get($oTabCtrl, ".styleString", "")
$oCtrl2.CodeString = _Json_Get($oTabCtrl, ".CodeString", "")
$oCtrl2.Items = _Json_Get($oTabCtrl, ".Items", "")
$oCtrl2.Img = _Json_Get($oTabCtrl, ".Img", "")
$oCtrl2.Color = _Json_Get($oTabCtrl, ".Color", -1)
If $oCtrl2.Color <> -1 Then
$oCtrl2.Color = Dec(StringReplace($oCtrl2.Color, "0x", ""))
EndIf
$oCtrl2.Background = _Json_Get($oTabCtrl, ".Background", -1)
If $oCtrl2.Background <> -1 Then
$oCtrl2.Background = Dec(StringReplace($oCtrl2.Background, "0x", ""))
EndIf
$oCtrl2.BorderColor = _Json_Get($oTabCtrl, ".BorderColor", '0x000000')
If $oCtrl2.BorderColor <> -1 Then
$oCtrl2.BorderColor = Dec(StringReplace($oCtrl2.BorderColor, "0x", ""))
EndIf
$oCtrl2.BorderSize = _Json_Get($oTabCtrl, ".BorderSize", 1)
$aCoords[0] = _Json_Get($oTabCtrl, ".Coords.Coord1_X", 0)
$aCoords[1] = _Json_Get($oTabCtrl, ".Coords.Coord1_Y", 0)
$oCtrl2.Coord1 = $aCoords
$aCoords[0] = _Json_Get($oTabCtrl, ".Coords.Coord2_X", 0)
$aCoords[1] = _Json_Get($oTabCtrl, ".Coords.Coord2_Y", 0)
$oCtrl2.Coord2 = $aCoords
$oNewCtrl = _create_ctrl($oCtrl2, True, -1, -1, $oCtrl.Hwnd)
Local $aStyles = StringSplit($oNewCtrl.styleString, ", ", $STR_ENTIRESPLIT + $STR_NOCOUNT)
For $sStyle In $aStyles
$iOldStyle = _WinAPI_GetWindowLong(GUICtrlGetHandle($oNewCtrl.Hwnd), $GWL_STYLE)
GUICtrlSetStyle($oNewCtrl.Hwnd, BitOR($iOldStyle, Execute($sStyle)))
Next
Switch $oCtrl2.Type
Case "Rect", "Ellipse", "Line"
_updateGraphic($oCtrl2)
EndSwitch
Next
GUICtrlCreateTabItem('')
GUISwitch($hGUI)
$j += 1
Next
EndIf
Case "Group"
Local $aCtrls = Json_Get($oThisCtrl, ".Controls")
If Not IsArray($aCtrls) Then ContinueLoop
For $oGroupCtrl In $aCtrls
$oCtrl2 = $oCtrls.createNew()
$oCtrl2.HwndCount = 1
$oCtrl2.Type = _Json_Get($oGroupCtrl, ".Type", -1)
$oCtrl2.Name = _Json_Get($oGroupCtrl, ".Name", -1)
$oCtrl2.Text = _Json_Get($oGroupCtrl, ".Text", -1)
$oCtrl2.Visible = _Json_Get($oGroupCtrl, ".Visible", 1)
$oCtrl2.OnTop = _Json_Get($oGroupCtrl, ".OnTop", 0)
$oCtrl2.Left = _Json_Get($oGroupCtrl, ".Left", -1)
$oCtrl2.Top = _Json_Get($oGroupCtrl, ".Top", -1)
$oCtrl2.Width = _Json_Get($oGroupCtrl, ".Width", -1)
$oCtrl2.Height = _Json_Get($oGroupCtrl, ".Height", -1)
$oCtrl2.Global = _Json_Get($oGroupCtrl, ".Global", $GUI_CHECKED)
$oCtrl2.Locked = _Json_Get($oGroupCtrl, ".Locked", $GUI_UNCHECKED)
$oCtrl2.styleString = _Json_Get($oGroupCtrl, ".styleString", "")
$oCtrl2.CodeString = _Json_Get($oGroupCtrl, ".CodeString", "")
$oCtrl2.Items = _Json_Get($oGroupCtrl, ".Items", "")
$oCtrl2.Img = _Json_Get($oGroupCtrl, ".Img", "")
$oCtrl2.Color = _Json_Get($oGroupCtrl, ".Color", -1)
If $oCtrl2.Color <> -1 Then
$oCtrl2.Color = Dec(StringReplace($oCtrl2.Color, "0x", ""))
EndIf
$oCtrl2.Background = _Json_Get($oGroupCtrl, ".Background", -1)
If $oCtrl2.Background <> -1 Then
$oCtrl2.Background = Dec(StringReplace($oCtrl2.Background, "0x", ""))
EndIf
$oCtrl2.BorderColor = _Json_Get($oGroupCtrl, ".BorderColor", -1)
If $oCtrl2.BorderColor <> -1 Then
$oCtrl2.BorderColor = Dec(StringReplace($oCtrl2.BorderColor, "0x", ""))
EndIf
$oCtrl2.BorderSize = _Json_Get($oGroupCtrl, ".BorderSize", 1)
$aCoords[0] = _Json_Get($oGroupCtrl, ".Coords.Coord1_X", 0)
$aCoords[1] = _Json_Get($oGroupCtrl, ".Coords.Coord1_Y", 0)
$oCtrl2.Coord1 = $aCoords
$aCoords[0] = _Json_Get($oGroupCtrl, ".Coords.Coord2_X", 0)
$aCoords[1] = _Json_Get($oGroupCtrl, ".Coords.Coord2_Y", 0)
$oCtrl2.Coord2 = $aCoords
$oNewCtrl = _create_ctrl($oCtrl2, True, -1, -1, $oCtrl.Hwnd)
Local $aStyles = StringSplit($oNewCtrl.styleString, ", ", $STR_ENTIRESPLIT + $STR_NOCOUNT)
For $sStyle In $aStyles
$iOldStyle = _WinAPI_GetWindowLong(GUICtrlGetHandle($oNewCtrl.Hwnd), $GWL_STYLE)
GUICtrlSetStyle($oNewCtrl.Hwnd, BitOR($iOldStyle, Execute($sStyle)))
Next
Switch $oCtrl2.Type
Case "Rect", "Ellipse", "Line"
_updateGraphic($oCtrl2)
EndSwitch
Next
EndSwitch
Switch $oCtrl.Type
Case "Menu"
Local $MenuItemCount = _Json_Get($oThisCtrl, ".MenuItemCount", 0)
If $MenuItemCount > 0 Then
Local $aMenuItems = Json_Get($oThisCtrl, ".MenuItems")
$j = 1
For $oMenuItem In $aMenuItems
_new_menuItemCreate($oCtrl, True)
$oCtrl.MenuItems.at($j - 1).Name = _Json_Get($oMenuItem, ".Name", "tempName")
$oCtrl.MenuItems.at($j - 1).Text = _Json_Get($oMenuItem, ".Text", "tempText")
GUICtrlSetData($oCtrl.MenuItems.at($j - 1).Hwnd, $oCtrl.MenuItems.at($j - 1).Text)
$j += 1
Next
EndIf
Case "Rect", "Ellipse", "Line"
_updateGraphic($oCtrl)
EndSwitch
Next
EndIf
_formObjectExplorer_updateList()
_refreshGenerateCode()
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
$bStatusNewMessage = True
_GUICtrlStatusBar_SetText($hStatusbar, "Loaded successfully")
$oMain.hasChanged = False
EndFunc
Func _Json_Get(ByRef $obj, $data, $defaultValue = 0)
Local $val = Json_Get($obj, $data)
If @error Then
Return $defaultValue
Else
Return $val
EndIf
EndFunc
Func _load_gui_definition_ini($AgdInfile = '')
Static $firstLoad = True
If $oCtrls.count > 0 Then
Switch MsgBox($MB_ICONWARNING + $MB_YESNO, "Load Gui Definition from file", "Loading a Gui Definition will clear existing controls." & @CRLF & "Are you sure?" & @CRLF)
Case $IDNO
Return
EndSwitch
EndIf
Switch $AgdInfile
Case ''
$lfld = IniRead($sIniPath, "Save Folder", "Last", "")
If $lfld = "" Then
$lfld = @MyDocumentsDir
EndIf
If Not $CmdLine[0] Then
$AgdInfile = FileOpenDialog("Load GUI Definition from file?", $lfld, "AutoIt Gui Definitions (*.agd)", $FD_FILEMUSTEXIST)
If @error Then
Return
EndIf
EndIf
EndSwitch
$AgdOutFile = $AgdInfile
If Not $firstLoad Or Not $CmdLine[0] Then
_wipe_current_gui()
EndIf
If $firstLoad Then $firstLoad = False
$oMain.Name = IniRead($AgdInfile, "Main", "Name", "hGUI")
$oMain.Title = IniRead($AgdInfile, "Main", "Title", StringTrimRight(StringTrimLeft(_get_script_title(), 1), 1))
$oMain.Left = IniRead($AgdInfile, "Main", "Left", -1)
$oMain.Top = IniRead($AgdInfile, "Main", "Top", -1)
$oMain.Width = IniRead($AgdInfile, "Main", "Width", 400)
$oMain.Height = IniRead($AgdInfile, "Main", "Height", 350)
If IsHWnd($hGUI) Then
Local $newLeft = $oMain.Left, $newTop = $oMain.Top
If $oMain.Left = -1 Then
$newLeft = Default
EndIf
If $oMain.Top = -1 Then
$newTop = Default
EndIf
WinMove($hGUI, "", $newLeft, $newTop, $oMain.Width + $iGuiFrameW, $oMain.Height + $iGuiFrameH)
WinSetTitle($hGUI, "", $oMain.AppName & " - Form (" & $oMain.Width & ", " & $oMain.Height & ")")
If $oOptions.showGrid Then
_display_grid($background, $oMain.Width, $oMain.Height)
EndIf
EndIf
$oMain.Background = IniRead($AgdInfile, "Main", "Background", -1)
$oProperties_Main.Background.value = $oMain.Background
If $oMain.Background <> -1 And $oMain.Background <> "" Then
$oMain.Background = Dec(StringReplace($oMain.Background, "0x", ""))
GUISetBkColor($oMain.Background, $hGUI)
Else
GUISetBkColor($defaultGuiBkColor, $hGUI)
EndIf
$oProperties_Main.Title.value = $oMain.Title
$oProperties_Main.Name.value = $oMain.Name
$oProperties_Main.Left.value = $oMain.Left
$oProperties_Main.Top.value = $oMain.Top
$oProperties_Main.Width.value = $oMain.Width
$oProperties_Main.Height.value = $oMain.Height
Local Const $numCtrls = IniRead($AgdInfile, "Main", "numctrls", -1)
Local $oCtrl, $Key
For $i = 1 To $numCtrls
$Key = "Control_" & $i
$oCtrl = $oCtrls.createNew()
$oCtrl.HwndCount = 1
$oCtrl.Type = IniRead($AgdInfile, $Key, "Type", -1)
$oCtrl.Name = IniRead($AgdInfile, $Key, "Name", -1)
$oCtrl.Text = IniRead($AgdInfile, $Key, "Text", -1)
$oCtrl.Visible = IniRead($AgdInfile, $Key, "Visible", 1)
$oCtrl.OnTop = IniRead($AgdInfile, $Key, "OnTop", 0)
$oCtrl.Left = IniRead($AgdInfile, $Key, "Left", -1)
$oCtrl.Top = IniRead($AgdInfile, $Key, "Top", -1)
$oCtrl.Width = IniRead($AgdInfile, $Key, "Width", -1)
$oCtrl.Height = IniRead($AgdInfile, $Key, "Height", -1)
$oCtrl.Global = IniRead($AgdInfile, $Key, "Global", $GUI_CHECKED)
$oCtrl.Locked = IniRead($AgdInfile, $Key, "Locked", $GUI_UNCHECKED)
$oCtrl.Color = IniRead($AgdInfile, $Key, "Color", -1)
If $oCtrl.Color <> -1 Then
$oCtrl.Color = Dec(StringReplace($oCtrl.Color, "0x", ""))
EndIf
$oCtrl.Background = IniRead($AgdInfile, $Key, "Background", -1)
If $oCtrl.Background <> -1 Then
$oCtrl.Background = Dec(StringReplace($oCtrl.Background, "0x", ""))
EndIf
Local $oNewCtrl = _create_ctrl($oCtrl, True)
$oCtrl = $oCtrls.get($oNewCtrl.Hwnd)
If $oCtrl.Type = "Tab" Then
Local $tabCount = IniRead($AgdInfile, $Key, "TabCount", 0)
If $tabCount > 0 Then
For $j = 1 To $tabCount
_new_tab()
$oTab = $oCtrls.getLast()
$oTab.Name = IniRead($AgdInfile, $Key, "TabItem" & $j & "_Name", "tempName")
$oTab.Text = IniRead($AgdInfile, $Key, "TabItem" & $j & "_Text", "tempText")
_GUICtrlTab_SetItemText($oCtrl.Hwnd, $j - 1, $oTab.Text)
Next
EndIf
EndIf
If $oCtrl.Type = "Menu" Then
Local $MenuItemCount = IniRead($AgdInfile, $Key, "MenuItemCount", 0)
If $MenuItemCount > 0 Then
For $j = 1 To $MenuItemCount
_new_menuItemCreate($oCtrl)
$oCtrl.MenuItems.at($j - 1).Name = IniRead($AgdInfile, $Key, "MenuItem" & $j & "_Name", "tempName")
$oCtrl.MenuItems.at($j - 1).Text = IniRead($AgdInfile, $Key, "MenuItem" & $j & "_Text", "tempText")
GUICtrlSetData($oCtrl.MenuItems.at($j - 1).Hwnd, $oCtrl.MenuItems.at($j - 1).Text)
Next
EndIf
EndIf
Next
_formObjectExplorer_updateList()
_refreshGenerateCode()
$bStatusNewMessage = True
_GUICtrlStatusBar_SetText($hStatusbar, "Loaded successfully")
$oMain.hasChanged = False
EndFunc
Func _onImportMenuItem()
If $oCtrls.count > 0 Then
Switch MsgBox($MB_ICONWARNING + $MB_YESNO, "Load Gui Definition from file", "Loading a Gui Definition will clear existing controls." & @CRLF & "Are you sure?" & @CRLF)
Case $IDNO
Return
EndSwitch
EndIf
Local $oFileData = _importAu3File()
If Not @error Then
If IsObj($oFileData) Then
_load_gui_definition('', $oFileData)
EndIf
Else
Local $errCode = @error, $lineNo = @extended
Switch $errCode
Case 2
MsgBox(1, "Error", "Error code: " & $errCode & @CRLF & "Error parsing parameters." & @CRLF & "Line number: " & $lineNo)
Case 3
MsgBox(1, "Error", "Error code: " & $errCode & @CRLF & "Cannot parse variables as parameters." & @CRLF & "Line number: " & $lineNo)
Case Else
MsgBox(1, "Error", "Error code: " & $errCode & @CRLF & "Error parsing AU3 file.")
EndSwitch
EndIf
EndFunc
Func _importAu3File()
Local $sFileName = FileOpenDialog("Import GUI from AU3 file?", $lfld, "AutoIt Gui Definitions (*.au3)", $FD_FILEMUSTEXIST)
If @error Then Return 1
Local $aFileData = FileReadToArray($sFileName)
If @error Then Return SetError(1)
Local $sFileData = FileRead($sFileName)
If @error Then Return SetError(1)
Local $objOutput, $oVariables = ObjCreate("Scripting.Dictionary")
Local $iLineCounter, $iCtrlCounter = -1, $aMatches, $aParams, $sCtrlType, $aParamMatches, $sStyles, $sScope
Local $sParam, $iTabParentIndex, $bIsChild, $iChildCounter = -1, $sJsonString, $iTabCounter = -1, $inTab, $inGroup, $iGroupParentIndex
Local $iBoxCommentLvl
For $sLine In $aFileData
$iLineCounter += 1
$sScope = ""
If StringRegExp($sLine, '(?im)^\s*(?:#comments-start|#cs)') Then
$iBoxCommentLvl += 1
ElseIf StringRegExp($sLine, '(?im)^\s*(?:#comments-end|#ce)') Then
$iBoxCommentLvl -= 1
EndIf
If $iBoxCommentLvl > 0 Then
ContinueLoop
EndIf
If StringRegExp($sLine, '(?im)^\s*;') Then
ContinueLoop
EndIf
Local $ctrlIndex, $fontWeight, $fontName
$aMatches = StringRegExp($sLine, '(?im)\s*(?:GUICtrlSetFont)\s*\((.+?),\s*(.+?)(?:,\s*(.+?))?(?:,\s*(?:.+?))?(?:,\s*"(.+?))?"\s*(?:,|\))', $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
If $aMatches[0] = "-1" Then
$ctrlIndex = $iCtrlCounter
Else
Local $sName = StringReplace($aMatches[0], "$", "")
If $oVariables.Exists($sName) Then
For $i = 0 To $iCtrlCounter
If Json_Get($objOutput, ".Controls[" & $i & "].Name") = $sName Then
$ctrlIndex = $i
ExitLoop
EndIf
Next
EndIf
EndIf
If UBound($aMatches) > 2 Then
$fontWeight = $aMatches[2]
Else
$fontWeight = 400
EndIf
If UBound($aMatches) > 3 Then
$fontName = $aMatches[3]
Else
$fontName = ""
EndIf
Json_Put($objOutput, ".Controls[" & $ctrlIndex & "].FontSize", $aMatches[1])
Json_Put($objOutput, ".Controls[" & $ctrlIndex & "].FontWeight", $fontWeight)
Json_Put($objOutput, ".Controls[" & $ctrlIndex & "].FontName", $fontName)
ContinueLoop
EndIf
$aMatches = StringRegExp($sLine, '(?im)\s*(?:GUICtrlSetBkColor)\s*\((.+?),\s*(.+?)\s*(?:,|\))', $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
If $aMatches[0] = "-1" Then
Json_Put($objOutput, ".Controls[" & $iCtrlCounter & "].Background", $aMatches[1])
Else
Local $sName = StringReplace($aMatches[0], "$", "")
If $oVariables.Exists($sName) Then
For $i = 0 To $iCtrlCounter
If Json_Get($objOutput, ".Controls[" & $i & "].Name") = $sName Then
Json_Put($objOutput, ".Controls[" & $i & "].Background", $aMatches[1])
ExitLoop
EndIf
Next
EndIf
EndIf
ContinueLoop
EndIf
$aMatches = StringRegExp($sLine, '(?im)\s*(?:GUICtrlSetColor)\s*\((.+?),\s*(.+?)\s*(?:,|\))', $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
If $aMatches[0] = "-1" Then
Json_Put($objOutput, ".Controls[" & $iCtrlCounter & "].Color", $aMatches[1])
Else
Local $sName = StringReplace($aMatches[0], "$", "")
If $oVariables.Exists($sName) Then
For $i = 0 To $iCtrlCounter
If Json_Get($objOutput, ".Controls[" & $i & "].Name") = $sName Then
Json_Put($objOutput, ".Controls[" & $i & "].Color", $aMatches[1])
ExitLoop
EndIf
Next
EndIf
EndIf
ContinueLoop
EndIf
$aMatches = StringRegExp($sLine, '(?im)^\s*(Global|Local)\s*(.+?)\s*(?:$|=)', $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
Local $aVars = StringSplit(StringReplace($aMatches[1], "$", ""), ",")
If @error Then
$oVariables.Item(StringReplace($aMatches[1], "$", "")) = $aMatches[0]
Else
For $i = 1 To $aVars[0]
$oVariables.Item(StringStripWS($aVars[$i], $STR_STRIPLEADING + $STR_STRIPTRAILING)) = $aMatches[0]
Next
EndIf
EndIf
$aMatches = StringRegExp($sLine, '(?i)(?:\s*?(Global|Local)?\s*?(?:\$(\S*?))?\s*?=)?\s*?(\S*?)\s*?\((.*)\)', $STR_REGEXPARRAYGLOBALMATCH)
If @error Then ContinueLoop
If $aMatches[2] = "GUICreate" Then
If $oVariables.Exists($aMatches[1]) Then
$sScope = $oVariables.Item($aMatches[1])
EndIf
If $aMatches[0] = "Global" Or $sScope = "Global" Then
Json_Put($objOutput, ".Main.Global", 1)
Else
Json_Put($objOutput, ".Main.Global", 0)
EndIf
Json_Put($objOutput, ".Main.Name", $aMatches[1])
$aParamMatches = StringRegExp($aMatches[3], '(?im)(.+?)(?:$|(?:,\s*(?:BitOR\()(.*?)\)(?:,\s*(?:BitOR)\((.*?)\))?))', $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$aParams = StringSplit($aParamMatches[0], ",")
If @error Then Return SetError(2, $iLineCounter)
If $aParams[0] > 5 Then
Else
If UBound($aParamMatches) > 1 Then
$aParams[0] = $aParams[0] + 1
ReDim $aParams[$aParams[0] + 1]
$aParams[$aParams[0]] = $aParamMatches[1]
EndIf
EndIf
Else
$aParams = StringSplit($aMatches[3], ",")
If @error Then Return SetError(2, $iLineCounter)
EndIf
Json_Put($objOutput, ".Main.Title", _removeQuotes(StringStripWS($aParams[1], $STR_STRIPLEADING + $STR_STRIPTRAILING)))
If $aParams[0] > 1 Then
$sParam = _FormatParameter($aParams[2])
If @error Then Return SetError(3, $iLineCounter)
Json_Put($objOutput, ".Main.Width", $sParam)
EndIf
If $aParams[0] > 2 Then
$sParam = _FormatParameter($aParams[3])
If @error Then Return SetError(3, $iLineCounter)
Json_Put($objOutput, ".Main.Height", $sParam)
EndIf
If $aParams[0] > 3 Then
$sParam = _FormatParameter($aParams[4])
If @error Then Return SetError(3, $iLineCounter)
Json_Put($objOutput, ".Main.Left", $sParam)
EndIf
If $aParams[0] > 4 Then
$sParam = _FormatParameter($aParams[5])
If @error Then Return SetError(3, $iLineCounter)
Json_Put($objOutput, ".Main.Top", $sParam)
EndIf
If $aParams[0] > 5 Then
$sParam = _FormatParameter($aParams[6])
Json_Put($objOutput, ".Main.styleString", $sParam)
EndIf
ElseIf $aMatches[2] = "GUICtrlCreateTab" Then
$iCtrlCounter += 1
$sCtrlType = "Tab"
$iTabParentIndex = $iCtrlCounter
$iTabCounter = -1
Json_Put($objOutput, ".Controls[" & $iCtrlCounter & "].Type", $sCtrlType)
If $oVariables.Exists($aMatches[1]) Then
$sScope = $oVariables.Item($aMatches[1])
EndIf
If $aMatches[0] = "Global" Or $sScope = "Global" Then
Json_Put($objOutput, ".Controls[" & $iCtrlCounter & "].Global", 1)
Else
Json_Put($objOutput, ".Controls[" & $iCtrlCounter & "].Global", 0)
EndIf
Json_Put($objOutput, ".Controls[" & $iCtrlCounter & "].Name", $aMatches[1])
$aParamMatches = StringRegExp($aMatches[3], '(?im)(.+?)(?:$|(?:,\s*(?:BitOR\()(.*?)\)(?:,\s*(?:BitOR)\((.*?)\))?))', $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$aParams = StringSplit($aParamMatches[0], ",")
If @error Then Return SetError(2, $iLineCounter)
If $aParams[0] > 4 Then
Else
If UBound($aParamMatches) > 1 Then
$aParams[0] = $aParams[0] + 1
ReDim $aParams[$aParams[0] + 1]
$aParams[$aParams[0]] = $aParamMatches[1]
EndIf
EndIf
Else
$aParams = StringSplit($aMatches[3], ",")
If @error Then Return SetError(2, $iLineCounter)
EndIf
If $aParams[0] < 2 Then
Return SetError(2, $iLineCounter)
EndIf
$sParam = _FormatParameter($aParams[1])
If @error Then Return SetError(3, $iLineCounter)
Json_Put($objOutput, ".Controls[" & $iCtrlCounter & "].Left", $sParam)
$sParam = _FormatParameter($aParams[2])
If @error Then Return SetError(3, $iLineCounter)
Json_Put($objOutput, ".Controls[" & $iCtrlCounter & "].Top", $sParam)
If $aParams[0] > 2 Then
$sParam = _FormatParameter($aParams[3])
If @error Then Return SetError(3, $iLineCounter)
Json_Put($objOutput, ".Controls[" & $iCtrlCounter & "].Width", $sParam)
EndIf
If $aParams[0] > 3 Then
$sParam = _FormatParameter($aParams[4])
If @error Then Return SetError(3, $iLineCounter)
Json_Put($objOutput, ".Controls[" & $iCtrlCounter & "].Height", $sParam)
EndIf
If $aParams[0] > 4 Then
$sParam = _FormatParameter($aParams[6])
Json_Put($objOutput, ".Controls[" & $iCtrlCounter & "].styleString", $sParam)
EndIf
Json_Put($objOutput, ".Controls[" & $iCtrlCounter & "].Locked", False)
Json_Put($objOutput, ".Controls[" & $iCtrlCounter & "].TabCount", 0)
ElseIf $aMatches[2] = "GUICtrlCreateTabItem" Then
If $iTabParentIndex > -1 Then
If _removeQuotes($aMatches[3]) = "" Then
$inTab = False
ContinueLoop
Else
$inTab = True
$iTabCounter += 1
$iChildCounter = -1
Json_Put($objOutput, ".Controls[" & $iTabParentIndex & "].TabCount", $iTabCounter + 1)
Json_Put($objOutput, ".Controls[" & $iTabParentIndex & "].Tabs[" & $iTabCounter & "].Type", "TabItem")
Json_Put($objOutput, ".Controls[" & $iTabParentIndex & "].Tabs[" & $iTabCounter & "].Name", $aMatches[1])
Json_Put($objOutput, ".Controls[" & $iTabParentIndex & "].Tabs[" & $iTabCounter & "].Text", _removeQuotes($aMatches[3]))
EndIf
Else
ContinueLoop
EndIf
Else
If $aMatches[2] = "GUICtrlCreateButton" Then
$sCtrlType = "Button"
ElseIf $aMatches[2] = "GUICtrlCreateLabel" Then
$sCtrlType = "Label"
ElseIf $aMatches[2] = "GUICtrlCreateCheckbox" Then
$sCtrlType = "Checkbox"
ElseIf $aMatches[2] = "GUICtrlCreateRadio" Then
$sCtrlType = "Radio"
ElseIf $aMatches[2] = "GUICtrlCreateList" Then
$sCtrlType = "List"
ElseIf $aMatches[2] = "GUICtrlCreateInput" Then
$sCtrlType = "Input"
ElseIf $aMatches[2] = "GUICtrlCreateEdit" Then
$sCtrlType = "Edit"
ElseIf $aMatches[2] = "GUICtrlCreateListView" Then
$sCtrlType = "ListView"
ElseIf $aMatches[2] = "GUICtrlCreateDate" Then
$sCtrlType = "Date"
ElseIf $aMatches[2] = "GUICtrlCreateCombo" Then
$sCtrlType = "Combo"
ElseIf $aMatches[2] = "GUICtrlCreateGroup" Then
$sCtrlType = "Group"
$inGroup = True
Else
ContinueLoop
EndIf
If $iTabParentIndex > -1 And $inTab Then
$iChildCounter += 1
$sJsonString = ".Controls[" & $iTabParentIndex & "].Tabs[" & $iTabCounter & "].Controls[" & $iChildCounter & "]"
Else
If Not $inGroup Then
$iCtrlCounter += 1
EndIf
$sJsonString = ".Controls[" & $iCtrlCounter & "]"
EndIf
If $inGroup Then
If $sCtrlType = "Group" Then
Local $aGroupParams = StringSplit($aMatches[3], ",")
If @error Then Return SetError(2, $iLineCounter)
If $aGroupParams[0] < 3 Then Return SetError(2, $iLineCounter)
If _FormatParameter($aGroupParams[2]) = -99 And _FormatParameter($aGroupParams[3]) = -99 Then
$inGroup = False
ContinueLoop
Else
$iCtrlCounter += 1
$iGroupParentIndex = $iCtrlCounter
$iChildCounter = -1
$sJsonString = ".Controls[" & $iGroupParentIndex & "]"
EndIf
Else
$iChildCounter += 1
$sJsonString = ".Controls[" & $iGroupParentIndex & "].Controls[" & $iChildCounter & "]"
EndIf
EndIf
Json_Put($objOutput, $sJsonString & ".Type", $sCtrlType)
If $oVariables.Exists($aMatches[1]) Then
$sScope = $oVariables.Item($aMatches[1])
EndIf
If $aMatches[0] = "Global" Or $sScope = "Global" Then
Json_Put($objOutput, $sJsonString & ".Global", 1)
Else
Json_Put($objOutput, $sJsonString & ".Global", 0)
EndIf
Json_Put($objOutput, $sJsonString & ".Name", $aMatches[1])
$aParamMatches = StringRegExp($aMatches[3], '(?im)(.+?)(?:$|(?:,\s*(?:BitOR\()(.*?)\)(?:,\s*(?:BitOR)\((.*?)\))?))', $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$aParams = StringSplit($aParamMatches[0], ",")
If @error Then Return SetError(2, $iLineCounter)
If $aParams[0] > 5 Then
Else
If UBound($aParamMatches) > 1 Then
$aParams[0] = $aParams[0] + 1
ReDim $aParams[$aParams[0] + 1]
$aParams[$aParams[0]] = $aParamMatches[1]
EndIf
EndIf
Else
$aParams = StringSplit($aMatches[3], ",")
If @error Then Return SetError(2, $iLineCounter)
EndIf
Json_Put($objOutput, $sJsonString & ".Text", _removeQuotes(StringStripWS($aParams[1], $STR_STRIPLEADING + $STR_STRIPTRAILING)))
If $aParams[0] < 3 Then
Return SetError(2, $iLineCounter)
EndIf
If $aParams[0] > 1 Then
$sParam = _FormatParameter($aParams[2])
If @error Then Return SetError(3, $iLineCounter)
Json_Put($objOutput, $sJsonString & ".Left", $sParam)
EndIf
If $aParams[0] > 2 Then
$sParam = _FormatParameter($aParams[3])
If @error Then Return SetError(3, $iLineCounter)
Json_Put($objOutput, $sJsonString & ".Top", $sParam)
EndIf
If $aParams[0] > 3 Then
$sParam = _FormatParameter($aParams[4])
If @error Then Return SetError(3, $iLineCounter)
Json_Put($objOutput, $sJsonString & ".Width", $sParam)
EndIf
If $aParams[0] > 4 Then
$sParam = _FormatParameter($aParams[5])
If @error Then Return SetError(3, $iLineCounter)
Json_Put($objOutput, $sJsonString & ".Height", $sParam)
EndIf
If $aParams[0] > 5 Then
$sParam = _FormatParameter($aParams[6])
Json_Put($objOutput, $sJsonString & ".styleString", $sParam)
EndIf
Json_Put($objOutput, $sJsonString & ".Locked", False)
EndIf
Next
Json_Put($objOutput, ".Main.numctrls", $iCtrlCounter + 1)
Return $objOutput
EndFunc
Func _FormatParameter($sParam)
$sParam = StringStripWS($sParam, $STR_STRIPLEADING + $STR_STRIPTRAILING)
If ($sParam = "0") Or (Number($sParam) <> 0) Then
Return $sParam
Else
Return SetError(1, 0, $sParam)
EndIf
EndFunc
Func _removeQuotes($sParam)
Local $sRet = StringRegExpReplace($sParam, '["' & "'" & ']', "")
If @error Then Return $sParam
Return $sRet
EndFunc
Func _code_generation()
Local $controls, $controlEvents, $globals[2]
Local $bAddDpiScale = False
Local $bOnEventMode = $oOptions.eventMode
Local $bGuiFunction = $oOptions.guiInFunction
Local $sDpiScale = ""
If $bAddDpiScale Then
$sDpiScale = " * $fDpiFactor"
EndIf
Local $regionStart = "#Region (=== GUI generated by " & $oMain.AppName & " " & $oMain.AppVersion & " ===)"
Local $regionEnd = "#EndRegion (=== GUI generated by " & $oMain.AppName & " " & $oMain.AppVersion & " ===)"
Local $includes = "" &  "#include <GUIConstantsEx.au3>" & @CRLF &  "#include <WindowsConstants.au3>"
If $bAddDpiScale Then
$includes &= @CRLF & "#include <GDIPlus.au3>"
EndIf
If $oMain.Name <> "" Then
$globals[0] = "Global $" & $oMain.Name & @CRLF
Else
$globals[0] = ""
EndIf
$globals[1] = "Global "
Local $globalsIndex = 1
Local $aCtrlCode
For $oCtrl In $oCtrls.ctrls.Items()
If (($oCtrl.Name <> "") And ($oCtrl.Global = $GUI_CHECKED)) Or (Not $bOnEventMode And $bGuiFunction And $oCtrl.CodeString <> "") Then
If StringLen($globals[$globalsIndex]) > 100 Then
$globals[$globalsIndex] = StringTrimRight($globals[$globalsIndex], 2) & @CRLF
$globalsIndex += 1
ReDim $globals[$globalsIndex + 1]
$globals[$globalsIndex] = "Global "
EndIf
$globals[$globalsIndex] &= "$" & $oCtrl.Name & ", "
EndIf
$includes &= _generate_includes($oCtrl, $includes)
$aCtrlCode = _generate_controls($controls, $oCtrl, $sDpiScale, False, $bOnEventMode, Not $bOnEventMode And $bGuiFunction And $oCtrl.CodeString <> "")
$controls &= $aCtrlCode[0]
$controlEvents &= $aCtrlCode[1]
Next
If $globals[$globalsIndex] = "Global " Then
$globals[$globalsIndex] = ""
Else
$globals[$globalsIndex] = StringTrimRight($globals[$globalsIndex], 2) & @CRLF
EndIf
Local $FuncMain = _getFuncMain($bOnEventMode, $bGuiFunction)
Local $FuncOnEventMode = _getFuncOnExit()
Local $FuncDpiScaling = _getFuncDpiScaling()
Local $gdtitle = _get_script_title()
If $oMain.Title <> "" Then
$gdtitle = $oMain.Title
EndIf
Local $w = $oMain.Width
If $w <> -1 Then
$w &= $sDpiScale
EndIf
Local $h = $oMain.Height
If $oCtrls.hasMenu Then
$h = $h + _WinAPI_GetSystemMetrics($SM_CYMENU)
EndIf
If $h <> -1 Then
$h &= $sDpiScale
EndIf
Local $x = $oMain.Left
If $x <> -1 Then
$x &= $sDpiScale
EndIf
Local $y = $oMain.Top
If $y <> -1 Then
$y &= $sDpiScale
EndIf
Local $setOnEvent = ""
If $bOnEventMode Then
$setOnEvent = 'GUISetOnEvent($GUI_EVENT_CLOSE, "_onExitMain")' & @CRLF
EndIf
Local $background = ""
If $oMain.Background <> -1 And $oMain.Background <> "" Then
$background = "GUISetBkColor(0x" & Hex($oMain.Background, 6) & ")" & @CRLF
Else
$background = ""
EndIf
Local $code = ""
If $bAddDpiScale Then
$code &= "#AutoIt3Wrapper_Res_HiDpi=y" & @CRLF & @CRLF
EndIf
If $bOnEventMode Then
$code &= 'Opt("GUIOnEventMode", 1)' & @CRLF & @CRLF
EndIf
$code &= $includes & @CRLF & @CRLF
If $bAddDpiScale Then
$code &= "Global $fDpiFactor = _GDIPlus_GraphicsGetDPIRatio()" & @CRLF & @CRLF
EndIf
$code &= $regionStart & @CRLF
If $bGuiFunction Then
For $line In $globals
$code &= $line
Next
$code &= @CRLF
Local $mDocData = _objDocData()
$mDocData.name = "_guiCreate"
$mDocData.description = "Create the main GUI"
$code &= _functionDoc($mDocData) & @CRLF
$code &= "Func _guiCreate()" & @CRLF
EndIf
Local $guiBodyCode = ""
Local $guiStyle = $oMain.styleString
If StringInStr($guiStyle, ",") Then
$guiStyle = "BitOR(" & $guiStyle & ")"
EndIf
If $guiStyle <> "" Then
$guiStyle = ", " & $guiStyle
EndIf
If $oMain.Name = "" Then
$guiBodyCode &= 'GUICreate("' & $gdtitle & '", ' & $w & ", " & $h & ", " & $x & ", " & $y & $guiStyle & ")" & @CRLF
Else
$guiBodyCode &= "Global $" & $oMain.Name & ' = GUICreate("' & $gdtitle & '", ' & $w & ", " & $h & ", " & $x & ", " & $y & $guiStyle & ")" & @CRLF
EndIf
$guiBodyCode &= $setOnEvent &  $background &  @CRLF & $controls
If $controlEvents <> "" Then
$guiBodyCode &= @CRLF & $controlEvents
EndIf
If $bGuiFunction Then
$guiBodyCode = StringReplace($guiBodyCode, "Global ", "")
$guiBodyCode = @TAB & StringReplace($guiBodyCode, @CRLF, @CRLF & @TAB)
$guiBodyCode = StringTrimRight($guiBodyCode, 1)
$guiBodyCode &= "EndFunc   ;==>_guiCreate" & @CRLF
EndIf
$code &= $guiBodyCode &  $regionEnd & @CRLF & @CRLF &  $FuncMain & @CRLF & @CRLF
If $bOnEventMode Then
$code &= @CRLF & $FuncOnEventMode
EndIf
If $bAddDpiScale Then
$code &= @CRLF & $FuncDpiScaling
EndIf
If $bOnEventMode Then
For $oCtrl In $oCtrls.ctrls.Items()
If $oCtrl.CodeString = "" Then ContinueLoop
$code &= @CRLF & _getFuncCtrl($oCtrl)
Next
EndIf
Return $code
EndFunc
Func _functionDoc($mDocData)
If Not IsObj($mDocData) Then Return ""
Local $sFileData = FileRead(@ScriptDir & "\storage\templateFunctionDoc.au3")
If @error Then Return ""
$sFileData = StringRegExpReplace($sFileData, "\%\%name\%\%", $mDocData.name)
$sFileData = StringRegExpReplace($sFileData, "\%\%description\%\%", $mDocData.description)
Return $sFileData
EndFunc
Func _generate_controls(ByRef $sControls, Const $oCtrl, $sDpiScale, $isChild = False, $bOnEventMode = False, $useCodeString = False)
Local $aRet[2] = ["", ""]
If $oCtrl.Type = "TabItem" Then Return $aRet
If Not $isChild And $oCtrl.CtrlParent <> 0 Then Return $aRet
Local $left = $oCtrl.Left
If $left <> -1 Then
$left &= $sDpiScale
EndIf
Local $top = $oCtrl.Top
If $top <> -1 Then
$top &= $sDpiScale
EndIf
Local $width = $oCtrl.Width
If $width <> -1 Then
$width &= $sDpiScale
EndIf
Local $height = $oCtrl.Height
If $height <> -1 Then
$height &= $sDpiScale
EndIf
Local Const $ltwh = $left & ", " & $top & ", " & $width & ", " & $height
Local $ctrlStyle = $oCtrl.styleString
If StringInStr($ctrlStyle, ",") Then
$ctrlStyle = "BitOR(" & $ctrlStyle & ")"
EndIf
If $ctrlStyle <> "" Then
$ctrlStyle = ", " & $ctrlStyle
EndIf
Local $mControls = ""
Local $sEvents = ""
Local $scopeString = "Local"
If ($oCtrl.Global = $GUI_CHECKED) Or $useCodeString Then $scopeString = "Global"
Switch $oCtrl.Type
Case "Tab", "Group"
If $sControls <> "" And Not (StringRight($sControls, 4) = (@CRLF & @CRLF)) Then
$mControls &= @CRLF
EndIf
EndSwitch
Switch StringStripWS($oCtrl.Name, $STR_STRIPALL) <> ''
Case True
$mControls &= $scopeString & " $" & $oCtrl.Name & " = "
EndSwitch
Switch $oCtrl.Type
Case "Progress", "Slider", "TreeView"
$mControls &= "GUICtrlCreate" & $oCtrl.Type & '(' & $ltwh & $ctrlStyle & ')' & @CRLF
Case "Icon"
$mControls &= "GUICtrlCreate" & $oCtrl.Type & '("", -1, ' & $ltwh & $ctrlStyle & ')' & @CRLF
$mControls &= "GUICtrlSetImage(-1, " & '"' & $oCtrl.Img & '")' & @CRLF
Case "Tab"
$mControls &= "GUICtrlCreate" & $oCtrl.Type & '(' & $ltwh & $ctrlStyle & ')' & @CRLF
Local $oTab, $aCtrlCode
For $hTab In $oCtrl.Tabs
$oTab = $oCtrls.get($hTab)
$mControls &= $scopeString & " $" & $oTab.Name & " = "
$mControls &= 'GUICtrlCreateTabItem("' & $oTab.Text & '")' & @CRLF
For $oTabCtrl In $oTab.ctrls.Items()
$aCtrlCode = _generate_controls($sControls, $oTabCtrl, $sDpiScale, True, $bOnEventMode, $useCodeString)
$mControls &= $aCtrlCode[0]
$sEvents &= $aCtrlCode[1]
Next
Next
$mControls &= 'GUICtrlCreateTabItem("")' & @CRLF & @CRLF
Case "Updown"
$mControls &= "GUICtrlCreateInput" & '("' & $oCtrl.Text & '", ' & $ltwh & ')' & @CRLF
$mControls &= "GUICtrlCreateUpdown(-1" & $ctrlStyle & ")" & @CRLF
Case "Pic"
$mControls &= "GUICtrlCreate" & $oCtrl.Type & '("", ' & $ltwh & $ctrlStyle & ')' & @CRLF
$mControls &= "GUICtrlSetImage(-1, " & '"' & $oCtrl.Img & '")' & @CRLF
Case "Avi"
$mControls &= "GUICtrlCreate" & $oCtrl.Type & '("' & $oCtrl.Img & '", 0, ' & $ltwh & $ctrlStyle & ')' & @CRLF
Case "Menu"
$mControls &= "GUICtrlCreate" & $oCtrl.Type & '("' & $oCtrl.Text & '")' & @CRLF
For $oMenuItem In $oCtrl.MenuItems
$mControls &= $scopeString & " $" & $oMenuItem.Name & " = "
$mControls &= 'GUICtrlCreateMenuItem("' & $oMenuItem.Text & '", $' & $oCtrl.Name & ')' & @CRLF
Next
Case "IP"
$mControls &= "_GUICtrlIpAddress_Create" & '($' & $oMain.Name & ', ' & $ltwh & $ctrlStyle & ')' & @CRLF
$mControls &= "_GUICtrlIpAddress_Set($" & $oCtrl.Name & ', "' & $oCtrl.Text & '")' & @CRLF
Case "Group"
$mControls &= "GUICtrlCreate" & $oCtrl.Type & '("' & $oCtrl.Text & '", ' & $ltwh & $ctrlStyle & ')' & @CRLF
Local $aCtrlCode
For $oGroupCtrl In $oCtrl.ctrls.Items()
$aCtrlCode = _generate_controls($sControls, $oGroupCtrl, $sDpiScale, True, $bOnEventMode, $useCodeString)
$mControls &= $aCtrlCode[0]
$sEvents &= $aCtrlCode[1]
Next
$mControls &= 'GUICtrlCreateGroup("", -99, -99, 1, 1)' & @CRLF & @CRLF
Case "List"
If $oCtrl.Items <> "" Then
$mControls &= "GUICtrlCreate" & $oCtrl.Type & '("", ' & $ltwh & $ctrlStyle & ')' & @CRLF
$mControls &= 'GuiCtrlSetData(-1, "' & $oCtrl.Items & '")' & @CRLF
Else
$mControls &= "GUICtrlCreate" & $oCtrl.Type & '("' & $oCtrl.Text & '", ' & $ltwh & $ctrlStyle & ')' & @CRLF
EndIf
Case "Combo"
If $oCtrl.Items <> "" Then
$mControls &= "GUICtrlCreate" & $oCtrl.Type & '("", ' & $ltwh & $ctrlStyle & ')' & @CRLF
$mControls &= 'GuiCtrlSetData(-1, "' & $oCtrl.Items & '")' & @CRLF
Else
$mControls &= "GUICtrlCreate" & $oCtrl.Type & '("' & $oCtrl.Text & '", ' & $ltwh & $ctrlStyle & ')' & @CRLF
EndIf
Case "Rect"
$mControls &= 'GUICtrlCreateGraphic(' & $ltwh & $ctrlStyle & ')' & @CRLF
Local $border, $back
If $oCtrl.BorderColor <> -1 Then
$border = '0x' & Hex($oCtrl.BorderColor, 6)
Else
$border = '0x000000'
EndIf
If $oCtrl.background <> -1 Then
$back = ', 0x' & Hex($oCtrl.background, 6)
Else
$back = ''
EndIf
$mControls &= 'GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, ' & $oCtrl.BorderSize & ')' & @CRLF
$mControls &= 'GUICtrlSetGraphic(-1, $GUI_GR_COLOR, ' & $border & $back & ')' & @CRLF
$mControls &= 'GUICtrlSetGraphic(-1, $GUI_GR_RECT, 0, 0, ' & $oCtrl.Width & ', ' & $oCtrl.Height & ')' & @CRLF
Case "Ellipse"
$mControls &= 'GUICtrlCreateGraphic(' & $ltwh & $ctrlStyle & ')' & @CRLF
Local $border, $back
If $oCtrl.BorderColor <> -1 Then
$border = '0x' & Hex($oCtrl.BorderColor, 6)
Else
$border = '0x000000'
EndIf
If $oCtrl.background <> -1 Then
$back = ', 0x' & Hex($oCtrl.background, 6)
Else
$back = ''
EndIf
$mControls &= 'GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, ' & $oCtrl.BorderSize & ')' & @CRLF
$mControls &= 'GUICtrlSetGraphic(-1, $GUI_GR_COLOR, ' & $border & $back & ')' & @CRLF
$mControls &= 'GUICtrlSetGraphic(-1, $GUI_GR_ELLIPSE, 0, 0, ' & $oCtrl.Width & ', ' & $oCtrl.Height & ')' & @CRLF
Case "Line"
$mControls &= 'GUICtrlCreateGraphic(' & $ltwh & $ctrlStyle & ')' & @CRLF
Local $border
If $oCtrl.BorderColor <> -1 Then
$border = '0x' & Hex($oCtrl.BorderColor, 6)
Else
$border = '0x000000'
EndIf
$mControls &= 'GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, ' & $oCtrl.BorderSize & ')' & @CRLF
$mControls &= 'GUICtrlSetGraphic(-1, $GUI_GR_COLOR, ' & $border & ')' & @CRLF
$mControls &= 'GUICtrlSetGraphic(-1, $GUI_GR_MOVE, ' & $oCtrl.Coord1[0] & ', ' & $oCtrl.Coord1[1] & ')' & @CRLF
$mControls &= 'GUICtrlSetGraphic(-1, $GUI_GR_LINE, ' & $oCtrl.Coord2[0] & ', ' & $oCtrl.Coord2[1] & ')' & @CRLF
Case Else
$mControls &= "GUICtrlCreate" & $oCtrl.Type & '("' & $oCtrl.Text & '", ' & $ltwh & $ctrlStyle & ')' & @CRLF
EndSwitch
If $bOnEventMode Then
If $oCtrl.CodeString <> "" Then
$sEvents &= 'GUICtrlSetOnEvent($' & $oCtrl.Name & ', "_on' & $oCtrl.Name & '")' & @CRLF
EndIf
EndIf
If ($oCtrl.FontSize <> "" And $oCtrl.FontSize <> -1 And $oCtrl.FontSize <> 8.5) Or $oCtrl.FontWeight <> 400 Or $oCtrl.FontName <> "" Then
Local $iFs, $sFw = "", $sFn = ""
If $oCtrl.FontName <> "" Then
$sFn = ', "' & $oCtrl.FontName & '"'
EndIf
If $oCtrl.FontWeight <> 400 Then
$sFw = ", " & $oCtrl.FontWeight
EndIf
If $oCtrl.FontSize = "" Or $oCtrl.FontSize = -1 Then
$iFs = 8.5
Else
$iFs = $oCtrl.FontSize
EndIf
If $oCtrl.Type = "IP" Then
If $sFn = "" Then
$sFn = ', "Arial"'
EndIf
$mControls &= '_GUICtrlIpAddress_SetFont($' & $oCtrl.Name & $sFn & ', ' & $iFs & $sFw & ')' & @CRLF
Else
If $sFn <> "" Then
$sFn = ', $GUI_FONTNORMAL' & $sFn
If $sFw = "" Then
$sFn = ', 400' & $sFn
EndIf
EndIf
$mControls &= 'GUICtrlSetFont(-1, ' & $iFs & $sFw & $sFn & ')' & @CRLF
EndIf
EndIf
If $oCtrl.Color <> -1 Then
$mControls &= "GUICtrlSetColor(-1, 0x" & Hex($oCtrl.Color, 6) & ")" & @CRLF
EndIf
If $oCtrl.Background <> -1 Then
Switch $oCtrl.Type
Case "Rect", "Ellipse", "Line"
Case Else
$mControls &= "GUICtrlSetBkColor(-1, 0x" & Hex($oCtrl.Background, 6) & ")" & @CRLF
EndSwitch
EndIf
$aRet[0] = $mControls
$aRet[1] = $sEvents
Return $aRet
EndFunc
Func _generate_includes(Const $oCtrl, Const $includes)
If StringInStr($oCtrl.styleString, "BS_") Then
If Not StringInStr($includes, "<ButtonConstants.au3>") Then
Return @CRLF & "#include <ButtonConstants.au3>"
EndIf
EndIf
If StringInStr($oCtrl.styleString, "CBS_") Then
If Not StringInStr($includes, "<ComboConstants.au3>") Then
Return @CRLF & "#include <ComboConstants.au3>"
EndIf
EndIf
If StringInStr($oCtrl.styleString, "LBS_") Then
If Not StringInStr($includes, "<ListBoxConstants.au3>") Then
Return @CRLF & "#include <ListBoxConstants.au3>"
EndIf
EndIf
If StringInStr($oCtrl.styleString, "ES_") Then
If Not StringInStr($includes, "<EditConstants.au3>") Then
Return @CRLF & "#include <EditConstants.au3>"
EndIf
EndIf
If StringInStr($oCtrl.styleString, "PBS_") Then
If Not StringInStr($includes, "<EditConstants.au3>") Then
Return @CRLF & "#include <EditConstants.au3>"
EndIf
EndIf
If StringInStr($oCtrl.styleString, "ES_") Then
If Not StringInStr($includes, "<ProgressConstants.au3>") Then
Return @CRLF & "#include <ProgressConstants.au3>"
EndIf
EndIf
If StringInStr($oCtrl.styleString, "UDS_") Then
If Not StringInStr($includes, "<UpDownConstants.au3>") Then
Return @CRLF & "#include <UpDownConstants.au3>"
EndIf
EndIf
If StringInStr($oCtrl.styleString, "SS_") Then
If Not StringInStr($includes, "<StaticConstants.au3>") Then
Return @CRLF & "#include <StaticConstants.au3>"
EndIf
EndIf
If StringInStr($oCtrl.styleString, "TCS_") Then
If Not StringInStr($includes, "<TabConstants.au3>") Then
Return @CRLF & "#include <TabConstants.au3>"
EndIf
EndIf
If StringInStr($oCtrl.styleString, "ACS_") Then
If Not StringInStr($includes, "<AVIConstants.au3>") Then
Return @CRLF & "#include <AVIConstants.au3>"
EndIf
EndIf
If StringInStr($oCtrl.styleString, "DTS_") Or StringInStr($oCtrl.styleString, "MCS_") Then
If Not StringInStr($includes, "<DateTimeConstants.au3>") Then
Return @CRLF & "#include <DateTimeConstants.au3>"
EndIf
EndIf
If StringInStr($oCtrl.styleString, "TVS_") Then
If Not StringInStr($includes, "<TreeViewConstants.au3>") Then
Return @CRLF & "#include <TreeViewConstants.au3>"
EndIf
EndIf
If StringInStr($oCtrl.styleString, "TBS_") Then
If Not StringInStr($includes, "<SliderConstants.au3>") Then
Return @CRLF & "#include <SliderConstants.au3>"
EndIf
EndIf
If StringInStr($oCtrl.styleString, "LVS_") Then
If Not StringInStr($includes, "<ListViewConstants.au3>") Then
Return @CRLF & "#include <ListViewConstants.au3>"
EndIf
EndIf
If $oCtrl.Type = "IP" Then
If Not StringInStr($includes, "<GuiIPAddress.au3>") Then
Return @CRLF & "#include <GuiIPAddress.au3>"
EndIf
EndIf
If $oCtrl.Type = "Avi" Then
If Not StringInStr($includes, "<AVIConstants.au3>") Then
Return @CRLF & "#include <AVIConstants.au3>"
EndIf
EndIf
Return ""
EndFunc
Func _save_code()
Local $code = _code_generation()
_copy_code_to_output($code)
EndFunc
Func _copy_code_to_output(Const $code)
Switch StringInStr($CmdLineRaw, "/StdOut")
Case True
_log("#region ; --- " & $oMain.AppName & " generated code Start ---" & @CRLF &  StringReplace($code, @CRLF, @LF) & @CRLF &  "#endregion ; --- " & $oMain.AppName & " generated code End ---")
Case False
If $mygui = "" Then
$mygui = "MyGUI.au3"
EndIf
Local Const $destination = FileSaveDialog("Save GUI to file?", "", "AutoIt (*.au3)", BitOR($FD_FILEMUSTEXIST, $FD_PATHMUSTEXIST, $FD_PROMPTOVERWRITE), $mygui)
If @error = 1 Or Not $destination Then
ClipPut($code)
$bStatusNewMessage = True
_GUICtrlStatusBar_SetText($hStatusbar, "Script copied to clipboard")
Else
FileDelete($destination)
FileWrite($destination, $code)
$bStatusNewMessage = True
_GUICtrlStatusBar_SetText($hStatusbar, "Saved to file")
EndIf
EndSwitch
EndFunc
Func _getFuncMain($bOnEventMode, $bGuiFunction)
Local $mDocData = _objDocData()
$mDocData.name = "_main"
$mDocData.description = "run the main program loop"
Local $FuncDoc = _functionDoc($mDocData) & @CRLF
Local $code = '' &  "_main()" & @CRLF & @CRLF &  $FuncDoc &  "Func _main()" & @CRLF
If $bGuiFunction Then
$code &= @TAB & "_guiCreate()" & @CRLF
EndIf
$code &= @TAB & "GUISetState(@SW_SHOWNORMAL)" & @CRLF & @CRLF &  @TAB & "While 1" & @CRLF
If Not $bOnEventMode Then
$code &= '' &  @TAB & @TAB & "Switch GUIGetMsg()" & @CRLF &  @TAB & @TAB & @TAB & "Case $GUI_EVENT_CLOSE" & @CRLF &  @TAB & @TAB & @TAB & @TAB & "ExitLoop" & @CRLF & @CRLF
For $oCtrl In $oCtrls.ctrls.Items()
If $oCtrl.CodeString <> "" Then
$code &= '' &  @TAB & @TAB & @TAB & "Case $" & $oCtrl.Name & @CRLF &  @TAB & @TAB & @TAB & @TAB & _formatCodeString($oCtrl.CodeString) & @CRLF & @CRLF
EndIf
Next
$code &= '' &  @TAB & @TAB & @TAB & "Case Else" & @CRLF &  @TAB & @TAB & @TAB & @TAB & ";" & @CRLF &  @TAB & @TAB & "EndSwitch" & @CRLF
Else
$code &= '' &  @TAB & @TAB & "Sleep(100)" & @CRLF
EndIf
$code &= '' &  @TAB & "WEnd" & @CRLF &  "EndFunc   ;==>_main"
Return $code
EndFunc
Func _getFuncOnExit()
Local $mDocData = _objDocData()
$mDocData.name = "_onExitMain"
$mDocData.description = "Clean up and exit the program"
Local $FuncDoc = _functionDoc($mDocData) & @CRLF
Local $code = '' &  $FuncDoc &  'Func _onExitMain()' & @CRLF &  @TAB & 'GUIDelete()' & @CRLF &  @TAB & 'Exit' & @CRLF &  'EndFunc   ;==>_onExitMain' & @CRLF
Return $code
EndFunc
Func _getFuncDpiScaling()
Local $code = '' &  ';------------------------------------------------------------------------------' & @CRLF &  '; Name ..........: _GDIPlus_GraphicsGetDPIRatio' & @CRLF &  '; Description ...:' & @CRLF &  '; Syntax ........: _GDIPlus_GraphicsGetDPIRatio([$iDPIDef = 96])' & @CRLF &  '; Parameters ....: $iDPIDef             - [optional] An integer value. Default is 96.' & @CRLF &  '; Return values .: Scaling value for control sizes and positions' & @CRLF &  '; Author ........: UEZ' & @CRLF &  '; Modified by....: KurtyKurtyBoy' & @CRLF &  '; Link ..........: http://www.autoitscript.com/forum/topic/159612-dpi-resolution-problem/?hl=%2Bdpi#entry1158317' & @CRLF &  ';------------------------------------------------------------------------------' & @CRLF &  'Func _GDIPlus_GraphicsGetDPIRatio($iDPIDef = 96)' & @CRLF &  @TAB & '_GDIPlus_Startup()' & @CRLF &  @TAB & 'Local $hGfx = _GDIPlus_GraphicsCreateFromHWND(0)' & @CRLF &  @TAB & 'If @error Then Return SetError(1, @extended, 0)' & @CRLF &  @TAB & 'Local $aResult' & @CRLF &  @TAB & '#forcedef $__g_hGDIPDll, $ghGDIPDll' & @CRLF &  @CRLF &  @TAB & '$aResult = DllCall($__g_hGDIPDll, "int", "GdipGetDpiX", "handle", $hGfx, "float*", 0)' & @CRLF &  @CRLF &  @TAB & 'If @error Then Return SetError(2, @extended, 0)' & @CRLF &  @TAB & 'Local $iDPI = $aResult[2]' & @CRLF &  @TAB & 'Local $aresults[2] = [$iDPIDef / $iDPI, $iDPI / $iDPIDef]' & @CRLF &  @TAB & '_GDIPlus_GraphicsDispose($hGfx)' & @CRLF &  @TAB & '_GDIPlus_Shutdown()' & @CRLF &  @CRLF &  @TAB & 'Return $aresults[1]' & @CRLF &  'EndFunc   ;==>_GDIPlus_GraphicsGetDPIRatio' & @CRLF
Return $code
EndFunc
Func _objDocData()
Local $oObject = _AutoItObject_Create()
_AutoItObject_AddProperty($oObject, "name", $ELSCOPE_PUBLIC, "")
_AutoItObject_AddProperty($oObject, "description", $ELSCOPE_PUBLIC, "")
Return $oObject
EndFunc
Func _getFuncCtrl($oCtrl)
Local $sCodeString = _formatCodeString($oCtrl.CodeString)
If $sCodeString = "" Then Return ""
Local $mDocData = _objDocData()
$mDocData.name = "_on" & $oCtrl.Name
$mDocData.description = ""
Local $FuncDoc = _functionDoc($mDocData) & @CRLF
Local $code = '' &  $FuncDoc &  "Func _on" & $oCtrl.Name & "()" & @CRLF
$code &= @TAB & _formatCodeString($oCtrl.CodeString) & @CRLF
$code &= '' &  "EndFunc   ;==>_on" & $oCtrl.Name & @CRLF
Return $code
EndFunc
Func _formatCodeString($sCodeString)
Local $sNewString
$sNewString = StringReplace($sCodeString, @CRLF, @CRLF & @TAB & @TAB & @TAB & @TAB)
Return $sNewString
EndFunc
Func _formMain()
Local $main_left = (@DesktopWidth / 2) - ($oMain.Width / 2)
Local $main_top = (@DesktopHeight / 2) - ($oMain.Height / 2)
Local $sPos = IniRead($sIniPath, "Settings", "posMain", $main_left & "," & $main_top)
Local $aPos = StringSplit($sPos, ",")
If Not @error Then
$main_left = $aPos[1]
$main_top = $aPos[2]
EndIf
Local $ixCoordMin = _WinAPI_GetSystemMetrics(76)
Local $iyCoordMin = _WinAPI_GetSystemMetrics(77)
Local $iFullDesktopWidth = _WinAPI_GetSystemMetrics(78)
Local $iFullDesktopHeight = _WinAPI_GetSystemMetrics(79)
If ($main_left + $oMain.Width) > ($ixCoordMin + $iFullDesktopWidth) Then
$main_left = $iFullDesktopWidth - $oMain.Width
ElseIf $main_left < $ixCoordMin Then
$main_left = 0
EndIf
If ($main_top + $oMain.Height) > ($iyCoordMin + $iFullDesktopHeight) Then
$main_top = $iFullDesktopHeight - $oMain.Height
ElseIf $main_top < $iyCoordMin Then
$main_top = 0
EndIf
$oMain.Left = $main_left
$oMain.Top = $main_top
$hFormHolder = GUICreate("GBP form holder", 10, 10, -1, -1, -1, -1, $hToolbar)
$hGUI = GUICreate($oMain.Title & " - Form (" & $oMain.Width & ", " & $oMain.Height & ')', $oMain.Width, $oMain.Height, $main_left, $main_top, BitOR($WS_SIZEBOX, $WS_CAPTION), BitOR($WS_EX_ACCEPTFILES, $WS_EX_COMPOSITED), $hFormHolder)
If Not @Compiled Then
GUISetIcon(@ScriptDir & '\resources\icons\icon.ico')
EndIf
_getGuiFrameSize()
WinMove($hGUI, "", Default, Default, $oMain.Width + $iGuiFrameW, $oMain.Height + $iGuiFrameH)
WinSetTitle($hGUI, "", $oMain.Title & " - Form (" & $oMain.Width & ", " & $oMain.Height & ")")
GUISetOnEvent($GUI_EVENT_CLOSE, "_onExitForm", $hGUI)
GUISetOnEvent($GUI_EVENT_RESIZED, "_onResize", $hGUI)
GUISetOnEvent($GUI_EVENT_PRIMARYDOWN, "_onMousePrimaryDown", $hGUI)
GUISetOnEvent($GUI_EVENT_PRIMARYUP, "_onMousePrimaryUp", $hGUI)
GUISetOnEvent($GUI_EVENT_SECONDARYDOWN, "_onMouseSecondaryDown", $hGUI)
GUISetOnEvent($GUI_EVENT_SECONDARYUP, "_onMouseSecondaryUp", $hGUI)
GUISetOnEvent($GUI_EVENT_MOUSEMOVE, "_onMouseMove", $hGUI)
GUIRegisterMsg($WM_DROPFILES, "_WM_DROPFILES")
GUIRegisterMsg($WM_SIZE, "_WM_SIZE")
GUIRegisterMsg($WM_MOVE, "_WM_MOVE")
GUIRegisterMsg($WM_NOTIFY, "WM_NOTIFY")
$background = GUICtrlCreateGraphic(0, 0, $oMain.Width, $oMain.Height)
$background_contextmenu = GUICtrlCreateContextMenu(GUICtrlCreateDummy())
$background_contextmenu_paste = GUICtrlCreateMenuItem("Paste", $background_contextmenu)
GUICtrlSetOnEvent($background_contextmenu_paste, "_onContextMenuPasteSelected")
$overlay_contextmenu = GUICtrlCreateContextMenu(GUICtrlCreateDummy())
Local $overlay_contextmenu_cut = GUICtrlCreateMenuItem("Cut", $overlay_contextmenu)
Local $overlay_contextmenu_copy = GUICtrlCreateMenuItem("Copy", $overlay_contextmenu)
Local $overlay_contextmenu_delete = GUICtrlCreateMenuItem("Delete", $overlay_contextmenu)
GUICtrlCreateMenuItem("", $overlay_contextmenu)
$contextmenu_lock = GUICtrlCreateMenuItem("Lock Control", $overlay_contextmenu)
GUICtrlCreateMenuItem("", $overlay_contextmenu)
Local $contextmenu_arrange = GUICtrlCreateMenu("Arrange", $overlay_contextmenu)
Local $contextmenu_arrange_left = GUICtrlCreateMenuItem("Align Left", $contextmenu_arrange)
Local $contextmenu_arrange_center = GUICtrlCreateMenuItem("Align Center", $contextmenu_arrange)
Local $contextmenu_arrange_right = GUICtrlCreateMenuItem("Align Right", $contextmenu_arrange)
GUICtrlCreateMenuItem("", $contextmenu_arrange)
Local $contextmenu_arrange_top = GUICtrlCreateMenuItem("Align Top", $contextmenu_arrange)
Local $contextmenu_arrange_middle = GUICtrlCreateMenuItem("Align Middle", $contextmenu_arrange)
Local $contextmenu_arrange_bottom = GUICtrlCreateMenuItem("Align Bottom", $contextmenu_arrange)
GUICtrlCreateMenuItem("", $contextmenu_arrange)
Local $contextmenu_arrange_centerPoints = GUICtrlCreateMenuItem("Align Center Points", $contextmenu_arrange)
GUICtrlCreateMenuItem("", $contextmenu_arrange)
Local $contextmenu_arrange_spaceVertical = GUICtrlCreateMenuItem("Space Vertical", $contextmenu_arrange)
Local $contextmenu_arrange_spaceHorizontal = GUICtrlCreateMenuItem("Space Horizontal", $contextmenu_arrange)
GUICtrlCreateMenuItem("", $overlay_contextmenu)
Local $contextmenu_event = GUICtrlCreateMenuItem("Set control event", $overlay_contextmenu)
GUICtrlSetOnEvent($overlay_contextmenu_cut, _cut_selected)
GUICtrlSetOnEvent($overlay_contextmenu_copy, _copy_selected)
GUICtrlSetOnEvent($overlay_contextmenu_delete, _delete_selected_controls)
GUICtrlSetOnEvent($contextmenu_lock, "_onLockControl")
GUICtrlSetOnEvent($contextmenu_arrange_left, "_onAlignMenu_Left")
GUICtrlSetOnEvent($contextmenu_arrange_center, "_onAlignMenu_Center")
GUICtrlSetOnEvent($contextmenu_arrange_right, "_onAlignMenu_Right")
GUICtrlSetOnEvent($contextmenu_arrange_top, "_onAlignMenu_Top")
GUICtrlSetOnEvent($contextmenu_arrange_middle, "_onAlignMenu_Middle")
GUICtrlSetOnEvent($contextmenu_arrange_bottom, "_onAlignMenu_Bottom")
GUICtrlSetOnEvent($contextmenu_arrange_centerPoints, "_onAlignMenu_CenterPoints")
GUICtrlSetOnEvent($contextmenu_arrange_spaceVertical, "_onAlignMenu_SpaceVertical")
GUICtrlSetOnEvent($contextmenu_arrange_spaceHorizontal, "_onAlignMenu_SpaceHorizontal")
GUICtrlSetOnEvent($contextmenu_event, "_onContextMenu_Event")
$overlay_contextmenutab = GUICtrlCreateContextMenu(GUICtrlCreateDummy())
Local $overlay_contextmenutab_delete = GUICtrlCreateMenuItem("Delete", $overlay_contextmenutab)
Local $overlay_contextmenutab_newtab = GUICtrlCreateMenuItem("New Tab", $overlay_contextmenutab)
Local $overlay_contextmenutab_deletetab = GUICtrlCreateMenuItem("Delete Tab", $overlay_contextmenutab)
GUICtrlSetOnEvent($overlay_contextmenutab_delete, _delete_selected_controls)
GUICtrlSetOnEvent($overlay_contextmenutab_newtab, "_onNewTab")
GUICtrlSetOnEvent($overlay_contextmenutab_deletetab, "_onDeleteTab")
EndFunc
Func _formToolbar()
Local Const $toolbar_width = 215
Local Const $toolbar_height = 480
Local $toolbar_left = $oMain.Left - ($toolbar_width + 5)
Local $toolbar_top = $oMain.Top
Local $sPos = IniRead($sIniPath, "Settings", "posToolbar", $toolbar_left & "," & $toolbar_top)
Local $aPos = StringSplit($sPos, ",")
If Not @error Then
$toolbar_left = $aPos[1]
$toolbar_top = $aPos[2]
EndIf
Local $ixCoordMin = _WinAPI_GetSystemMetrics(76)
Local $iyCoordMin = _WinAPI_GetSystemMetrics(77)
Local $iFullDesktopWidth = _WinAPI_GetSystemMetrics(78)
Local $iFullDesktopHeight = _WinAPI_GetSystemMetrics(79)
If ($toolbar_left + $toolbar_width) > ($ixCoordMin + $iFullDesktopWidth) Then
$toolbar_left = $iFullDesktopWidth - $toolbar_width
ElseIf $toolbar_left < $ixCoordMin Then
$toolbar_left = 0
EndIf
If ($toolbar_top + $toolbar_height) > ($iyCoordMin + $iFullDesktopHeight) Then
$toolbar_top = $iFullDesktopHeight - $toolbar_height
ElseIf $toolbar_top < $iyCoordMin Then
$toolbar_top = 0
EndIf
$hToolbar = GUICreate($oMain.AppName, $toolbar_width, $toolbar_height, $toolbar_left, $toolbar_top, BitOR($WS_SYSMENU, $WS_MINIMIZEBOX))
GUISetOnEvent($GUI_EVENT_CLOSE, "_onExit", $hToolbar)
GUISetOnEvent($GUI_EVENT_MINIMIZE, "_onMinimize", $hToolbar)
GUISetOnEvent($GUI_EVENT_RESTORE, "_onRestore", $hToolbar)
If Not @Compiled Then
GUISetIcon(@ScriptDir & '\resources\icons\icon.ico')
TraySetIcon(@ScriptDir & '\resources\icons\icon.ico')
EndIf
$menu_file = GUICtrlCreateMenu("File")
Local $menu_save_definition = GUICtrlCreateMenuItem("Save" & @TAB & "Ctrl+S", $menu_file)
Local $menu_saveas_definition = GUICtrlCreateMenuItem("Save As..." & @TAB & "Ctrl+S", $menu_file)
Local $menu_load_definition = GUICtrlCreateMenuItem("Open" & @TAB & "Ctrl+O", $menu_file)
GUICtrlCreateMenuItem("", $menu_file)
Local $menu_import_au3 = GUICtrlCreateMenuItem("Import from au3", $menu_file)
Local $menu_export_au3 = GUICtrlCreateMenuItem("Export to au3", $menu_file)
GUICtrlCreateMenuItem("", $menu_file)
Local $aRecentFiles = IniReadSection($sIniPath, "Recent")
If Not @error Then
For $i = 1 To $aRecentFiles[0][0]
$aMenuRecentList[$i - 1] = GUICtrlCreateMenuItem($i & " " & $aRecentFiles[$i][1], $menu_file)
GUICtrlSetOnEvent(-1, "_onMenuRecent")
Next
$aMenuRecentList[10] = GUICtrlCreateMenuItem("", $menu_file)
EndIf
$aMenuRecentList[11] = GUICtrlCreateMenuItem("Exit", $menu_file)
GUICtrlSetOnEvent(-1, "_onExit")
GUICtrlSetOnEvent($menu_save_definition, "_onSaveGui")
GUICtrlSetOnEvent($menu_saveas_definition, "_onSaveAsGui")
GUICtrlSetOnEvent($menu_load_definition, "_onload_gui_definition")
GUICtrlSetOnEvent($menu_import_au3, "_onImportMenuItem")
GUICtrlSetOnEvent($menu_export_au3, "_onExportMenuItem")
Local $menu_edit = GUICtrlCreateMenu("Edit")
Local $menu_undo = GUICtrlCreateMenuItem("Undo" & @TAB & "Ctrl+Z", $menu_edit)
Local $menu_redo = GUICtrlCreateMenuItem("Redo" & @TAB & "Ctrl+Y", $menu_edit)
GUICtrlCreateMenuItem("", $menu_edit)
Local $menu_cut = GUICtrlCreateMenuItem("Cut" & @TAB & "Ctrl+X", $menu_edit)
Local $menu_copy = GUICtrlCreateMenuItem("Copy" & @TAB & "Ctrl+C", $menu_edit)
Local $menu_paste = GUICtrlCreateMenuItem("Paste" & @TAB & "Ctrl+V", $menu_edit)
Local $menu_duplicate = GUICtrlCreateMenuItem("Duplicate" & @TAB & "Ctrl+D", $menu_edit)
Local $menu_selectall = GUICtrlCreateMenuItem("Select All" & @TAB & "Ctrl+A", $menu_edit)
GUICtrlCreateMenuItem("", $menu_edit)
$menu_wipe = GUICtrlCreateMenuItem("Clear All Controls", $menu_edit)
GUICtrlSetState($menu_wipe, $GUI_DISABLE)
GUICtrlSetOnEvent($menu_undo, "_onUndo")
GUICtrlSetOnEvent($menu_redo, "_onRedo")
GUICtrlSetOnEvent($menu_copy, "_copy_selected")
GUICtrlSetOnEvent($menu_paste, "_onMenuPasteSelected")
GUICtrlSetOnEvent($menu_duplicate, "_onDuplicate")
GUICtrlSetOnEvent($menu_selectall, "_onMenuSelectAll")
GUICtrlSetOnEvent($menu_wipe, _wipe_current_gui)
GUICtrlCreateMenuItem("", $menu_edit)
Local $menu_arrange = GUICtrlCreateMenu("Arrange", $menu_edit)
Local $menu_arrange_left = GUICtrlCreateMenuItem("Align Left", $menu_arrange)
Local $menu_arrange_center = GUICtrlCreateMenuItem("Align Center", $menu_arrange)
Local $menu_arrange_right = GUICtrlCreateMenuItem("Align Right", $menu_arrange)
GUICtrlCreateMenuItem("", $menu_arrange)
Local $menu_arrange_top = GUICtrlCreateMenuItem("Align Top", $menu_arrange)
Local $menu_arrange_middle = GUICtrlCreateMenuItem("Align Middle", $menu_arrange)
Local $menu_arrange_bottom = GUICtrlCreateMenuItem("Align Bottom", $menu_arrange)
GUICtrlCreateMenuItem("", $menu_arrange)
Local $menu_arrange_centerPoints = GUICtrlCreateMenuItem("Align Center Points", $menu_arrange)
GUICtrlCreateMenuItem("", $menu_arrange)
Local $menu_arrange_spaceVertical = GUICtrlCreateMenuItem("Space Vertical", $menu_arrange)
Local $menu_arrange_spaceHorizontal = GUICtrlCreateMenuItem("Space Horizontal", $menu_arrange)
GUICtrlSetOnEvent($menu_arrange_left, "_onAlignMenu_Left")
GUICtrlSetOnEvent($menu_arrange_center, "_onAlignMenu_Center")
GUICtrlSetOnEvent($menu_arrange_right, "_onAlignMenu_Right")
GUICtrlSetOnEvent($menu_arrange_top, "_onAlignMenu_Top")
GUICtrlSetOnEvent($menu_arrange_middle, "_onAlignMenu_Middle")
GUICtrlSetOnEvent($menu_arrange_bottom, "_onAlignMenu_Bottom")
GUICtrlSetOnEvent($menu_arrange_centerPoints, "_onAlignMenu_CenterPoints")
GUICtrlSetOnEvent($menu_arrange_spaceVertical, "_onAlignMenu_SpaceVertical")
GUICtrlSetOnEvent($menu_arrange_spaceHorizontal, "_onAlignMenu_SpaceHorizontal")
Local $menu_view = GUICtrlCreateMenu("View")
$menu_show_grid = GUICtrlCreateMenuItem("Show grid" & @TAB & "F7", $menu_view)
GUICtrlSetOnEvent($menu_show_grid, _onShowGrid)
GUICtrlSetState($menu_show_grid, $GUI_CHECKED)
$menu_generateCode = GUICtrlCreateMenuItem("Code Preview", $menu_view)
GUICtrlSetOnEvent($menu_generateCode, "_onGenerateCode")
GUICtrlSetState($menu_generateCode, $GUI_UNCHECKED)
$menu_ObjectExplorer = GUICtrlCreateMenuItem("Object Explorer", $menu_view)
GUICtrlSetOnEvent($menu_ObjectExplorer, "_onShowObjectExplorer")
GUICtrlSetState($menu_ObjectExplorer, $GUI_UNCHECKED)
Local $menu_tools = GUICtrlCreateMenu("Tools")
Local $menu_testForm = GUICtrlCreateMenuItem("Test GUI" & @TAB & "F5", $menu_tools)
Local $menu_settings = GUICtrlCreateMenuItem("Settings", $menu_tools)
GUICtrlSetOnEvent($menu_testForm, "_onTestGUI")
GUICtrlSetOnEvent($menu_settings, "_onSettings")
Local $menu_help = GUICtrlCreateMenu("Help")
$menu_helpchm = GUICtrlCreateMenuItem("Help" & @TAB & "F1", $menu_help)
Local $menu_github = GUICtrlCreateMenuItem("Github Repository", $menu_help)
Local $menu_about = GUICtrlCreateMenuItem("About", $menu_help)
GUICtrlSetOnEvent($menu_about, _menu_about)
GUICtrlSetOnEvent($menu_github, _onGithubItem)
GUICtrlSetOnEvent($menu_helpchm, _onHelpItem)
Local Const $contype_btn_w = 40
Local Const $contype_btn_h = 40
Local $toolButton
$toolButton = GUICtrlCreateRadio('', 5, 5, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 1.ico", 201)
GUICtrlSetTip(-1, "Cursor")
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, _set_default_mode)
$oMain.DefaultCursor = $toolButton
$toolButton = GUICtrlCreateRadio("Tab", 45, 5, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 2.ico", 202)
GUICtrlSetTip(-1, "Tab")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("Group", 85, 5, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 3.ico", 203)
GUICtrlSetTip(-1, "Group")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("Button", 125, 5, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 4.ico", 204)
GUICtrlSetTip(-1, "Button")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("Checkbox", 165, 5, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 5.ico", 205)
GUICtrlSetTip(-1, "Checkbox")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("Radio", 5, 45, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 6.ico", 206)
GUICtrlSetTip(-1, "Radio")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("Edit", 45, 45, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 7.ico", 207)
GUICtrlSetTip(-1, "Edit")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("Input", 85, 45, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 8.ico", 208)
GUICtrlSetTip(-1, "Input")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("Label", 125, 45, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 9.ico", 209)
GUICtrlSetTip(-1, "Label")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("Updown", 165, 45, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 10.ico", 210)
GUICtrlSetTip(-1, "Updown")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("List", 5, 85, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 11.ico", 211)
GUICtrlSetTip(-1, "List")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("Combo", 45, 85, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 12.ico", 212)
GUICtrlSetTip(-1, "Combo")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("Date", 85, 85, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 13.ico", 213)
GUICtrlSetTip(-1, "Date")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("TreeView", 125, 85, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 14.ico", 214)
GUICtrlSetTip(-1, "TreeView")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("Progress", 165, 85, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 15.ico", 215)
GUICtrlSetTip(-1, "Progress")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("Pic", 5, 125, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 17.ico", 217)
GUICtrlSetTip(-1, "Image")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("Menu", 45, 125, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 19.ico", 219)
GUICtrlSetTip(-1, "Menu")
GUICtrlSetOnEvent(-1, _control_type)
$button_graphic = GUICtrlCreateRadio("Rect", 85, 125, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($button_graphic, "Icon 24.ico", 224)
GUICtrlSetTip(-1, "Draw Rectangle")
GUICtrlSetOnEvent(-1, _control_type)
Local $graphic_contextmenu = GUICtrlCreateContextMenu($button_graphic)
GUICtrlCreateMenuItem("Rectangle", $graphic_contextmenu)
GUICtrlSetOnEvent(-1, "_onGraphicMenuRect")
GUICtrlCreateMenuItem("Ellipse", $graphic_contextmenu)
GUICtrlSetOnEvent(-1, "_onGraphicMenuEllipse")
GUICtrlCreateMenuItem("Line", $graphic_contextmenu)
GUICtrlSetOnEvent(-1, "_onGraphicMenuLine")
$toolButton = GUICtrlCreateRadio("Slider", 125, 125, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 21.ico", 221)
GUICtrlSetTip(-1, "Slider")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("ListView", 165, 125, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 23.ico", 223)
GUICtrlSetTip(-1, "ListView")
GUICtrlSetOnEvent(-1, _control_type)
$toolButton = GUICtrlCreateRadio("IP", 5, 165, $contype_btn_w, $contype_btn_h, BitOR($BS_PUSHLIKE, $BS_ICON))
_setIconFromResource($toolButton, "Icon 22.ico", 222)
GUICtrlSetTip(-1, "IP Address")
GUICtrlSetOnEvent(-1, _control_type)
$exititemtray = TrayCreateItem("Exit")
TrayItemSetOnEvent(-1, "_onExit")
TraySetToolTip($oMain.AppName & " " & $oMain.AppVersion)
_formPropertyInspector(0, 210, $toolbar_width, 222)
$hStatusbar = _GUICtrlStatusBar_Create($hToolbar)
EndFunc
Func _set_accelerators($styleOnly = False)
Local Const $accel_delete = GUICtrlCreateDummy()
Local Const $accel_x = GUICtrlCreateDummy()
Local Const $accel_c = GUICtrlCreateDummy()
Local Const $accel_v = GUICtrlCreateDummy()
Local Const $accel_d = GUICtrlCreateDummy()
Local Const $accel_a = GUICtrlCreateDummy()
Local Const $accel_up = GUICtrlCreateDummy()
Local Const $accel_down = GUICtrlCreateDummy()
Local Const $accel_left = GUICtrlCreateDummy()
Local Const $accel_right = GUICtrlCreateDummy()
Local Const $accel_Ctrlup = GUICtrlCreateDummy()
Local Const $accel_Ctrldown = GUICtrlCreateDummy()
Local Const $accel_Ctrlleft = GUICtrlCreateDummy()
Local Const $accel_Ctrlright = GUICtrlCreateDummy()
Local Const $accel_s = GUICtrlCreateDummy()
Local Const $accel_o = GUICtrlCreateDummy()
Local Const $accel_F3 = GUICtrlCreateDummy()
Local Const $accel_F5 = GUICtrlCreateDummy()
Local Const $accel_z = GUICtrlCreateDummy()
Local Const $accel_y = GUICtrlCreateDummy()
Local Const $accel_F1 = GUICtrlCreateDummy()
Local Const $accelerators[22][2] =  [  ["{Delete}", $accel_delete],  ["^x", $accel_x],  ["^c", $accel_c],  ["^v", $accel_v],  ["^d", $accel_d],  ["^a", $accel_a],  ["{UP}", $accel_up],  ["{DOWN}", $accel_down],  ["{LEFT}", $accel_left],  ["{RIGHT}", $accel_right],  ["^{UP}", $accel_Ctrlup],  ["^{DOWN}", $accel_Ctrldown],  ["^{LEFT}", $accel_Ctrlleft],  ["^{RIGHT}", $accel_Ctrlright],  ["{F3}", $accel_F3],  ["{F7}", $menu_show_grid],  ["{F5}", $accel_F5],  ["^s", $accel_s],  ["^o", $accel_o],  ["^z", $accel_z],  ["^y", $accel_y],  ["{F1}", $menu_helpchm]  ]
If Not $styleOnly Then
GUISetAccelerators($accelerators, $hGUI)
EndIf
Local Const $acceleratorsToolbar[6][2] =  [  ["{F3}", $accel_F3],  ["{F7}", $menu_show_grid],  ["{F5}", $accel_F5],  ["^s", $accel_s],  ["^o", $accel_o],  ["{F1}", $menu_helpchm]  ]
If Not $styleOnly Then
GUISetAccelerators($accelerators, $hToolbar)
GUISetAccelerators($accelerators, $oProperties_Main.properties.Hwnd)
GUISetAccelerators($accelerators, $oProperties_Ctrls.properties.Hwnd)
EndIf
GUISetAccelerators($accelerators, $tabStylesHwnd)
GUICtrlSetOnEvent($accel_delete, _delete_selected_controls)
GUICtrlSetOnEvent($accel_x, _cut_selected)
GUICtrlSetOnEvent($accel_c, _copy_selected)
GUICtrlSetOnEvent($accel_v, "_onPasteSelected")
GUICtrlSetOnEvent($accel_d, "_onDuplicate")
GUICtrlSetOnEvent($accel_a, "_onMenuSelectAll")
GUICtrlSetOnEvent($accel_up, "_onKeyUp")
GUICtrlSetOnEvent($accel_down, "_onKeyDown")
GUICtrlSetOnEvent($accel_left, "_onKeyLeft")
GUICtrlSetOnEvent($accel_right, "_onKeyRight")
GUICtrlSetOnEvent($accel_Ctrlup, "_onKeyCtrlUp")
GUICtrlSetOnEvent($accel_Ctrldown, "_onKeyCtrlDown")
GUICtrlSetOnEvent($accel_Ctrlleft, "_onKeyCtrlLeft")
GUICtrlSetOnEvent($accel_Ctrlright, "_onKeyCtrlRight")
GUICtrlSetOnEvent($accel_s, "_onSaveGui")
GUICtrlSetOnEvent($accel_o, "_onload_gui_definition")
GUICtrlSetOnEvent($accel_F5, "_onTestGUI")
GUICtrlSetOnEvent($accel_F3, "_onGridsnap")
GUICtrlSetOnEvent($accel_z, "_onUndo")
GUICtrlSetOnEvent($accel_y, "_onRedo")
EndFunc
Func _getGuiFrameSize()
Local $aWinPos = WinGetPos($hGUI)
Local $iClientX = 0, $iClientY = 0
ClientToScreen($iClientX, $iClientY)
$iGuiFrameW = 2 * ($iClientX - $aWinPos[0])
$iGuiFrameH = ($iClientY - $aWinPos[1]) + ($iClientX - $aWinPos[0])
EndFunc
Func _show_grid(ByRef $grid_ctrl, Const $width, Const $height)
GUISwitch($hGUI)
GUICtrlDelete($grid_ctrl)
$grid_ctrl = GUICtrlCreateGraphic(0, 0, $width, $height)
_display_grid($grid_ctrl, $width, $height)
EndFunc
Func _hide_grid(ByRef $grid_ctrl)
GUISwitch($hGUI)
GUICtrlDelete($grid_ctrl)
$grid_ctrl = GUICtrlCreateGraphic(0, 0, $oMain.Width, $oMain.Height)
EndFunc
Func _display_grid(Const $grid_ctrl, Const $width, Const $height)
Local Const $iColor = 0xDEDEDE
Local $penSize = 1
Local Const $width_steps = $width / $oOptions.gridSize
Local Const $height_steps = $height / $oOptions.gridSize
GUICtrlSetGraphic($grid_ctrl, $GUI_GR_PENSIZE, $penSize)
GUICtrlSetGraphic($grid_ctrl, $GUI_GR_COLOR, $iColor)
For $x = 0 To $width_steps
GUICtrlSetGraphic($grid_ctrl, $GUI_GR_MOVE, $x * $oOptions.gridSize, 0)
GUICtrlSetGraphic($grid_ctrl, $GUI_GR_LINE, $x * $oOptions.gridSize, $height)
Next
For $x = 0 To $height_steps
GUICtrlSetGraphic($grid_ctrl, $GUI_GR_MOVE, 0, $x * $oOptions.gridSize)
GUICtrlSetGraphic($grid_ctrl, $GUI_GR_LINE, $width, $x * $oOptions.gridSize)
Next
GUICtrlSetGraphic($grid_ctrl, $GUI_GR_REFRESH)
GUICtrlSetPos($grid_ctrl, Default, Default, $width, $height)
_WinAPI_SetWindowPos(GUICtrlGetHandle($grid_ctrl), $HWND_BOTTOM, 0, 0, 0, 0, $SWP_NOMOVE + $SWP_NOSIZE + $SWP_NOCOPYBITS)
GUICtrlSetState($grid_ctrl, $GUI_DISABLE)
For $oCtrl In $oCtrls.ctrls.Items()
Switch $oCtrl.Type
Case "Rect", "Ellipse", "Line"
_updateGraphic($oCtrl)
EndSwitch
Next
EndFunc
Func _onExit()
If $oMain.hasChanged Then
Switch MsgBox($MB_SYSTEMMODAL + $MB_YESNOCANCEL, "Quit?", "Do you want to save the GUI?")
Case $IDYES
$ret = _save_gui_definition()
Switch $ret
Case -1
$bStatusNewMessage = True
_GUICtrlStatusBar_SetText($hStatusbar, "Save cancelled.")
Return
Case -2
$bStatusNewMessage = True
_GUICtrlStatusBar_SetText($hStatusbar, "Save failed.")
Return
EndSwitch
Case $IDCANCEL
Return
EndSwitch
EndIf
_saveWinPositions()
If $hSelectionGraphic <> -1 Then
_GDIPlus_GraphicsDispose($hSelectionGraphic)
EndIf
GUIDelete($hToolbar)
GUIDelete($hGUI)
If FileExists($testFileName) Then
FileDelete($testFileName)
EndIf
Exit
EndFunc
Func _onExitForm()
_onExit()
EndFunc
Func _onMinimize()
_saveWinPositions()
GUISetState(@SW_MINIMIZE, $hToolbar)
GUISetState(@SW_HIDE, $oProperties_Main.properties.Hwnd)
GUISetState(@SW_HIDE, $oProperties_Ctrls.properties.Hwnd)
GUISetState(@SW_HIDE, $tabStylesHwnd)
EndFunc
Func _onRestore()
GUISetState(@SW_RESTORE, $hToolbar)
If $oSelected.count > 0 Then
Switch $tabSelected
Case "Properties"
GUISetState(@SW_SHOWNOACTIVATE, $oProperties_Ctrls.properties.Hwnd)
Case "Styles"
GUISetState(@SW_SHOWNOACTIVATE, $tabStylesHwnd)
EndSwitch
Else
Switch $tabSelected
Case "Properties"
GUISetState(@SW_SHOWNOACTIVATE, $oProperties_Main.properties.Hwnd)
Case "Styles"
GUISetState(@SW_SHOWNOACTIVATE, $tabStylesHwnd)
EndSwitch
EndIf
GUISetState(@SW_SHOWNORMAL, $hToolbar)
GUISwitch($hGUI)
$bResizedFlag = False
EndFunc
Func _WM_SIZE($hWnd, $Msg, $wParam, $lParam)
Switch $hWnd
Case $hGUI
$bResizedFlag = 1
Case $hFormGenerateCode
Local $aPos = ControlGetPos($hFormGenerateCode, "", $labelCodeGeneration)
WinMove($editCodeGeneration, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3])
Case Else
Return $GUI_RUNDEFMSG
EndSwitch
Return $GUI_RUNDEFMSG
EndFunc
Func _WM_MOVE($hWnd, $Msg, $wParam, $lParam)
If $hWnd <> $hGUI Then Return $GUI_RUNDEFMSG
$bResizedFlag = 1
Return $GUI_RUNDEFMSG
EndFunc
Func WM_NOTIFY($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $wParam
$tNMHDR = DllStructCreate($tagNMHDR, $lParam)
$hWndFrom = DllStructGetData($tNMHDR, "hWndFrom")
$iIDFrom = DllStructGetData($tNMHDR, "IDFrom")
$iCode = DllStructGetData($tNMHDR, "Code")
Switch $iIDFrom
Case $lvObjects
Switch $iCode
Case $NM_RCLICK
Local $tPoint = _WinAPI_GetMousePos(True, $hWndFrom), $tHitTest
$tHitTest = _GUICtrlTreeView_HitTestEx($hWndFrom, DllStructGetData($tPoint, 1), DllStructGetData($tPoint, 2))
If BitAND(DllStructGetData($tHitTest, "Flags"), $TVHT_ONITEM) Then
_GUICtrlTreeView_SelectItem($hWndFrom, DllStructGetData($tHitTest, 'Item'))
_onLvObjectsItem()
EndIf
EndSwitch
EndSwitch
Return $GUI_RUNDEFMSG
EndFunc
Func _onResize()
Local $win_client_size = WinGetClientSize($hGUI)
If $oOptions.showGrid Then
_display_grid($background, $win_client_size[0], $win_client_size[1])
EndIf
$oMain.Width = $win_client_size[0]
$oMain.Height = $win_client_size[1]
$oProperties_Main.properties.Width.value = $oMain.Width
If $oCtrls.hasMenu Then
$oProperties_Main.properties.Height.value = $oMain.Height + _WinAPI_GetSystemMetrics($SM_CYMENU)
Else
$oProperties_Main.properties.Height.value = $oMain.Height
EndIf
WinSetTitle($hGUI, "", $oMain.Title & " - Form (" & $oProperties_Main.properties.Width.value & ", " & $oProperties_Main.properties.Height.value & ")")
EndFunc
Func _WM_DROPFILES(Const $hWnd, Const $msgID, Const $wParam, Const $lParam)
#forceref $hWnd, $lParam, $msgID
Local Const $nSize = DllCall("shell32.dll", "int", "DragQueryFileW", "hwnd", $wParam, "int", 0, "ptr", 0, "int", 0)[0] + 1
Local Const $pFileName = DllStructCreate("wchar[" & $nSize & "]")
DllCall("shell32.dll", "int", "DragQueryFileW", "hwnd", $wParam, "int", 0, "ptr", DllStructGetPtr($pFileName), "int", $nSize)
Local Const $GUI_DragFile = DllStructGetData($pFileName, 1)
_load_gui_definition($GUI_DragFile)
Return $GUI_RUNDEFMSG
EndFunc
Func _onKeyUp()
_nudgeSelected(0, -1)
EndFunc
Func _onKeyDown()
_nudgeSelected(0, 1)
EndFunc
Func _onKeyLeft()
_nudgeSelected(-1, 0)
EndFunc
Func _onKeyRight()
_nudgeSelected(1, 0)
EndFunc
Func _onKeyCtrlUp()
_nudgeSelected(0, -1 * $oOptions.GridSize)
EndFunc
Func _onKeyCtrlDown()
_nudgeSelected(0, $oOptions.GridSize)
EndFunc
Func _onKeyCtrlLeft()
_nudgeSelected(-1 * $oOptions.GridSize, 0)
EndFunc
Func _onKeyCtrlRight()
_nudgeSelected($oOptions.GridSize, 0)
EndFunc
Func _nudgeSelected($x = 0, $y = 0, $aUndoCtrls = 0)
GUICtrlSetState($oMain.DefaultCursor, $GUI_CHECKED)
$oCtrls.mode = $mode_default
Local $nudgeAmount = 1
Local $adjustmentX = 0, $adjustmentX = 0
Local $aCtrls
If IsArray($aUndoCtrls) Then
$aCtrls = $aUndoCtrls
Else
$aCtrls = $oSelected.ctrls.Items()
EndIf
For $oCtrl In $aCtrls
$adjustmentX = Mod($oCtrl.Left, $nudgeAmount)
If $adjustmentX > 0 Then
If $x = 1 Then
$adjustmentX = -1 * $adjustmentX
ElseIf $x = -1 Then
$adjustmentX = -1 * ($nudgeAmount - $adjustmentX)
EndIf
EndIf
$adjustmentY = Mod($oCtrl.Top, $nudgeAmount)
If $adjustmentY > 0 Then
If $y = 1 Then
$adjustmentY = -1 * $adjustmentY
ElseIf $y = -1 Then
$adjustmentY = -1 * ($nudgeAmount - $adjustmentY)
EndIf
EndIf
_change_ctrl_size_pos($oCtrl, $oCtrl.Left + $x * ($nudgeAmount + $adjustmentX), $oCtrl.Top + $y * ($nudgeAmount + $adjustmentY), $oCtrl.Width, $oCtrl.Height)
Switch $oCtrl.Type
Case "Tab"
_moveTabCtrls($oCtrl, -1 * $x * ($nudgeAmount + $adjustmentX), -1 * $y * ($nudgeAmount + $adjustmentY), Default, Default)
Case "Group"
_moveGroupCtrls($oCtrl, -1 * $x * ($nudgeAmount + $adjustmentX), -1 * $y * ($nudgeAmount + $adjustmentY), Default, Default)
EndSwitch
Next
Local $oCtrlLast = $oSelected.getLast()
_populate_control_properties_gui($oCtrlLast)
If Not IsArray($aUndoCtrls) Then
Local $oAction = _objAction()
$oAction.action = $action_nudgeCtrl
$oAction.ctrls = $aCtrls
Local $aParams[2] = [$x, $y]
$oAction.parameters = $aParams
_updateActionStacks($oAction)
EndIf
_refreshGenerateCode()
EndFunc
Func _onLockControl()
If $oSelected.count = 0 Then Return 0
_SendMessage($hGUI, $WM_SETREDRAW, False)
For $oCtrl In $oSelected.ctrls.Items()
$oCtrl.Locked = True
$oCtrl.grippies.show()
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
EndFunc
Func _onUnlockControl()
If $oSelected.count = 0 Then Return 0
_SendMessage($hGUI, $WM_SETREDRAW, False)
For $oCtrl In $oSelected.ctrls.Items()
$oCtrl.Locked = False
$oCtrl.grippies.show()
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hGUI)
EndFunc
Func _onAlignMenu_Left()
If $oSelected.count = 0 Then Return 0
Local $value = $oSelected.getFirst().Left
For $oCtrl In $oSelected.ctrls.Items()
_change_ctrl_size_pos($oCtrl, $value, Default, Default, Default)
Next
EndFunc
Func _onAlignMenu_Center()
If $oSelected.count = 0 Then Return 0
Local $oCtrlValue = $oSelected.getFirst()
Local $value = $oCtrlValue.Left + $oCtrlValue.Width / 2
For $oCtrl In $oSelected.ctrls.Items()
_change_ctrl_size_pos($oCtrl, $value - $oCtrl.Width / 2, Default, Default, Default)
Next
EndFunc
Func _onAlignMenu_Right()
If $oSelected.count = 0 Then Return 0
Local $oCtrlValue = $oSelected.getFirst()
Local $value = $oCtrlValue.Left + $oCtrlValue.Width
For $oCtrl In $oSelected.ctrls.Items()
_change_ctrl_size_pos($oCtrl, $value - $oCtrl.Width, Default, Default, Default)
Next
EndFunc
Func _onAlignMenu_Top()
If $oSelected.count = 0 Then Return 0
Local $value = $oSelected.getFirst().Top
For $oCtrl In $oSelected.ctrls.Items()
_change_ctrl_size_pos($oCtrl, Default, $value, Default, Default)
Next
EndFunc
Func _onAlignMenu_Middle()
If $oSelected.count = 0 Then Return 0
Local $oCtrlValue = $oSelected.getFirst()
Local $value = $oCtrlValue.Top + $oCtrlValue.Height / 2
For $oCtrl In $oSelected.ctrls.Items()
_change_ctrl_size_pos($oCtrl, Default, $value - $oCtrl.Height / 2, Default, Default)
Next
EndFunc
Func _onAlignMenu_Bottom()
If $oSelected.count = 0 Then Return 0
Local $oCtrlValue = $oSelected.getFirst()
Local $value = $oCtrlValue.Top + $oCtrlValue.Height
For $oCtrl In $oSelected.ctrls.Items()
_change_ctrl_size_pos($oCtrl, Default, $value - $oCtrl.Height, Default, Default)
Next
EndFunc
Func _onAlignMenu_CenterPoints()
If $oSelected.count = 0 Then Return 0
Local $oCtrlValue = $oSelected.getFirst()
Local $valueCenter = $oCtrlValue.Left + $oCtrlValue.Width / 2
Local $valueMiddle = $oCtrlValue.Top + $oCtrlValue.Height / 2
For $oCtrl In $oSelected.ctrls.Items()
_change_ctrl_size_pos($oCtrl, $valueCenter - $oCtrl.Width / 2, $valueMiddle - $oCtrl.Height / 2, Default, Default)
Next
EndFunc
Func _onAlignMenu_SpaceVertical()
If $oSelected.count = 0 Then Return 0
Local $oCtrlFirst, $oCtrlLast
Local $aCtrls[1], $firstObj = True
For $oCtrl In $oSelected.ctrls.Items()
For $i = 0 To UBound($aCtrls) - 1
If $firstObj Then
$aCtrls[0] = $oCtrl
$firstObj = False
ExitLoop
ElseIf $oCtrl.Top < $aCtrls[$i].Top Then
_ArrayInsert($aCtrls, $i, $oCtrl)
ExitLoop
ElseIf $i = UBound($aCtrls) - 1 Then
_ArrayAdd($aCtrls, $oCtrl, 0, "|", @CRLF, $ARRAYFILL_FORCE_SINGLEITEM)
EndIf
Next
Next
Local $posTop = $aCtrls[0].Top + $aCtrls[0].Height / 2
Local $posBottom = $aCtrls[$oSelected.count - 1].Top + $aCtrls[$oSelected.count - 1].Height / 2
Local $spacing = ($posBottom - $posTop) / ($oSelected.count - 1)
Local $pos = $aCtrls[0].Top + $aCtrls[0].Height / 2
For $oCtrl In $aCtrls
_change_ctrl_size_pos($oCtrl, Default, $pos - $oCtrl.Height / 2, Default, Default)
$pos += $spacing
Next
EndFunc
Func _onAlignMenu_SpaceHorizontal()
If $oSelected.count = 0 Then Return 0
Local $oCtrlFirst, $oCtrlLast
Local $aCtrls[1], $firstObj = True
For $oCtrl In $oSelected.ctrls.Items()
For $i = 0 To UBound($aCtrls) - 1
If $firstObj Then
$aCtrls[0] = $oCtrl
$firstObj = False
ExitLoop
ElseIf $oCtrl.Left < $aCtrls[$i].Left Then
_ArrayInsert($aCtrls, $i, $oCtrl)
ExitLoop
ElseIf $i = UBound($aCtrls) - 1 Then
_ArrayAdd($aCtrls, $oCtrl, 0, "|", @CRLF, $ARRAYFILL_FORCE_SINGLEITEM)
EndIf
Next
Next
Local $posLeft = $aCtrls[0].Left + $aCtrls[0].Width / 2
Local $posRight = $aCtrls[$oSelected.count - 1].Left + $aCtrls[$oSelected.count - 1].Width / 2
Local $spacing = ($posRight - $posLeft) / ($oSelected.count - 1)
Local $pos = $aCtrls[0].Left + $aCtrls[0].Width / 2
For $oCtrl In $aCtrls
_change_ctrl_size_pos($oCtrl, $pos - $oCtrl.Width / 2, Default, Default, Default)
$pos += $spacing
Next
EndFunc
Func _onAlignMenu_Back()
If $oSelected.count = 0 Then Return 0
For $oCtrl In $oSelected.ctrls.Items()
_WinAPI_SetWindowPos(GUICtrlGetHandle($oCtrl.Hwnd), $HWND_TOP, 0, 0, 0, 0, $SWP_NOMOVE + $SWP_NOSIZE + $SWP_NOCOPYBITS)
Next
EndFunc
Func _onAlignMenu_Front()
If $oSelected.count = 0 Then Return 0
For $oCtrl In $oSelected.ctrls.Items()
_WinAPI_SetWindowPos(GUICtrlGetHandle($oCtrl.Hwnd), $HWND_BOTTOM, 0, 0, 0, 0, $SWP_NOMOVE + $SWP_NOSIZE + $SWP_NOCOPYBITS)
Next
EndFunc
Func _onPasteSelected()
_PasteSelected()
EndFunc
Func _onMenuPasteSelected()
_PasteSelected(True)
EndFunc
Func _onDuplicate()
_DuplicateSelected()
EndFunc
Func _onContextMenuPasteSelected()
_PasteSelected(False, True)
EndFunc
Func _onMenuSelectAll()
_selectAll()
EndFunc
Func _onUndo()
_undo()
EndFunc
Func _onRedo()
_redo()
EndFunc
Func _onGraphicMenuRect()
GUICtrlSetTip($button_graphic, "Draw Rectangle")
GUICtrlSetData($button_graphic, "Rect")
_setIconFromResource($button_graphic, "Icon 24.ico", 224)
GUICtrlSetState($button_graphic, $GUI_CHECKED)
$oCtrls.CurrentType = "Rect"
$oCtrls.mode = $mode_draw
EndFunc
Func _onGraphicMenuEllipse()
GUICtrlSetTip($button_graphic, "Draw Ellipse")
GUICtrlSetData($button_graphic, "Ellipse")
_setIconFromResource($button_graphic, "Icon 25.ico", 225)
GUICtrlSetState($button_graphic, $GUI_CHECKED)
$oCtrls.CurrentType = "Ellipse"
$oCtrls.mode = $mode_draw
EndFunc
Func _onGraphicMenuLine()
GUICtrlSetTip($button_graphic, "Draw Line")
GUICtrlSetData($button_graphic, "Line")
_setIconFromResource($button_graphic, "Icon 26.ico", 226)
GUICtrlSetState($button_graphic, $GUI_CHECKED)
$oCtrls.CurrentType = "Line"
$oCtrls.mode = $mode_draw
EndFunc
Func _GetDoubleClickTime()
Local $aDllRet = DllCall("user32.dll", "uint", "GetDoubleClickTime")
If Not @error Then Return $aDllRet[0]
EndFunc
Func _onMousePrimaryDown()
If $bResizedFlag Then
_log("** PrimaryDown: resizedflag **")
$bResizedFlag = 0
Return
EndIf
$left_click = True
Local $aDrawStartPos = GUIGetCursorInfo($hGUI)
Local $ctrl_hwnd = $aDrawStartPos[4]
Local $aMousePos = MouseGetPos()
If $ctrl_hwnd = 0 And $oCtrls.hasIP Then
For $oThisCtrl In $oCtrls.ctrls.Items()
If $oThisCtrl.Type = "IP" Then
If $aDrawStartPos[0] > $oThisCtrl.Left And $aDrawStartPos[0] < $oThisCtrl.Left + $oThisCtrl.Width And $aDrawStartPos[1] > $oThisCtrl.Top And $aDrawStartPos[1] < $oThisCtrl.Top + $oThisCtrl.Height Then
$ctrl_hwnd = $oThisCtrl.Hwnd
ExitLoop
EndIf
EndIf
Next
EndIf
$oCtrls.clickedCtrl = $oCtrls.get($ctrl_hwnd)
Local $pos
If (Not $initResize And Not $oCtrls.mode = $mode_init_move) And Not $oCtrls.mode = $mode_draw Then
If $oCtrls.exists($ctrl_hwnd) And $ctrl_hwnd <> $background And $ctrl_hwnd <> 0 Then
GUICtrlSetState($oMain.DefaultCursor, $GUI_CHECKED)
$oCtrls.mode = $mode_default
EndIf
EndIf
If _IsPressed("10") And $oCtrls.exists($ctrl_hwnd) Then
_copy_selected()
Local Const $smallest = _left_top_union_rect()
$oMouse.X = $smallest.Left
$oMouse.Y = $smallest.Top
_PasteSelected()
EndIf
Switch $oCtrls.mode
Case $mode_draw
_log("** PrimaryDown: draw **")
$initDraw = True
_set_current_mouse_pos()
$oMouse.StartX = $oMouse.X
$oMouse.StartY = $oMouse.Y
$oCtrls.drawHwnd = $ctrl_hwnd
If $oCtrls.CurrentType = "Menu" Then
Local $oCtrl = _create_ctrl(0, 0, $oMouse.StartX, $oMouse.StartY)
If IsObj($oCtrl) Then
_set_default_mode()
$oCtrls.mode = $mode_default
_formObjectExplorer_updateList()
_refreshGenerateCode()
GUICtrlSetState($oMain.DefaultCursor, $GUI_CHECKED)
Else
GUICtrlSetState($oMain.DefaultCursor, $GUI_CHECKED)
_set_default_mode()
$oCtrls.mode = $mode_default
EndIf
Else
$oCtrls.mode = $mode_drawing
EndIf
Case $mode_default
_log("** PrimaryDown: default **")
Switch $ctrl_hwnd
Case $background, 0
_log("  background")
_set_default_mode()
_set_current_mouse_pos(1)
$oCtrls.clickedCtrl = 0
$oCtrls.mode = $mode_init_selection
Local $aMousePos = MouseGetPos()
$oMouse.StartX = $aMousePos[0]
$oMouse.StartY = $aMousePos[1]
Case Else
_log("  other control")
If Not $oCtrls.exists($ctrl_hwnd) Then
$oCtrls.clickedCtrl = 0
Return
EndIf
Local $aMousePos = MouseGetPos()
$oMouse.StartX = $aMousePos[0]
$oMouse.StartY = $aMousePos[1]
Static Local $clickTime, $prevCtrl
If $ctrl_hwnd = $prevCtrl And TimerDiff($clickTime) <= $dblClickTime Then
_formEventCode()
Return
EndIf
$prevCtrl = $ctrl_hwnd
$clickTime = TimerInit()
Local $oCtrl = $oCtrls.get($ctrl_hwnd)
Switch _IsPressed("11")
Case False
If Not $oSelected.exists($ctrl_hwnd) Then
_add_to_selected($oCtrl, True, False)
_set_current_mouse_pos()
EndIf
Case True
Switch _group_select($oCtrl)
Case True
_set_current_mouse_pos()
GUICtrlSetCursor($oCtrl.Hwnd, $SIZE_ALL)
Case False
If Not $oSelected.exists($ctrl_hwnd) Then
_add_to_selected($oCtrl, False, False)
_set_current_mouse_pos()
Else
_remove_from_selected($oCtrl, False)
EndIf
EndSwitch
EndSwitch
If $oSelected.count <= 1 Then
_setLvSelected($oSelected.getFirst())
EndIf
EndSwitch
Case $mode_paste
_log("** PrimaryDown: paste **")
$left_click = False
ToolTip('')
_recall_overlay()
$oCtrls.mode = $mode_default
Case Else
_log("** PrimaryDown: case else **")
GUICtrlSetState($oMain.DefaultCursor, $GUI_CHECKED)
_set_current_mouse_pos()
EndSwitch
EndFunc
Func _onMousePrimaryUp()
$left_click = False
Local $ctrl_hwnd, $oCtrl, $updateObjectExplorer
$oCtrls.clickedCtrl = 0
Switch $oCtrls.mode
Case $mode_drawing
_log("** PrimaryUp: draw **")
GUICtrlSetState($oMain.DefaultCursor, $GUI_CHECKED)
_set_default_mode()
_showProperties()
$initDraw = False
Case $mode_init_move
_log("** PrimaryUp: init_move **")
ToolTip('')
Local $aMousePos = MouseGetPos()
Local $oAction = _objAction()
$oAction.action = $action_moveCtrl
$oAction.ctrls = $oSelected.ctrls.Items()
Local $aParams[2] = [$aMousePos[0] - $oMouse.StartX, $aMousePos[1] - $oMouse.StartY]
$oAction.parameters = $aParams
_updateActionStacks($oAction)
$oCtrls.mode = $mode_default
$oCtrl = $oSelected.getLast()
If IsObj($oCtrl) Then
_populate_control_properties_gui($oCtrl)
EndIf
If $oSelected.count > 0 Then
_refreshGenerateCode()
EndIf
_showProperties()
Case $mode_init_selection
_log("** PrimaryUp: init_selection **")
ToolTip('')
_recall_overlay()
$oCtrls.mode = $mode_default
_showProperties()
_populate_control_properties_gui($oSelected.getLast())
Case $resize_nw, $resize_n, $resize_ne, $resize_e, $resize_se, $resize_s, $resize_sw, $resize_w
_log("** PrimaryUp: Resize **")
ToolTip('')
For $oCtrl In $oSelected.ctrls.Items()
$oCtrl.isResizeMaster = False
Next
$oCtrlSelectedFirst = $oSelected.getFirst()
If $initDraw Then
_log("  init draw")
$initDraw = False
Local $tolerance = 5
If $oCtrlSelectedFirst.Type = "Tab" Then
GUICtrlSetState($oMain.DefaultCursor, $GUI_CHECKED)
EndIf
If Abs($oMouse.X - $oMouse.StartX) < $tolerance And Abs($oMouse.Y - $oMouse.StartY) < $tolerance Then
_log("  click away")
GUICtrlSetState($oMain.DefaultCursor, $GUI_CHECKED)
_delete_selected_controls()
_set_default_mode()
Else
Switch $oCtrlSelectedFirst.Type
Case "Rect", "Ellipse", "Line"
Local $aCoord1 = [$oCtrlSelectedFirst.coord1[0], $oCtrlSelectedFirst.coord1[1]]
Local $aCoord2 = [$oCtrlSelectedFirst.coord2[0], $oCtrlSelectedFirst.coord2[1]]
If $oCtrlSelectedFirst.width < 0 And $oCtrlSelectedFirst.height < 0 Then
$oCtrlSelectedFirst.width = -1 * $oCtrlSelectedFirst.width
$oCtrlSelectedFirst.left -= $oCtrlSelectedFirst.width
$oCtrlSelectedFirst.height = -1 * $oCtrlSelectedFirst.height
$oCtrlSelectedFirst.top -= $oCtrlSelectedFirst.height
Switch $oCtrls.mode
Case $resize_se, $resize_nw
$aCoord1[0] = 0
$aCoord2[0] = $oCtrlSelectedFirst.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord1[1] = 0
$aCoord2[1] = $oCtrlSelectedFirst.height
Else
$aCoord1[1] = $oCtrlSelectedFirst.height
$aCoord2[1] = 0
EndIf
Case $resize_ne, $resize_sw
$aCoord1[0] = 0
$aCoord2[0] = $oCtrlSelectedFirst.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord1[1] = 0
$aCoord2[1] = $oCtrlSelectedFirst.height
Else
$aCoord1[1] = $oCtrlSelectedFirst.height
$aCoord2[1] = 0
EndIf
EndSwitch
$oCtrlSelectedFirst.grippies.show()
ElseIf $oCtrlSelectedFirst.width < 0 Then
$oCtrlSelectedFirst.width = -1 * $oCtrlSelectedFirst.width
$oCtrlSelectedFirst.left -= $oCtrlSelectedFirst.width
$aCoord1[0] = 0
$aCoord1[1] = $oCtrlSelectedFirst.coord2[1]
$aCoord2[0] = $oCtrlSelectedFirst.width
$aCoord2[1] = $oCtrl.coord1[1]
$oCtrl.grippies.show()
ElseIf $oCtrl.height < 0 Then
$oCtrl.height = -1 * $oCtrl.height
$oCtrlSelectedFirst.top -= $oCtrlSelectedFirst.height
If $aCoord2[1] > $aCoord1[1] Then
$aCoord1[0] = 0
$aCoord1[1] = $oCtrlSelectedFirst.height
$aCoord2[0] = $oCtrlSelectedFirst.width
$aCoord2[1] = 0
Else
$aCoord1[0] = 0
$aCoord1[1] = 0
$aCoord2[0] = $oCtrlSelectedFirst.width
$aCoord2[1] = $oCtrlSelectedFirst.height
EndIf
$oCtrlSelectedFirst.grippies.show()
EndIf
$oCtrlSelectedFirst.coord1 = $aCoord1
$oCtrlSelectedFirst.coord2 = $aCoord2
If $oCtrlSelectedFirst.Type = "Line" Then
Switch $oCtrls.mode
Case $resize_nw
$aCoord2[0] = $oCtrlSelectedFirst.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrlSelectedFirst.height
Else
$aCoord1[1] = $oCtrlSelectedFirst.height
EndIf
Case $resize_n
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrlSelectedFirst.height
Else
$aCoord1[1] = $oCtrlSelectedFirst.height
EndIf
Case $resize_w
$aCoord2[0] = $oCtrlSelectedFirst.width
Case $resize_e
$aCoord2[0] = $oCtrlSelectedFirst.width
Case $resize_s
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrlSelectedFirst.height
Else
$aCoord1[1] = $oCtrlSelectedFirst.height
EndIf
Case $resize_se
$aCoord2[0] = $oCtrlSelectedFirst.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrlSelectedFirst.height
Else
$aCoord1[1] = $oCtrlSelectedFirst.height
EndIf
Case $resize_ne
$aCoord2[0] = $oCtrlSelectedFirst.width
$aCoord2[0] = $oCtrlSelectedFirst.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrlSelectedFirst.height
Else
$aCoord1[1] = $oCtrlSelectedFirst.height
EndIf
Case $resize_sw
$aCoord2[0] = $oCtrlSelectedFirst.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrlSelectedFirst.height
Else
$aCoord1[1] = $oCtrlSelectedFirst.height
EndIf
EndSwitch
$oCtrlSelectedFirst.coord1 = $aCoord1
$oCtrlSelectedFirst.coord2 = $aCoord2
EndIf
_updateGraphic($oCtrlSelectedFirst)
EndSwitch
Local $oAction = _objAction()
$oAction.action = $action_drawCtrl
$oAction.ctrls = $oSelected.ctrls.Items()
Local $aParams[$oSelected.ctrls.Count]
Local $aParam[1]
For $i = 0 To UBound($oAction.ctrls) - 1
$aParam[0] = $oAction.ctrls[$i].Hwnd
$aParams[$i] = $aParam
Next
$oAction.parameters = $aParams
_updateActionStacks($oAction)
EndIf
Else
_log("** PrimaryUp: Resize Else **")
For $oCtrl In $oSelected.ctrls.Items()
Switch $oCtrl.Type
Case "Rect", "Ellipse", "Line"
Local $aCoord1 = [$oCtrl.coord1[0], $oCtrl.coord1[1]]
Local $aCoord2 = [$oCtrl.coord2[0], $oCtrl.coord2[1]]
If $oCtrl.width < 0 And $oCtrl.height < 0 Then
$oCtrl.width = -1 * $oCtrl.width
$oCtrl.left -= $oCtrl.width
$oCtrl.height = -1 * $oCtrl.height
$oCtrl.top -= $oCtrl.height
Switch $oCtrls.mode
Case $resize_se, $resize_nw
$aCoord1[0] = 0
$aCoord2[0] = $oCtrl.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord1[1] = 0
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
$aCoord2[1] = 0
EndIf
Case $resize_ne, $resize_sw
$aCoord1[0] = 0
$aCoord2[0] = $oCtrl.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord1[1] = 0
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
$aCoord2[1] = 0
EndIf
EndSwitch
$oCtrl.grippies.show()
ElseIf $oCtrl.width < 0 Then
$oCtrl.width = -1 * $oCtrl.width
$oCtrl.left -= $oCtrl.width
$aCoord1[0] = 0
$aCoord1[1] = $oCtrl.coord2[1]
$aCoord2[0] = $oCtrl.width
$aCoord2[1] = $oCtrl.coord1[1]
$oCtrl.grippies.show()
ElseIf $oCtrl.height < 0 Then
$oCtrl.height = -1 * $oCtrl.height
$oCtrl.top -= $oCtrl.height
If $aCoord2[1] > $aCoord1[1] Then
$aCoord1[0] = 0
$aCoord1[1] = $oCtrl.height
$aCoord2[0] = $oCtrl.width
$aCoord2[1] = 0
Else
$aCoord1[0] = 0
$aCoord1[1] = 0
$aCoord2[0] = $oCtrl.width
$aCoord2[1] = $oCtrl.height
EndIf
$oCtrl.grippies.show()
EndIf
$oCtrl.coord1 = $aCoord1
$oCtrl.coord2 = $aCoord2
If $oCtrl.Type = "Line" Then
Switch $oCtrls.mode
Case $resize_nw
$aCoord2[0] = $oCtrl.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
EndIf
Case $resize_n
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
EndIf
Case $resize_w
$aCoord2[0] = $oCtrl.width
Case $resize_e
$aCoord2[0] = $oCtrl.width
Case $resize_s
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
EndIf
Case $resize_se
$aCoord2[0] = $oCtrl.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
EndIf
Case $resize_ne
$aCoord2[0] = $oCtrl.width
$aCoord2[0] = $oCtrl.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
EndIf
Case $resize_sw
$aCoord2[0] = $oCtrl.width
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
EndIf
EndSwitch
$oCtrl.coord1 = $aCoord1
$oCtrl.coord2 = $aCoord2
EndIf
_updateGraphic($oCtrl)
EndSwitch
Next
Local $oAction = _objAction()
$oAction.action = $action_resizeCtrl
$oAction.ctrls = $oSelected.ctrls.Items()
Local $aParams[$oSelected.ctrls.Count]
Local $aParam[8]
For $i = 0 To UBound($oAction.ctrls) - 1
$aParam[0] = $oAction.ctrls[$i].PrevWidth
$aParam[1] = $oAction.ctrls[$i].PrevHeight
$aParam[2] = $oAction.ctrls[$i].Width
$aParam[3] = $oAction.ctrls[$i].Height
$aParam[4] = $oAction.ctrls[$i].PrevLeft
$aParam[5] = $oAction.ctrls[$i].PrevTop
$aParam[6] = $oAction.ctrls[$i].Left
$aParam[7] = $oAction.ctrls[$i].Top
$aParams[$i] = $aParam
Next
$oAction.parameters = $aParams
_updateActionStacks($oAction)
EndIf
_populate_control_properties_gui($oCtrlSelectedFirst)
If BitAND(GUICtrlRead($oMain.DefaultCursor), $GUI_CHECKED) = $GUI_CHECKED Then
$oCtrls.mode = $mode_default
Else
$oCtrls.mode = $mode_draw
EndIf
_refreshGenerateCode()
$initResize = False
_WinAPI_RedrawWindow($hGUI)
$updateObjectExplorer = True
_setLvSelected($oSelected.getFirst())
Case Else
_log("** PrimaryUp: Else **")
ToolTip('')
$oCtrl = $oSelected.getLast()
If IsObj($oCtrl) Then
_populate_control_properties_gui($oCtrl)
EndIf
If $oSelected.count > 0 Then
_refreshGenerateCode()
EndIf
_showProperties()
EndSwitch
If $oSelected.hasIP Then
For $oCtrl In $oCtrls.ctrls.Items()
If $oCtrl.Type = "IP" And $oCtrl.Dirty Then
_updateIP($oCtrl)
$oCtrl.Dirty = False
EndIf
Next
$updateObjectExplorer = True
EndIf
If $updateObjectExplorer Then
_formObjectExplorer_updateList()
EndIf
EndFunc
Func _onMouseSecondaryDown()
Local Const $ctrl_hwnd = GUIGetCursorInfo($hGUI)[4]
Switch $ctrl_hwnd
Case $background
_log("** SecondaryDown: background **")
_set_current_mouse_pos()
Case Else
_log("** SecondaryDown: control **")
Local $oCtrl = $oCtrls.get($ctrl_hwnd)
If $oCtrls.exists($ctrl_hwnd) Then
If Not $oSelected.exists($ctrl_hwnd) Then
_add_to_selected($oCtrl)
EndIf
_setLvSelected($oSelected.getFirst())
EndIf
EndSwitch
_set_current_mouse_pos()
EndFunc
Func _onMouseSecondaryUp()
Local Const $ctrl_hwnd = GUIGetCursorInfo($hGUI)[4]
Switch $ctrl_hwnd
Case $background
_log("** SecondaryUp: background **")
$oMouse.StartX = $oMouse.X
$oMouse.StartY = $oMouse.Y
ShowMenu($background_contextmenu, $oMouse.X, $oMouse.Y)
Case Else
_log("** SecondaryUp: control **")
Local $oCtrl = $oCtrls.get($ctrl_hwnd)
If $oCtrls.exists($ctrl_hwnd) Then
If $oCtrl.Type = "Tab" Then
ShowMenu($overlay_contextmenutab, $oMouse.X, $oMouse.Y)
Else
Local $hasLocked = False
For $oSelectedCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then
$hasLocked = True
ExitLoop
EndIf
Next
If $hasLocked Then
GUICtrlSetData($contextmenu_lock, "Unlock Control")
GUICtrlSetOnEvent($contextmenu_lock, "_onUnlockControl")
Else
GUICtrlSetData($contextmenu_lock, "Lock Control")
GUICtrlSetOnEvent($contextmenu_lock, "_onLockControl")
EndIf
ShowMenu($overlay_contextmenu, $oMouse.X, $oMouse.Y)
EndIf
EndIf
EndSwitch
EndFunc
Func _onMouseMove()
Static $timeMove = TimerInit()
If TimerDiff($timeMove) < 20 Then
Return 0
EndIf
Switch $oCtrls.mode
Case $mode_drawing
_log("MOVE:  Drawing")
Local $oCtrl = _create_ctrl(0, 0, $oMouse.StartX, $oMouse.StartY, $oCtrls.drawHwnd)
If IsObj($oCtrl) Then
_add_to_selected($oCtrl)
Switch $oCtrl.Type
Case "Combo", "Checkbox", "Radio"
$pos = ControlGetPos($hGUI, '', $oCtrl.grippies.East)
$oSelected.StartResizing()
$oCtrls.mode = $resize_e
_move_mouse_to_grippy($pos[0], $pos[1])
Case "Menu"
_set_default_mode()
$oCtrls.mode = $mode_default
_formObjectExplorer_updateList()
_refreshGenerateCode()
GUICtrlSetState($oMain.DefaultCursor, $GUI_CHECKED)
Case Else
$pos = ControlGetPos($hGUI, '', $oCtrl.grippies.SE)
$oSelected.StartResizing()
$oCtrls.mode = $resize_se
_move_mouse_to_grippy($pos[0], $pos[1])
EndSwitch
Else
GUICtrlSetState($oMain.DefaultCursor, $GUI_CHECKED)
_set_default_mode()
$oCtrls.mode = $mode_default
EndIf
Case $mode_default
If IsObj($oCtrls.clickedCtrl) Then
$oCtrls.mode = $mode_init_move
$oMouse.X = $oMouse.StartX
$oMouse.Y = $oMouse.StartY
EndIf
Case $mode_init_move, $mode_paste
Local $mouse_prevpos[2] = [$oMouse.X, $oMouse.Y]
$mouse_prevpos = _snap_to_grid($mouse_prevpos)
Local Const $mouse_pos = _mouse_snap_pos()
Local Const $delta_x = $mouse_prevpos[0] - $mouse_pos[0]
Local Const $delta_y = $mouse_prevpos[1] - $mouse_pos[1]
$oMouse.X = $mouse_pos[0]
$oMouse.Y = $mouse_pos[1]
If Not $left_click And Not $oCtrls.mode = $mode_paste Then
Return
EndIf
Local $tooltip
Local $count = $oSelected.count
If IsObj($oCtrls.clickedCtrl) Then
If $oCtrls.clickedCtrl.Locked Then
$oCtrls.mode = $mode_default
Return
EndIf
EndIf
_SendMessage($hGUI, $WM_SETREDRAW, False)
For $oCtrl In $oSelected.ctrls.Items()
_change_ctrl_size_pos($oCtrl, $oCtrl.Left - $delta_x, $oCtrl.Top - $delta_y, Default, Default)
$tooltip &= $oCtrl.Name & ": X:" & $oCtrl.Left & ", Y:" & $oCtrl.Top & ", W:" & $oCtrl.Width & ", H:" & $oCtrl.Height & @CRLF
If $oCtrls.mode = $mode_init_move Then
$oCtrl.Dirty = True
EndIf
Switch $oCtrl.Type
Case "Tab"
_moveTabCtrls($oCtrl, $delta_x, $delta_y, Default, Default)
Case "Group"
_moveGroupCtrls($oCtrl, $delta_x, $delta_y, Default, Default)
EndSwitch
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
If $oSelected.count < 5 Then
ToolTip(StringTrimRight($tooltip, 2))
Else
ToolTip("")
EndIf
Case $mode_init_selection
_log("MOVE:  Selection")
Local Const $oRect = _rect_from_points($oMouse.X, $oMouse.Y, MouseGetPos(0), MouseGetPos(1))
_display_selection_rect($oRect)
_add_remove_selected_control($oRect)
Return
Case $resize_nw, $resize_n, $resize_ne, $resize_w, $resize_e, $resize_sw, $resize_s, $resize_se
Local $tooltip
_SendMessage($hGUI, $WM_SETREDRAW, False)
For $oCtrlSelect In $oSelected.ctrls.Items()
$oCtrlSelect.grippies.resizing($oCtrls.mode)
$tooltip &= $oCtrlSelect.Name & ": X:" & $oCtrlSelect.Left & ", Y:" & $oCtrlSelect.Top & ", W:" & $oCtrlSelect.Width & ", H:" & $oCtrlSelect.Height & @CRLF
If $oCtrls.mode = $mode_init_move Then
$oCtrl.Dirty = True
EndIf
Next
_SendMessage($hGUI, $WM_SETREDRAW, True)
If $oSelected.count < 5 Then
ToolTip(StringTrimRight($tooltip, 2))
Else
ToolTip("")
EndIf
$oMain.hasChanged = True
EndSwitch
_WinAPI_RedrawWindow($hGUI)
$timeMove = TimerInit()
EndFunc
Func _onGenerateCode()
If Not IsHWnd($hFormGenerateCode) Then
GUICtrlSetState($menu_generateCode, $GUI_CHECKED)
_formGenerateCode()
GUISetState(@SW_SHOWNOACTIVATE, $hFormGenerateCode)
GUISwitch($hGUI)
Else
_onExitGenerateCode()
EndIf
Switch BitAND(GUICtrlRead($menu_generateCode), $GUI_CHECKED) = $GUI_CHECKED
Case True
IniWrite($sIniPath, "Settings", "ShowCode", 1)
$oOptions.showCodeViewer = True
Case False
IniWrite($sIniPath, "Settings", "ShowCode", 0)
$oOptions.showCodeViewer = False
EndSwitch
EndFunc
Func _onShowObjectExplorer()
If Not IsHWnd($hFormObjectExplorer) Then
GUICtrlSetState($menu_ObjectExplorer, $GUI_CHECKED)
_formObjectExplorer()
GUISetState(@SW_SHOWNOACTIVATE, $hFormObjectExplorer)
GUISwitch($hGUI)
Else
_onExitObjectExplorer()
EndIf
Switch BitAND(GUICtrlRead($menu_ObjectExplorer), $GUI_CHECKED) = $GUI_CHECKED
Case True
IniWrite($sIniPath, "Settings", "ShowObjectExplorer", 1)
$oOptions.ShowObjectExplorer = True
Case False
IniWrite($sIniPath, "Settings", "ShowObjectExplorer", 0)
$oOptions.ShowObjectExplorer = False
EndSwitch
EndFunc
Func _onResetLayout()
$oMain.Width = 400
$oMain.Height = 300
$oMain.Left = (@DesktopWidth / 2) - ($oMain.Width / 2)
$oMain.Top = (@DesktopHeight / 2) - ($oMain.Height / 2)
WinMove($hGUI, "", $oMain.Left, $oMain.Top, $oMain.Width + $iGuiFrameW, $oMain.Height + $iGuiFrameH)
WinSetTitle($hGUI, "", $oMain.Title & " - Form (" & $oMain.Width & ", " & $oMain.Height & ")")
Local Const $toolbar_width = 215
Local Const $toolbar_height = 480
Local $toolbar_left = $oMain.Left - ($toolbar_width + 5)
Local $toolbar_top = $oMain.Top
WinMove($hToolbar, "", $toolbar_left, $toolbar_top, $toolbar_width, $toolbar_height)
If IsHWnd($hFormObjectExplorer) Then
Local $w = 250
Local $h = 500
Local $x = $oMain.Left + ($oMain.Width + 5)
Local $y = $oMain.Top
WinMove($hFormObjectExplorer, "", $x, $y, $w, $h)
EndIf
If IsHWnd($hFormGenerateCode) Then
Local $w = 450
Local $h = 550
Local $x = $oMain.Left + 100
Local $y = $oMain.Top - 50
WinMove($hFormGenerateCode, "", $x, $y, $w, $h)
EndIf
EndFunc
Func _onTestGUI()
If ProcessExists($TestFilePID) Then
WinClose(_WinGetByPID($TestFilePID))
$bReTest = 1
Return
EndIf
Local $code = _code_generation()
$testFileName = _TempFile()
Local $fTestFile = FileOpen($testFileName, $FO_OVERWRITE)
If $fTestFile = -1 Then
MsgBox(1, "Error", "Error creating the test script")
Return
EndIf
Local $ret = FileWrite($fTestFile, $code)
If $fTestFile = 0 Then
MsgBox(1, "Error", "Error writing the test script")
Return
EndIf
FileClose($fTestFile)
If Not FileExists($au3InstallPath) Then
If Not FileExists(@ProgramFilesDir & "\AutoIt3\AutoIt3.exe") Then
Local $sFileOpenDialog = FileOpenDialog("Select AutoIt3.exe", @ProgramFilesDir, "(*.exe)", $FD_FILEMUSTEXIST, "AutoIt3.exe")
If @error Then
MsgBox(1, "Error", "Could not find AutoIt3.exe")
Return
Else
$au3InstallPath = $sFileOpenDialog
IniWrite($sIniPath, "Settings", "AutoIt3FullPath", $au3InstallPath)
EndIf
Else
$au3InstallPath = @ProgramFilesDir & "\AutoIt3\AutoIt3.exe"
EndIf
EndIf
$TestFilePID = Run($au3InstallPath & ' /AutoIt3ExecuteScript ' & $testFileName, @ScriptDir)
EndFunc
Func _onSettings()
_formSettings()
EndFunc
Func _WinGetByPID($iPID, $nArray = 1)
If IsString($iPID) Then $iPID = ProcessExists($iPID)
Local $aWList = WinList(), $sHold
For $iCC = 1 To $aWList[0][0]
If WinGetProcess($aWList[$iCC][1]) = $iPID And  BitAND(WinGetState($aWList[$iCC][1]), 2) Then
If $nArray Then Return $aWList[$iCC][0]
$sHold &= $aWList[$iCC][0] & Chr(1)
EndIf
Next
If $sHold Then Return StringSplit(StringTrimRight($sHold, 1), Chr(1))
Return SetError(1, 0, 0)
EndFunc
Func _onExitChild()
$a_ret = DllCall("user32.dll", "int", "DestroyWindow", "hwnd", @GUI_WinHandle)
EndFunc
Func _populate_control_properties_gui(Const $oCtrl, $childHwnd = -1)
If Not IsObj($oCtrl) Then Return
If Not $oCtrls.exists($oCtrl.Hwnd) Then
Return
EndIf
Local $text = $oCtrl.Text
If $oCtrl.Type = "Tab" Then
If $childHwnd <> -1 Then
Local $iTabFocus = _GUICtrlTab_GetCurSel($oCtrl.Hwnd)
If $iTabFocus >= 0 Then
$tabID = $oCtrl.Tabs.at($iTabFocus)
$text = $oCtrls.get($tabID).Text
EndIf
EndIf
EndIf
$oProperties_Ctrls.properties.Text.value = $text
Local $name = $oCtrl.Name
If $oCtrl.Type = "Tab" Then
If $childHwnd <> -1 Then
Local $iTabFocus = _GUICtrlTab_GetCurSel($oCtrl.Hwnd)
If $iTabFocus >= 0 Then
$tabID = $oCtrl.Tabs.at($iTabFocus)
$name = $oCtrls.get($tabID).Name
EndIf
EndIf
EndIf
$oProperties_Ctrls.properties.Name.value = $name
$oProperties_Ctrls.properties.Left.value = $oCtrl.Left
$oProperties_Ctrls.properties.Top.value = $oCtrl.Top
$oProperties_Ctrls.properties.Width.value = $oCtrl.Width
$oProperties_Ctrls.properties.Height.value = $oCtrl.Height
If $oCtrl.FontSize <> -1 Then
$oProperties_Ctrls.properties.FontSize.value = $oCtrl.FontSize
Else
$oProperties_Ctrls.properties.FontSize.value = 8.5
EndIf
If $oCtrl.Background <> -1 Then
$oProperties_Ctrls.properties.Background.value = "0x" & Hex($oCtrl.Background, 6)
Else
$oProperties_Ctrls.properties.Background.value = ""
EndIf
If $oCtrl.Color <> -1 Then
$oProperties_Ctrls.properties.Color.value = "0x" & Hex($oCtrl.Color, 6)
Else
$oProperties_Ctrls.properties.Color.value = ""
EndIf
If $oCtrl.BorderColor <> -1 Then
$oProperties_Ctrls.properties.BorderColor.value = "0x" & Hex($oCtrl.BorderColor, 6)
Else
$oProperties_Ctrls.properties.BorderColor.value = -1
EndIf
If $oCtrl.BorderSize > 1 Then
$oProperties_Ctrls.properties.BorderSize.value = $oCtrl.BorderSize
Else
$oProperties_Ctrls.properties.BorderSize.value = 1
EndIf
$oProperties_Ctrls.properties.Items.value = $oCtrl.Items
$oProperties_Ctrls.properties.Global.value = $oCtrl.Global
Local $iFw
Switch $oCtrl.FontWeight
Case 100
$iFw = 0
Case 200
$iFw = 1
Case 300
$iFw = 2
Case 400
$iFw = 3
Case 500
$iFw = 4
Case 600
$iFw = 5
Case 700
$iFw = 6
Case 800
$iFw = 7
Case 900
$iFw = 8
Case Else
$iFw = 3
EndSwitch
_GUICtrlComboBox_SetCurSel(GUICtrlGetHandle($oProperties_Ctrls.properties.FontWeight.Hwnd), $iFw)
If $oCtrl.FontName = "" Then
_GUICtrlComboBox_SetCurSel(GUICtrlGetHandle($oProperties_Ctrls.properties.FontName.Hwnd), -1)
Else
Local $selection = ControlCommand(HWnd($oProperties_Ctrls.properties.Hwnd), "", $oProperties_Ctrls.properties.FontName.Hwnd, "FindString", $oCtrl.FontName)
_GUICtrlComboBox_SetCurSel(GUICtrlGetHandle($oProperties_Ctrls.properties.FontName.Hwnd), $selection)
EndIf
$oProperties_Ctrls.properties.Img.value = $oCtrl.Img
EndFunc
Func _main_change_title()
Local Const $new_text = $oProperties_Main.properties.Title.value
$oMain.Title = $new_text
_refreshGenerateCode()
$oMain.hasChanged = True
WinSetTitle($hGUI, "", $oMain.Title & " - Form (" & $oMain.Width & ", " & $oMain.Height & ")")
EndFunc
Func _main_change_name()
Local $new_name = $oProperties_Main.properties.Name.value
$new_name = StringReplace($new_name, " ", "_")
$oProperties_Main.properties.Name.value = $new_name
$oMain.Name = $new_name
_refreshGenerateCode()
_formObjectExplorer_updateList()
$oMain.hasChanged = True
EndFunc
Func _main_change_left()
Local Const $new_text = $oProperties_Main.properties.Left.value
$oMain.Left = $new_text
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _main_change_top()
Local Const $new_text = $oProperties_Main.properties.Top.value
$oMain.Top = $new_text
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _main_change_width()
Local Const $newValue = $oProperties_Main.properties.Width.value
WinMove($hGUI, "", Default, Default, $newValue + $iGuiFrameW, Default)
Local $aWinPos = WinGetClientSize($hGUI)
WinSetTitle($hGUI, "", $oMain.Title & " - Form (" & $aWinPos[0] & ", " & $aWinPos[1] & ")")
$oMain.Width = $aWinPos[0]
If $oOptions.showGrid Then
_display_grid($background, $aWinPos[0], $aWinPos[1])
EndIf
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _main_change_height()
Local Const $newValue = $oProperties_Main.properties.Height.value
WinMove($hGUI, "", Default, Default, Default, $newValue + $iGuiFrameH)
Local $aWinPos = WinGetClientSize($hGUI)
WinSetTitle($hGUI, "", $oMain.Title & " - Form (" & $aWinPos[0] & ", " & $aWinPos[1] & ")")
$oMain.Height = $aWinPos[1]
If $oOptions.showGrid Then
_display_grid($background, $aWinPos[0], $aWinPos[1])
EndIf
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _main_pick_bkColor()
Local $color = _ChooseColor(2)
If $color = -1 Then Return 0
$oProperties_Main.properties.Background.value = $color
_main_change_background()
$oMain.hasChanged = True
EndFunc
Func _main_change_background()
Local $colorInput = $oProperties_Main.properties.Background.value
If $colorInput = "" Or $colorInput = -1 Then
$colorInput = $defaultGuiBkColor
Else
$colorInput = Dec(StringReplace($colorInput, "0x", ""))
EndIf
$oMain.Background = $oProperties_Main.properties.Background.value
GUISetBkColor($colorInput, $hGUI)
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _ctrl_change_text()
Local Const $new_text = $oProperties_Ctrls.properties.Text.value
Local Const $sel_count = $oSelected.count
Local $oAction = _objAction()
$oAction.action = $action_changeText
$oAction.ctrls = $oSelected.ctrls.Items()
Local $aParams[$oSelected.ctrls.Count]
Local $aParam[2]
For $i = 0 To UBound($oAction.ctrls) - 1
$aParam[0] = $oAction.ctrls[$i].Text
$aParam[1] = $oProperties_Ctrls.properties.Text.value
$aParams[$i] = $aParam
Next
$oAction.parameters = $aParams
_updateActionStacks($oAction)
Switch $sel_count >= 1
Case True
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
If $oCtrl.Type = "Combo" Then
GUICtrlSetData($oCtrl.Hwnd, $new_text, $new_text)
$oCtrl.Text = $new_text
ElseIf $oCtrl.Type = "Tab" Then
If $childSelected Then
Local $iTabFocus = _GUICtrlTab_GetCurSel($oCtrl.Hwnd)
If $iTabFocus >= 0 Then
_GUICtrlTab_SetItemText($oCtrl.Hwnd, $iTabFocus, $new_text)
$tabID = $oCtrl.Tabs.at($iTabFocus)
$oCtrls.get($tabID).Text = $new_text
EndIf
Else
$oCtrl.Text = $new_text
EndIf
ElseIf $oCtrl.Type = "Menu" Then
If $childSelected Then
Local $hSelected = _getLvSelectedHwnd()
Local $oCtrl = $oCtrls.get($hSelected)
If Not IsObj($oCtrl) Then Return -1
GUICtrlSetData($oCtrl.Hwnd, $new_text)
$oCtrl.Text = $new_text
Else
GUICtrlSetData($oCtrl.Hwnd, $new_text)
$oCtrl.Text = $new_text
EndIf
ElseIf $oCtrl.Type = "IP" Then
_GUICtrlIpAddress_Set($oCtrl.Hwnd, $new_text)
$oCtrl.Text = $new_text
Else
GUICtrlSetData($oCtrl.Hwnd, $new_text)
$oCtrl.Text = $new_text
EndIf
Next
EndSwitch
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _ctrl_change_name()
Local $new_name = $oProperties_Ctrls.properties.Name.value
$new_name = StringReplace($new_name, " ", "_")
$oProperties_Ctrls.properties.Name.value = $new_name
Local Const $sel_count = $oSelected.count
Local $oAction = _objAction()
$oAction.action = $action_renameCtrl
$oAction.ctrls = $oSelected.ctrls.Items()
Local $aParams[2] = [$oAction.ctrls[0].Name, $oProperties_Ctrls.properties.Name.value]
$oAction.parameters = $aParams
_updateActionStacks($oAction)
If $sel_count = 1 Then
Local $oCtrl = $oSelected.getFirst()
If $oCtrl.Locked Then Return
If $oCtrl.Type = "Tab" Then
If $childSelected Then
Local $iTabFocus = _GUICtrlTab_GetCurSel($oCtrl.Hwnd)
If $iTabFocus >= 0 Then
$tabID = $oCtrl.Tabs.at($iTabFocus)
$oCtrls.get($tabID).Name = $new_name
Else
$oCtrl.Name = $new_name
EndIf
Else
$oCtrl.Name = $new_name
EndIf
ElseIf $oCtrl.Type = "Menu" Then
If $childSelected Then
Local $hSelected = _getLvSelectedHwnd()
Local $oCtrl = $oCtrls.get($hSelected)
If Not IsObj($oCtrl) Then Return -1
$oCtrl.Name = $new_name
Else
$oCtrl.Name = $new_name
EndIf
Else
$oCtrl.Name = $new_name
EndIf
EndIf
_refreshGenerateCode()
_formObjectExplorer_updateList()
$oMain.hasChanged = True
EndFunc
Func _ctrl_change_left()
Local $new_data = $oProperties_Ctrls.properties.Left.value
If $new_data = "" Then
$new_data = 0
$oProperties_Ctrls.properties.Left.value = $new_data
EndIf
Local Const $sel_count = $oSelected.count
Local $oAction = _objAction()
$oAction.action = $action_resizeCtrl
$oAction.ctrls = $oSelected.ctrls.Items()
Local $aParams[$oSelected.ctrls.Count]
Local $aParam[8]
For $i = 0 To UBound($oAction.ctrls) - 1
$aParam[0] = $oAction.ctrls[$i].Width
$aParam[1] = $oAction.ctrls[$i].Height
$aParam[2] = $oAction.ctrls[$i].Width
$aParam[3] = $oAction.ctrls[$i].Height
$aParam[4] = $oAction.ctrls[$i].Left
$aParam[5] = $oAction.ctrls[$i].Top
$aParam[6] = $oProperties_Ctrls.properties.Left.value
$aParam[7] = $oAction.ctrls[$i].Top
$aParams[$i] = $aParam
Next
$oAction.parameters = $aParams
_updateActionStacks($oAction)
Switch $sel_count >= 1
Case True
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
Switch $oCtrl.Type
Case "Tab"
_moveTabCtrls($oCtrl, $oCtrl.Left - $new_data, Default, Default, Default)
Case "Group"
_moveGroupCtrls($oCtrl, $oCtrl.Left - $new_data, Default, Default, Default)
EndSwitch
_change_ctrl_size_pos($oCtrl, $new_data, Default, Default, Default)
$oCtrl.Left = $new_data
If $oSelected.hasIP Then
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Type = "IP" Then
_updateIP($oCtrl)
EndIf
Next
_formObjectExplorer_updateList()
EndIf
$oCtrl.grippies.show()
Next
EndSwitch
_refreshGenerateCode()
EndFunc
Func _ctrl_change_top()
Local $new_data = $oProperties_Ctrls.properties.Top.value
If $new_data = "" Then
$new_data = 0
$oProperties_Ctrls.properties.Top.value = $new_data
EndIf
Local Const $sel_count = $oSelected.count
Local $oAction = _objAction()
$oAction.action = $action_resizeCtrl
$oAction.ctrls = $oSelected.ctrls.Items()
Local $aParams[$oSelected.ctrls.Count]
Local $aParam[8]
For $i = 0 To UBound($oAction.ctrls) - 1
$aParam[0] = $oAction.ctrls[$i].Width
$aParam[1] = $oAction.ctrls[$i].Height
$aParam[2] = $oAction.ctrls[$i].Width
$aParam[3] = $oAction.ctrls[$i].Height
$aParam[4] = $oAction.ctrls[$i].Left
$aParam[5] = $oAction.ctrls[$i].Top
$aParam[6] = $oAction.ctrls[$i].Left
$aParam[7] = $oProperties_Ctrls.properties.Top.value
$aParams[$i] = $aParam
Next
$oAction.parameters = $aParams
_updateActionStacks($oAction)
Switch $sel_count >= 1
Case True
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
Switch $oCtrl.Type
Case "Tab"
_moveTabCtrls($oCtrl, Default, $oCtrl.Top - $new_data, Default, Default)
Case "Group"
_moveGroupCtrls($oCtrl, Default, $oCtrl.Top - $new_data, Default, Default)
EndSwitch
_change_ctrl_size_pos($oCtrl, Default, $new_data, Default, Default)
$oCtrl.Top = $new_data
If $oSelected.hasIP Then
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Type = "IP" Then
_updateIP($oCtrl)
EndIf
Next
_formObjectExplorer_updateList()
EndIf
$oCtrl.grippies.show()
Next
EndSwitch
_refreshGenerateCode()
EndFunc
Func _ctrl_change_width()
Local $new_data = $oProperties_Ctrls.properties.Width.value
If $new_data = "" Then
$new_data = 0
$oProperties_Ctrls.properties.Width.value = $new_data
EndIf
Local Const $sel_count = $oSelected.count
Local $oAction = _objAction()
$oAction.action = $action_resizeCtrl
$oAction.ctrls = $oSelected.ctrls.Items()
Local $aParams[$oSelected.ctrls.Count]
Local $aParam[8]
For $i = 0 To UBound($oAction.ctrls) - 1
$aParam[0] = $oAction.ctrls[$i].Width
$aParam[1] = $oAction.ctrls[$i].Height
$aParam[2] = $oProperties_Ctrls.properties.Width.value
$aParam[3] = $oAction.ctrls[$i].Height
$aParam[4] = $oAction.ctrls[$i].Left
$aParam[5] = $oAction.ctrls[$i].Top
$aParam[6] = $oAction.ctrls[$i].Left
$aParam[7] = $oAction.ctrls[$i].Top
$aParams[$i] = $aParam
Next
$oAction.parameters = $aParams
_updateActionStacks($oAction)
Switch $sel_count >= 1
Case True
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
_change_ctrl_size_pos($oCtrl, Default, Default, $new_data, Default)
Switch $oCtrl.Type
Case "Line"
Local $aCoord1 = [$oCtrl.coord1[0], $oCtrl.coord1[1]]
Local $aCoord2 = [$oCtrl.coord2[0], $oCtrl.coord2[1]]
$aCoord2[0] = $oCtrl.width
$oCtrl.coord1 = $aCoord1
$oCtrl.coord2 = $aCoord2
EndSwitch
$oCtrl.Width = $new_data
If $oSelected.hasIP Then
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Type = "IP" Then
_updateIP($oCtrl)
EndIf
Next
_formObjectExplorer_updateList()
EndIf
$oCtrl.grippies.show()
Next
EndSwitch
_refreshGenerateCode()
EndFunc
Func _ctrl_change_height()
Local $new_data = $oProperties_Ctrls.properties.Height.value
If $new_data = "" Then
$new_data = 0
$oProperties_Ctrls.properties.Height.value = $new_data
EndIf
Local Const $sel_count = $oSelected.count
Local $oAction = _objAction()
$oAction.action = $action_resizeCtrl
$oAction.ctrls = $oSelected.ctrls.Items()
Local $aParams[$oSelected.ctrls.Count]
Local $aParam[8]
For $i = 0 To UBound($oAction.ctrls) - 1
$aParam[0] = $oAction.ctrls[$i].Width
$aParam[1] = $oAction.ctrls[$i].Height
$aParam[2] = $oAction.ctrls[$i].Width
$aParam[3] = $oProperties_Ctrls.properties.Height.value
$aParam[4] = $oAction.ctrls[$i].Left
$aParam[5] = $oAction.ctrls[$i].Top
$aParam[6] = $oAction.ctrls[$i].Left
$aParam[7] = $oAction.ctrls[$i].Top
$aParams[$i] = $aParam
Next
$oAction.parameters = $aParams
_updateActionStacks($oAction)
Switch $sel_count >= 1
Case True
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
_change_ctrl_size_pos($oCtrl, Default, Default, Default, $new_data)
Switch $oCtrl.Type
Case "Line"
Local $aCoord1 = [$oCtrl.coord1[0], $oCtrl.coord1[1]]
Local $aCoord2 = [$oCtrl.coord2[0], $oCtrl.coord2[1]]
If $aCoord2[1] > $aCoord1[1] Then
$aCoord2[1] = $oCtrl.height
Else
$aCoord1[1] = $oCtrl.height
EndIf
$oCtrl.coord1 = $aCoord1
$oCtrl.coord2 = $aCoord2
EndSwitch
$oCtrl.Height = $new_data
If $oSelected.hasIP Then
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Type = "IP" Then
_updateIP($oCtrl)
EndIf
Next
_formObjectExplorer_updateList()
EndIf
$oCtrl.grippies.show()
Next
EndSwitch
_refreshGenerateCode()
EndFunc
Func _ctrl_pick_bkColor()
Local $color = _ChooseColor(2)
If $color = -1 Then Return 0
$oProperties_Ctrls.properties.Background.value = $color
_ctrl_change_bkColor()
$oMain.hasChanged = True
EndFunc
Func _ctrl_change_bkColor()
Local $colorInput = $oProperties_Ctrls.properties.Background.value
Local $newColor = $colorInput
If $colorInput = "" Then
$colorInput = -1
$oProperties_Ctrls.properties.Background.value = -1
Else
$colorInput = Dec(StringReplace($colorInput, "0x", ""))
EndIf
Local Const $sel_count = $oSelected.count
Local $oAction = _objAction()
$oAction.action = $action_changeBkColor
$oAction.ctrls = $oSelected.ctrls.Items()
Local $aParams[$oSelected.ctrls.Count]
Local $aParam[2]
For $i = 0 To UBound($oAction.ctrls) - 1
$aParam[0] = $oAction.ctrls[$i].Background
$aParam[1] = $colorInput
$aParams[$i] = $aParam
Next
$oAction.parameters = $aParams
_updateActionStacks($oAction)
Switch $sel_count >= 1
Case True
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
Switch $oCtrl.Type
Case "Label", "Checkbox", "Radio", "Input", "Edit"
If $colorInput <> -1 Then
GUICtrlSetBkColor($oCtrl.Hwnd, $colorInput)
Else
GUICtrlSetBkColor($oCtrl.Hwnd, $defaultGuiBkColor)
$oCtrl.Background = -1
EndIf
$oCtrl.Background = $colorInput
Case "Rect", "Ellipse", "Line"
$oCtrl.Background = $colorInput
_updateGraphic($oCtrl)
Case Else
ContinueLoop
EndSwitch
Next
EndSwitch
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _ctrl_pick_borderColor()
Local $color = _ChooseColor(2)
If $color = -1 Then Return 0
$oProperties_Ctrls.properties.BorderColor.value = $color
_ctrl_change_borderColor()
$oMain.hasChanged = True
EndFunc
Func _ctrl_change_borderColor()
Local $colorInput = $oProperties_Ctrls.properties.BorderColor.value
Local $newColor = $colorInput
If $colorInput = "" Then
$colorInput = -1
$oProperties_Ctrls.properties.BorderColor.value = -1
Else
$colorInput = Dec(StringReplace($colorInput, "0x", ""))
EndIf
Local Const $sel_count = $oSelected.count
Local $oAction = _objAction()
$oAction.action = $action_changeBorderColor
$oAction.ctrls = $oSelected.ctrls.Items()
Local $aParams[$oSelected.ctrls.Count]
Local $aParam[2]
For $i = 0 To UBound($oAction.ctrls) - 1
$aParam[0] = $oAction.ctrls[$i].BorderColor
$aParam[1] = $colorInput
$aParams[$i] = $aParam
Next
$oAction.parameters = $aParams
_updateActionStacks($oAction)
Switch $sel_count >= 1
Case True
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
Switch $oCtrl.Type
Case "Rect", "Ellipse", "Line"
$oCtrl.BorderColor = $colorInput
_updateGraphic($oCtrl)
Case Else
ContinueLoop
EndSwitch
Next
EndSwitch
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _ctrl_change_borderSize()
Local $new_data = $oProperties_Ctrls.properties.BorderSize.value
If $new_data = "" Or $new_data = "-1" Then
$oProperties_Ctrls.properties.BorderSize.value = 1
$new_data = 1
EndIf
Local Const $sel_count = $oSelected.count
Local $oAction = _objAction()
$oAction.action = $action_changeBorderSize
$oAction.ctrls = $oSelected.ctrls.Items()
Local $aParams[$oSelected.ctrls.Count]
Local $aParam[2]
For $i = 0 To UBound($oAction.ctrls) - 1
$aParam[0] = $oAction.ctrls[$i].BorderSize
$aParam[1] = $new_data
$aParams[$i] = $aParam
Next
$oAction.parameters = $aParams
_updateActionStacks($oAction)
Switch $sel_count >= 1
Case True
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
Switch $oCtrl.Type
Case "Rect", "Ellipse", "Line"
$oCtrl.BorderSize = $new_data
_updateGraphic($oCtrl)
Case Else
ContinueLoop
EndSwitch
Next
EndSwitch
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _ctrl_change_global()
Local $new_data = _onCheckboxChange(@GUI_CtrlId)
Local Const $sel_count = $oSelected.count
Switch $sel_count >= 1
Case True
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
$oCtrl.Global = $new_data
Next
EndSwitch
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _ctrl_change_items()
Local $new_data = $oProperties_Ctrls.properties.Items.value
$new_data = _items_GetList($new_data, "|", "|")
Local Const $sel_count = $oSelected.count
Switch $sel_count >= 1
Case True
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
$oCtrl.Items = $new_data
Next
EndSwitch
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _ctrl_change_FontSize()
Local $new_data = $oProperties_Ctrls.properties.FontSize.value
If $new_data = "" Or $new_data = "8.5" Then
$oProperties_Ctrls.properties.FontSize.value = 8.5
$new_data = -1
ElseIf Not StringRegExp($new_data, '^[1-9]\d*(\.\d+)?$') Then
$oProperties_Ctrls.properties.FontSize.value = ""
Return -1
EndIf
Local Const $sel_count = $oSelected.count
Switch $sel_count >= 1
Case True
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
If $oCtrl.Type = "IP" Then
_GUICtrlIpAddress_SetFont($oCtrl.Hwnd, "Arial", $new_data)
Else
GUICtrlSetFont($oCtrl.Hwnd, $new_data, $oCtrl.FontWeight)
EndIf
$oCtrl.FontSize = $new_data
Next
EndSwitch
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _ctrl_change_FontWeight()
Local $new_data = $oProperties_Ctrls.properties.FontWeight.value
Switch $new_data
Case "Thin"
$new_data = 100
Case "Extra Light"
$new_data = 200
Case "Light"
$new_data = 300
Case "Normal"
$new_data = 400
Case "Medium"
$new_data = 500
Case "Semi Bold"
$new_data = 600
Case "Bold"
$new_data = 700
Case "Extra Bold"
$new_data = 800
Case "Heavy"
$new_data = 900
Case Else
$new_data = 400
EndSwitch
Local Const $sel_count = $oSelected.count
Switch $sel_count >= 1
Case True
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
If $oCtrl.Type = "IP" Then
_GUICtrlIpAddress_SetFont($oCtrl.Hwnd, "Arial", $oCtrl.FontSize, $new_data)
Else
GUICtrlSetFont($oCtrl.Hwnd, $oCtrl.FontSize, $new_data)
EndIf
$oCtrl.FontWeight = $new_data
Next
EndSwitch
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _ctrl_change_FontName()
Local $new_data = $oProperties_Ctrls.properties.FontName.value
Local Const $sel_count = $oSelected.count
Switch $sel_count >= 1
Case True
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
If $oCtrl.Type = "IP" Then
_GUICtrlIpAddress_SetFont($oCtrl.Hwnd, $new_data, $oCtrl.FontSize, $oCtrl.FontWeight)
Else
GUICtrlSetFont($oCtrl.Hwnd, $oCtrl.FontSize, $oCtrl.FontWeight, $GUI_FONTNORMAL, $new_data)
EndIf
$oCtrl.FontName = $new_data
Next
EndSwitch
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _ctrl_pick_Color()
Local $color = _ChooseColor(2)
If $color = -1 Then Return 0
$oProperties_Ctrls.properties.Color.value = $color
_ctrl_change_Color()
EndFunc
Func _ctrl_change_Color()
Local $colorInput = $oProperties_Ctrls.properties.Color.value
Local $newColor = $colorInput
If $colorInput = "" Then
$colorInput = -1
$oProperties_Ctrls.properties.Color.value = -1
Else
$colorInput = Dec(StringReplace($colorInput, "0x", ""))
EndIf
Local Const $sel_count = $oSelected.count
Local $oAction = _objAction()
$oAction.action = $action_changeColor
$oAction.ctrls = $oSelected.ctrls.Items()
Local $aParams[$oSelected.ctrls.Count]
Local $aParam[2]
For $i = 0 To UBound($oAction.ctrls) - 1
$aParam[0] = $oAction.ctrls[$i].Color
$aParam[1] = $colorInput
$aParams[$i] = $aParam
Next
$oAction.parameters = $aParams
_updateActionStacks($oAction)
Switch $sel_count >= 1
Case True
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
Switch $oCtrl.Type
Case "Label", "Edit", "Input"
If $colorInput <> -1 Then
GUICtrlSetColor($oCtrl.Hwnd, $colorInput)
Else
GUICtrlDelete($oCtrl.Hwnd)
$oCtrl.Hwnd = GUICtrlCreateLabel($oCtrl.Text, $oCtrl.Left, $oCtrl.Top, $oCtrl.Width, $oCtrl.Height)
$oCtrl.Color = -1
If $oCtrl.Background <> -1 Then
GUICtrlSetBkColor($oCtrl.Hwnd, $oCtrl.Background)
EndIf
EndIf
$oCtrl.Color = $colorInput
Case Else
Return 0
EndSwitch
Next
EndSwitch
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _ctrl_pick_img()
Local $filterString = "All (*.bmp; *.jpg; *.gif; *.ico; *.avi)|Bitmap (*.bmp)|JPEG (*.jpg; *.jpeg)|GIF (*.gif)|Icon (*.ico)|AVI (*.avi)"
Local $ret = FileOpenDialog("Select Image", @ScriptFullPath, $filterString, $FD_FILEMUSTEXIST)
If @error Then
Return
EndIf
$oProperties_Ctrls.properties.Img.value = $ret
_ctrl_change_img()
EndFunc
Func _ctrl_change_img()
Local $ext = StringRegExpReplace($oProperties_Ctrls.properties.Img.value, "^.*\.", "", "")
For $oCtrl In $oSelected.ctrls.Items()
If $oCtrl.Locked Then ContinueLoop
$oCtrl.Img = $oProperties_Ctrls.properties.Img.value
If StringCompare($ext, "ico") = 0 Then
If $oCtrl.Type <> "Icon" Then
$oCtrl.Type = "Icon"
GUICtrlDelete($oCtrl.hwnd)
$oCtrl.hwnd = GUICtrlCreateIcon($oCtrl.Img, -1, $oCtrl.Left, $oCtrl.Top, $oCtrl.Width, $oCtrl.Height)
EndIf
ElseIf StringCompare($ext, "avi") = 0 Then
$oCtrl.Type = "Avi"
GUICtrlDelete($oCtrl.hwnd)
$oCtrl.hwnd = GUICtrlCreateAvi($oCtrl.Img, 0, $oCtrl.Left, $oCtrl.Top, $oCtrl.Width, $oCtrl.Height)
Else
If $oCtrl.Type <> "Pic" Then
$oCtrl.Type = "Pic"
GUICtrlDelete($oCtrl.hwnd)
$oCtrl.hwnd = GUICtrlCreatePic($oCtrl.Img, $oCtrl.Left, $oCtrl.Top, $oCtrl.Width, $oCtrl.Height)
EndIf
EndIf
GUICtrlSetImage($oCtrl.Hwnd, $oCtrl.Img, -1)
Next
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _ctrl_change_visible()
EndFunc
Func _ctrl_change_enabled()
EndFunc
Func _ctrl_change_focus()
EndFunc
Func _ctrl_change_ontop()
EndFunc
Func _ctrl_change_dropaccepted()
EndFunc
Func _ctrl_change_style_autocheckbox()
EndFunc
Func _ctrl_change_style_top()
EndFunc
Func _wipe_current_gui()
Switch @GUI_CtrlId
Case $menu_wipe
Switch MsgBox($MB_SYSTEMMODAL + $MB_YESNO + $MB_ICONWARNING, "Alert", "Are You Sure?  This action can not be undone.")
Case $IDNO
Return
EndSwitch
EndSwitch
GUICtrlSetState($menu_wipe, $GUI_DISABLE)
Local Const $count = $oCtrls.count
For $oCtrl In $oCtrls.ctrls.Items()
_delete_ctrl($oCtrl, True)
Next
_formObjectExplorer_updateList()
_set_default_mode()
_WinAPI_RedrawWindow($hGUI)
$oCtrls.ButtonCount = 0
$oCtrls.GroupCount = 0
$oCtrls.CheckboxCount = 0
$oCtrls.RadioCount = 0
$oCtrls.EditCount = 0
$oCtrls.InputCount = 0
$oCtrls.LabelCount = 0
$oCtrls.ListCount = 0
$oCtrls.ComboCount = 0
$oCtrls.DateCount = 0
$oCtrls.SliderCount = 0
$oCtrls.TabCount = 0
$oCtrls.TreeViewCount = 0
$oCtrls.UpdownCount = 0
$oCtrls.ProgressCount = 0
$oCtrls.PicCount = 0
$oCtrls.AviCount = 0
$oCtrls.IconCount = 0
_refreshGenerateCode()
_formObjectExplorer_updateList()
_updateActionStacks()
EndFunc
Func ClientToScreen(ByRef $x, ByRef $y)
Local $tPoint = DllStructCreate("int X;int Y")
DllStructSetData($tPoint, "X", $x)
DllStructSetData($tPoint, "Y", $y)
_WinAPI_ClientToScreen($hGUI, $tPoint)
$x = DllStructGetData($tPoint, "X")
$y = DllStructGetData($tPoint, "Y")
EndFunc
Func ScreenToClient(ByRef $x, ByRef $y)
Local $tPoint = DllStructCreate("int X;int Y")
DllStructSetData($tPoint, "X", $x)
DllStructSetData($tPoint, "Y", $y)
_WinAPI_ScreenToClient($hGUI, $tPoint)
$x = DllStructGetData($tPoint, "X")
$y = DllStructGetData($tPoint, "Y")
EndFunc
Func _mouse_snap_pos()
Return _snap_to_grid(MouseGetPos())
EndFunc
Func _snap_to_grid($coords)
If $oOptions.snapGrid Then
$coords[0] = $oOptions.gridSize * Int($coords[0] / $oOptions.gridSize - 0.5) + $oOptions.gridSize
$coords[1] = $oOptions.gridSize * Int($coords[1] / $oOptions.gridSize - 0.5) + $oOptions.gridSize
EndIf
Return $coords
EndFunc
Func _set_current_mouse_pos($noSnap = False)
Local $mouse_snap_pos
If $noSnap Then
$mouse_snap_pos = MouseGetPos()
Else
$mouse_snap_pos = _mouse_snap_pos()
EndIf
$oMouse.X = $mouse_snap_pos[0]
$oMouse.Y = $mouse_snap_pos[1]
EndFunc
Func _cursor_out_of_bounds(Const $cursor_pos)
If __WinAPI_PtInRectEx($cursor_pos[0], $cursor_pos[1], 0, 0, $oMain.Width, $oMain.Height) Then
Return False
EndIf
Return True
EndFunc
Func _set_default_mode()
_recall_overlay()
_remove_all_from_selected()
_setLvSelected(0)
$oCtrls.mode = $mode_default
EndFunc
Func __WinAPI_CreateRect(Const $left, Const $top, Const $right, Const $bottom)
Local Static $tRECT = DllStructCreate($tagRECT)
With $tRECT
.Left = $left
.Top = $top
.Right = $right
.Bottom = $bottom
EndWith
Return $tRECT
EndFunc
Func __WinAPI_CreatePoint(Const $x, Const $y)
Local Static $tPoint = DllStructCreate($tagPOINT)
With $tPoint
.X = $x
.Y = $y
EndWith
Return $tPoint
EndFunc
Func __WinAPI_PtInRectEx(Const $x, Const $y, Const $left, Const $top, Const $width, Const $height)
Local Const $right = $left + $width
Local Const $bottom = $top + $height
Local $tRECT = __WinAPI_CreateRect($left, $top, $right, $bottom)
Local $tPoint = __WinAPI_CreatePoint($x, $y)
Local Const $aRet = _WinAPI_PtInRect($tRECT, $tPoint)
Return @error ? SetError(@error, @extended, False) : $aRet
EndFunc
Func _CtrlInRect(Const $x, Const $y, Const $w, Const $h, Const $left, Const $top, Const $width, Const $height)
If $x > $left And $y > $top And $x + $w < $left + $width And $y + $h < $top + $height Then
Return True
Else
Return False
EndIf
EndFunc
Func _CtrlCrossRect(Const $x, Const $y, Const $w, Const $h, Const $left, Const $top, Const $width, Const $height)
If ($left < ($x + $w) And $top < ($y + $h)) And (($left + $width) > $x And ($top + $height) > $y) Then
Return True
Else
Return False
EndIf
EndFunc
Func _rect_from_points(Const $a1, Const $a2, Const $b1, Const $b2)
Local $oRect = _objCreateRect()
$oRect.Left = ($a1 < $b1) ? $a1 : $b1
$oRect.Top = ($a2 < $b2) ? $a2 : $b2
$oRect.Width = ($b1 > $a1) ? ($b1 - $oRect.Left) : ($a1 - $oRect.Left)
$oRect.Height = ($b2 > $a2) ? ($b2 - $oRect.Top) : ($a2 - $oRect.Top)
Return $oRect
EndFunc
Func _onExportMenuItem()
_save_code()
EndFunc
Func ShowMenu(Const $context, $x, $y)
Local Const $hMenu = GUICtrlGetHandle($context)
ClientToScreen($x, $y)
_GUICtrlMenu_TrackPopupMenu($hMenu, $hGUI, $x, $y)
EndFunc
Func _onHelpItem()
ShellExecute(@ScriptDir & "\storage\GuiBuilderPlus.chm")
EndFunc
Func _onGithubItem()
ShellExecute('https://github.com/KurtisLiggett/GuiBuilderPlus')
EndFunc
Func _menu_about()
_formAbout()
EndFunc
Func _onContextMenu_Event()
_formEventCode()
EndFunc
Func _onMenuRecent()
Local $sText = GUICtrlRead(@GUI_CtrlId, $GUI_READ_EXTENDED)
Local $sFilename = StringRegExpReplace($sText, '^\d+ ', "", 1)
_load_gui_definition($sFilename)
EndFunc
Func _addToRecentFiles($sFilename)
For $i = 0 To UBound($aMenuRecentList) - 1
If $aMenuRecentList[$i] <> 0 Then
GUICtrlDelete($aMenuRecentList[$i])
EndIf
Next
Local $aRecentFiles = IniReadSection($sIniPath, "Recent")
If Not @error Then
Local $aNewList[$aRecentFiles[0][0] + 1][2]
$aNewList[0][0] = $aRecentFiles[0][0]
$aNewList[1][0] = 1
$aNewList[1][1] = $sFilename
Local $index = 2
Local $exists = False
For $i = 1 To $aRecentFiles[0][0]
If $index > $aRecentFiles[0][0] Then
If $aRecentFiles[0][0] < 10 And $aRecentFiles[$i][1] <> $sFilename Then
ReDim $aNewList[$aNewList[0][0] + 2][2]
$aNewList[0][0] = $aRecentFiles[0][0] + 1
$aNewList[$index][0] = $index
$aNewList[$index][1] = $aRecentFiles[$i][1]
EndIf
ExitLoop
EndIf
If $aRecentFiles[$i][1] <> $sFilename Then
$aNewList[$index][0] = $index
$aNewList[$index][1] = $aRecentFiles[$i][1]
$index += 1
EndIf
Next
Else
Local $aNewList[2][2]
$aNewList[0][0] = 1
$aNewList[1][0] = 1
$aNewList[1][1] = $sFilename
EndIf
For $i = 1 To 10
If $i > $aNewList[0][0] Then
$aMenuRecentList[$i - 1] = 0
Else
$aMenuRecentList[$i - 1] = GUICtrlCreateMenuItem($i & " " & $aNewList[$i][1], $menu_file)
GUICtrlSetOnEvent(-1, "_onMenuRecent")
EndIf
Next
$aMenuRecentList[10] = GUICtrlCreateMenuItem("", $menu_file)
$aMenuRecentList[11] = GUICtrlCreateMenuItem("Exit", $menu_file)
GUICtrlSetOnEvent(-1, "_onExit")
IniWriteSection($sIniPath, "Recent", $aNewList)
EndFunc
Func GUIGetBkColor($hWnd)
Local $iColor = 0
If IsHWnd($hWnd) Then
Local $hDC = _WinAPI_GetDC($hWnd)
$iColor = _WinAPI_GetBkColor($hDC)
_WinAPI_ReleaseDC($hWnd, $hDC)
EndIf
Return $iColor
EndFunc
Func _saveWinPositions()
If Not BitAND(WinGetState($hGUI), $WIN_STATE_MINIMIZED) Then
Local $currentWinPos = WinGetPos($hGUI)
IniWrite($sIniPath, "Settings", "posMain", $currentWinPos[0] & "," & $currentWinPos[1])
$currentWinPos = WinGetPos($hToolbar)
IniWrite($sIniPath, "Settings", "posToolbar", $currentWinPos[0] & "," & $currentWinPos[1])
If IsHWnd($hFormGenerateCode) Then
$currentWinPos = WinGetPos($hFormGenerateCode)
IniWrite($sIniPath, "Settings", "posGenerateCode", $currentWinPos[0] & "," & $currentWinPos[1])
EndIf
If IsHWnd($hFormObjectExplorer) Then
$currentWinPos = WinGetPos($hFormObjectExplorer)
IniWrite($sIniPath, "Settings", "posObjectExplorer", $currentWinPos[0] & "," & $currentWinPos[1])
EndIf
EndIf
EndFunc
Func _setIconFromResource($ctrlID, $sIconName, $iIcon)
If @Compiled = 1 Then
GUICtrlSetImage($ctrlID, @ScriptFullPath, $iIcon)
Else
GUICtrlSetImage($ctrlID, $iconset & "\" & $sIconName)
EndIf
EndFunc
Func GetIconData($iconSel)
Local $icondData
Switch $iconSel
Case 0
$icondData = '' &  'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAByFBMVEX///8AAP8A' &  'AAAACwAAqgAABwD+/v8DA//5+f/09PTx8fHCwsJeYF7q6uri4uJrbWtZWVm2tv+m' &  'pqaOjo6C1YJoamixsf+Z3ZkOrw729v+trf/8/f3X8tdmZmYCAgLU1P/R0f+hof8u' &  'Lv8hIf8TE/8PD//39/cGBgb7+//z8//t7f/X1//Hx/92dv9OTv/5+fnc3NxjY2NR' &  'UVFKSkobGxsKCgrv7//r6//e3v/a2v/Ly/+lpf+Jif95ef9YWP86Ov8zM/8pKf8e' &  'Hv8MDP8KCv8HB/+8vLwuLi7n5//i4v+/v/+pqf+dnf9wcP9jY/9LS/8lJf8bG/8W' &  'Fv/m5ubU79TOzs6RkZGLi4uIiIhBQUE+Pj4SEhLOzv+4uP+Tk/+Ojv99ff9zc/9n' &  'Z/9cXP9RUf83N/8ZGf/Y2NjV1dXR0dHIyMi3t7etra2hoaGampqVlZWEhIRycnJp' &  'aWlVVVU4ODg1NTUiIiIWFhYAoA8IqwuGhv+EhP9AQP8NDf9fYfzs7OwADezg7uDg' &  '4ODe3t7O6M7A2sA9bbe1tbUAM7Oy5bKysrIAOKpSlpkARJkAU4M0h4J/1H9Wx1ZO' &  'xE5BwEE1vDUAijAnJycApwXm4IuGAAADT0lEQVRIx72W11rbQBCFR46QRAlghyhg' &  'E2yKwdh003sJmN57SWih9xIgvfdeXzdnJQtJxjZ3/De738452pnRymu6CjpuMkoo' &  'KrmKaJsYN66BmHjSSXPO2e3W2UrSiYthqoQwBqG7L0vkVAb75bRLDGl3szkTOQ2d' &  'UQxC5oomvNOmbdP2UAo1xABmqBpQFEOLdT5JEDzV8kKLspDlYwaGaoi9zigmVysH' &  'HlsF0qltFNkmMgmKKI4MFLgRyrZSCK77WBbr6AJOpm/MV5s+ZhufGN9adRBwvP30' &  'nBNlCsHLutPAshE6DissKjMJHQ5K5/mvyMpHZhqhLyQwdmQxcrQGwzcRlUtkRIa+' &  'iD1/N4/J8gL+Q39AmZ6M8nzKPMKPyIBnkONWvJhMMs2DnVi1fTZ/hsXyBgZPE95M' &  'J+nU4QmsEVtMn5SrB8am817DQC6RZazThByR0PUZ6PfIiFCSzgy0hFOSRho12CAT' &  '4z70Zbr4e6oCz5+lpp6dnv6xk8Y9ZJiP1492Vozohh+8iX9PSaMILcKwgw0OSGf0' &  'FiOF539i+PzlfStpDHFcPYYyGOIpFLUGmkPaVdoHhrkVYzkyckQydEJUQCrVmDvR' &  'dmxwTJEMAhqrVe2CoYuoxNCjzWQNW9BAOeik2bAOQzKpJFs08kaDBjcM5pTWDDuU' &  'Ws558ev3By0lc9EvEZ0mlUSbwhSWYkmhy1A0tSptzcVJKycTt3WDFQav4cUNYPiL' &  '8KtIhgZ8v+ajoSY+EcmQxXH9RIaqe4k+sm+hOLyhFhJ76PEuLkd8MryhEcdb0gM9' &  '6vneZX2PD2eYRVMbSMeDn7jhKnIcQ1Dx7qJBwo/Tk+DR05s24KGSEygyElYFYjji' &  'A0FDIccab2IJS30CraMMWAIHk+N7CeocXehFsFkiE5WDWFwQaMRvMZFRCj0KcNdQ' &  'CL4cOJYrSdicyjiXz5RukMTyEa10gVrmGJKR/ohtv2xq2l86sVGM5WYst/eQgbhE' &  'Ri45sznQJBuSFQqWRay5reRQRM/MF4q3iGMM92e6KiUp32fvwyNAc41+oYRcWT2t' &  'XJD2dm3mrpeiXootnInhee9l125BYXPw6WLLolWKcu3qSDXdstztzI9wsXckMS77' &  '66CItukK+A86y3aCrkROIwAAAABJRU5ErkJggg=='
EndSwitch
Return _Base64Decode($icondData)
EndFunc
Func _Base64Decode($input_string)
Local $struct = DllStructCreate("int")
$a_Call = DllCall("Crypt32.dll", "int", "CryptStringToBinary",  "str", $input_string,  "int", 0,  "int", 1,  "ptr", 0,  "ptr", DllStructGetPtr($struct, 1),  "ptr", 0,  "ptr", 0)
If @error Or Not $a_Call[0] Then
Return SetError(1, 0, "")
EndIf
Local $a = DllStructCreate("byte[" & DllStructGetData($struct, 1) & "]")
$a_Call = DllCall("Crypt32.dll", "int", "CryptStringToBinary",  "str", $input_string,  "int", 0,  "int", 1,  "ptr", DllStructGetPtr($a),  "ptr", DllStructGetPtr($struct, 1),  "ptr", 0,  "ptr", 0)
If @error Or Not $a_Call[0] Then
Return SetError(2, 0, "")
EndIf
Return DllStructGetData($a, 1)
EndFunc
Func _memoryToPic($idPic, $name)
$hBmp = _GDIPlus_BitmapCreateFromMemory(Binary($name), 1)
_WinAPI_DeleteObject(GUICtrlSendMsg($idPic, 0x0172, 0, $hBmp))
_WinAPI_DeleteObject($hBmp)
Return 0
EndFunc
Func _display_selection_rect(Const $oRect)
GUISwitch($hGUI)
If $overlay <> -1 Then
GUICtrlDelete($overlay)
$overlay = -1
EndIf
$overlay = GUICtrlCreateGraphic($oRect.Left, $oRect.Top, $oRect.Width, $oRect.Height)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetGraphic($overlay, $GUI_GR_RECT, 0, 0, $oRect.Width, $oRect.Height)
GUICtrlSetGraphic($overlay, $GUI_GR_REFRESH)
GUICtrlSetGraphic($background, $GUI_GR_REFRESH)
GUISwitch($hGUI)
EndFunc
Func _recall_overlay()
GUISwitch($hGUI)
If $overlay <> -1 Then
GUICtrlDelete($overlay)
$overlay = -1
$overlay = GUICtrlCreateGraphic(0, 0, 0, 0)
GUICtrlSetState(-1, $GUI_DISABLE)
EndIf
GUISwitch($hGUI)
EndFunc
Global Enum $typeHeading, $typeText, $typeNumber, $typeCheck, $typeColor, $getHeight, $typeReal, $typeComboFW, $typeComboFN
Global $properties_data[100][10], $properties_fontIndex, $properties_borderIndex, $properties_itemsIndex, $properties_textIndex, $properties_imgIndex
Func _formPropertyInspector($x, $y, $w, $h)
$w = $w - $__g_aSB_WindowInfo[0][5] / 2
$h = $h - 25
Local $labelLine = GUICtrlCreateLabel("", $x, $y, 70 + 50, 1)
GUICtrlSetBkColor(-1, 0xC5C5C5)
Local $tabHeight = 20
$tabProperties = GUICtrlCreateLabel("Properties", $x, $y + 1, 70, $tabHeight - 1, BitOR($GUI_SS_DEFAULT_LABEL, $SS_CENTER, $SS_CENTERIMAGE))
GUICtrlSetBkColor(-1, 0xEEEEEE)
GUICtrlSetColor(-1, 0x000000)
GUICtrlSetOnEvent(-1, "_onTabProperties")
$labelLine = GUICtrlCreateLabel("", $x + 70, $y, 1, $tabHeight)
GUICtrlSetBkColor(-1, 0xC5C5C5)
$tabStyles = GUICtrlCreateLabel("Styles", $x + 71, $y + 1, 50, $tabHeight - 1, BitOR($GUI_SS_DEFAULT_LABEL, $SS_CENTER, $SS_CENTERIMAGE))
GUICtrlSetBkColor(-1, 0xD6D6D6)
GUICtrlSetColor(-1, 0x000000)
GUICtrlSetOnEvent(-1, "_onTabStyles")
$labelLine = GUICtrlCreateLabel("", $x + 71 + 50, $y, 1, $tabHeight)
GUICtrlSetBkColor(-1, 0xC5C5C5)
$labelLine = GUICtrlCreateLabel("", $x, $y + $tabHeight, $w, 1)
GUICtrlSetBkColor(-1, 0xC5C5C5)
$y = $y + $tabHeight
$h = $h - $tabHeight
$labelLine = GUICtrlCreateLabel("", $x, $y, $w, 1)
GUICtrlSetBkColor(-1, 0xDDDDDD)
Local $guiHandle = GUICreate("", $w, $h, $x, $y + 1, $WS_POPUP, $WS_EX_MDICHILD, $hToolbar)
GUISetBkColor(0xFFFFFF)
Local $ret = _GUIScrollbars_Generate($guiHandle, $w - 2, $h)
$oProperties_Main.properties.Hwnd = $guiHandle
Local $iScrollbarWidth = $__g_aSB_WindowInfo[0][5]
Local $labelLine = GUICtrlCreateLabel("", $w - $iScrollbarWidth - 1, 0, 1, $h + 20)
GUICtrlSetBkColor(-1, 0xDDDDDD)
$oProperties_Main.properties.Background.Hwnd = _formPropertyInspector_newitem("Background", $typeColor, 20, 1, $w - $iScrollbarWidth - 1, 20, "_main_pick_bkColor")
$oProperties_Main.properties.Height.Hwnd = _formPropertyInspector_newitem("Height", $typeNumber)
$oProperties_Main.properties.Left.Hwnd = _formPropertyInspector_newitem("Left", $typeNumber)
$oProperties_Main.properties.Name.Hwnd = _formPropertyInspector_newitem("Name", $typeText)
$oProperties_Main.properties.Title.Hwnd = _formPropertyInspector_newitem("Title", $typeText)
$oProperties_Main.properties.Top.Hwnd = _formPropertyInspector_newitem("Top", $typeNumber)
$oProperties_Main.properties.Width.Hwnd = _formPropertyInspector_newitem("Width", $typeNumber)
Local $itemsHeight = _formPropertyInspector_newitem("", $getHeight)
$labelLine = GUICtrlCreateLabel("", $w - $iScrollbarWidth - 1 - 81, 0, 1, $itemsHeight)
GUICtrlSetBkColor(-1, 0xDDDDDD)
GUICtrlSetOnEvent($oProperties_Main.properties.Title.Hwnd, _main_change_title)
GUICtrlSetOnEvent($oProperties_Main.properties.Name.Hwnd, _main_change_name)
GUICtrlSetOnEvent($oProperties_Main.properties.Left.Hwnd, _main_change_left)
GUICtrlSetOnEvent($oProperties_Main.properties.Top.Hwnd, _main_change_top)
GUICtrlSetOnEvent($oProperties_Main.properties.Width.Hwnd, _main_change_width)
GUICtrlSetOnEvent($oProperties_Main.properties.Height.Hwnd, _main_change_height)
GUICtrlSetOnEvent($oProperties_Main.properties.Background.Hwnd, _main_change_background)
$oProperties_Main.properties.Title.value = $oMain.Title
$oProperties_Main.properties.Name.value = $oMain.Name
$oProperties_Main.properties.Width.value = $oMain.Width
$oProperties_Main.properties.Height.value = $oMain.Height
$oProperties_Main.properties.Left.value = $oMain.Left
$oProperties_Main.properties.Top.value = $oMain.Top
$oProperties_Main.properties.Background.value = $oMain.Background
_generateStyles($w, $h, $x, $y + 1)
$newH = 19 * 15
$guiHandle = GUICreate("", $w, $h, $x, $y + 1, $WS_POPUP, $WS_EX_MDICHILD, $hToolbar)
GUISetBkColor(0xFFFFFF)
_GUIScrollbars_Generate($guiHandle, $w - 2, $newH)
$oProperties_Ctrls.properties.Hwnd = $guiHandle
Local $labelLine = GUICtrlCreateLabel("", $w - $iScrollbarWidth - 1, 0, 1, $newH + 20)
GUICtrlSetBkColor(-1, 0xDDDDDD)
$oProperties_Ctrls.properties.Background.Hwnd = _formPropertyInspector_newitem("Background", $typeColor, 20, 1, $w - $iScrollbarWidth - 1, 20, "_ctrl_pick_bkColor", 1)
$oProperties_Ctrls.properties.FontName.Hwnd = _formPropertyInspector_newitem("Font", $typeComboFN, 20, -1, -1, -1, -1, 1)
$properties_fontIndex = $properties_data[0][0]
$oProperties_Ctrls.properties.FontSize.Hwnd = _formPropertyInspector_newitem("Size", $typeReal, 30, -1, -1, -1, -1, 1, 1, $properties_fontIndex)
$oProperties_Ctrls.properties.FontWeight.Hwnd = _formPropertyInspector_newitem("Weight", $typeComboFW, 30, -1, -1, -1, -1, 1, 1, $properties_fontIndex)
$oProperties_Ctrls.properties.Color.Hwnd = _formPropertyInspector_newitem("Color", $typeColor, 30, -1, -1, -1, "_ctrl_pick_Color", 1, 1, $properties_fontIndex)
$oProperties_Ctrls.properties.Global.Hwnd = _formPropertyInspector_newitem("Global", $typeCheck, 20, -1, -1, -1, -1, 1)
$oProperties_Ctrls.properties.Height.Hwnd = _formPropertyInspector_newitem("Height", $typeNumber, -1, -1, -1, -1, -1, 1)
$oProperties_Ctrls.properties.Img.Hwnd = _formPropertyInspector_newitem("Image", $typeColor, -1, -1, -1, -1, "_ctrl_pick_img", 1)
$properties_imgIndex = $properties_data[0][0]
$oProperties_Ctrls.properties.Items.Hwnd = _formPropertyInspector_newitem("Items", $typeColor, -1, -1, -1, -1, "_formListItems", 1)
$properties_itemsIndex = $properties_data[0][0]
$oProperties_Ctrls.properties.Left.Hwnd = _formPropertyInspector_newitem("Left", $typeNumber, -1, -1, -1, -1, -1, 1)
$oProperties_Ctrls.properties.BorderColor.Hwnd = _formPropertyInspector_newitem("Line Color", $typeColor, -1, -1, -1, -1, "_ctrl_pick_borderColor", 1)
$properties_borderIndex = $properties_data[0][0]
$oProperties_Ctrls.properties.BorderSize.Hwnd = _formPropertyInspector_newitem("Thickness", $typeNumber, 30, -1, -1, -1, -1, 1, 1, $properties_borderIndex)
$oProperties_Ctrls.properties.Name.Hwnd = _formPropertyInspector_newitem("Name", $typeText, 20, -1, -1, -1, -1, 1)
$oProperties_Ctrls.properties.Text.Hwnd = _formPropertyInspector_newitem("Text", $typeText, -1, -1, -1, -1, -1, 1)
$properties_textIndex = $properties_data[0][0]
$oProperties_Ctrls.properties.Top.Hwnd = _formPropertyInspector_newitem("Top", $typeNumber, -1, -1, -1, -1, -1, 1)
$oProperties_Ctrls.properties.Width.Hwnd = _formPropertyInspector_newitem("Width", $typeNumber, -1, -1, -1, -1, -1, 1)
$properties_borderButton = GUICtrlCreateLabel("-", 3, 201, 15, 18, BitOR($SS_CENTER, $SS_CENTERIMAGE))
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetFont(-1, 12)
GUICtrlSetOnEvent(-1, "_onBorderButton")
Local $aTemp = $properties_data[$properties_borderIndex][0]
For $i = 0 To UBound($aTemp)
If $aTemp[$i] = 0 Then
$aTemp[$i] = $properties_borderButton
ExitLoop
EndIf
Next
$properties_data[$properties_borderIndex][0] = $aTemp
$properties_fontButton = GUICtrlCreateLabel("-", 3, 21, 15, 18, BitOR($SS_CENTER, $SS_CENTERIMAGE))
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetFont(-1, 12)
GUICtrlSetOnEvent(-1, "_onFontButton")
$aTemp = $properties_data[$properties_fontIndex][0]
For $i = 0 To UBound($aTemp)
If $aTemp[$i] = 0 Then
$aTemp[$i] = $properties_fontButton
ExitLoop
EndIf
Next
$properties_data[$properties_fontIndex][0] = $aTemp
_onBorderButton()
_onFontButton()
Local $itemsHeight = _formPropertyInspector_newitem("", $getHeight)
$labelLine = GUICtrlCreateLabel("", $w - $iScrollbarWidth - 1 - 81, 0, 1, $itemsHeight)
GUICtrlSetBkColor(-1, 0xDDDDDD)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.Text.Hwnd, _ctrl_change_text)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.Name.Hwnd, _ctrl_change_name)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.Left.Hwnd, _ctrl_change_left)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.Top.Hwnd, _ctrl_change_top)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.Width.Hwnd, _ctrl_change_width)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.Height.Hwnd, _ctrl_change_height)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.Color.Hwnd, _ctrl_change_Color)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.FontName.Hwnd, _ctrl_change_FontName)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.FontSize.Hwnd, _ctrl_change_FontSize)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.FontWeight.Hwnd, _ctrl_change_FontWeight)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.Background.Hwnd, _ctrl_change_bkColor)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.BorderColor.Hwnd, _ctrl_change_borderColor)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.BorderSize.Hwnd, _ctrl_change_borderSize)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.Global.Hwnd, _ctrl_change_global)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.Items.Hwnd, _ctrl_change_items)
GUICtrlSetOnEvent($oProperties_Ctrls.properties.Img.Hwnd, _ctrl_change_img)
GUISwitch($hToolbar)
EndFunc
Func _onFontButton()
Local $shiftAmount = 60
Local $hWin = HWnd($oProperties_Ctrls.properties.Hwnd)
$properties_data[$properties_fontIndex][1] = Not $properties_data[$properties_fontIndex][1]
For $i = $properties_fontIndex + 1 To $properties_data[0][0]
If $properties_data[$i][2] = $properties_fontIndex Then
If $properties_data[$properties_fontIndex][1] Then
$properties_data[$i][1] = 1
For $iCtrl In $properties_data[$i][0]
If $iCtrl = 0 Then ExitLoop
GUICtrlSetState($iCtrl, $GUI_SHOW)
Next
GUICtrlSetData($properties_fontButton, "-")
Else
$properties_data[$i][1] = 0
For $iCtrl In $properties_data[$i][0]
If $iCtrl = 0 Then ExitLoop
GUICtrlSetState($iCtrl, $GUI_HIDE)
Next
GUICtrlSetData($properties_fontButton, "+")
EndIf
Else
If $properties_data[$properties_fontIndex][1] Then
For $iCtrl In $properties_data[$i][0]
If $iCtrl = 0 Then ExitLoop
Local $aPos = ControlGetPos($hWin, "", $iCtrl)
ControlMove($hWin, "", $iCtrl, $aPos[0], $aPos[1] + $shiftAmount)
Next
Else
For $iCtrl In $properties_data[$i][0]
If $iCtrl = 0 Then ExitLoop
Local $aPos = ControlGetPos($hWin, "", $iCtrl)
ControlMove($hWin, "", $iCtrl, $aPos[0], $aPos[1] - $shiftAmount)
Next
EndIf
EndIf
Next
_WinAPI_RedrawWindow($hWin)
EndFunc
Func _onBorderButton()
Local $shiftAmount = 20
Local $hWin = HWnd($oProperties_Ctrls.properties.Hwnd)
$properties_data[$properties_borderIndex][1] = Not $properties_data[$properties_borderIndex][1]
For $i = $properties_borderIndex + 1 To $properties_data[0][0]
If $properties_data[$i][2] = $properties_borderIndex Then
If $properties_data[$properties_borderIndex][1] Then
$properties_data[$i][1] = 1
For $iCtrl In $properties_data[$i][0]
If $iCtrl = 0 Then ExitLoop
GUICtrlSetState($iCtrl, $GUI_SHOW)
Next
GUICtrlSetData($properties_borderButton, "-")
Else
$properties_data[$i][1] = 0
For $iCtrl In $properties_data[$i][0]
If $iCtrl = 0 Then ExitLoop
GUICtrlSetState($iCtrl, $GUI_HIDE)
Next
GUICtrlSetData($properties_borderButton, "+")
EndIf
Else
If $properties_data[$properties_borderIndex][1] Then
For $iCtrl In $properties_data[$i][0]
If $iCtrl = 0 Then ExitLoop
Local $aPos = ControlGetPos($hWin, "", $iCtrl)
ControlMove($hWin, "", $iCtrl, $aPos[0], $aPos[1] + $shiftAmount)
Next
Else
For $iCtrl In $properties_data[$i][0]
If $iCtrl = 0 Then ExitLoop
Local $aPos = ControlGetPos($hWin, "", $iCtrl)
ControlMove($hWin, "", $iCtrl, $aPos[0], $aPos[1] - $shiftAmount)
Next
EndIf
EndIf
Next
_WinAPI_RedrawWindow($hWin)
EndFunc
Func _propertiesShowBorder($show = True)
_propertiesShowProp($properties_borderIndex, $show)
EndFunc
Func _propertiesShowItems($show = True)
_propertiesShowProp($properties_itemsIndex, $show)
EndFunc
Func _propertiesShowText($show = True)
_propertiesShowProp($properties_textIndex, $show)
EndFunc
Func _propertiesShowImg($show = True)
_propertiesShowProp($properties_imgIndex, $show)
EndFunc
Func _propertiesShowProp($itemIndex, $show = True)
Local $aCtrl = $properties_data[$itemIndex][0]
If (BitAND(GUICtrlGetState($aCtrl[0]), $GUI_SHOW) = $GUI_SHOW) = $show Then Return
Local $shiftSize = 20
Local $shiftAmount = $shiftSize
Local $hWin = HWnd($oProperties_Ctrls.properties.Hwnd)
If $show Then
For $iCtrl In $properties_data[$itemIndex][0]
If $iCtrl = 0 Then ExitLoop
GUICtrlSetState($iCtrl, $GUI_SHOW)
Next
Else
For $iCtrl In $properties_data[$itemIndex][0]
If $iCtrl = 0 Then ExitLoop
GUICtrlSetState($iCtrl, $GUI_HIDE)
Next
EndIf
For $i = $itemIndex + 1 To $properties_data[0][0]
If $show Then
If $properties_data[$i][2] = $itemIndex Then
If $properties_data[$itemIndex][1] Then
$shiftAmount += $shiftSize
For $iCtrl In $properties_data[$i][0]
If $iCtrl = 0 Then ExitLoop
GUICtrlSetState($iCtrl, $GUI_SHOW)
Next
Else
For $iCtrl In $properties_data[$i][0]
If $iCtrl = 0 Then ExitLoop
GUICtrlSetState($iCtrl, $GUI_HIDE)
Next
EndIf
Else
For $iCtrl In $properties_data[$i][0]
If $iCtrl = 0 Then ExitLoop
Local $aPos = ControlGetPos($hWin, "", $iCtrl)
ControlMove($hWin, "", $iCtrl, $aPos[0], $aPos[1] + $shiftAmount)
Next
EndIf
Else
If $properties_data[$i][2] = $itemIndex Then
If $properties_data[$i][1] Then
$shiftAmount += $shiftSize
EndIf
For $iCtrl In $properties_data[$i][0]
If $iCtrl = 0 Then ExitLoop
GUICtrlSetState($iCtrl, $GUI_HIDE)
Next
Else
For $iCtrl In $properties_data[$i][0]
If $iCtrl = 0 Then ExitLoop
Local $aPos = ControlGetPos($hWin, "", $iCtrl)
ControlMove($hWin, "", $iCtrl, $aPos[0], $aPos[1] - $shiftAmount)
Next
EndIf
EndIf
Next
_WinAPI_RedrawWindow($hWin)
EndFunc
Func _formPropertyInspector_newitem($text, $type = -1, $x = -1, $y = -1, $w = -1, $h = -1, $funcName = -1, $ctrlProp = 0, $show = 1, $parent = -1)
Static $item_x, $item_y, $item_w, $item_h, $count = 0
If $type = $getHeight Then
Return $item_y + $item_h
EndIf
If $x <> -1 Then
$item_x = $x
Else
If $count = 0 Then
$item_x = 0
EndIf
EndIf
If $x <> -1 Then
$item_x = $x
Else
If $count = 0 Then
$item_x = 0
EndIf
EndIf
If $y <> -1 Then
$item_y = $y
Else
If $count = 0 Then
$item_y = 0
Else
$item_y += $item_h
EndIf
EndIf
If $w <> -1 Then
$item_w = $w
Else
If $count = 0 Then
$item_w = 0
EndIf
EndIf
If $h <> -1 Then
$item_h = $h
Else
If $count = 0 Then
$item_h = 0
EndIf
EndIf
$count += 1
Local $editWidth = 80
Local $labelWidth = $item_w - $editWidth - $item_x
Local $label = GUICtrlCreateLabel($text, $item_x, $item_y, $labelWidth - 5 - 1, $item_h - 1, $SS_CENTERIMAGE)
GUICtrlSetFont(-1, 8.5)
GUICtrlSetColor(-1, 0x333333)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetTip(-1, $text)
Local $aLineIds[10]
If $ctrlProp Then
_addLineID($aLineIds, $label)
EndIf
Switch $type
Case $typeNumber
Local $edit = GUICtrlCreateInput("", $item_w - $editWidth, $item_y, $editWidth, $item_h - 1, BitOR($ES_AUTOHSCROLL, $ES_NUMBER, $SS_CENTERIMAGE), $WS_EX_TRANSPARENT)
GUICtrlSetFont(-1, 8.5)
If $ctrlProp Then
_addLineID($aLineIds, $edit)
EndIf
Case $typeReal
Local $edit = GUICtrlCreateInput("", $item_w - $editWidth, $item_y, $editWidth, $item_h - 1, BitOR($ES_AUTOHSCROLL, $SS_CENTERIMAGE), $WS_EX_TRANSPARENT)
GUICtrlSetFont(-1, 8.5)
If $ctrlProp Then
_addLineID($aLineIds, $edit)
EndIf
Case $typeColor
Local $edit = GUICtrlCreateInput("", $item_w - $editWidth, $item_y, $editWidth - 15, $item_h - 1, BitOR($ES_AUTOHSCROLL, $SS_CENTERIMAGE), $WS_EX_TRANSPARENT)
GUICtrlSetFont(-1, 8.5)
If $ctrlProp Then
_addLineID($aLineIds, $edit)
EndIf
Local $pickButton = GUICtrlCreateButton("...", $item_w - 16, $item_y + 2, 18, $item_h - 4)
If $funcName <> -1 Then
GUICtrlSetOnEvent($pickButton, $funcName)
EndIf
If $ctrlProp Then
_addLineID($aLineIds, $pickButton)
EndIf
Case $typeCheck
Local $lab = GUICtrlCreateLabel("", $item_w - $editWidth, $item_y, $editWidth, $item_h - 1)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetState(-1, $GUI_DISABLE)
If $ctrlProp Then
_addLineID($aLineIds, $lab)
EndIf
Local $edit = GUICtrlCreateCheckbox("", $item_w - 45, $item_y, -1, $item_h - 1, BitOR($SS_CENTERIMAGE, $BS_3STATE))
GUICtrlSetBkColor(-1, 0xFFFFFF)
If $ctrlProp Then
_addLineID($aLineIds, $edit)
EndIf
Case $typeComboFN
Local $edit = GUICtrlCreateCombo("", $item_w - $editWidth, $item_y, $editWidth, $item_h - 1, BitOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
Local $sData = ""
Local $aData = _WinAPI_EnumFontFamilies(0, '', $ANSI_CHARSET, BitOR($DEVICE_FONTTYPE, $TRUETYPE_FONTTYPE), '@*', 1)
If Not @error And $aData[0][0] > 0 Then
$sData = $aData[1][0]
For $i = 2 To $aData[0][0]
$sData &= "|" & $aData[$i][0]
Next
EndIf
GUICtrlSetData($edit, $sData)
If $ctrlProp Then
_addLineID($aLineIds, $edit)
EndIf
Case $typeComboFW
Local $edit = GUICtrlCreateCombo("", $item_w - $editWidth, $item_y, $editWidth, $item_h - 1, BitOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
GUICtrlSetData(-1, "Thin|Extra Light|Light|Normal|Medium|Semi Bold|Bold|Extra Bold|Heavy")
If $ctrlProp Then
_addLineID($aLineIds, $edit)
EndIf
Case $typeHeading
Local $aStrings = StringSplit($text, "|", $STR_NOCOUNT)
GUICtrlSetData($label, $aStrings[0])
GUICtrlSetFont($label, 8.5, $FW_BOLD)
Local $edit = GUICtrlCreateLabel(" " & $aStrings[1], $item_w - $editWidth, $item_y, $editWidth, $item_h - 1, $SS_CENTERIMAGE)
GUICtrlSetColor(-1, 0x333333)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetFont($edit, 8.5, $FW_BOLD)
Case Else
Local $edit = GUICtrlCreateInput("", $item_w - $editWidth, $item_y, $editWidth, $item_h - 1, BitOR($ES_AUTOHSCROLL, $SS_CENTERIMAGE), $WS_EX_TRANSPARENT)
If $ctrlProp Then
_addLineID($aLineIds, $edit)
EndIf
EndSwitch
Local $labelLine = GUICtrlCreateLabel("", 0, $item_y + $item_h - 1, $item_w, 1)
GUICtrlSetBkColor(-1, 0xDDDDDD)
If $ctrlProp Then
_addLineID($aLineIds, $labelLine)
_addPropertyToGlobalArray($aLineIds, $show, $parent, $item_y)
EndIf
Return $edit
EndFunc
Func _addLineID(ByRef $aLineData, $id)
For $i = 0 To UBound($aLineData) - 1
If $aLineData[$i] <> 0 Then
ContinueLoop
Else
$aLineData[$i] = $id
ExitLoop
EndIf
Next
EndFunc
Func _addPropertyToGlobalArray($ctrlID, $show, $parent, $yPos)
If $properties_data[0][0] + 1 > UBound($properties_data) - 1 Then
ReDim $properties_data[$properties_data[0][0] + 100][10]
EndIf
$properties_data[0][0] = $properties_data[0][0] + 1
$properties_data[$properties_data[0][0]][0] = $ctrlID
$properties_data[$properties_data[0][0]][1] = $show
$properties_data[$properties_data[0][0]][2] = $parent
$properties_data[$properties_data[0][0]][3] = $yPos
EndFunc
Func _showProperties($props = $props_Main)
If $oSelected.count > 0 Then
$props = $props_Ctrls
Else
$props = $props_Main
EndIf
Switch $props
Case $props_Main
GUISetState(@SW_HIDE, $oProperties_Ctrls.properties.Hwnd)
Switch $tabSelected
Case "Properties"
GUISetState(@SW_SHOWNOACTIVATE, $oProperties_Main.properties.Hwnd)
GUISetState(@SW_HIDE, $tabStylesHwnd)
Case "Styles"
_generateStyles()
GUISetState(@SW_HIDE, $oProperties_Main.properties.Hwnd)
GUISetState(@SW_SHOWNOACTIVATE, $tabStylesHwnd)
EndSwitch
Case $props_Ctrls
GUISetState(@SW_HIDE, $oProperties_Main.properties.Hwnd)
Switch $tabSelected
Case "Properties"
Local $aCtrlTypes = _check_Ctl_Types()
Local $bIsAllLabels = $aCtrlTypes[0]
Local $bIsGraphic = $aCtrlTypes[1]
Local $bHasBG = $aCtrlTypes[2]
Local $bHasItems = $aCtrlTypes[3]
Local $bHasText = $aCtrlTypes[4]
Local $bHasImg = $aCtrlTypes[5]
If $bIsAllLabels Then
GUICtrlSetState($oProperties_Ctrls.properties.Color.Hwnd, $GUI_ENABLE)
Else
GUICtrlSetState($oProperties_Ctrls.properties.Color.Hwnd, $GUI_DISABLE)
EndIf
If $bHasBG Then
GUICtrlSetState($oProperties_Ctrls.properties.Background.Hwnd, $GUI_ENABLE)
Else
GUICtrlSetState($oProperties_Ctrls.properties.Background.Hwnd, $GUI_DISABLE)
EndIf
If $bIsGraphic Then
_propertiesShowBorder(True)
Else
_propertiesShowBorder(False)
EndIf
If $bHasItems Then
_propertiesShowItems(True)
Else
_propertiesShowItems(False)
EndIf
If $bHasText Then
_propertiesShowText(True)
Else
_propertiesShowText(False)
EndIf
If $bHasImg Then
_propertiesShowImg(True)
Else
_propertiesShowImg(False)
EndIf
GUISetState(@SW_HIDE, $tabStylesHwnd)
GUISetState(@SW_SHOWNOACTIVATE, $oProperties_Ctrls.properties.Hwnd)
Case "Styles"
_generateStyles()
GUISetState(@SW_SHOWNOACTIVATE, $tabStylesHwnd)
GUISetState(@SW_HIDE, $oProperties_Ctrls.properties.Hwnd)
EndSwitch
Case Else
GUISetState(@SW_SHOWNOACTIVATE, $oProperties_Main.properties.Hwnd)
GUISetState(@SW_HIDE, $tabStylesHwnd)
GUISetState(@SW_HIDE, $oProperties_Ctrls.properties.Hwnd)
EndSwitch
GUISwitch($hGUI)
EndFunc
Func _generateStyles($w = Default, $h = Default, $x = Default, $y = Default)
Static $left, $top, $width, $height
If $w = Default Then
GUIDelete($tabStylesHwnd)
EndIf
If $x <> Default Then $left = $x
If $y <> Default Then $top = $y
If $w <> Default Then $width = $w
If $h <> Default Then $height = $h
$tabStylesHwnd = GUICreate("", $width, $height - 2, $left, $top + 1, $WS_POPUP, $WS_EX_MDICHILD, $hToolbar)
GUISetBkColor(0xFFFFFF)
Local $ret = _GUIScrollbars_Generate($tabStylesHwnd, $width - 2, $height + 350)
_set_accelerators(True)
Local $iScrollbarWidth = $__g_aSB_WindowInfo[0][5]
Local $labelLine = GUICtrlCreateLabel("", $width - $iScrollbarWidth - 1, 0, 1, $height + 20)
GUICtrlSetBkColor(-1, 0xDDDDDD)
Local $props
If $oSelected.count > 0 Then
$props = $props_Ctrls
Else
$props = $props_Main
EndIf
Local $isVisible = BitAND(WinGetState($tabStylesHwnd), $WIN_STATE_VISIBLE)
If $isVisible Then
_SendMessage($tabStylesHwnd, $WM_SETREDRAW, False)
EndIf
Switch $props
Case $props_Main
Local $i = 0, $objProp
$oProperties_Main.styles.RemoveAll()
For $sStyleString In $oMain.styles.Keys()
$objProp = _objProperty($sStyleString, "Checkbox")
If $i = 0 Then
$objProp.Hwnd = _formPropertyInspector_newitem($sStyleString, $typeCheck, 5, 1, $width - $iScrollbarWidth - 1, 20)
Else
$objProp.Hwnd = _formPropertyInspector_newitem($sStyleString, $typeCheck, -1, -1, -1, -1)
EndIf
GUICtrlSetOnEvent($objProp.Hwnd, "_onStyleChange")
$objProp.value = (StringRegExp($oMain.styleString, '(?:^|,\s)\$' & $sStyleString & '(?:,|$)')) ? $GUI_CHECKED : $GUI_UNCHECKED
$oProperties_Main.styles.Add($sStyleString, $objProp)
$i += 1
Next
Case $props_Ctrls
Local $stylesObj
For $oCtrl In $oSelected.ctrls.Items()
If Not IsObj($stylesObj) Then
$stylesObj = $oCtrl
Else
If $oCtrl.styles.Count < $stylesObj.styles.Count Then
$stylesObj = $oCtrl
EndIf
EndIf
Next
Local $aStyles[100], $addStyle = True, $i = 0
For $sStyleString In $stylesObj.styles.Keys()
For $oCtrl In $oSelected.ctrls.Items()
If Not $oCtrl.styles.Exists($sStyleString) Then
$addStyle = False
ExitLoop
EndIf
Next
If $addStyle Then
$aStyles[$i] = $sStyleString
$i += 1
EndIf
Next
$i = 0
Local $objProp
$oProperties_Ctrls.styles.RemoveAll()
For $sStyleString In $aStyles
If $sStyleString = "" Then ExitLoop
$objProp = _objProperty($sStyleString, "Checkbox")
If $i = 0 Then
$objProp.Hwnd = _formPropertyInspector_newitem($sStyleString, $typeCheck, 5, 1, $width - $iScrollbarWidth - 1, 20)
Else
$objProp.Hwnd = _formPropertyInspector_newitem($sStyleString, $typeCheck, -1, -1, -1, -1)
EndIf
GUICtrlSetOnEvent($objProp.Hwnd, "_onStyleChange")
Local $checkValue = -1
For $oCtrl In $oSelected.ctrls.Items()
If StringRegExp($oCtrl.styleString, '(?:^|,\s)\$' & $sStyleString & '(?:,|$)') Then
If $checkValue = $GUI_UNCHECKED Then
$checkValue = $GUI_INDETERMINATE
ExitLoop
Else
$checkValue = $GUI_CHECKED
EndIf
Else
If $checkValue = $GUI_CHECKED Then
$checkValue = $GUI_INDETERMINATE
ExitLoop
Else
$checkValue = $GUI_UNCHECKED
EndIf
EndIf
Next
$objProp.value = $checkValue
$oProperties_Ctrls.styles.Add($sStyleString, $objProp)
$i += 1
Next
EndSwitch
Local $itemsHeight = _formPropertyInspector_newitem("", $getHeight)
$labelLine = GUICtrlCreateLabel("", $width - $iScrollbarWidth - 1 - 81, 0, 1, $itemsHeight)
GUICtrlSetBkColor(-1, 0xDDDDDD)
If $isVisible Then
_SendMessage($tabStylesHwnd, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($tabStylesHwnd)
EndIf
GUISwitch($hGUI)
EndFunc
Func _check_Ctl_Types()
Local $aTypeChecks[10] = [True, True, True, True, True, True, True, True, True, True]
If $oSelected.count > 0 Then
For $oCtrl In $oSelected.ctrls.Items()
Switch $oCtrl.Type
Case "Label", "Input", "Edit"
$aTypeChecks[1] = False
$aTypeChecks[3] = False
Case "Rect", "Ellipse", "Line"
$aTypeChecks[0] = False
$aTypeChecks[3] = False
Case "List", "Combo", "ListView"
$aTypeChecks[0] = False
$aTypeChecks[1] = False
Case Else
$aTypeChecks[0] = False
$aTypeChecks[1] = False
$aTypeChecks[3] = False
EndSwitch
Switch $oCtrl.Type
Case "Label", "Checkbox", "Radio", "Edit", "Input", "Rect", "Ellipse"
Case Else
$aTypeChecks[2] = False
EndSwitch
Switch $oCtrl.Type
Case "Rect", "Ellipse", "Line", "List", "Combo", "ListView", "TreeView", "Slider", "Progress", "Pic", "Icon", "Avi"
$aTypeChecks[4] = False
EndSwitch
Switch $oCtrl.Type
Case "Pic", "Icon", "Avi"
Case Else
$aTypeChecks[5] = False
EndSwitch
Next
EndIf
Return $aTypeChecks
EndFunc
Func _onTabProperties()
$tabSelected = "Properties"
GUICtrlSetBkColor($tabProperties, 0xEEEEEE)
GUICtrlSetBkColor($tabStyles, 0xD6D6D6)
_showProperties()
EndFunc
Func _onTabStyles()
$tabSelected = "Styles"
GUICtrlSetBkColor($tabProperties, 0xD6D6D6)
GUICtrlSetBkColor($tabStyles, 0xEEEEEE)
_showProperties()
EndFunc
Func _onStyleChange()
Local $value = GUICtrlRead(@GUI_CtrlId)
If BitAND($value, $GUI_UNCHECKED) = $GUI_UNCHECKED Then
GUICtrlSetState(@GUI_CtrlId, $GUI_CHECKED)
$value = $GUI_CHECKED
Else
GUICtrlSetState(@GUI_CtrlId, $GUI_UNCHECKED)
$value = $GUI_UNCHECKED
EndIf
Local $props
If $oSelected.count > 0 Then
$props = $props_Ctrls
Else
$props = $props_Main
EndIf
Switch $props
Case $props_Main
For $oCtrl In $oProperties_Main.styles.Items()
If $oCtrl.Hwnd = @GUI_CtrlId Then
$text = $oCtrl.name
If StringRegExp($oMain.styleString, '(?:^|,\s)\$' & $text & '(?:,|$)') <> ($value = $GUI_CHECKED) Then
If ($value = $GUI_CHECKED) Then
If $oMain.styleString = "" Then
$oMain.styleString = "$" & $text
ElseIf Not StringInStr($oMain.styleString, $text) Then
$oMain.styleString &= ", " & "$" & $text
EndIf
Else
$oMain.styleString = StringRegExpReplace($oMain.styleString, '(\$' & $text & ', )', "")
$oMain.styleString = StringRegExpReplace($oMain.styleString, '((?:^|,\s)\$' & $text & '$)', "")
EndIf
EndIf
ExitLoop
EndIf
Next
Case $props_Ctrls
Local $iOldStyle, $oThisCtrl, $CtrlValue
For $oCtrl In $oProperties_Ctrls.styles.Items()
If $oCtrl.Hwnd = @GUI_CtrlId Then
$text = $oCtrl.name
Local $iCtrlId
For $oThisCtrl In $oSelected.ctrls.Items()
$iCtrlId = $oThisCtrl.Hwnd
If $oThisCtrl.Type = "UpDown" Then
$iCtrlId = $oThisCtrl.Hwnd2
EndIf
$CtrlValue = StringRegExp($oThisCtrl.styleString, '(?:^|,\s)\$' & $text & '(?:,|$)')
If $CtrlValue <> ($value = $GUI_CHECKED) Then
$iOldStyle = _WinAPI_GetWindowLong(GUICtrlGetHandle($iCtrlId), $GWL_STYLE)
If ($value = $GUI_CHECKED) Then
If $oThisCtrl.styleString = "" Then
$oThisCtrl.styleString = "$" & $text
ElseIf Not StringRegExp($oThisCtrl.styleString, '(?:^|,\s)\$' & $text & '(?:,|$)') Then
$oThisCtrl.styleString &= ", " & "$" & $text
EndIf
GUICtrlSetStyle($iCtrlId, BitOR($iOldStyle, Eval($text)))
Else
$oThisCtrl.styleString = StringRegExpReplace($oThisCtrl.styleString, '(\$' & $text & ', )', "")
$oThisCtrl.styleString = StringRegExpReplace($oThisCtrl.styleString, '((?:^|,\s)\$' & $text & '$)', "")
GUICtrlSetStyle($iCtrlId, BitXOR($iOldStyle, Eval($text)))
EndIf
EndIf
Next
ExitLoop
EndIf
Next
EndSwitch
_refreshGenerateCode()
$oMain.hasChanged = True
EndFunc
Func _onCheckboxChange($ctrlID)
Local $value = GUICtrlRead($ctrlID)
If BitAND($value, $GUI_UNCHECKED) = $GUI_UNCHECKED Then
GUICtrlSetState($ctrlID, $GUI_CHECKED)
$value = $GUI_CHECKED
Else
GUICtrlSetState($ctrlID, $GUI_UNCHECKED)
$value = $GUI_UNCHECKED
EndIf
Return $value
EndFunc
Func _formGenerateCode()
Local $w = 450
Local $h = 575
Local $currentWinPos = WinGetPos($hToolbar)
Local $x = $currentWinPos[0] + 100
$y = $currentWinPos[1] - 50
Local $sPos = IniRead($sIniPath, "Settings", "posGenerateCode", $x & "," & $y)
Local $aPos = StringSplit($sPos, ",")
If Not @error Then
$x = $aPos[1]
$y = $aPos[2]
EndIf
$sPos = IniRead($sIniPath, "Settings", "sizeGenerateCode", $w & "," & $h)
$aPos = StringSplit($sPos, ",")
If Not @error Then
$w = $aPos[1]
$h = $aPos[2]
EndIf
Local $ixCoordMin = _WinAPI_GetSystemMetrics(76)
Local $iyCoordMin = _WinAPI_GetSystemMetrics(77)
Local $iFullDesktopWidth = _WinAPI_GetSystemMetrics(78)
Local $iFullDesktopHeight = _WinAPI_GetSystemMetrics(79)
If ($x + $w) > ($ixCoordMin + $iFullDesktopWidth) Then
$x = $iFullDesktopWidth - $w
ElseIf $x < $ixCoordMin Then
$x = 1
EndIf
If ($y + $h) > ($iyCoordMin + $iFullDesktopHeight) Then
$y = $iFullDesktopHeight - $h
ElseIf $y < $iyCoordMin Then
$y = 1
EndIf
$hFormGenerateCode = GUICreate("Code Preview", $w, $h, $x, $y, $WS_SIZEBOX, -1, $hToolbar)
GUISetOnEvent($GUI_EVENT_CLOSE, "_onExitGenerateCode")
If Not @Compiled Then
GUISetIcon(@ScriptDir & '\resources\icons\icon.ico')
EndIf
Local $titleBarHeight = _WinAPI_GetSystemMetrics($SM_CYCAPTION) + 3
GUICtrlCreateLabel("", 0, 0, $w, $h - $titleBarHeight - 57)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKBORDERS)
$labelCodeGeneration = GUICtrlCreateLabel("", 10, 10, $w - 20, $h - $titleBarHeight - 78)
GUICtrlSetResizing(-1, $GUI_DOCKBORDERS)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$editCodeGeneration = _GUICtrlRichEdit_Create($hFormGenerateCode, "", 10, 10, $w - 20, $h - $titleBarHeight - 78, BitOR($ES_MULTILINE, $WS_VSCROLL, $WS_HSCROLL, $ES_AUTOVSCROLL))
_RESH_SyntaxHighlight($editCodeGeneration, 0, _code_generation())
GUICtrlCreateButton("Copy", $w - 15 - 75 * 2 - 5, $h - 27 - $titleBarHeight, 75, 22)
GUICtrlSetOnEvent(-1, "_onCodeCopy")
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlCreateButton("Save to file", $w - 15 - 75, $h - 27 - $titleBarHeight, 75, 22)
GUICtrlSetOnEvent(-1, "_onCodeSave")
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$radio_msgMode = GUICtrlCreateRadio("Msg Mode", 10, $h - 27 - $titleBarHeight - 25, 75, 22)
GUICtrlSetOnEvent(-1, "_radio_onMsgMode")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKSIZE)
$radio_eventMode = GUICtrlCreateRadio("OnEvent Mode", 10 + 75 + 5, $h - 27 - $titleBarHeight - 25, 100, 22)
GUICtrlSetOnEvent(-1, "_radio_onEventMode")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKSIZE)
$check_guiFunc = GUICtrlCreateCheckbox("Create GUI in a function", 10, $h - 27 - $titleBarHeight, 150, 22)
GUICtrlSetOnEvent(-1, "_menu_gui_function")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKSIZE)
If $oOptions.eventMode Then
GUICtrlSetState($radio_eventMode, $GUI_CHECKED)
Else
GUICtrlSetState($radio_msgMode, $GUI_CHECKED)
EndIf
If $oOptions.guiInFunction Then
GUICtrlSetState($check_guiFunc, $GUI_CHECKED)
Else
GUICtrlSetState($check_guiFunc, $GUI_UNCHECKED)
EndIf
GUISwitch($hGUI)
EndFunc
Func _onCodeRefresh()
_RESH_SyntaxHighlight($editCodeGeneration, 0, _code_generation())
EndFunc
Func _onCodeSave()
_copy_code_to_output(_GUICtrlRichEdit_GetText($editCodeGeneration))
EndFunc
Func _onCodeCopy()
ClipPut(_GUICtrlRichEdit_GetText($editCodeGeneration))
EndFunc
Func _onSelectAll()
_GUICtrlEdit_SetSel($editCodeGeneration, 0, -1)
EndFunc
Func _onExitGenerateCode()
_saveWinPositions()
GUIDelete($hFormGenerateCode)
GUICtrlSetState($menu_generateCode, $GUI_UNCHECKED)
GUISwitch($hGUI)
IniWrite($sIniPath, "Settings", "ShowCode", 0)
EndFunc
Func _refreshGenerateCode()
If IsHWnd($hFormGenerateCode) Then
_RESH_SyntaxHighlight($editCodeGeneration, 0, _code_generation())
EndIf
EndFunc
Func _formObjectExplorer()
Local $w = 250
Local $h = 500
Local $currentWinPos = WinGetPos($hGUI)
Local $x = $currentWinPos[0] + $currentWinPos[2]
Local $y = $currentWinPos[1]
Local $sPos = IniRead($sIniPath, "Settings", "posObjectExplorer", $x & "," & $y)
Local $aPos = StringSplit($sPos, ",")
If Not @error Then
$x = $aPos[1]
$y = $aPos[2]
EndIf
$sPos = IniRead($sIniPath, "Settings", "sizeObjectExplorer", $w & "," & $h)
$aPos = StringSplit($sPos, ",")
If Not @error Then
$w = $aPos[1]
$h = $aPos[2]
EndIf
Local $ixCoordMin = _WinAPI_GetSystemMetrics(76)
Local $iyCoordMin = _WinAPI_GetSystemMetrics(77)
Local $iFullDesktopWidth = _WinAPI_GetSystemMetrics(78)
Local $iFullDesktopHeight = _WinAPI_GetSystemMetrics(79)
If ($x + $w) > ($ixCoordMin + $iFullDesktopWidth) Then
$x = $iFullDesktopWidth - $w
ElseIf $x < $ixCoordMin Then
$x = 1
EndIf
If ($y + $h) > ($iyCoordMin + $iFullDesktopHeight) Then
$y = $iFullDesktopHeight - $h
ElseIf $y < $iyCoordMin Then
$y = 1
EndIf
$hFormObjectExplorer = GUICreate("Object Explorer", $w, $h, $x, $y, $WS_SIZEBOX, -1, $hToolbar)
GUISetOnEvent($GUI_EVENT_CLOSE, "_onExitObjectExplorer")
If Not @Compiled Then
GUISetIcon(@ScriptDir & '\resources\icons\icon.ico')
EndIf
Local $titleBarHeight = _WinAPI_GetSystemMetrics($SM_CYCAPTION) + 3
GUICtrlCreateLabel("", 0, 0, $w, $h - $titleBarHeight - 25)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKBORDERS)
$lvObjects = GUICtrlCreateTreeView(1, 5, $w, $h - $titleBarHeight - 40, BitOR($TVS_LINESATROOT, $TVS_HASLINES, $TVS_HASBUTTONS, $TVS_FULLROWSELECT, $TVS_SHOWSELALWAYS), $WS_EX_TRANSPARENT)
GUICtrlSetResizing(-1, $GUI_DOCKBORDERS)
$labelObjectCount = GUICtrlCreateLabel("Object Count: " & $oCtrls.count, 5, $h - 18 - $titleBarHeight)
GUICtrlCreateButton("Move Up", $w - 20 - 58 * 2 - 5 * 1, $h - 22 - $titleBarHeight, 68, 20)
GUICtrlSetOnEvent(-1, "_onLvMoveUp")
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlCreateButton("Move Down", $w - 20 - 48 - 5, $h - 22 - $titleBarHeight, 68, 20)
GUICtrlSetOnEvent(-1, "_onLvMoveDown")
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
_formObjectExplorer_updateList()
Local Const $accel_delete = GUICtrlCreateDummy()
Local Const $accelerators[1][2] =  [  ["{Delete}", $accel_delete]  ]
GUISetAccelerators($accelerators, $hFormObjectExplorer)
GUICtrlSetOnEvent($accel_delete, "_onLvObjectsDelete")
GUISwitch($hGUI)
EndFunc
Func _onExitObjectExplorer()
_saveWinPositions()
GUIDelete($hFormObjectExplorer)
GUICtrlSetState($menu_ObjectExplorer, $GUI_UNCHECKED)
GUISwitch($hGUI)
IniWrite($sIniPath, "Settings", "ShowObjectExplorer", 0)
EndFunc
Func _onLvObjectsItem()
$childSelected = False
Local $count = _GUICtrlTreeView_GetCount($lvObjects)
Local $aItems[$count]
Local $iIndex = 0, $first = True
Local $hItem = _GUICtrlTreeView_GetFirstItem($lvObjects)
If $hItem = 0 Then Return -1
Do
If _GUICtrlTreeView_GetSelected($lvObjects, $hItem) Then
$aItems[$iIndex] = $hItem
$iIndex += 1
Local $aText = _GUICtrlTreeView_GetText($lvObjects, $hItem)
Local $aStrings = StringSplit($aText, @TAB)
Local $textHwnd = StringTrimRight(StringTrimLeft($aStrings[2], 7), 1)
$oCtrl = $oCtrls.get(Dec($textHwnd))
Local $hParent = _GUICtrlTreeView_GetParentHandle($lvObjects, $hItem)
Local $aParentText1, $aParentStrings1, $ParentTextHwnd1, $oParentCtrl1
If $hParent <> 0 Then
Local $hParent1 = _GUICtrlTreeView_GetParentHandle($lvObjects, _GUICtrlTreeView_GetItemHandle($lvObjects, $hParent))
If $hParent1 <> 0 Then
Local $aParentText = _GUICtrlTreeView_GetText($lvObjects, $hParent)
Local $aParentStrings = StringSplit($aParentText, @TAB)
Local $ParentTextHwnd = StringTrimRight(StringTrimLeft($aParentStrings[2], 7), 1)
$oParentCtrl = $oCtrls.get(Dec($ParentTextHwnd))
Local $aParentText1 = _GUICtrlTreeView_GetText($lvObjects, $hParent1)
Local $aParentStrings1 = StringSplit($aParentText1, @TAB)
Local $ParentTextHwnd1 = StringTrimRight(StringTrimLeft($aParentStrings1[2], 7), 1)
$oParentCtrl1 = $oCtrls.get(Dec($ParentTextHwnd1))
If $oParentCtrl1.Type = "Tab" Then
Local $i = 0, $oTab
For $hTab In $oParentCtrl1.Tabs
$oTab = $oCtrls.get($hTab)
For $oTabCtrl In $oTab.ctrls.Items()
If $oTabCtrl.Hwnd = Dec($textHwnd) Then
_GUICtrlTab_ActivateTab($oParentCtrl1.Hwnd, $i)
If $first Then
$first = False
_add_to_selected($oTabCtrl)
_populate_control_properties_gui($oTabCtrl.Hwnd)
Else
_add_to_selected($oTabCtrl, False)
EndIf
EndIf
Next
$i += 1
Next
EndIf
Else
Local $aParentText = _GUICtrlTreeView_GetText($lvObjects, $hParent)
Local $aParentStrings = StringSplit($aParentText, @TAB)
Local $ParentTextHwnd = StringTrimRight(StringTrimLeft($aParentStrings[2], 7), 1)
$oParentCtrl = $oCtrls.get(Dec($ParentTextHwnd))
Switch $oParentCtrl.Type
Case "Tab"
Local $i = 0, $oTab
For $hTab In $oParentCtrl.Tabs
$oTab = $oCtrls.get($hTab)
If $oTab.Hwnd = Dec($textHwnd) Then
$childSelected = True
_GUICtrlTab_ActivateTab($oParentCtrl.Hwnd, $i)
_add_to_selected($oParentCtrl)
_populate_control_properties_gui($oParentCtrl, Dec($textHwnd))
EndIf
$i += 1
Next
Case "Group"
$childSelected = True
_add_to_selected($oCtrl)
_populate_control_properties_gui($oCtrl, Dec($textHwnd))
Case "Menu"
$childSelected = True
_populate_control_properties_gui($oCtrl, Dec($textHwnd))
EndSwitch
EndIf
Else
If $first Then
$first = False
_add_to_selected($oCtrl)
_populate_control_properties_gui($oCtrl)
Else
_add_to_selected($oCtrl, False)
EndIf
EndIf
EndIf
$hItem = _GUICtrlTreeView_GetNext($lvObjects, $hItem)
Until $hItem = 0
EndFunc
Func _onLvObjectsDelete()
_delete_selected_controls()
EndFunc
Func _onLvObjectsDeleteMenu()
_delete_selected_controls()
EndFunc
Func _onLvObjectsTabItemDelete()
ShowMenu($overlay_contextmenutab, $oMouse.X, $oMouse.Y)
EndFunc
Func _onLvMoveUp()
Local $oCtrlMove = _getLvSelected()
If IsObj($oCtrlMove) Then
$oCtrls.moveUp($oCtrlMove)
Local $foundIndex, $nextHwnd
For $oThisCtrl In $oCtrls.ctrls.Items()
If $foundIndex Then
$nextHwnd = $oThisCtrl.Hwnd
ExitLoop
EndIf
If $oThisCtrl.Hwnd = $oCtrlMove.Hwnd Then
$foundIndex = True
EndIf
Next
If $foundIndex Then
ConsoleWrite("found index" & @CRLF)
GuiCtrlSetOnTop($oCtrlMove.Hwnd, $nextHwnd)
EndIf
_refreshGenerateCode()
_formObjectExplorer_updateList()
_setLvSelected($oCtrlMove)
EndIf
EndFunc
Func _onLvMoveDown()
Local $oCtrlMove = _getLvSelected()
If IsObj($oCtrlMove) Then
$oCtrls.moveDown($oCtrlMove)
Local $foundIndex, $nextHwnd
For $oThisCtrl In $oCtrls.ctrls.Items()
If $foundIndex Then
$nextHwnd = $oThisCtrl.Hwnd
ExitLoop
EndIf
If $oThisCtrl.Hwnd = $oCtrlMove.Hwnd Then
$foundIndex = True
EndIf
Next
If $foundIndex Then
ConsoleWrite("found index" & @CRLF)
GuiCtrlSetOnTop($oCtrlMove.Hwnd, $nextHwnd)
EndIf
_refreshGenerateCode()
_formObjectExplorer_updateList()
_setLvSelected($oCtrlMove)
EndIf
EndFunc
Func _getLvSelected()
$childSelected = False
Local $count = _GUICtrlTreeView_GetCount($lvObjects)
Local $aItems[$count]
Local $iIndex = 0, $first = True
Local $hItem = _GUICtrlTreeView_GetFirstItem($lvObjects)
If $hItem = 0 Then Return -1
Do
If _GUICtrlTreeView_GetSelected($lvObjects, $hItem) Then
Local $aText = _GUICtrlTreeView_GetText($lvObjects, $hItem)
Local $aStrings = StringSplit($aText, @TAB)
Local $textHwnd = StringTrimRight(StringTrimLeft($aStrings[2], 7), 1)
$oCtrl = $oCtrls.get(Dec($textHwnd))
If $oCtrl.Type = "TabItem" Then
Local $hParent = _GUICtrlTreeView_GetParentHandle($lvObjects, $hItem)
If $hParent <> 0 Then
Local $aParentText = _GUICtrlTreeView_GetText($lvObjects, $hParent)
Local $aParentStrings = StringSplit($aParentText, @TAB)
Local $ParentTextHwnd = StringTrimRight(StringTrimLeft($aParentStrings[2], 7), 1)
$oCtrl = $oCtrls.get(Dec($ParentTextHwnd))
EndIf
Else
$oCtrl = $oCtrl
EndIf
Return $oCtrl
EndIf
$hItem = _GUICtrlTreeView_GetNext($lvObjects, $hItem)
$iIndex += 1
Until $hItem = 0
Return -1
EndFunc
Func _setLvSelected($oCtrlSelect, $bSelect = False)
Local $i = 0
Local $hItem = _GUICtrlTreeView_GetFirstItem($lvObjects)
If $hItem = 0 Then Return -1
Do
_GUICtrlTreeView_SetSelected($lvObjects, $hItem, False)
$hItem = _GUICtrlTreeView_GetNext($lvObjects, $hItem)
Until $hItem = 0
If Not IsObj($oCtrlSelect) Then Return 0
$i = 0
$hItem = _GUICtrlTreeView_GetFirstItem($lvObjects)
If $hItem = 0 Then Return -1
Do
Local $aText = _GUICtrlTreeView_GetText($lvObjects, $hItem)
Local $aStrings = StringSplit($aText, @TAB)
Local $textHwnd = StringTrimRight(StringTrimLeft($aStrings[2], 7), 1)
If Dec($textHwnd) = $oCtrlSelect.Hwnd Then
_GUICtrlTreeView_SetSelected($lvObjects, $hItem, True)
If $bSelect Then
_GUICtrlTreeView_SelectItem($lvObjects, $hItem, $TVGN_CARET)
EndIf
Return 0
EndIf
$hItem = _GUICtrlTreeView_GetNext($lvObjects, $hItem)
$i += 1
Until $hItem = 0
Return -1
EndFunc
Func _getLvSelectedHwnd()
Local $count = _GUICtrlTreeView_GetCount($lvObjects)
Local $aItems[$count]
Local $iIndex = 0, $first = True
Local $hItem = _GUICtrlTreeView_GetFirstItem($lvObjects)
If $hItem = 0 Then Return -1
Do
If _GUICtrlTreeView_GetSelected($lvObjects, $hItem) Then
Local $aText = _GUICtrlTreeView_GetText($lvObjects, $hItem)
Local $aStrings = StringSplit($aText, @TAB)
Local $textHwnd = StringTrimRight(StringTrimLeft($aStrings[2], 7), 1)
$oCtrl = $oCtrls.get(Dec($textHwnd))
Return Dec($textHwnd)
EndIf
$hItem = _GUICtrlTreeView_GetNext($lvObjects, $hItem)
$iIndex += 1
Until $hItem = 0
Return -1
EndFunc
Func _setLvSelectedHwnd($hwnd, $bSelect = False)
Local $i = 0
Local $hItem = _GUICtrlTreeView_GetFirstItem($lvObjects)
If $hItem = 0 Then Return -1
Do
_GUICtrlTreeView_SetSelected($lvObjects, $hItem, False)
$hItem = _GUICtrlTreeView_GetNext($lvObjects, $hItem)
Until $hItem = 0
$i = 0
$hItem = _GUICtrlTreeView_GetFirstItem($lvObjects)
If $hItem = 0 Then Return -1
Do
Local $aText = _GUICtrlTreeView_GetText($lvObjects, $hItem)
Local $aStrings = StringSplit($aText, @TAB)
Local $textHwnd = StringTrimRight(StringTrimLeft($aStrings[2], 7), 1)
If Dec($textHwnd) = $hwnd Then
_GUICtrlTreeView_SetSelected($lvObjects, $hItem, True)
If $bSelect Then
_GUICtrlTreeView_SelectItem($lvObjects, $hItem, $TVGN_CARET)
EndIf
Return 0
EndIf
$hItem = _GUICtrlTreeView_GetNext($lvObjects, $hItem)
$i += 1
Until $hItem = 0
Return -1
EndFunc
Func _formObjectExplorer_updateList()
If Not IsHWnd($hFormObjectExplorer) Then Return
Local $prevSelected = _getLvSelectedHwnd()
Local $count = $oCtrls.count
Local $aList[$count]
Local $lvItem, $lvMenu, $lvMenuDelete, $childItem, $tabMenu, $tabMenuDelete, $lvMenuNewTab, $lvMenuDeleteTab, $sName, $childTabCtrl
Local $lvMenuNewMenuItem, $menuItemMenu
Local $isVisible = BitAND(WinGetState($hFormObjectExplorer), $WIN_STATE_VISIBLE)
If $isVisible Then
_SendMessage($hFormObjectExplorer, $WM_SETREDRAW, False)
EndIf
_GUICtrlTreeView_DeleteAll($lvObjects)
For $oCtrl In $oCtrls.ctrls.Items()
If $oCtrl.Type = "TabItem" Then ContinueLoop
If $oCtrl.CtrlParent <> 0 Then ContinueLoop
$sName = $oCtrl.Name
If $sName = "" Then
$sName = $oCtrl.Type & "*"
EndIf
$lvItem = GUICtrlCreateTreeViewItem($sName & "       " & @TAB & "(HWND: " & Hex($oCtrl.Hwnd) & ")", $lvObjects)
GUICtrlSetOnEvent(-1, "_onLvObjectsItem")
$lvMenu = GUICtrlCreateContextMenu($lvItem)
$lvMenuDelete = GUICtrlCreateMenuItem("Delete", $lvMenu)
GUICtrlSetOnEvent($lvMenuDelete, "_onLvObjectsDeleteMenu")
Switch $oCtrl.Type
Case "Tab"
$lvMenuNewTab = GUICtrlCreateMenuItem("New Tab", $lvMenu)
$lvMenuDeleteTab = GUICtrlCreateMenuItem("Delete Tab", $lvMenu)
GUICtrlSetOnEvent($lvMenuNewTab, "_onNewTab")
GUICtrlSetOnEvent($lvMenuDeleteTab, "_onDeleteTab")
Local $oTab
For $hTab In $oCtrl.Tabs
$oTab = $oCtrls.get($hTab)
$childItem = GUICtrlCreateTreeViewItem($oTab.Name & "       " & @TAB & "(HWND: " & Hex($oTab.Hwnd) & ")", $lvItem)
GUICtrlSetOnEvent(-1, "_onLvObjectsItem")
$tabMenu = GUICtrlCreateContextMenu($childItem)
$tabMenuDelete = GUICtrlCreateMenuItem("Delete Tab", $tabMenu)
GUICtrlSetOnEvent($tabMenuDelete, "_delete_tab")
_GUICtrlTreeView_Expand($lvObjects, $lvItem)
For $oTabCtrl In $oTab.ctrls.Items()
$sName = $oTabCtrl.Name
If $sName = "" Then
$sName = $oTabCtrl.Type & "*"
EndIf
$childTabCtrl = GUICtrlCreateTreeViewItem($sName & "       " & @TAB & "(HWND: " & Hex($oTabCtrl.Hwnd) & ")", $childItem)
GUICtrlSetOnEvent(-1, "_onLvObjectsItem")
$lvMenu = GUICtrlCreateContextMenu($childTabCtrl)
$lvMenuDelete = GUICtrlCreateMenuItem("Delete", $lvMenu)
GUICtrlSetOnEvent($lvMenuDelete, "_onLvObjectsDeleteMenu")
Next
Next
_GUICtrlTreeView_Expand($lvObjects, $lvItem)
Case "Group"
For $oThisCtrl In $oCtrl.ctrls.Items()
$sName = $oThisCtrl.Name
If $sName = "" Then
$sName = $oThisCtrl.Type & "*"
EndIf
$childCtrl = GUICtrlCreateTreeViewItem($sName & "       " & @TAB & "(HWND: " & Hex($oThisCtrl.Hwnd) & ")", $lvItem)
GUICtrlSetOnEvent(-1, "_onLvObjectsItem")
$lvMenu = GUICtrlCreateContextMenu($childCtrl)
$lvMenuDelete = GUICtrlCreateMenuItem("Delete", $lvMenu)
GUICtrlSetOnEvent($lvMenuDelete, "_onLvObjectsDeleteMenu")
Next
_GUICtrlTreeView_Expand($lvObjects, $lvItem)
Case "Menu"
$lvMenuNewMenuItem = GUICtrlCreateMenuItem("New menu item", $lvMenu)
GUICtrlSetOnEvent($lvMenuNewMenuItem, "_new_menuItem")
For $oMenuItem In $oCtrl.MenuItems
$childItem = GUICtrlCreateTreeViewItem($oMenuItem.Name & "       " & @TAB & "(HWND: " & Hex($oMenuItem.Hwnd) & ")", $lvItem)
GUICtrlSetOnEvent(-1, "_onLvObjectsItem")
$menuItemMenu = GUICtrlCreateContextMenu($childItem)
$menuItemMenuDelete = GUICtrlCreateMenuItem("Delete menu item", $menuItemMenu)
GUICtrlSetOnEvent($menuItemMenuDelete, "_delete_menuItem")
_GUICtrlTreeView_Expand($lvObjects, $lvItem)
Next
EndSwitch
Next
If $isVisible Then
_SendMessage($hFormObjectExplorer, $WM_SETREDRAW, True)
_WinAPI_RedrawWindow($hFormObjectExplorer)
EndIf
If StringStripWS($count, $STR_STRIPALL) = "" Then $count = 0
GUICtrlSetData($labelObjectCount, "Object Count: " & $count)
If $prevSelected <> -1 Then
_setLvSelectedHwnd($prevSelected)
EndIf
EndFunc
Func _formAbout()
$w = 350
$h = 305
Local $aGuiPos = WinGetPos($hToolbar)
$hAbout = GUICreate("About " & $oMain.AppName, $w, $h, $aGuiPos[0] + 50, $aGuiPos[1] + 50, $WS_CAPTION, -1, $hGUI)
GUISetOnEvent($GUI_EVENT_CLOSE, "_onExitAbout")
GUICtrlCreateLabel("", 0, 0, $w, $h - 32)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel("", 0, $h - 32, $w, 1)
GUICtrlSetBkColor(-1, 0x000000)
GUICtrlSetState(-1, $GUI_DISABLE)
Local $pic = GUICtrlCreatePic("", 10, 10, 48, 48)
_memoryToPic($pic, GetIconData(0))
GUICtrlCreateLabel($oMain.AppName, 70, 10, $w - 15)
GUICtrlSetFont(-1, 13, 800)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateLabel("Version:", 60, 30, 60, -1, $SS_RIGHT)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateLabel($oMain.AppVersion, 125, 30, 65, -1)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateLabel("License:", 60, 46, 60, -1, $SS_RIGHT)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateLabel("GNU GPL v3", 125, 46, 65, -1)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateLabel("", 0, 75, $w, 1)
GUICtrlSetBkColor(-1, 0x000000)
GUICtrlSetState(-1, $GUI_DISABLE)
$desc = "GuiBuilderPlus is a small, easy to use GUI designer for AutoIt." & @CRLF & @CRLF &  "Originally created as AutoBuilder by the user CyberSlug," & @CRLF &  "enhanced as GuiBuilder by TheSaint," & @CRLF &  "and further enhanced and expanded as GuiBuilderNxt by jaberwacky," & @CRLF &  "with additional modifications by kurtykurtyboy as GuiBuilderPlus," & @CRLF & @CRLF &  "GuiBuilderPlus is a continuation of the great work started by others," & @CRLF &  "with a focus on increased stability and usability followed by new features."
GUICtrlCreateLabel($desc, 10, 85, $w - 16, 135)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateLabel("", 0, 225, $w, 1)
GUICtrlSetBkColor(-1, 0x000000)
GUICtrlSetState(-1, $GUI_DISABLE)
$desc = "Control button icons created by Roland Hahn (Lazarus IDE)" & @CRLF &  "- modified by kurtykurtyboy"
GUICtrlCreateLabel($desc, 10, 235, $w - 16)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
$bt_AboutOk = GUICtrlCreateButton("OK", $w - 55, $h - 27, 50, 22)
GUICtrlSetOnEvent(-1, "_onExitAbout")
GUISetState(@SW_DISABLE, $hGUI)
GUISetState(@SW_SHOW, $hAbout)
EndFunc
Func _onExitAbout()
GUIDelete($hAbout)
GUISetState(@SW_ENABLE, $hGUI)
GUISwitch($hGUI)
EndFunc
Func _formEventCode()
$w = 350
$h = 265
$footH = 32
Local $aGuiPos = WinGetPos($hGUI)
$hEvent = GUICreate("Event Code", $w, $h, $aGuiPos[0] + $aGuiPos[2]/2 - $w/2, $aGuiPos[1] + $aGuiPos[3]/2 - $h/2, $WS_CAPTION, -1, $hGUI)
GUISetOnEvent($GUI_EVENT_CLOSE, "_onEventExit")
GUICtrlCreateLabel("", 0, 0, $w, $h - 32)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel("", 5, 5, $w - 10, $h - $footH - 10)
GUICtrlSetBkColor(-1, 0x555555)
GUICtrlSetState(-1, $GUI_DISABLE)
$editEventCode = GUICtrlCreateEdit($oSelected.getFirst().CodeString, 5 + 1, 5 + 1, $w - 12, $h - $footH - 12, BitOR($ES_WANTRETURN, $WS_VSCROLL, $ES_AUTOVSCROLL), 0)
GUICtrlCreateLabel("", 0, $h - $footH, $w, 1)
GUICtrlSetBkColor(-1, 0x000000)
Local $bt_Save = GUICtrlCreateButton("Save", $w - 55, $h - $footH + 5, 50, 22)
GUICtrlSetOnEvent(-1, "_onEventSave")
Local $bt_Exit = GUICtrlCreateButton("Cancel", $w - 55 - 55, $h - $footH + 5, 50, 22)
GUICtrlSetOnEvent(-1, "_onEventExit")
Local $bt_InsertCode = GUICtrlCreateButton("Insert ConsoleWrite", 5, $h - $footH + 5, 100, 22)
GUICtrlSetOnEvent(-1, "_onEventInsert1")
Local $bt_InsertMsgBox = GUICtrlCreateButton("Insert MsgBox", 110, $h - $footH + 5, 85, 22)
GUICtrlSetOnEvent(-1, "_onEventInsert2")
GUISetState(@SW_DISABLE, $hGUI)
GUISetState(@SW_SHOW, $hEvent)
EndFunc
Func _onEventInsert1()
_GUICtrlEdit_AppendText(GUICtrlGetHandle($editEventCode), 'ConsoleWrite("Event: $' & $oSelected.getFirst().Name & '" & @CRLF)')
EndFunc
Func _onEventInsert2()
_GUICtrlEdit_AppendText(GUICtrlGetHandle($editEventCode), 'MsgBox(0, "Event Message", "Event: $' & $oSelected.getFirst().Name & '")')
EndFunc
Func _onEventSave()
Local $sCode = GUICtrlRead($editEventCode)
Local $oAction = _objAction()
$oAction.action = $action_changeCode
$oAction.ctrls = $oSelected.ctrls.Items()
Local $aParams[$oSelected.ctrls.Count]
Local $aParam[2]
For $i = 0 To UBound($oAction.ctrls) - 1
$aParam[0] = $oAction.ctrls[$i].CodeString
$aParam[1] = $sCode
$aParams[$i] = $aParam
Next
$oAction.parameters = $aParams
_updateActionStacks($oAction)
For $oCtrl In $oSelected.ctrls.Items()
$oCtrl.CodeString = $sCode
Next
_onEventExit()
_refreshGenerateCode()
EndFunc
Func _onEventExit()
GUIDelete($hEvent)
GUISetState(@SW_ENABLE, $hGUI)
GUISwitch($hGUI)
EndFunc
Func _formSettings()
Local $w = 210
Local $h = 178
Local $aGuiPos = WinGetPos($hToolbar)
$hSettings = GUICreate("Settings", $w, $h, $aGuiPos[0] + 50, $aGuiPos[1] + 50)
GUISetOnEvent($GUI_EVENT_CLOSE, "_onExitSettings")
$label_bg = GUICtrlCreateLabel("", 0, 0, 210, 140)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetState(-1, $GUI_DISABLE)
$settingsChk_snapgrid = GUICtrlCreateCheckbox("Snap to grid [F3]", 10, 10, 151, 20)
GUICtrlSetBkColor(-1, 0xFFFFFF)
$settingsChk_pasteatmouse = GUICtrlCreateCheckbox("Paste at mouse position", 10, 32.5, 151, 20)
GUICtrlSetBkColor(-1, 0xFFFFFF)
$settingsChk_guifunction = GUICtrlCreateCheckbox("Create GUI in a function", 10, 55, 151, 20)
GUICtrlSetBkColor(-1, 0xFFFFFF)
$settingsChk_eventmode = GUICtrlCreateCheckbox("Enable OnEvent mode", 10, 77.5, 151, 20)
GUICtrlSetBkColor(-1, 0xFFFFFF)
$label_gridsize = GUICtrlCreateLabel("Grid size:", 10, 103, 55, 21)
GUICtrlSetBkColor(-1, 0xFFFFFF)
$settingsInput_gridsize = GUICtrlCreateInput($oOptions.gridSize, 60, 100, 71, 21, $ES_NUMBER)
If $oOptions.snapGrid Then
GUICtrlSetState($settingsChk_snapgrid, $GUI_CHECKED)
EndIf
If $oOptions.pasteAtMouse Then
GUICtrlSetState($settingsChk_pasteatmouse, $GUI_CHECKED)
EndIf
If $oOptions.guiInFunction Then
GUICtrlSetState($settingsChk_guifunction, $GUI_CHECKED)
EndIf
If $oOptions.eventMode Then
GUICtrlSetState($settingsChk_eventmode, $GUI_CHECKED)
EndIf
$line = GUICtrlCreateLabel("", 0, 139, 211, 1)
GUICtrlSetBkColor(-1, 0x333333)
GUICtrlSetState(-1, $GUI_DISABLE)
$button_save = GUICtrlCreateButton("Save", 150, 150, 51, 21)
GUICtrlSetOnEvent(-1, "_onSaveSettings")
$button_cancel = GUICtrlCreateButton("Cancel", 95, 149, 51, 21)
GUICtrlSetOnEvent(-1, "_onExitSettings")
GUISetState(@SW_DISABLE, $hGUI)
GUISetState(@SW_SHOW, $hSettings)
EndFunc
Func _onSaveSettings()
Local $bSnapgrid = (BitAND(GUICtrlRead($settingsChk_snapgrid), $GUI_CHECKED) = $GUI_CHECKED)
Local $bPasteatmouse = (BitAND(GUICtrlRead($settingsChk_pasteatmouse), $GUI_CHECKED) = $GUI_CHECKED)
Local $bGuifunction = (BitAND(GUICtrlRead($settingsChk_guifunction), $GUI_CHECKED) = $GUI_CHECKED)
Local $bEventmode = (BitAND(GUICtrlRead($settingsChk_eventmode), $GUI_CHECKED) = $GUI_CHECKED)
Local $iGridsize = GUICtrlRead($settingsInput_gridsize)
If $iGridsize < 2 Then
$bStatusNewMessage = True
_GUICtrlStatusBar_SetText($hStatusbar, "Grid size too small!")
Return 0
EndIf
GUIDelete($hSettings)
GUISetState(@SW_ENABLE, $hGUI)
GUISwitch($hGUI)
If $oOptions.snapGrid <> $bSnapgrid Then
_gridsnap($bSnapgrid)
EndIf
If $oOptions.pasteAtMouse <> $bPasteatmouse Then
If $bPasteatmouse Then
IniWrite($sIniPath, "Settings", "PastePos", 1)
Else
IniWrite($sIniPath, "Settings", "PastePos", 0)
EndIf
$oOptions.pasteAtMouse = $bPasteatmouse
EndIf
If $oOptions.guiInFunction <> $bGuifunction Then
If $bGuifunction Then
GUICtrlSetState($check_guiFunc, $GUI_CHECKED)
IniWrite($sIniPath, "Settings", "GuiInFunction", 1)
Else
GUICtrlSetState($check_guiFunc, $GUI_UNCHECKED)
IniWrite($sIniPath, "Settings", "GuiInFunction", 0)
EndIf
$oOptions.guiInFunction = $bGuifunction
_refreshGenerateCode()
EndIf
If $oOptions.eventMode <> $bEventmode Then
_set_onEvent_mode($bEventmode)
EndIf
If $oOptions.gridSize <> $iGridsize Then
$oOptions.gridSize = $iGridsize
_showgrid(True)
IniWrite($sIniPath, "Settings", "GridSize", $iGridsize)
EndIf
EndFunc
Func _onExitSettings()
GUIDelete($hSettings)
GUISetState(@SW_ENABLE, $hGUI)
GUISwitch($hGUI)
EndFunc
Func _onShowGrid()
_showgrid()
EndFunc
Func _showgrid($state = Default)
Local $message = "Grid: "
Local $newState
If $state = Default Then
$newState = Not $oOptions.showGrid
Else
$newState = $state
EndIf
If Not $newState Then
GUICtrlSetState($menu_show_grid, $GUI_UNCHECKED)
_hide_grid($background)
IniWrite($sIniPath, "Settings", "ShowGrid", 0)
$message &= "OFF"
Else
GUICtrlSetState($menu_show_grid, $GUI_CHECKED)
_hide_grid($background)
_show_grid($background, $oMain.Width, $oMain.Height)
IniWrite($sIniPath, "Settings", "ShowGrid", 1)
$message &= "ON"
EndIf
$oOptions.showGrid = $newState
If $state = Default Then
$bStatusNewMessage = True
_GUICtrlStatusBar_SetText($hStatusbar, $message)
EndIf
EndFunc
Func _pastepos()
If $oOptions.pasteAtMouse Then
IniWrite($sIniPath, "Settings", "PastePos", 0)
Else
IniWrite($sIniPath, "Settings", "PastePos", 1)
EndIf
$oOptions.pasteAtMouse = Not $oOptions.pasteAtMouse
EndFunc
Func _onGridsnap()
_gridsnap()
EndFunc
Func _gridsnap($state = Default)
Local $message = "Grid snap: "
Local $newState
If $state = Default Then
$newState = Not $oOptions.snapGrid
Else
$newState = $state
EndIf
If Not $newState Then
IniWrite($sIniPath, "Settings", "GridSnap", 0)
$message &= "OFF"
Else
IniWrite($sIniPath, "Settings", "GridSnap", 1)
$message &= "ON"
EndIf
$oOptions.snapGrid = $newState
If $state = Default Then
$bStatusNewMessage = True
_GUICtrlStatusBar_SetText($hStatusbar, $message)
EndIf
EndFunc
Func _menu_onEvent_mode()
_set_onEvent_mode()
EndFunc
Func _radio_onMsgMode()
_set_onEvent_mode(0)
EndFunc
Func _radio_onEventMode()
_set_onEvent_mode(1)
EndFunc
Func _set_onEvent_mode($iState = Default)
Local $newState, $IniState
If $iState = Default Then
Switch $oOptions.eventMode
Case True
$newState = $GUI_UNCHECKED
$IniState = 0
$oOptions.eventMode = False
Case False
$newState = $GUI_CHECKED
$IniState = 1
$oOptions.eventMode = True
EndSwitch
ElseIf $iState = 0 Then
$newState = $GUI_UNCHECKED
$IniState = 0
$oOptions.eventMode = False
ElseIf $iState = 1 Then
$newState = $GUI_CHECKED
$IniState = 1
$oOptions.eventMode = True
EndIf
GUICtrlSetState($radio_eventMode, $newState)
If $newState = $GUI_UNCHECKED Then
GUICtrlSetState($radio_msgMode, $GUI_CHECKED)
EndIf
IniWrite($sIniPath, "Settings", "OnEventMode", $IniState)
_refreshGenerateCode()
EndFunc
Func _menu_gui_function()
Switch $oOptions.guiInFunction
Case True
GUICtrlSetState($check_guiFunc, $GUI_UNCHECKED)
IniWrite($sIniPath, "Settings", "GuiInFunction", 0)
$oOptions.guiInFunction = False
Case False
GUICtrlSetState($check_guiFunc, $GUI_CHECKED)
IniWrite($sIniPath, "Settings", "GuiInFunction", 1)
$oOptions.guiInFunction = True
EndSwitch
_refreshGenerateCode()
EndFunc
Func _formListItems()
If $oSelected.getFirst().Type = "ListView" Then
_showFormListViewItems()
Else
_showFormListItems()
EndIf
EndFunc
Func _showFormListItems()
$w = 300
$h = 265
$footH = 32
Local $aGuiPos = WinGetPos($hGUI)
$hListItems = GUICreate("Items", $w, $h, $aGuiPos[0] + $aGuiPos[2] / 2 - $w / 2, $aGuiPos[1] + $aGuiPos[3] / 2 - $h / 2, $WS_CAPTION, -1, $hGUI)
GUISetOnEvent($GUI_EVENT_CLOSE, "_onExitListItems")
GUICtrlCreateLabel("", 0, 0, $w, $h - 32)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel("", 5, 5, $w - 10, $h - $footH - 10)
GUICtrlSetBkColor(-1, 0x555555)
GUICtrlSetState(-1, $GUI_DISABLE)
$sItems = _items_GetList($oSelected.getFirst().Items)
$editListItems = GUICtrlCreateEdit($sItems, 5 + 1, 5 + 1, $w - 12, $h - $footH - 12, BitOR($ES_WANTRETURN, $WS_VSCROLL, $ES_AUTOVSCROLL), 0)
_GUICtrlEdit_SetPadding($editListItems, 2, 2)
GUICtrlCreateLabel("", 0, $h - $footH, $w, 1)
GUICtrlSetBkColor(-1, 0x000000)
Local $bt_Save = GUICtrlCreateButton("Save", $w - 55, $h - $footH + 5, 50, 22)
GUICtrlSetOnEvent(-1, "_onSaveListItems")
Local $bt_Exit = GUICtrlCreateButton("Cancel", $w - 55 - 55, $h - $footH + 5, 50, 22)
GUICtrlSetOnEvent(-1, "_onExitListItems")
GUISetState(@SW_DISABLE, $hGUI)
GUISetState(@SW_SHOW, $hListItems)
_GUICtrlEdit_SetSel($editListItems, -1, -1)
EndFunc
Func _onSaveListItems()
Local $sItems = GUICtrlRead($editListItems)
$sItems = _items_GetList($sItems, @CRLF, "|")
GUIDelete($hListItems)
GUISetState(@SW_ENABLE, $hGUI)
GUISwitch($hGUI)
For $oThisCtrl In $oSelected.ctrls.Items()
$oThisCtrl.Items = $sItems
GuiCtrlSetData($oThisCtrl.Hwnd, "|" & $oThisCtrl.Items)
Next
$oProperties_Ctrls.properties.Items.value = $sItems
_refreshGenerateCode()
EndFunc
Func _onExitListItems()
GUIDelete($hListItems)
GUISetState(@SW_ENABLE, $hGUI)
GUISwitch($hGUI)
EndFunc
Func _items_GetList($sItems, $char = "|", $sep = @CRLF)
If $sItems <> "" Then
Local $aItems = StringSplit($sItems, $char)
If $aItems[0] > 0 Then
$sItems = ""
If $aItems[1] <> "" Then
$sItems = $aItems[1]
EndIf
EndIf
If $aItems[0] > 1 Then
For $i = 2 To $aItems[0]
If $aItems[$i] <> "" Then
If $sItems <> "" Then
$sItems &= $sep
EndIf
$sItems &= $aItems[$i]
EndIf
Next
EndIf
If $sep = @CRLF Then
$sItems &= $sep
EndIf
EndIf
Return $sItems
EndFunc
Func _showFormListViewItems()
MsgBox($MB_ICONWARNING, "Feature not available", "This feature is not yet available.")
EndFunc
Func MyErrFunc($oError)
SetError(1)
MsgBox(1, "COM Error", "COM Erorr" & @CRLF & "Error Number: " & Hex($oError.number) & @CRLF & $oError.windescription)
EndFunc
_log("", True)
_main()
Func _main()
_log("Startup")
_GDIPlus_Startup()
$dblClickTime = _GetDoubleClickTime()
$oMouse = _objCreateMouse()
$oCtrls = _objCtrls()
$oCtrls.mode = $mode_default
$oSelected = _objCtrls(True)
$oClipboard = _objCtrls()
$oMain = _objMain()
$oMain.AppName = "GuiBuilderPlus"
$oMain.AppVersion = "1.2.0"
$oMain.Title = StringTrimRight(StringTrimLeft(_get_script_title(), 1), 1)
$oMain.Name = "hGUI"
$oMain.Width = 400
$oMain.Height = 350
$oMain.Left = -1
$oMain.Top = -1
$oMain.Background = ""
$tabSelected = "Properties"
$oProperties_Main = _objProperties()
$oProperties_Ctrls = _objProperties()
$oOptions = _objOptions()
_formToolbar()
_formMain()
_set_accelerators()
_check_command_line()
_initialize_settings()
If $oOptions.ShowObjectExplorer Then
_formObjectExplorer()
EndIf
If $oOptions.showCodeViewer Then
_formGenerateCode()
EndIf
GUISetState(@SW_SHOWNORMAL, $hToolbar)
GUISetState(@SW_SHOWNORMAL, $oProperties_Main.properties.Hwnd)
GUISwitch($hGUI)
GUISetState(@SW_SHOWNORMAL, $hGUI)
$bResizedFlag = 0
GUISetState(@SW_SHOWNOACTIVATE, $hFormObjectExplorer)
GUISetState(@SW_SHOWNOACTIVATE, $hFormGenerateCode)
GUISwitch($hGUI)
$au3InstallPath = IniRead($sIniPath, "Settings", "AutoIt3FullPath", "")
If StringInStr(@AutoItExe, "\AutoIt3.exe") Or StringInStr(@AutoItExe, "\AutoIt3_x64.exe") Then $au3InstallPath = @AutoItExe
Local $statusDelay = 3000
Static $startTimer = False
Do
If $bStatusNewMessage Then
$tStatusbarTimer = TimerInit()
$bStatusNewMessage = False
$startTimer = True
EndIf
If $startTimer = True And TimerDiff($tStatusbarTimer) > $statusDelay Then
_GUICtrlStatusBar_SetText($hStatusbar, "")
$startTimer = False
EndIf
If $TestFilePID <> 0 Then
If Not ProcessExists($TestFilePID) Then
$TestFilePID = 0
If $bReTest Then
$bReTest = 0
_onTestGUI()
Else
FileDelete($testFileName)
EndIf
EndIf
EndIf
_GUIScrollbars_EventMonitor()
Sleep(100)
Until False
EndFunc
Func _check_command_line()
If $CmdLine[0] > 0 Then
If StringRight($CmdLine[1], 4) = ".agd" Then
Local $AgdInfile = FileGetLongName($CmdLine[1])
_load_gui_definition($AgdInfile)
EndIf
EndIf
EndFunc
Func _get_script_title()
Local $AgdInfile = ""
If $CmdLine[0] > 0 Then
If StringRight($CmdLine[1], 4) = ".agd" Then
$AgdInfile = FileGetLongName($CmdLine[1])
EndIf
EndIf
Local $gdtitle
If $AgdOutFile <> "" Then
$gdtitle = $AgdOutFile
ElseIf $AgdInfile = "" Then
$gdtitle = $AgdInfile
Else
$gdtitle = WinGetTitle("classname=SciTEWindow", "")
EndIf
If $gdtitle <> "" Then
Local $gdvar = StringSplit($gdtitle, "\")
$lfld = StringLeft($gdtitle, StringInStr($gdtitle, $gdvar[$gdvar[0]]) - 2)
$gdtitle = $gdvar[$gdvar[0]]
If $AgdInfile = "" Then
$gdvar = StringInStr($gdtitle, ".au3")
Else
$gdvar = StringInStr($gdtitle, ".agd")
EndIf
$gdtitle = StringLeft($gdtitle, $gdvar - 1)
Else
$gdtitle = "MyGUI"
EndIf
$mygui = $gdtitle & ".au3"
$gdtitle = '"' & $gdtitle & '"'
Return $gdtitle
EndFunc
Func _initialize_settings()
$oOptions.GridSize = 5
Local $aSettings = IniReadSection($sIniPath, "Settings")
If Not @error Then
For $i = 1 To $aSettings[0][0]
Switch $aSettings[$i][0]
Case "ShowGrid"
$oOptions.showGrid = ($aSettings[$i][1] = 1) ? True : False
Case "PastePos"
$oOptions.pasteAtMouse = ($aSettings[$i][1] = 1) ? True : False
Case "GridSnap"
$oOptions.snapGrid = ($aSettings[$i][1] = 1) ? True : False
Case "ShowCode"
$oOptions.showCodeViewer = ($aSettings[$i][1] = 1) ? True : False
Case "ShowObjectExplorer"
$oOptions.showObjectExplorer = ($aSettings[$i][1] = 1) ? True : False
Case "GuiInFunction"
$oOptions.guiInFunction = ($aSettings[$i][1] = 1) ? True : False
Case "OnEventMode"
$oOptions.eventMode = ($aSettings[$i][1] = 1) ? True : False
Case "GridSize"
$oOptions.GridSize = $aSettings[$i][1]
EndSwitch
Next
Else
$oOptions.showGrid = True
$oOptions.pasteAtMouse = True
$oOptions.guiInFunction = True
$oOptions.eventMode = False
EndIf
If $oOptions.showGrid Then
_show_grid($background, $oMain.Width, $oMain.Height)
Else
_hide_grid($background)
EndIf
_setCheckedState($menu_show_grid, $oOptions.showGrid)
_setCheckedState($menu_generateCode, $oOptions.showCodeViewer)
_setCheckedState($menu_ObjectExplorer, $oOptions.ShowObjectExplorer)
If Not FileExists("storage") Then
DirCreate("storage")
EndIf
EndFunc
Func _setCheckedState($ctrlID, $bState)
If $bState Then
GUICtrlSetState($ctrlID, $GUI_CHECKED)
Else
GUICtrlSetState($ctrlID, $GUI_UNCHECKED)
EndIf
EndFunc
Func _objCreateMouse()
Local $oSelf = _AutoItObject_Create()
_AutoItObject_AddProperty($oSelf, "X", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oSelf, "Y", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oSelf, "StartX", $ELSCOPE_PUBLIC, 0)
_AutoItObject_AddProperty($oSelf, "StartY", $ELSCOPE_PUBLIC, 0)
Return $oSelf
EndFunc
Func _log($sMessage, $startup = False)
Static $tTimer = TimerInit()
If $startup Or Not $debug Then Return
Local $iTime = Floor(TimerDiff($tTimer))
Local $sTime = StringFormat("%d:%.2d:%06.3f", (Floor($iTime / 3600000)), (Floor(Mod($iTime, 3600000) / 60000)), (Mod(Mod($iTime, 3600000), 60000) / 1000))
If $sMessage == "" Then
ConsoleWrite(@CRLF)
Else
ConsoleWrite($sTime & ":  " & $sMessage & @CRLF)
EndIf
EndFunc
